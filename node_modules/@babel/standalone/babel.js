(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Babel = {}));
}(this, (function (exports) { 'use strict';

  var babel = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get version () { return version$3; },
    get types () { return t$p; },
    get DEFAULT_EXTENSIONS () { return DEFAULT_EXTENSIONS; },
    get OptionManager () { return OptionManager; },
    get Plugin () { return Plugin; },
    get File () { return File; },
    get buildExternalHelpers () { return babelBuildExternalHelpers; },
    get resolvePlugin () { return resolvePlugin; },
    get resolvePreset () { return resolvePreset; },
    get getEnv () { return getEnv; },
    get tokTypes () { return types$1; },
    get traverse () { return traverse; },
    get template () { return template$2; },
    get createConfigItem () { return createConfigItem; },
    get createConfigItemSync () { return createConfigItemSync; },
    get createConfigItemAsync () { return createConfigItemAsync; },
    get loadPartialConfig () { return loadPartialConfig; },
    get loadPartialConfigSync () { return loadPartialConfigSync; },
    get loadPartialConfigAsync () { return loadPartialConfigAsync; },
    get loadOptions () { return loadOptions; },
    get loadOptionsSync () { return loadOptionsSync; },
    get loadOptionsAsync () { return loadOptionsAsync; },
    get transform () { return transform$2; },
    get transformSync () { return transformSync; },
    get transformAsync () { return transformAsync; },
    get transformFile () { return transformFile; },
    get transformFileSync () { return transformFileSync; },
    get transformFileAsync () { return transformFileAsync; },
    get transformFromAst () { return transformFromAst$1; },
    get transformFromAstSync () { return transformFromAstSync; },
    get transformFromAstAsync () { return transformFromAstAsync; },
    get parse () { return parse$3; },
    get parseSync () { return parseSync; },
    get parseAsync () { return parseAsync; }
  });

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _taggedTemplateLiteralLoose(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    strings.raw = raw;
    return strings;
  }

  function _slicedToArray$2(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);

    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      return function () {
        if (i >= o.length) return {
          done: true
        };
        return {
          done: false,
          value: o[i++]
        };
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function shallowEqual(actual, expected) {
    var keys = Object.keys(expected);

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];

      if (actual[key] !== expected[key]) {
        return false;
      }
    }

    return true;
  }

  function isArrayExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BinaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterpreterDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterpreterDirective") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirective(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Directive") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDirectiveLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DirectiveLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BlockStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBreakStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BreakStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCatchClause(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "CatchClause") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditionalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ConditionalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isContinueStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ContinueStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDebuggerStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DebuggerStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoWhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExpressionStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "File") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForInStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForInStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Identifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLabeledStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LabeledStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumericLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumericLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegExpLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegExpLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLogicalExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "LogicalExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNewExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NewExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProgram(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Program") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isReturnStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ReturnStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSequenceExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SequenceExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isParenthesizedExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ParenthesizedExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchCase(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchCase") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSwitchStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SwitchStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThrowStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThrowStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTryStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TryStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnaryExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUpdateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UpdateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariableDeclarator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VariableDeclarator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhileStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WhileStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWithStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "WithStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAssignmentPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AssignmentPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrowFunctionExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrowFunctionExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamedDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamedDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForOfStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ForOfStatement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMetaProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MetaProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectPattern") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSuper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Super") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTaggedTemplateExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TaggedTemplateExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTemplateLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TemplateLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isYieldExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "YieldExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAwaitExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AwaitExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImport(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Import") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBigIntLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BigIntLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportNamespaceSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportNamespaceSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalCallExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalCallExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isAnyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "AnyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArrayTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArrayTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBooleanLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BooleanLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassImplements(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassImplements") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareClass") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareInterface(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareInterface") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModule(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModule") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareModuleExports(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareModuleExports") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareTypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareOpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareVariable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareVariable") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclareExportAllDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclareExportAllDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DeclaredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExistsTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExistsTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionTypeParam(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "FunctionTypeParam") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isGenericTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "GenericTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInferredPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InferredPredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceExtends(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceExtends") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isInterfaceTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "InterfaceTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIntersectionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IntersectionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMixedTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "MixedTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEmptyTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EmptyTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNullableTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NullableTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeInternalSlot(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeInternalSlot") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeCallProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeCallProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeIndexer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeIndexer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectTypeSpreadProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ObjectTypeSpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOpaqueType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OpaqueType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isQualifiedTypeIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "QualifiedTypeIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringLiteralTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringLiteralTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStringTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StringTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSymbolTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SymbolTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isThisTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ThisTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeofTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeofTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAlias(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAlias") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeCastExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeCastExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnionTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "UnionTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVariance(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Variance") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isVoidTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "VoidTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumSymbolBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumSymbolBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBooleanMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumBooleanMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumNumberMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumNumberMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumStringMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumStringMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumDefaultedMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "EnumDefaultedMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isIndexedAccessType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "IndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isOptionalIndexedAccessType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "OptionalIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXEmptyExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXEmptyExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXExpressionContainer(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXExpressionContainer") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadChild(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadChild") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXMemberExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXMemberExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXNamespacedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXNamespacedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningElement") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXSpreadAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXSpreadAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXText(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXText") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXOpeningFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXOpeningFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSXClosingFragment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "JSXClosingFragment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNoop(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Noop") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Placeholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isV8IntrinsicIdentifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "V8IntrinsicIdentifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isArgumentPlaceholder(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ArgumentPlaceholder") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBindExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "BindExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineTopicExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineTopicExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelineBareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelineBareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPipelinePrimaryTopicReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PipelinePrimaryTopicReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClassPrivateMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ClassPrivateMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isImportAttribute(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ImportAttribute") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDecorator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "Decorator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDoExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DoExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDefaultSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ExportDefaultSpecifier") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivateName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "PrivateName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRecordExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RecordExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTupleExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TupleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDecimalLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "DecimalLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStaticBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "StaticBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "ModuleExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParameterProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParameterProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareFunction(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareFunction") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSDeclareMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSDeclareMethod") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSQualifiedName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSQualifiedName") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSCallSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSCallSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructSignatureDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructSignatureDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSPropertySignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSPropertySignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMethodSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMethodSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexSignature(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexSignature") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAnyKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAnyKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBooleanKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBooleanKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBigIntKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSBigIntKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIntrinsicKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIntrinsicKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNeverKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNeverKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNullKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNullKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNumberKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNumberKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSObjectKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSObjectKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSStringKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSStringKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSSymbolKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSSymbolKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUndefinedKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUndefinedKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnknownKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnknownKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSVoidKeyword(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSVoidKeyword") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSThisType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSThisType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSFunctionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSFunctionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConstructorType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConstructorType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypePredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypePredicate") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeQuery(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeQuery") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSArrayType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSArrayType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTupleType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTupleType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSOptionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSOptionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSRestType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSRestType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNamedTupleMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNamedTupleMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSUnionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSUnionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIntersectionType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIntersectionType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSConditionalType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSConditionalType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInferType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInferType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSParenthesizedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSParenthesizedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeOperator(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeOperator") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSIndexedAccessType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSIndexedAccessType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSMappedType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSMappedType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSLiteralType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSLiteralType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExpressionWithTypeArguments(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExpressionWithTypeArguments") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSInterfaceBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSInterfaceBody") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAliasDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAliasDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSAsExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSAsExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAssertion(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAssertion") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSEnumMember") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSModuleBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSModuleBlock") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportType") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSImportEqualsDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSImportEqualsDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExternalModuleReference(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExternalModuleReference") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNonNullExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNonNullExpression") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSExportAssignment(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSExportAssignment") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSNamespaceExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSNamespaceExportDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeAnnotation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterInstantiation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterInstantiation") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameterDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameterDeclaration") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeParameter(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "TSTypeParameter") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpression(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ArrayExpression" === nodeType || "AssignmentExpression" === nodeType || "BinaryExpression" === nodeType || "CallExpression" === nodeType || "ConditionalExpression" === nodeType || "FunctionExpression" === nodeType || "Identifier" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "LogicalExpression" === nodeType || "MemberExpression" === nodeType || "NewExpression" === nodeType || "ObjectExpression" === nodeType || "SequenceExpression" === nodeType || "ParenthesizedExpression" === nodeType || "ThisExpression" === nodeType || "UnaryExpression" === nodeType || "UpdateExpression" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "MetaProperty" === nodeType || "Super" === nodeType || "TaggedTemplateExpression" === nodeType || "TemplateLiteral" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType || "Import" === nodeType || "BigIntLiteral" === nodeType || "OptionalMemberExpression" === nodeType || "OptionalCallExpression" === nodeType || "TypeCastExpression" === nodeType || "JSXElement" === nodeType || "JSXFragment" === nodeType || "BindExpression" === nodeType || "PipelinePrimaryTopicReference" === nodeType || "DoExpression" === nodeType || "RecordExpression" === nodeType || "TupleExpression" === nodeType || "DecimalLiteral" === nodeType || "ModuleExpression" === nodeType || "TSAsExpression" === nodeType || "TSTypeAssertion" === nodeType || "TSNonNullExpression" === nodeType || nodeType === "Placeholder" && ("Expression" === node.expectedNode || "Identifier" === node.expectedNode || "StringLiteral" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBinary(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BinaryExpression" === nodeType || "LogicalExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isScopable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassExpression" === nodeType || "ClassDeclaration" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlockParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "CatchClause" === nodeType || "DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "Program" === nodeType || "ObjectMethod" === nodeType || "SwitchStatement" === nodeType || "WhileStatement" === nodeType || "ArrowFunctionExpression" === nodeType || "ForOfStatement" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType || "StaticBlock" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isBlock(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "Program" === nodeType || "TSModuleBlock" === nodeType || nodeType === "Placeholder" && "BlockStatement" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BlockStatement" === nodeType || "BreakStatement" === nodeType || "ContinueStatement" === nodeType || "DebuggerStatement" === nodeType || "DoWhileStatement" === nodeType || "EmptyStatement" === nodeType || "ExpressionStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "FunctionDeclaration" === nodeType || "IfStatement" === nodeType || "LabeledStatement" === nodeType || "ReturnStatement" === nodeType || "SwitchStatement" === nodeType || "ThrowStatement" === nodeType || "TryStatement" === nodeType || "VariableDeclaration" === nodeType || "WhileStatement" === nodeType || "WithStatement" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ForOfStatement" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || "TSImportEqualsDeclaration" === nodeType || "TSExportAssignment" === nodeType || "TSNamespaceExportDeclaration" === nodeType || nodeType === "Placeholder" && ("Statement" === node.expectedNode || "Declaration" === node.expectedNode || "BlockStatement" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTerminatorless(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType || "YieldExpression" === nodeType || "AwaitExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isCompletionStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("BreakStatement" === nodeType || "ContinueStatement" === nodeType || "ReturnStatement" === nodeType || "ThrowStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isConditional(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ConditionalExpression" === nodeType || "IfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLoop$1(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "ForInStatement" === nodeType || "ForStatement" === nodeType || "WhileStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isWhile(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DoWhileStatement" === nodeType || "WhileStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExpressionWrapper(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExpressionStatement" === nodeType || "ParenthesizedExpression" === nodeType || "TypeCastExpression" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFor(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isForXStatement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ForInStatement" === nodeType || "ForOfStatement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunction$1(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFunctionParent(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "ObjectMethod" === nodeType || "ArrowFunctionExpression" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPureish(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "FunctionExpression" === nodeType || "StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "ArrowFunctionExpression" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("FunctionDeclaration" === nodeType || "VariableDeclaration" === nodeType || "ClassDeclaration" === nodeType || "ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType || "EnumDeclaration" === nodeType || "TSDeclareFunction" === nodeType || "TSInterfaceDeclaration" === nodeType || "TSTypeAliasDeclaration" === nodeType || "TSEnumDeclaration" === nodeType || "TSModuleDeclaration" === nodeType || nodeType === "Placeholder" && "Declaration" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPatternLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLVal(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "MemberExpression" === nodeType || "RestElement" === nodeType || "AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || "TSParameterProperty" === nodeType || nodeType === "Placeholder" && ("Pattern" === node.expectedNode || "Identifier" === node.expectedNode)) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSEntityName(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("Identifier" === nodeType || "TSQualifiedName" === nodeType || nodeType === "Placeholder" && "Identifier" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isLiteral(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("StringLiteral" === nodeType || "NumericLiteral" === nodeType || "NullLiteral" === nodeType || "BooleanLiteral" === nodeType || "RegExpLiteral" === nodeType || "TemplateLiteral" === nodeType || "BigIntLiteral" === nodeType || "DecimalLiteral" === nodeType || nodeType === "Placeholder" && "StringLiteral" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUserWhitespacable(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isMethod(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ClassMethod" === nodeType || "ClassPrivateMethod" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isObjectMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectMethod" === nodeType || "ObjectProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isProperty(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ObjectProperty" === nodeType || "ClassProperty" === nodeType || "ClassPrivateProperty" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isUnaryLike(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("UnaryExpression" === nodeType || "SpreadElement" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPattern(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AssignmentPattern" === nodeType || "ArrayPattern" === nodeType || "ObjectPattern" === nodeType || nodeType === "Placeholder" && "Pattern" === node.expectedNode) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isClass(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ClassExpression" === nodeType || "ClassDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType || "ImportDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isExportDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportAllDeclaration" === nodeType || "ExportDefaultDeclaration" === nodeType || "ExportNamedDeclaration" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isModuleSpecifier(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ExportSpecifier" === nodeType || "ImportDefaultSpecifier" === nodeType || "ImportNamespaceSpecifier" === nodeType || "ImportSpecifier" === nodeType || "ExportNamespaceSpecifier" === nodeType || "ExportDefaultSpecifier" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlow(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ClassImplements" === nodeType || "DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "DeclaredPredicate" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "FunctionTypeParam" === nodeType || "GenericTypeAnnotation" === nodeType || "InferredPredicate" === nodeType || "InterfaceExtends" === nodeType || "InterfaceDeclaration" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "ObjectTypeInternalSlot" === nodeType || "ObjectTypeCallProperty" === nodeType || "ObjectTypeIndexer" === nodeType || "ObjectTypeProperty" === nodeType || "ObjectTypeSpreadProperty" === nodeType || "OpaqueType" === nodeType || "QualifiedTypeIdentifier" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "TypeAlias" === nodeType || "TypeAnnotation" === nodeType || "TypeCastExpression" === nodeType || "TypeParameter" === nodeType || "TypeParameterDeclaration" === nodeType || "TypeParameterInstantiation" === nodeType || "UnionTypeAnnotation" === nodeType || "Variance" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "ArrayTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "BooleanLiteralTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "ExistsTypeAnnotation" === nodeType || "FunctionTypeAnnotation" === nodeType || "GenericTypeAnnotation" === nodeType || "InterfaceTypeAnnotation" === nodeType || "IntersectionTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NullableTypeAnnotation" === nodeType || "NumberLiteralTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "ObjectTypeAnnotation" === nodeType || "StringLiteralTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "TupleTypeAnnotation" === nodeType || "TypeofTypeAnnotation" === nodeType || "UnionTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType || "IndexedAccessType" === nodeType || "OptionalIndexedAccessType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowBaseAnnotation(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("AnyTypeAnnotation" === nodeType || "BooleanTypeAnnotation" === nodeType || "NullLiteralTypeAnnotation" === nodeType || "MixedTypeAnnotation" === nodeType || "EmptyTypeAnnotation" === nodeType || "NumberTypeAnnotation" === nodeType || "StringTypeAnnotation" === nodeType || "SymbolTypeAnnotation" === nodeType || "ThisTypeAnnotation" === nodeType || "VoidTypeAnnotation" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowDeclaration(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DeclareClass" === nodeType || "DeclareFunction" === nodeType || "DeclareInterface" === nodeType || "DeclareModule" === nodeType || "DeclareModuleExports" === nodeType || "DeclareTypeAlias" === nodeType || "DeclareOpaqueType" === nodeType || "DeclareVariable" === nodeType || "DeclareExportDeclaration" === nodeType || "DeclareExportAllDeclaration" === nodeType || "InterfaceDeclaration" === nodeType || "OpaqueType" === nodeType || "TypeAlias" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isFlowPredicate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("DeclaredPredicate" === nodeType || "InferredPredicate" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumBody(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("EnumBooleanBody" === nodeType || "EnumNumberBody" === nodeType || "EnumStringBody" === nodeType || "EnumSymbolBody" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isEnumMember(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("EnumBooleanMember" === nodeType || "EnumNumberMember" === nodeType || "EnumStringMember" === nodeType || "EnumDefaultedMember" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isJSX(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("JSXAttribute" === nodeType || "JSXClosingElement" === nodeType || "JSXElement" === nodeType || "JSXEmptyExpression" === nodeType || "JSXExpressionContainer" === nodeType || "JSXSpreadChild" === nodeType || "JSXIdentifier" === nodeType || "JSXMemberExpression" === nodeType || "JSXNamespacedName" === nodeType || "JSXOpeningElement" === nodeType || "JSXSpreadAttribute" === nodeType || "JSXText" === nodeType || "JSXFragment" === nodeType || "JSXOpeningFragment" === nodeType || "JSXClosingFragment" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isPrivate(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("ClassPrivateProperty" === nodeType || "ClassPrivateMethod" === nodeType || "PrivateName" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSTypeElement(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSCallSignatureDeclaration" === nodeType || "TSConstructSignatureDeclaration" === nodeType || "TSPropertySignature" === nodeType || "TSMethodSignature" === nodeType || "TSIndexSignature" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSFunctionType" === nodeType || "TSConstructorType" === nodeType || "TSTypeReference" === nodeType || "TSTypePredicate" === nodeType || "TSTypeQuery" === nodeType || "TSTypeLiteral" === nodeType || "TSArrayType" === nodeType || "TSTupleType" === nodeType || "TSOptionalType" === nodeType || "TSRestType" === nodeType || "TSUnionType" === nodeType || "TSIntersectionType" === nodeType || "TSConditionalType" === nodeType || "TSInferType" === nodeType || "TSParenthesizedType" === nodeType || "TSTypeOperator" === nodeType || "TSIndexedAccessType" === nodeType || "TSMappedType" === nodeType || "TSLiteralType" === nodeType || "TSExpressionWithTypeArguments" === nodeType || "TSImportType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isTSBaseType(node, opts) {
    if (!node) return false;
    var nodeType = node.type;

    if ("TSAnyKeyword" === nodeType || "TSBooleanKeyword" === nodeType || "TSBigIntKeyword" === nodeType || "TSIntrinsicKeyword" === nodeType || "TSNeverKeyword" === nodeType || "TSNullKeyword" === nodeType || "TSNumberKeyword" === nodeType || "TSObjectKeyword" === nodeType || "TSStringKeyword" === nodeType || "TSSymbolKeyword" === nodeType || "TSUndefinedKeyword" === nodeType || "TSUnknownKeyword" === nodeType || "TSVoidKeyword" === nodeType || "TSThisType" === nodeType || "TSLiteralType" === nodeType) {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "NumberLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RegexLiteral") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "RestProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }
  function isSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    if (!node) return false;
    var nodeType = node.type;

    if (nodeType === "SpreadProperty") {
      if (typeof opts === "undefined") {
        return true;
      } else {
        return shallowEqual(node, opts);
      }
    }

    return false;
  }

  function matchesPattern$1(member, match, allowPartial) {
    if (!isMemberExpression(member)) return false;
    var parts = Array.isArray(match) ? match : match.split(".");
    var nodes = [];
    var node;

    for (node = member; isMemberExpression(node); node = node.object) {
      nodes.push(node.property);
    }

    nodes.push(node);
    if (nodes.length < parts.length) return false;
    if (!allowPartial && nodes.length > parts.length) return false;

    for (var i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
      var _node = nodes[j];
      var value = void 0;

      if (isIdentifier(_node)) {
        value = _node.name;
      } else if (isStringLiteral(_node)) {
        value = _node.value;
      } else if (isThisExpression(_node)) {
        value = "this";
      } else {
        return false;
      }

      if (parts[i] !== value) return false;
    }

    return true;
  }

  function buildMatchMemberExpression(match, allowPartial) {
    var parts = match.split(".");
    return function (member) {
      return matchesPattern$1(member, parts, allowPartial);
    };
  }

  var isReactComponent = buildMatchMemberExpression("React.Component");

  function isCompatTag(tagName) {
    return !!tagName && /^[a-z]/.test(tagName);
  }

  var fastProto = null;

  function FastObject(o) {
    if (fastProto !== null && typeof fastProto.property) {
      var result = fastProto;
      fastProto = FastObject.prototype = null;
      return result;
    }

    fastProto = FastObject.prototype = o == null ? Object.create(null) : o;
    return new FastObject();
  }

  FastObject();

  var toFastProperties = function toFastproperties(o) {
    return FastObject(o);
  };

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  const DYNAMIC_REQUIRE_LOADERS = Object.create(null);
  const DYNAMIC_REQUIRE_CACHE = Object.create(null);
  const DEFAULT_PARENT_MODULE = {
  	id: '<' + 'rollup>', exports: {}, parent: undefined, filename: null, loaded: false, children: [], paths: []
  };
  const CHECKED_EXTENSIONS = ['', '.js', '.json'];

  function normalize$2 (path) {
  	path = path.replace(/\\/g, '/');
  	const parts = path.split('/');
  	const slashed = parts[0] === '';
  	for (let i = 1; i < parts.length; i++) {
  		if (parts[i] === '.' || parts[i] === '') {
  			parts.splice(i--, 1);
  		}
  	}
  	for (let i = 1; i < parts.length; i++) {
  		if (parts[i] !== '..') continue;
  		if (i > 0 && parts[i - 1] !== '..' && parts[i - 1] !== '.') {
  			parts.splice(--i, 2);
  			i--;
  		}
  	}
  	path = parts.join('/');
  	if (slashed && path[0] !== '/')
  	  path = '/' + path;
  	else if (path.length === 0)
  	  path = '.';
  	return path;
  }

  function join$1 () {
  	if (arguments.length === 0)
  	  return '.';
  	let joined;
  	for (let i = 0; i < arguments.length; ++i) {
  	  let arg = arguments[i];
  	  if (arg.length > 0) {
  		if (joined === undefined)
  		  joined = arg;
  		else
  		  joined += '/' + arg;
  	  }
  	}
  	if (joined === undefined)
  	  return '.';

  	return joined;
  }

  function isPossibleNodeModulesPath (modulePath) {
  	let c0 = modulePath[0];
  	if (c0 === '/' || c0 === '\\') return false;
  	let c1 = modulePath[1], c2 = modulePath[2];
  	if ((c0 === '.' && (!c1 || c1 === '/' || c1 === '\\')) ||
  		(c0 === '.' && c1 === '.' && (!c2 || c2 === '/' || c2 === '\\'))) return false;
  	if (c1 === ':' && (c2 === '/' || c2 === '\\'))
  		return false;
  	return true;
  }

  function dirname$1 (path) {
    if (path.length === 0)
      return '.';

    let i = path.length - 1;
    while (i > 0) {
      const c = path.charCodeAt(i);
      if ((c === 47 || c === 92) && i !== path.length - 1)
        break;
      i--;
    }

    if (i > 0)
      return path.substr(0, i);

    if (path.chartCodeAt(0) === 47 || path.chartCodeAt(0) === 92)
      return path.charAt(0);

    return '.';
  }

  function commonjsResolveImpl (path, originalModuleDir, testCache) {
  	const shouldTryNodeModules = isPossibleNodeModulesPath(path);
  	path = normalize$2(path);
  	let relPath;
  	if (path[0] === '/') {
  		originalModuleDir = '/';
  	}
  	while (true) {
  		if (!shouldTryNodeModules) {
  			relPath = originalModuleDir ? normalize$2(originalModuleDir + '/' + path) : path;
  		} else if (originalModuleDir) {
  			relPath = normalize$2(originalModuleDir + '/node_modules/' + path);
  		} else {
  			relPath = normalize$2(join$1('node_modules', path));
  		}

  		if (relPath.endsWith('/..')) {
  			break; // Travelled too far up, avoid infinite loop
  		}

  		for (let extensionIndex = 0; extensionIndex < CHECKED_EXTENSIONS.length; extensionIndex++) {
  			const resolvedPath = relPath + CHECKED_EXTENSIONS[extensionIndex];
  			if (DYNAMIC_REQUIRE_CACHE[resolvedPath]) {
  				return resolvedPath;
  			}			if (DYNAMIC_REQUIRE_LOADERS[resolvedPath]) {
  				return resolvedPath;
  			}		}
  		if (!shouldTryNodeModules) break;
  		const nextDir = normalize$2(originalModuleDir + '/..');
  		if (nextDir === originalModuleDir) break;
  		originalModuleDir = nextDir;
  	}
  	return null;
  }

  function commonjsResolve (path, originalModuleDir) {
  	const resolvedPath = commonjsResolveImpl(path, originalModuleDir);
  	if (resolvedPath !== null) {
  		return resolvedPath;
  	}
  	return require.resolve(path);
  }

  function commonjsRequire (path, originalModuleDir) {
  	const resolvedPath = commonjsResolveImpl(path, originalModuleDir);
  	if (resolvedPath !== null) {
      let cachedModule = DYNAMIC_REQUIRE_CACHE[resolvedPath];
      if (cachedModule) return cachedModule.exports;
      const loader = DYNAMIC_REQUIRE_LOADERS[resolvedPath];
      if (loader) {
        DYNAMIC_REQUIRE_CACHE[resolvedPath] = cachedModule = {
          id: resolvedPath,
          filename: resolvedPath,
          path: dirname$1(resolvedPath),
          exports: {},
          parent: DEFAULT_PARENT_MODULE,
          loaded: false,
          children: [],
          paths: [],
          require: function (path, base) {
            return commonjsRequire(path, (base === undefined || base === null) ? cachedModule.path : base);
          }
        };
        try {
          loader.call(commonjsGlobal, cachedModule, cachedModule.exports);
        } catch (error) {
          delete DYNAMIC_REQUIRE_CACHE[resolvedPath];
          throw error;
        }
        cachedModule.loaded = true;
        return cachedModule.exports;
      }	}
  	return require(path);
  }

  commonjsRequire.cache = DYNAMIC_REQUIRE_CACHE;
  commonjsRequire.resolve = commonjsResolve;

  var browser$6 = createCommonjsModule(function (module) {
    var process = module.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;

    function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
    }

    function defaultClearTimeout() {
      throw new Error('clearTimeout has not been defined');
    }

    (function () {
      try {
        if (typeof setTimeout === 'function') {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }

      try {
        if (typeof clearTimeout === 'function') {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();

    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }

      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }

      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }

    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }

      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }

      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }

    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;

    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }

      draining = false;

      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }

      if (queue.length) {
        drainQueue();
      }
    }

    function drainQueue() {
      if (draining) {
        return;
      }

      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;

      while (len) {
        currentQueue = queue;
        queue = [];

        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }

        queueIndex = -1;
        len = queue.length;
      }

      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }

    process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);

      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }

      queue.push(new Item(fun, args));

      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };

    function Item(fun, array) {
      this.fun = fun;
      this.array = array;
    }

    Item.prototype.run = function () {
      this.fun.apply(null, this.array);
    };

    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = '';
    process.versions = {};

    function noop() {}

    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;

    process.listeners = function (name) {
      return [];
    };

    process.binding = function (name) {
      throw new Error('process.binding is not supported');
    };

    process.cwd = function () {
      return '/';
    };

    process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
    };

    process.umask = function () {
      return 0;
    };
  }, "/$$rollup_base$$/node_modules/process");

  function isType$1(nodeType, targetType) {
    if (nodeType === targetType) return true;
    if (ALIAS_KEYS[targetType]) return false;
    var aliases = FLIPPED_ALIAS_KEYS[targetType];

    if (aliases) {
      if (aliases[0] === nodeType) return true;

      for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
        var alias = _step.value;
        if (nodeType === alias) return true;
      }
    }

    return false;
  }

  function isPlaceholderType(placeholderType, targetType) {
    if (placeholderType === targetType) return true;
    var aliases = PLACEHOLDERS_ALIAS[placeholderType];

    if (aliases) {
      for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
        var alias = _step.value;
        if (targetType === alias) return true;
      }
    }

    return false;
  }

  function is$1(type, node, opts) {
    if (!node) return false;
    var matches = isType$1(node.type, type);

    if (!matches) {
      if (!opts && node.type === "Placeholder" && type in FLIPPED_ALIAS_KEYS) {
        return isPlaceholderType(node.expectedNode, type);
      }

      return false;
    }

    if (typeof opts === "undefined") {
      return true;
    } else {
      return shallowEqual(node, opts);
    }
  }

  var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08C7\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\u9FFC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7BF\uA7C2-\uA7CA\uA7F5-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
  var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF\u1AC0\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";
  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];
  var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];

  function isInAstralSet(code, set) {
    var pos = 0x10000;

    for (var i = 0, length = set.length; i < length; i += 2) {
      pos += set[i];
      if (pos > code) return false;
      pos += set[i + 1];
      if (pos >= code) return true;
    }

    return false;
  }

  function isIdentifierStart(code) {
    if (code < 65) return code === 36;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes);
  }
  function isIdentifierChar(code) {
    if (code < 48) return code === 36;
    if (code < 58) return true;
    if (code < 65) return false;
    if (code <= 90) return true;
    if (code < 97) return code === 95;
    if (code <= 122) return true;

    if (code <= 0xffff) {
      return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
    }

    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
  }
  function isIdentifierName(name) {
    var isFirst = true;

    for (var i = 0; i < name.length; i++) {
      var cp = name.charCodeAt(i);

      if ((cp & 0xfc00) === 0xd800 && i + 1 < name.length) {
        var trail = name.charCodeAt(++i);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      if (isFirst) {
        isFirst = false;

        if (!isIdentifierStart(cp)) {
          return false;
        }
      } else if (!isIdentifierChar(cp)) {
        return false;
      }
    }

    return !isFirst;
  }

  var reservedWords = {
    keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
    strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
    strictBind: ["eval", "arguments"]
  };
  var keywords$1 = new Set(reservedWords.keyword);
  var reservedWordsStrictSet = new Set(reservedWords.strict);
  var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
  function isReservedWord(word, inModule) {
    return inModule && word === "await" || word === "enum";
  }
  function isStrictReservedWord(word, inModule) {
    return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
  }
  function isStrictBindOnlyReservedWord(word) {
    return reservedWordsStrictBindSet.has(word);
  }
  function isStrictBindReservedWord(word, inModule) {
    return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
  }
  function isKeyword(word) {
    return keywords$1.has(word);
  }

  function isValidIdentifier(name, reserved) {
    if (reserved === void 0) {
      reserved = true;
    }

    if (typeof name !== "string") return false;

    if (reserved) {
      if (isKeyword(name) || isStrictReservedWord(name, true)) {
        return false;
      }
    }

    return isIdentifierName(name);
  }

  var STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
  var FLATTENABLE_KEYS = ["body", "expressions"];
  var FOR_INIT_KEYS = ["left", "init"];
  var COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
  var LOGICAL_OPERATORS = ["||", "&&", "??"];
  var UPDATE_OPERATORS = ["++", "--"];
  var BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
  var EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
  var COMPARISON_BINARY_OPERATORS = [].concat(EQUALITY_BINARY_OPERATORS, ["in", "instanceof"]);
  var BOOLEAN_BINARY_OPERATORS = [].concat(_toConsumableArray(COMPARISON_BINARY_OPERATORS), BOOLEAN_NUMBER_BINARY_OPERATORS);
  var NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
  var BINARY_OPERATORS = ["+"].concat(NUMBER_BINARY_OPERATORS, _toConsumableArray(BOOLEAN_BINARY_OPERATORS));
  var ASSIGNMENT_OPERATORS = ["=", "+="].concat(_toConsumableArray(NUMBER_BINARY_OPERATORS.map(function (op) {
    return op + "=";
  })), _toConsumableArray(LOGICAL_OPERATORS.map(function (op) {
    return op + "=";
  })));
  var BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
  var NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
  var STRING_UNARY_OPERATORS = ["typeof"];
  var UNARY_OPERATORS = ["void", "throw"].concat(BOOLEAN_UNARY_OPERATORS, NUMBER_UNARY_OPERATORS, STRING_UNARY_OPERATORS);
  var INHERIT_KEYS = {
    optional: ["typeAnnotation", "typeParameters", "returnType"],
    force: ["start", "loc", "end"]
  };
  var BLOCK_SCOPED_SYMBOL = Symbol["for"]("var used to be block scoped");
  var NOT_LOCAL_BINDING = Symbol["for"]("should not be considered a local binding");

  function validate$3(node, key, val) {
    if (!node) return;
    var fields = NODE_FIELDS[node.type];
    if (!fields) return;
    var field = fields[key];
    validateField(node, key, val, field);
    validateChild(node, key, val);
  }
  function validateField(node, key, val, field) {
    if (!(field != null && field.validate)) return;
    if (field.optional && val == null) return;
    field.validate(node, key, val);
  }
  function validateChild(node, key, val) {
    if (val == null) return;
    var validate = NODE_PARENT_VALIDATIONS[val.type];
    if (!validate) return;
    validate(node, key, val);
  }

  var VISITOR_KEYS = {};
  var ALIAS_KEYS = {};
  var FLIPPED_ALIAS_KEYS = {};
  var NODE_FIELDS = {};
  var BUILDER_KEYS = {};
  var DEPRECATED_KEYS = {};
  var NODE_PARENT_VALIDATIONS = {};

  function getType$2(val) {
    if (Array.isArray(val)) {
      return "array";
    } else if (val === null) {
      return "null";
    } else {
      return typeof val;
    }
  }

  function validate$2(validate) {
    return {
      validate: validate
    };
  }
  function typeIs(typeName) {
    return typeof typeName === "string" ? assertNodeType(typeName) : assertNodeType.apply(void 0, _toConsumableArray(typeName));
  }
  function validateType(typeName) {
    return validate$2(typeIs(typeName));
  }
  function validateOptional(validate) {
    return {
      validate: validate,
      optional: true
    };
  }
  function validateOptionalType(typeName) {
    return {
      validate: typeIs(typeName),
      optional: true
    };
  }
  function arrayOf(elementType) {
    return chain$1(assertValueType("array"), assertEach(elementType));
  }
  function arrayOfType(typeName) {
    return arrayOf(typeIs(typeName));
  }
  function validateArrayOfType(typeName) {
    return validate$2(arrayOfType(typeName));
  }
  function assertEach(callback) {
    function validator(node, key, val) {
      if (!Array.isArray(val)) return;

      for (var i = 0; i < val.length; i++) {
        var subkey = key + "[" + i + "]";
        var v = val[i];
        callback(node, subkey, v);
        if (browser$6.env.BABEL_TYPES_8_BREAKING) validateChild(node, subkey, v);
      }
    }

    validator.each = callback;
    return validator;
  }
  function assertOneOf() {
    for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {
      values[_key] = arguments[_key];
    }

    function validate(node, key, val) {
      if (values.indexOf(val) < 0) {
        throw new TypeError("Property " + key + " expected value to be one of " + JSON.stringify(values) + " but got " + JSON.stringify(val));
      }
    }

    validate.oneOf = values;
    return validate;
  }
  function assertNodeType() {
    for (var _len2 = arguments.length, types = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      types[_key2] = arguments[_key2];
    }

    function validate(node, key, val) {
      for (var _iterator = _createForOfIteratorHelperLoose(types), _step; !(_step = _iterator()).done;) {
        var type = _step.value;

        if (is$1(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
    }

    validate.oneOfNodeTypes = types;
    return validate;
  }
  function assertNodeOrValueType() {
    for (var _len3 = arguments.length, types = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      types[_key3] = arguments[_key3];
    }

    function validate(node, key, val) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(types), _step2; !(_step2 = _iterator2()).done;) {
        var type = _step2.value;

        if (getType$2(val) === type || is$1(type, val)) {
          validateChild(node, key, val);
          return;
        }
      }

      throw new TypeError("Property " + key + " of " + node.type + " expected node to be of a type " + JSON.stringify(types) + " but instead got " + JSON.stringify(val == null ? void 0 : val.type));
    }

    validate.oneOfNodeOrValueTypes = types;
    return validate;
  }
  function assertValueType(type) {
    function validate(node, key, val) {
      var valid = getType$2(val) === type;

      if (!valid) {
        throw new TypeError("Property " + key + " expected type of " + type + " but got " + getType$2(val));
      }
    }

    validate.type = type;
    return validate;
  }
  function assertShape(shape) {
    function validate(node, key, val) {
      var errors = [];

      for (var _i = 0, _Object$keys = Object.keys(shape); _i < _Object$keys.length; _i++) {
        var property = _Object$keys[_i];

        try {
          validateField(node, property, val[property], shape[property]);
        } catch (error) {
          if (error instanceof TypeError) {
            errors.push(error.message);
            continue;
          }

          throw error;
        }
      }

      if (errors.length) {
        throw new TypeError("Property " + key + " of " + node.type + " expected to have the following:\n" + errors.join("\n"));
      }
    }

    validate.shapeOf = shape;
    return validate;
  }
  function assertOptionalChainStart() {
    function validate(node) {
      var _current2;

      var current = node;

      while (node) {
        var _current = current,
            type = _current.type;

        if (type === "OptionalCallExpression") {
          if (current.optional) return;
          current = current.callee;
          continue;
        }

        if (type === "OptionalMemberExpression") {
          if (current.optional) return;
          current = current.object;
          continue;
        }

        break;
      }

      throw new TypeError("Non-optional " + node.type + " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from " + ((_current2 = current) == null ? void 0 : _current2.type));
    }

    return validate;
  }
  function chain$1() {
    for (var _len4 = arguments.length, fns = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      fns[_key4] = arguments[_key4];
    }

    function validate() {
      for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
        var fn = _step3.value;
        fn.apply(void 0, arguments);
      }
    }

    validate.chainOf = fns;

    if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
      throw new Error("An assertValueType(\"array\") validator can only be followed by an assertEach(...) validator.");
    }

    return validate;
  }
  var validTypeOpts = ["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"];
  var validFieldKeys = ["default", "optional", "validate"];
  function defineType(type, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var inherits = opts.inherits && store[opts.inherits] || {};
    var fields = opts.fields;

    if (!fields) {
      fields = {};

      if (inherits.fields) {
        var keys = Object.getOwnPropertyNames(inherits.fields);

        for (var _iterator4 = _createForOfIteratorHelperLoose(keys), _step4; !(_step4 = _iterator4()).done;) {
          var _key5 = _step4.value;
          var field = inherits.fields[_key5];
          var def = field["default"];

          if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
            throw new Error("field defaults can only be primitives or empty arrays currently");
          }

          fields[_key5] = {
            "default": Array.isArray(def) ? [] : def,
            optional: field.optional,
            validate: field.validate
          };
        }
      }
    }

    var visitor = opts.visitor || inherits.visitor || [];
    var aliases = opts.aliases || inherits.aliases || [];
    var builder = opts.builder || inherits.builder || opts.visitor || [];

    for (var _i2 = 0, _Object$keys2 = Object.keys(opts); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];

      if (validTypeOpts.indexOf(k) === -1) {
        throw new Error("Unknown type option \"" + k + "\" on " + type);
      }
    }

    if (opts.deprecatedAlias) {
      DEPRECATED_KEYS[opts.deprecatedAlias] = type;
    }

    for (var _iterator5 = _createForOfIteratorHelperLoose(visitor.concat(builder)), _step5; !(_step5 = _iterator5()).done;) {
      var _key7 = _step5.value;
      fields[_key7] = fields[_key7] || {};
    }

    for (var _i3 = 0, _Object$keys3 = Object.keys(fields); _i3 < _Object$keys3.length; _i3++) {
      var _key6 = _Object$keys3[_i3];
      var _field = fields[_key6];

      if (_field["default"] !== undefined && builder.indexOf(_key6) === -1) {
        _field.optional = true;
      }

      if (_field["default"] === undefined) {
        _field["default"] = null;
      } else if (!_field.validate && _field["default"] != null) {
        _field.validate = assertValueType(getType$2(_field["default"]));
      }

      for (var _i4 = 0, _Object$keys4 = Object.keys(_field); _i4 < _Object$keys4.length; _i4++) {
        var _k = _Object$keys4[_i4];

        if (validFieldKeys.indexOf(_k) === -1) {
          throw new Error("Unknown field key \"" + _k + "\" on " + type + "." + _key6);
        }
      }
    }

    VISITOR_KEYS[type] = opts.visitor = visitor;
    BUILDER_KEYS[type] = opts.builder = builder;
    NODE_FIELDS[type] = opts.fields = fields;
    ALIAS_KEYS[type] = opts.aliases = aliases;
    aliases.forEach(function (alias) {
      FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
      FLIPPED_ALIAS_KEYS[alias].push(type);
    });

    if (opts.validate) {
      NODE_PARENT_VALIDATIONS[type] = opts.validate;
    }

    store[type] = opts;
  }
  var store = {};

  defineType("ArrayExpression", {
    fields: {
      elements: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeOrValueType("null", "Expression", "SpreadElement"))),
        "default": !browser$6.env.BABEL_TYPES_8_BREAKING ? [] : undefined
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("AssignmentExpression", {
    fields: {
      operator: {
        validate: function () {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) {
            return assertValueType("string");
          }

          var identifier = assertOneOf.apply(void 0, _toConsumableArray(ASSIGNMENT_OPERATORS));
          var pattern = assertOneOf("=");
          return function (node, key, val) {
            var validator = is$1("Pattern", node.left) ? pattern : identifier;
            validator(node, key, val);
          };
        }()
      },
      left: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Expression"]
  });
  defineType("BinaryExpression", {
    builder: ["operator", "left", "right"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(BINARY_OPERATORS))
      },
      left: {
        validate: function () {
          var expression = assertNodeType("Expression");
          var inOp = assertNodeType("Expression", "PrivateName");

          var validator = function validator(node, key, val) {
            var validator = node.operator === "in" ? inOp : expression;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "PrivateName"];
          return validator;
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      }
    },
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"]
  });
  defineType("InterpreterDirective", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("Directive", {
    visitor: ["value"],
    fields: {
      value: {
        validate: assertNodeType("DirectiveLiteral")
      }
    }
  });
  defineType("DirectiveLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("BlockStatement", {
    builder: ["body", "directives"],
    visitor: ["directives", "body"],
    fields: {
      directives: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block", "Statement"]
  });
  defineType("BreakStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("CallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments"],
    aliases: ["Expression"],
    fields: Object.assign({
      callee: {
        validate: assertNodeType("Expression", "V8IntrinsicIdentifier")
      },
      arguments: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      }
    }, !browser$6.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {}, {
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    })
  });
  defineType("CatchClause", {
    visitor: ["param", "body"],
    fields: {
      param: {
        validate: assertNodeType("Identifier", "ArrayPattern", "ObjectPattern"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ConditionalExpression", {
    visitor: ["test", "consequent", "alternate"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Expression")
      },
      alternate: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Expression", "Conditional"]
  });
  defineType("ContinueStatement", {
    visitor: ["label"],
    fields: {
      label: {
        validate: assertNodeType("Identifier"),
        optional: true
      }
    },
    aliases: ["Statement", "Terminatorless", "CompletionStatement"]
  });
  defineType("DebuggerStatement", {
    aliases: ["Statement"]
  });
  defineType("DoWhileStatement", {
    visitor: ["test", "body"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    },
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
  });
  defineType("EmptyStatement", {
    aliases: ["Statement"]
  });
  defineType("ExpressionStatement", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    },
    aliases: ["Statement", "ExpressionWrapper"]
  });
  defineType("File", {
    builder: ["program", "comments", "tokens"],
    visitor: ["program"],
    fields: {
      program: {
        validate: assertNodeType("Program")
      },
      comments: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? Object.assign(function () {}, {
          each: {
            oneOfNodeTypes: ["CommentBlock", "CommentLine"]
          }
        }) : assertEach(assertNodeType("CommentBlock", "CommentLine")),
        optional: true
      },
      tokens: {
        validate: assertEach(Object.assign(function () {}, {
          type: "any"
        })),
        optional: true
      }
    }
  });
  defineType("ForInStatement", {
    visitor: ["left", "right", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertNodeType("VariableDeclaration", "LVal") : assertNodeType("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("ForStatement", {
    visitor: ["init", "test", "update", "body"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
    fields: {
      init: {
        validate: assertNodeType("VariableDeclaration", "Expression"),
        optional: true
      },
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      update: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  var functionCommon = {
    params: {
      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement")))
    },
    generator: {
      "default": false
    },
    async: {
      "default": false
    }
  };
  var functionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  var functionDeclarationCommon = Object.assign({}, functionCommon, {
    declare: {
      validate: assertValueType("boolean"),
      optional: true
    },
    id: {
      validate: assertNodeType("Identifier"),
      optional: true
    }
  });
  defineType("FunctionDeclaration", {
    builder: ["id", "params", "body", "generator", "async"],
    visitor: ["id", "params", "body", "returnType", "typeParameters"],
    fields: Object.assign({}, functionDeclarationCommon, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
    validate: function () {
      if (!browser$6.env.BABEL_TYPES_8_BREAKING) return function () {};
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!is$1("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("FunctionExpression", {
    inherits: "FunctionDeclaration",
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  var patternLikeCommon = {
    typeAnnotation: {
      validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
      optional: true
    },
    decorators: {
      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator")))
    }
  };
  defineType("Identifier", {
    builder: ["name"],
    visitor: ["typeAnnotation", "decorators"],
    aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
    fields: Object.assign({}, patternLikeCommon, {
      name: {
        validate: chain$1(assertValueType("string"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (!isValidIdentifier(val, false)) {
            throw new TypeError("\"" + val + "\" is not a valid identifier name");
          }
        }, {
          type: "string"
        }))
      },
      optional: {
        validate: assertValueType("boolean"),
        optional: true
      }
    }),
    validate: function validate(parent, key, node) {
      if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
      var match = /\.(\w+)$/.exec(key);
      if (!match) return;

      var _match = _slicedToArray$2(match, 2),
          parentKey = _match[1];

      var nonComp = {
        computed: false
      };

      if (parentKey === "property") {
        if (is$1("MemberExpression", parent, nonComp)) return;
        if (is$1("OptionalMemberExpression", parent, nonComp)) return;
      } else if (parentKey === "key") {
        if (is$1("Property", parent, nonComp)) return;
        if (is$1("Method", parent, nonComp)) return;
      } else if (parentKey === "exported") {
        if (is$1("ExportSpecifier", parent)) return;
      } else if (parentKey === "imported") {
        if (is$1("ImportSpecifier", parent, {
          imported: node
        })) return;
      } else if (parentKey === "meta") {
        if (is$1("MetaProperty", parent, {
          meta: node
        })) return;
      }

      if ((isKeyword(node.name) || isReservedWord(node.name, false)) && node.name !== "this") {
        throw new TypeError("\"" + node.name + "\" is not a valid identifier");
      }
    }
  });
  defineType("IfStatement", {
    visitor: ["test", "consequent", "alternate"],
    aliases: ["Statement", "Conditional"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      consequent: {
        validate: assertNodeType("Statement")
      },
      alternate: {
        optional: true,
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("LabeledStatement", {
    visitor: ["label", "body"],
    aliases: ["Statement"],
    fields: {
      label: {
        validate: assertNodeType("Identifier")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("StringLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NumericLiteral", {
    builder: ["value"],
    deprecatedAlias: "NumberLiteral",
    fields: {
      value: {
        validate: assertValueType("number")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("NullLiteral", {
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("BooleanLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("boolean")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("RegExpLiteral", {
    builder: ["pattern", "flags"],
    deprecatedAlias: "RegexLiteral",
    aliases: ["Expression", "Pureish", "Literal"],
    fields: {
      pattern: {
        validate: assertValueType("string")
      },
      flags: {
        validate: chain$1(assertValueType("string"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
          var invalid = /[^gimsuy]/.exec(val);

          if (invalid) {
            throw new TypeError("\"" + invalid[0] + "\" is not a valid RegExp flag");
          }
        }, {
          type: "string"
        })),
        "default": ""
      }
    }
  });
  defineType("LogicalExpression", {
    builder: ["operator", "left", "right"],
    visitor: ["left", "right"],
    aliases: ["Binary", "Expression"],
    fields: {
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(LOGICAL_OPERATORS))
      },
      left: {
        validate: assertNodeType("Expression")
      },
      right: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("MemberExpression", {
    builder: ["object", "property", "computed"].concat(_toConsumableArray(!browser$6.env.BABEL_TYPES_8_BREAKING ? ["optional"] : [])),
    visitor: ["object", "property"],
    aliases: ["Expression", "LVal"],
    fields: Object.assign({
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier", "PrivateName");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
          return validator;
        }()
      },
      computed: {
        "default": false
      }
    }, !browser$6.env.BABEL_TYPES_8_BREAKING ? {
      optional: {
        validate: assertOneOf(true, false),
        optional: true
      }
    } : {})
  });
  defineType("NewExpression", {
    inherits: "CallExpression"
  });
  defineType("Program", {
    visitor: ["directives", "body"],
    builder: ["body", "directives", "sourceType", "interpreter"],
    fields: {
      sourceFile: {
        validate: assertValueType("string")
      },
      sourceType: {
        validate: assertOneOf("script", "module"),
        "default": "script"
      },
      interpreter: {
        validate: assertNodeType("InterpreterDirective"),
        "default": null,
        optional: true
      },
      directives: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Directive"))),
        "default": []
      },
      body: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent", "Block"]
  });
  defineType("ObjectExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ObjectMethod", "ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("ObjectMethod", {
    builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      kind: Object.assign({
        validate: assertOneOf("method", "get", "set")
      }, !browser$6.env.BABEL_TYPES_8_BREAKING ? {
        "default": "method"
      } : {}),
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    }),
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
  });
  defineType("ObjectProperty", {
    builder: ["key", "value", "computed", "shorthand"].concat(_toConsumableArray(!browser$6.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : [])),
    fields: {
      computed: {
        "default": false
      },
      key: {
        validate: function () {
          var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral"];
          return validator;
        }()
      },
      value: {
        validate: assertNodeType("Expression", "PatternLike")
      },
      shorthand: {
        validate: chain$1(assertValueType("boolean"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.computed) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
          }
        }, {
          type: "boolean"
        }), function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !is$1("Identifier", node.key)) {
            throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
          }
        }),
        "default": false
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    },
    visitor: ["key", "value", "decorators"],
    aliases: ["UserWhitespacable", "Property", "ObjectMember"],
    validate: function () {
      var pattern = assertNodeType("Identifier", "Pattern");
      var expression = assertNodeType("Expression");
      return function (parent, key, node) {
        if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
        var validator = is$1("ObjectPattern", parent) ? pattern : expression;
        validator(node, "value", node.value);
      };
    }()
  });
  defineType("RestElement", {
    visitor: ["argument", "typeAnnotation"],
    builder: ["argument"],
    aliases: ["LVal", "PatternLike"],
    deprecatedAlias: "RestProperty",
    fields: Object.assign({}, patternLikeCommon, {
      argument: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertNodeType("LVal") : assertNodeType("Identifier", "Pattern", "MemberExpression")
      }
    }),
    validate: function validate(parent, key) {
      if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
      var match = /(\w+)\[(\d+)\]/.exec(key);
      if (!match) throw new Error("Internal Babel error: malformed key.");

      var _match2 = _slicedToArray$2(match, 3),
          listKey = _match2[1],
          index = _match2[2];

      if (parent[listKey].length > index + 1) {
        throw new TypeError("RestElement must be last element of " + listKey);
      }
    }
  });
  defineType("ReturnStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression"),
        optional: true
      }
    }
  });
  defineType("SequenceExpression", {
    visitor: ["expressions"],
    fields: {
      expressions: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression")))
      }
    },
    aliases: ["Expression"]
  });
  defineType("ParenthesizedExpression", {
    visitor: ["expression"],
    aliases: ["Expression", "ExpressionWrapper"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("SwitchCase", {
    visitor: ["test", "consequent"],
    fields: {
      test: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      consequent: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    }
  });
  defineType("SwitchStatement", {
    visitor: ["discriminant", "cases"],
    aliases: ["Statement", "BlockParent", "Scopable"],
    fields: {
      discriminant: {
        validate: assertNodeType("Expression")
      },
      cases: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("SwitchCase")))
      }
    }
  });
  defineType("ThisExpression", {
    aliases: ["Expression"]
  });
  defineType("ThrowStatement", {
    visitor: ["argument"],
    aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("TryStatement", {
    visitor: ["block", "handler", "finalizer"],
    aliases: ["Statement"],
    fields: {
      block: {
        validate: chain$1(assertNodeType("BlockStatement"), Object.assign(function (node) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (!node.handler && !node.finalizer) {
            throw new TypeError("TryStatement expects either a handler or finalizer, or both");
          }
        }, {
          oneOfNodeTypes: ["BlockStatement"]
        }))
      },
      handler: {
        optional: true,
        validate: assertNodeType("CatchClause")
      },
      finalizer: {
        optional: true,
        validate: assertNodeType("BlockStatement")
      }
    }
  });
  defineType("UnaryExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": true
      },
      argument: {
        validate: assertNodeType("Expression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(UNARY_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["UnaryLike", "Expression"]
  });
  defineType("UpdateExpression", {
    builder: ["operator", "argument", "prefix"],
    fields: {
      prefix: {
        "default": false
      },
      argument: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertNodeType("Expression") : assertNodeType("Identifier", "MemberExpression")
      },
      operator: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(UPDATE_OPERATORS))
      }
    },
    visitor: ["argument"],
    aliases: ["Expression"]
  });
  defineType("VariableDeclaration", {
    builder: ["kind", "declarations"],
    visitor: ["declarations"],
    aliases: ["Statement", "Declaration"],
    fields: {
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      kind: {
        validate: assertOneOf("var", "let", "const")
      },
      declarations: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("VariableDeclarator")))
      }
    },
    validate: function validate(parent, key, node) {
      if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
      if (!is$1("ForXStatement", parent, {
        left: node
      })) return;

      if (node.declarations.length !== 1) {
        throw new TypeError("Exactly one VariableDeclarator is required in the VariableDeclaration of a " + parent.type);
      }
    }
  });
  defineType("VariableDeclarator", {
    visitor: ["id", "init"],
    fields: {
      id: {
        validate: function () {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("LVal");
          }

          var normal = assertNodeType("Identifier", "ArrayPattern", "ObjectPattern");
          var without = assertNodeType("Identifier");
          return function (node, key, val) {
            var validator = node.init ? normal : without;
            validator(node, key, val);
          };
        }()
      },
      definite: {
        optional: true,
        validate: assertValueType("boolean")
      },
      init: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("WhileStatement", {
    visitor: ["test", "body"],
    aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    fields: {
      test: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("WithStatement", {
    visitor: ["object", "body"],
    aliases: ["Statement"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      }
    }
  });
  defineType("AssignmentPattern", {
    visitor: ["left", "right", "decorators"],
    builder: ["left", "right"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      left: {
        validate: assertNodeType("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression")
      },
      right: {
        validate: assertNodeType("Expression")
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrayPattern", {
    visitor: ["elements", "typeAnnotation"],
    builder: ["elements"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      elements: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeOrValueType("null", "PatternLike")))
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    })
  });
  defineType("ArrowFunctionExpression", {
    builder: ["params", "body", "async"],
    visitor: ["params", "body", "returnType", "typeParameters"],
    aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
    fields: Object.assign({}, functionCommon, functionTypeAnnotationCommon, {
      expression: {
        validate: assertValueType("boolean")
      },
      body: {
        validate: assertNodeType("BlockStatement", "Expression")
      }
    })
  });
  defineType("ClassBody", {
    visitor: ["body"],
    fields: {
      body: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "TSDeclareMethod", "TSIndexSignature")))
      }
    }
  });
  defineType("ClassExpression", {
    builder: ["id", "superClass", "body", "decorators"],
    visitor: ["id", "body", "superClass", "mixins", "typeParameters", "superTypeParameters", "implements", "decorators"],
    aliases: ["Scopable", "Class", "Expression"],
    fields: {
      id: {
        validate: assertNodeType("Identifier"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      "implements": {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      mixins: {
        validate: assertNodeType("InterfaceExtends"),
        optional: true
      }
    }
  });
  defineType("ClassDeclaration", {
    inherits: "ClassExpression",
    aliases: ["Scopable", "Class", "Statement", "Declaration"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      },
      body: {
        validate: assertNodeType("ClassBody")
      },
      superClass: {
        optional: true,
        validate: assertNodeType("Expression")
      },
      superTypeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      },
      "implements": {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSExpressionWithTypeArguments", "ClassImplements"))),
        optional: true
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      mixins: {
        validate: assertNodeType("InterfaceExtends"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      },
      "abstract": {
        validate: assertValueType("boolean"),
        optional: true
      }
    },
    validate: function () {
      var identifier = assertNodeType("Identifier");
      return function (parent, key, node) {
        if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

        if (!is$1("ExportDefaultDeclaration", parent)) {
          identifier(node, "id", node.id);
        }
      };
    }()
  });
  defineType("ExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      source: {
        validate: assertNodeType("StringLiteral")
      },
      exportKind: validateOptional(assertOneOf("type", "value")),
      assertions: {
        optional: true,
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
      }
    }
  });
  defineType("ExportDefaultDeclaration", {
    visitor: ["declaration"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        validate: assertNodeType("FunctionDeclaration", "TSDeclareFunction", "ClassDeclaration", "Expression")
      }
    }
  });
  defineType("ExportNamedDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration", "ExportDeclaration"],
    fields: {
      declaration: {
        optional: true,
        validate: chain$1(assertNodeType("Declaration"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.specifiers.length) {
            throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
          }
        }, {
          oneOfNodeTypes: ["Declaration"]
        }), function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (val && node.source) {
            throw new TypeError("Cannot export a declaration from a source");
          }
        })
      },
      assertions: {
        optional: true,
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
      },
      specifiers: {
        "default": [],
        validate: chain$1(assertValueType("array"), assertEach(function () {
          var sourced = assertNodeType("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
          var sourceless = assertNodeType("ExportSpecifier");
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return sourced;
          return function (node, key, val) {
            var validator = node.source ? sourced : sourceless;
            validator(node, key, val);
          };
        }()))
      },
      source: {
        validate: assertNodeType("StringLiteral"),
        optional: true
      },
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("ExportSpecifier", {
    visitor: ["local", "exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      exported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      }
    }
  });
  defineType("ForOfStatement", {
    visitor: ["left", "right", "body"],
    builder: ["left", "right", "body", "await"],
    aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
    fields: {
      left: {
        validate: function () {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) {
            return assertNodeType("VariableDeclaration", "LVal");
          }

          var declaration = assertNodeType("VariableDeclaration");
          var lval = assertNodeType("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern");
          return function (node, key, val) {
            if (is$1("VariableDeclaration", val)) {
              declaration(node, key, val);
            } else {
              lval(node, key, val);
            }
          };
        }()
      },
      right: {
        validate: assertNodeType("Expression")
      },
      body: {
        validate: assertNodeType("Statement")
      },
      "await": {
        "default": false
      }
    }
  });
  defineType("ImportDeclaration", {
    visitor: ["specifiers", "source"],
    aliases: ["Statement", "Declaration", "ModuleDeclaration"],
    fields: {
      assertions: {
        optional: true,
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportAttribute")))
      },
      specifiers: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier")))
      },
      source: {
        validate: assertNodeType("StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof", "value"),
        optional: true
      }
    }
  });
  defineType("ImportDefaultSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportNamespaceSpecifier", {
    visitor: ["local"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("ImportSpecifier", {
    visitor: ["local", "imported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      local: {
        validate: assertNodeType("Identifier")
      },
      imported: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      importKind: {
        validate: assertOneOf("type", "typeof"),
        optional: true
      }
    }
  });
  defineType("MetaProperty", {
    visitor: ["meta", "property"],
    aliases: ["Expression"],
    fields: {
      meta: {
        validate: chain$1(assertNodeType("Identifier"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;
          var property;

          switch (val.name) {
            case "function":
              property = "sent";
              break;

            case "new":
              property = "target";
              break;

            case "import":
              property = "meta";
              break;
          }

          if (!is$1("Identifier", node.property, {
            name: property
          })) {
            throw new TypeError("Unrecognised MetaProperty");
          }
        }, {
          oneOfNodeTypes: ["Identifier"]
        }))
      },
      property: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  var classMethodOrPropertyCommon = {
    "abstract": {
      validate: assertValueType("boolean"),
      optional: true
    },
    accessibility: {
      validate: assertOneOf("public", "private", "protected"),
      optional: true
    },
    "static": {
      "default": false
    },
    override: {
      "default": false
    },
    computed: {
      "default": false
    },
    optional: {
      validate: assertValueType("boolean"),
      optional: true
    },
    key: {
      validate: chain$1(function () {
        var normal = assertNodeType("Identifier", "StringLiteral", "NumericLiteral");
        var computed = assertNodeType("Expression");
        return function (node, key, val) {
          var validator = node.computed ? computed : normal;
          validator(node, key, val);
        };
      }(), assertNodeType("Identifier", "StringLiteral", "NumericLiteral", "Expression"))
    }
  };
  var classMethodOrDeclareMethodCommon = Object.assign({}, functionCommon, classMethodOrPropertyCommon, {
    params: {
      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Identifier", "Pattern", "RestElement", "TSParameterProperty")))
    },
    kind: {
      validate: assertOneOf("get", "set", "method", "constructor"),
      "default": "method"
    },
    access: {
      validate: chain$1(assertValueType("string"), assertOneOf("public", "private", "protected")),
      optional: true
    },
    decorators: {
      validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
      optional: true
    }
  });
  defineType("ClassMethod", {
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
    builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("ObjectPattern", {
    visitor: ["properties", "typeAnnotation", "decorators"],
    builder: ["properties"],
    aliases: ["Pattern", "PatternLike", "LVal"],
    fields: Object.assign({}, patternLikeCommon, {
      properties: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("RestElement", "ObjectProperty")))
      }
    })
  });
  defineType("SpreadElement", {
    visitor: ["argument"],
    aliases: ["UnaryLike"],
    deprecatedAlias: "SpreadProperty",
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("Super", {
    aliases: ["Expression"]
  });
  defineType("TaggedTemplateExpression", {
    visitor: ["tag", "quasi"],
    aliases: ["Expression"],
    fields: {
      tag: {
        validate: assertNodeType("Expression")
      },
      quasi: {
        validate: assertNodeType("TemplateLiteral")
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("TemplateElement", {
    builder: ["value", "tail"],
    fields: {
      value: {
        validate: assertShape({
          raw: {
            validate: assertValueType("string")
          },
          cooked: {
            validate: assertValueType("string"),
            optional: true
          }
        })
      },
      tail: {
        "default": false
      }
    }
  });
  defineType("TemplateLiteral", {
    visitor: ["quasis", "expressions"],
    aliases: ["Expression", "Literal"],
    fields: {
      quasis: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TemplateElement")))
      },
      expressions: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "TSType")), function (node, key, val) {
          if (node.quasis.length !== val.length + 1) {
            throw new TypeError("Number of " + node.type + " quasis should be exactly one more than the number of expressions.\nExpected " + (val.length + 1) + " quasis but got " + node.quasis.length);
          }
        })
      }
    }
  });
  defineType("YieldExpression", {
    builder: ["argument", "delegate"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      delegate: {
        validate: chain$1(assertValueType("boolean"), Object.assign(function (node, key, val) {
          if (!browser$6.env.BABEL_TYPES_8_BREAKING) return;

          if (val && !node.argument) {
            throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
          }
        }, {
          type: "boolean"
        })),
        "default": false
      },
      argument: {
        optional: true,
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("AwaitExpression", {
    builder: ["argument"],
    visitor: ["argument"],
    aliases: ["Expression", "Terminatorless"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("Import", {
    aliases: ["Expression"]
  });
  defineType("BigIntLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("ExportNamespaceSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("OptionalMemberExpression", {
    builder: ["object", "property", "computed", "optional"],
    visitor: ["object", "property"],
    aliases: ["Expression"],
    fields: {
      object: {
        validate: assertNodeType("Expression")
      },
      property: {
        validate: function () {
          var normal = assertNodeType("Identifier");
          var computed = assertNodeType("Expression");

          var validator = function validator(node, key, val) {
            var validator = node.computed ? computed : normal;
            validator(node, key, val);
          };

          validator.oneOfNodeTypes = ["Expression", "Identifier"];
          return validator;
        }()
      },
      computed: {
        "default": false
      },
      optional: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain$1(assertValueType("boolean"), assertOptionalChainStart())
      }
    }
  });
  defineType("OptionalCallExpression", {
    visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
    builder: ["callee", "arguments", "optional"],
    aliases: ["Expression"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      },
      arguments: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement", "JSXNamespacedName", "ArgumentPlaceholder")))
      },
      optional: {
        validate: !browser$6.env.BABEL_TYPES_8_BREAKING ? assertValueType("boolean") : chain$1(assertValueType("boolean"), assertOptionalChainStart())
      },
      typeArguments: {
        validate: assertNodeType("TypeParameterInstantiation"),
        optional: true
      },
      typeParameters: {
        validate: assertNodeType("TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });

  var defineInterfaceishType = function defineInterfaceishType(name, typeParameterType) {
    if (typeParameterType === void 0) {
      typeParameterType = "TypeParameterDeclaration";
    }

    defineType(name, {
      builder: ["id", "typeParameters", "extends", "body"],
      visitor: ["id", "typeParameters", "extends", "mixins", "implements", "body"],
      aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: validateType("Identifier"),
        typeParameters: validateOptionalType(typeParameterType),
        "extends": validateOptional(arrayOfType("InterfaceExtends")),
        mixins: validateOptional(arrayOfType("InterfaceExtends")),
        "implements": validateOptional(arrayOfType("ClassImplements")),
        body: validateType("ObjectTypeAnnotation")
      }
    });
  };

  defineType("AnyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ArrayTypeAnnotation", {
    visitor: ["elementType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      elementType: validateType("FlowType")
    }
  });
  defineType("BooleanTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("BooleanLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$2(assertValueType("boolean"))
    }
  });
  defineType("NullLiteralTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ClassImplements", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("DeclareClass");
  defineType("DeclareFunction", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      predicate: validateOptionalType("DeclaredPredicate")
    }
  });
  defineInterfaceishType("DeclareInterface");
  defineType("DeclareModule", {
    builder: ["id", "body", "kind"],
    visitor: ["id", "body"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType("BlockStatement"),
      kind: validateOptional(assertOneOf("CommonJS", "ES"))
    }
  });
  defineType("DeclareModuleExports", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("DeclareTypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("DeclareOpaqueType", {
    visitor: ["id", "typeParameters", "supertype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType")
    }
  });
  defineType("DeclareVariable", {
    visitor: ["id"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("DeclareExportDeclaration", {
    visitor: ["declaration", "specifiers", "source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      declaration: validateOptionalType("Flow"),
      specifiers: validateOptional(arrayOfType(["ExportSpecifier", "ExportNamespaceSpecifier"])),
      source: validateOptionalType("StringLiteral"),
      "default": validateOptional(assertValueType("boolean"))
    }
  });
  defineType("DeclareExportAllDeclaration", {
    visitor: ["source"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      source: validateType("StringLiteral"),
      exportKind: validateOptional(assertOneOf("type", "value"))
    }
  });
  defineType("DeclaredPredicate", {
    visitor: ["value"],
    aliases: ["Flow", "FlowPredicate"],
    fields: {
      value: validateType("Flow")
    }
  });
  defineType("ExistsTypeAnnotation", {
    aliases: ["Flow", "FlowType"]
  });
  defineType("FunctionTypeAnnotation", {
    visitor: ["typeParameters", "params", "rest", "returnType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      params: validate$2(arrayOfType("FunctionTypeParam")),
      rest: validateOptionalType("FunctionTypeParam"),
      "this": validateOptionalType("FunctionTypeParam"),
      returnType: validateType("FlowType")
    }
  });
  defineType("FunctionTypeParam", {
    visitor: ["name", "typeAnnotation"],
    aliases: ["Flow"],
    fields: {
      name: validateOptionalType("Identifier"),
      typeAnnotation: validateType("FlowType"),
      optional: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("GenericTypeAnnotation", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow", "FlowType"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineType("InferredPredicate", {
    aliases: ["Flow", "FlowPredicate"]
  });
  defineType("InterfaceExtends", {
    visitor: ["id", "typeParameters"],
    aliases: ["Flow"],
    fields: {
      id: validateType(["Identifier", "QualifiedTypeIdentifier"]),
      typeParameters: validateOptionalType("TypeParameterInstantiation")
    }
  });
  defineInterfaceishType("InterfaceDeclaration");
  defineType("InterfaceTypeAnnotation", {
    visitor: ["extends", "body"],
    aliases: ["Flow", "FlowType"],
    fields: {
      "extends": validateOptional(arrayOfType("InterfaceExtends")),
      body: validateType("ObjectTypeAnnotation")
    }
  });
  defineType("IntersectionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$2(arrayOfType("FlowType"))
    }
  });
  defineType("MixedTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EmptyTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("NullableTypeAnnotation", {
    visitor: ["typeAnnotation"],
    aliases: ["Flow", "FlowType"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("NumberLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$2(assertValueType("number"))
    }
  });
  defineType("NumberTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ObjectTypeAnnotation", {
    visitor: ["properties", "indexers", "callProperties", "internalSlots"],
    aliases: ["Flow", "FlowType"],
    builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
    fields: {
      properties: validate$2(arrayOfType(["ObjectTypeProperty", "ObjectTypeSpreadProperty"])),
      indexers: validateOptional(arrayOfType("ObjectTypeIndexer")),
      callProperties: validateOptional(arrayOfType("ObjectTypeCallProperty")),
      internalSlots: validateOptional(arrayOfType("ObjectTypeInternalSlot")),
      exact: {
        validate: assertValueType("boolean"),
        "default": false
      },
      inexact: validateOptional(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeInternalSlot", {
    visitor: ["id", "value", "optional", "static", "method"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateType("Identifier"),
      value: validateType("FlowType"),
      optional: validate$2(assertValueType("boolean")),
      "static": validate$2(assertValueType("boolean")),
      method: validate$2(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeCallProperty", {
    visitor: ["value"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      value: validateType("FlowType"),
      "static": validate$2(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeIndexer", {
    visitor: ["id", "key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      id: validateOptionalType("Identifier"),
      key: validateType("FlowType"),
      value: validateType("FlowType"),
      "static": validate$2(assertValueType("boolean")),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("ObjectTypeProperty", {
    visitor: ["key", "value", "variance"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      key: validateType(["Identifier", "StringLiteral"]),
      value: validateType("FlowType"),
      kind: validate$2(assertOneOf("init", "get", "set")),
      "static": validate$2(assertValueType("boolean")),
      proto: validate$2(assertValueType("boolean")),
      optional: validate$2(assertValueType("boolean")),
      variance: validateOptionalType("Variance"),
      method: validate$2(assertValueType("boolean"))
    }
  });
  defineType("ObjectTypeSpreadProperty", {
    visitor: ["argument"],
    aliases: ["Flow", "UserWhitespacable"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("OpaqueType", {
    visitor: ["id", "typeParameters", "supertype", "impltype"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      supertype: validateOptionalType("FlowType"),
      impltype: validateType("FlowType")
    }
  });
  defineType("QualifiedTypeIdentifier", {
    visitor: ["id", "qualification"],
    aliases: ["Flow"],
    fields: {
      id: validateType("Identifier"),
      qualification: validateType(["Identifier", "QualifiedTypeIdentifier"])
    }
  });
  defineType("StringLiteralTypeAnnotation", {
    builder: ["value"],
    aliases: ["Flow", "FlowType"],
    fields: {
      value: validate$2(assertValueType("string"))
    }
  });
  defineType("StringTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("SymbolTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("ThisTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("TupleTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$2(arrayOfType("FlowType"))
    }
  });
  defineType("TypeofTypeAnnotation", {
    visitor: ["argument"],
    aliases: ["Flow", "FlowType"],
    fields: {
      argument: validateType("FlowType")
    }
  });
  defineType("TypeAlias", {
    visitor: ["id", "typeParameters", "right"],
    aliases: ["Flow", "FlowDeclaration", "Statement", "Declaration"],
    fields: {
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TypeParameterDeclaration"),
      right: validateType("FlowType")
    }
  });
  defineType("TypeAnnotation", {
    aliases: ["Flow"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("FlowType")
    }
  });
  defineType("TypeCastExpression", {
    visitor: ["expression", "typeAnnotation"],
    aliases: ["Flow", "ExpressionWrapper", "Expression"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TypeAnnotation")
    }
  });
  defineType("TypeParameter", {
    aliases: ["Flow"],
    visitor: ["bound", "default", "variance"],
    fields: {
      name: validate$2(assertValueType("string")),
      bound: validateOptionalType("TypeAnnotation"),
      "default": validateOptionalType("FlowType"),
      variance: validateOptionalType("Variance")
    }
  });
  defineType("TypeParameterDeclaration", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$2(arrayOfType("TypeParameter"))
    }
  });
  defineType("TypeParameterInstantiation", {
    aliases: ["Flow"],
    visitor: ["params"],
    fields: {
      params: validate$2(arrayOfType("FlowType"))
    }
  });
  defineType("UnionTypeAnnotation", {
    visitor: ["types"],
    aliases: ["Flow", "FlowType"],
    fields: {
      types: validate$2(arrayOfType("FlowType"))
    }
  });
  defineType("Variance", {
    aliases: ["Flow"],
    builder: ["kind"],
    fields: {
      kind: validate$2(assertOneOf("minus", "plus"))
    }
  });
  defineType("VoidTypeAnnotation", {
    aliases: ["Flow", "FlowType", "FlowBaseAnnotation"]
  });
  defineType("EnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      id: validateType("Identifier"),
      body: validateType(["EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody"])
    }
  });
  defineType("EnumBooleanBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$2(assertValueType("boolean")),
      members: validateArrayOfType("EnumBooleanMember"),
      hasUnknownMembers: validate$2(assertValueType("boolean"))
    }
  });
  defineType("EnumNumberBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$2(assertValueType("boolean")),
      members: validateArrayOfType("EnumNumberMember"),
      hasUnknownMembers: validate$2(assertValueType("boolean"))
    }
  });
  defineType("EnumStringBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      explicitType: validate$2(assertValueType("boolean")),
      members: validateArrayOfType(["EnumStringMember", "EnumDefaultedMember"]),
      hasUnknownMembers: validate$2(assertValueType("boolean"))
    }
  });
  defineType("EnumSymbolBody", {
    aliases: ["EnumBody"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("EnumDefaultedMember"),
      hasUnknownMembers: validate$2(assertValueType("boolean"))
    }
  });
  defineType("EnumBooleanMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("BooleanLiteral")
    }
  });
  defineType("EnumNumberMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("NumericLiteral")
    }
  });
  defineType("EnumStringMember", {
    aliases: ["EnumMember"],
    visitor: ["id", "init"],
    fields: {
      id: validateType("Identifier"),
      init: validateType("StringLiteral")
    }
  });
  defineType("EnumDefaultedMember", {
    aliases: ["EnumMember"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("IndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      objectType: validateType("FlowType"),
      indexType: validateType("FlowType")
    }
  });
  defineType("OptionalIndexedAccessType", {
    visitor: ["objectType", "indexType"],
    aliases: ["Flow", "FlowType"],
    fields: {
      objectType: validateType("FlowType"),
      indexType: validateType("FlowType"),
      optional: validate$2(assertValueType("boolean"))
    }
  });

  defineType("JSXAttribute", {
    visitor: ["name", "value"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXNamespacedName")
      },
      value: {
        optional: true,
        validate: assertNodeType("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
      }
    }
  });
  defineType("JSXClosingElement", {
    visitor: ["name"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      }
    }
  });
  defineType("JSXElement", {
    builder: ["openingElement", "closingElement", "children", "selfClosing"],
    visitor: ["openingElement", "children", "closingElement"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingElement: {
        validate: assertNodeType("JSXOpeningElement")
      },
      closingElement: {
        optional: true,
        validate: assertNodeType("JSXClosingElement")
      },
      children: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      },
      selfClosing: {
        validate: assertValueType("boolean"),
        optional: true
      }
    }
  });
  defineType("JSXEmptyExpression", {
    aliases: ["JSX"]
  });
  defineType("JSXExpressionContainer", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression", "JSXEmptyExpression")
      }
    }
  });
  defineType("JSXSpreadChild", {
    visitor: ["expression"],
    aliases: ["JSX", "Immutable"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXIdentifier", {
    builder: ["name"],
    aliases: ["JSX"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXMemberExpression", {
    visitor: ["object", "property"],
    aliases: ["JSX"],
    fields: {
      object: {
        validate: assertNodeType("JSXMemberExpression", "JSXIdentifier")
      },
      property: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXNamespacedName", {
    visitor: ["namespace", "name"],
    aliases: ["JSX"],
    fields: {
      namespace: {
        validate: assertNodeType("JSXIdentifier")
      },
      name: {
        validate: assertNodeType("JSXIdentifier")
      }
    }
  });
  defineType("JSXOpeningElement", {
    builder: ["name", "attributes", "selfClosing"],
    visitor: ["name", "attributes"],
    aliases: ["JSX", "Immutable"],
    fields: {
      name: {
        validate: assertNodeType("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
      },
      selfClosing: {
        "default": false
      },
      attributes: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXAttribute", "JSXSpreadAttribute")))
      },
      typeParameters: {
        validate: assertNodeType("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
        optional: true
      }
    }
  });
  defineType("JSXSpreadAttribute", {
    visitor: ["argument"],
    aliases: ["JSX"],
    fields: {
      argument: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("JSXText", {
    aliases: ["JSX", "Immutable"],
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    }
  });
  defineType("JSXFragment", {
    builder: ["openingFragment", "closingFragment", "children"],
    visitor: ["openingFragment", "children", "closingFragment"],
    aliases: ["JSX", "Immutable", "Expression"],
    fields: {
      openingFragment: {
        validate: assertNodeType("JSXOpeningFragment")
      },
      closingFragment: {
        validate: assertNodeType("JSXClosingFragment")
      },
      children: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")))
      }
    }
  });
  defineType("JSXOpeningFragment", {
    aliases: ["JSX", "Immutable"]
  });
  defineType("JSXClosingFragment", {
    aliases: ["JSX", "Immutable"]
  });

  var PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
  var PLACEHOLDERS_ALIAS = {
    Declaration: ["Statement"],
    Pattern: ["PatternLike", "LVal"]
  };

  for (var _i$3 = 0, _PLACEHOLDERS = PLACEHOLDERS; _i$3 < _PLACEHOLDERS.length; _i$3++) {
    var type$2 = _PLACEHOLDERS[_i$3];
    var alias = ALIAS_KEYS[type$2];
    if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type$2] = alias;
  }

  var PLACEHOLDERS_FLIPPED_ALIAS = {};
  Object.keys(PLACEHOLDERS_ALIAS).forEach(function (type) {
    PLACEHOLDERS_ALIAS[type].forEach(function (alias) {
      if (!Object.hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
        PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
      }

      PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
    });
  });

  {
    defineType("Noop", {
      visitor: []
    });
  }
  defineType("Placeholder", {
    visitor: [],
    builder: ["expectedNode", "name"],
    fields: {
      name: {
        validate: assertNodeType("Identifier")
      },
      expectedNode: {
        validate: assertOneOf.apply(void 0, _toConsumableArray(PLACEHOLDERS))
      }
    }
  });
  defineType("V8IntrinsicIdentifier", {
    builder: ["name"],
    fields: {
      name: {
        validate: assertValueType("string")
      }
    }
  });

  defineType("ArgumentPlaceholder", {});
  defineType("BindExpression", {
    visitor: ["object", "callee"],
    aliases: ["Expression"],
    fields: !browser$6.env.BABEL_TYPES_8_BREAKING ? {
      object: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      },
      callee: {
        validate: Object.assign(function () {}, {
          oneOfNodeTypes: ["Expression"]
        })
      }
    } : {
      object: {
        validate: assertNodeType("Expression")
      },
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("ClassProperty", {
    visitor: ["key", "value", "typeAnnotation", "decorators"],
    builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
    aliases: ["Property"],
    fields: Object.assign({}, classMethodOrPropertyCommon, {
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      definite: {
        validate: assertValueType("boolean"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      declare: {
        validate: assertValueType("boolean"),
        optional: true
      }
    })
  });
  defineType("PipelineTopicExpression", {
    builder: ["expression"],
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelineBareFunction", {
    builder: ["callee"],
    visitor: ["callee"],
    fields: {
      callee: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("PipelinePrimaryTopicReference", {
    aliases: ["Expression"]
  });
  defineType("ClassPrivateProperty", {
    visitor: ["key", "value", "decorators"],
    builder: ["key", "value", "decorators", "static"],
    aliases: ["Property", "Private"],
    fields: {
      key: {
        validate: assertNodeType("PrivateName")
      },
      value: {
        validate: assertNodeType("Expression"),
        optional: true
      },
      typeAnnotation: {
        validate: assertNodeType("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      decorators: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Decorator"))),
        optional: true
      }
    }
  });
  defineType("ClassPrivateMethod", {
    builder: ["kind", "key", "params", "body", "static"],
    visitor: ["key", "params", "body", "decorators", "returnType", "typeParameters"],
    aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, functionTypeAnnotationCommon, {
      key: {
        validate: assertNodeType("PrivateName")
      },
      body: {
        validate: assertNodeType("BlockStatement")
      }
    })
  });
  defineType("ImportAttribute", {
    visitor: ["key", "value"],
    fields: {
      key: {
        validate: assertNodeType("Identifier", "StringLiteral")
      },
      value: {
        validate: assertNodeType("StringLiteral")
      }
    }
  });
  defineType("Decorator", {
    visitor: ["expression"],
    fields: {
      expression: {
        validate: assertNodeType("Expression")
      }
    }
  });
  defineType("DoExpression", {
    visitor: ["body"],
    builder: ["body", "async"],
    aliases: ["Expression"],
    fields: {
      body: {
        validate: assertNodeType("BlockStatement")
      },
      async: {
        validate: assertValueType("boolean"),
        "default": false
      }
    }
  });
  defineType("ExportDefaultSpecifier", {
    visitor: ["exported"],
    aliases: ["ModuleSpecifier"],
    fields: {
      exported: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("PrivateName", {
    visitor: ["id"],
    aliases: ["Private"],
    fields: {
      id: {
        validate: assertNodeType("Identifier")
      }
    }
  });
  defineType("RecordExpression", {
    visitor: ["properties"],
    aliases: ["Expression"],
    fields: {
      properties: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("ObjectProperty", "SpreadElement")))
      }
    }
  });
  defineType("TupleExpression", {
    fields: {
      elements: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Expression", "SpreadElement"))),
        "default": []
      }
    },
    visitor: ["elements"],
    aliases: ["Expression"]
  });
  defineType("DecimalLiteral", {
    builder: ["value"],
    fields: {
      value: {
        validate: assertValueType("string")
      }
    },
    aliases: ["Expression", "Pureish", "Literal", "Immutable"]
  });
  defineType("StaticBlock", {
    visitor: ["body"],
    fields: {
      body: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("Statement")))
      }
    },
    aliases: ["Scopable", "BlockParent"]
  });
  defineType("ModuleExpression", {
    visitor: ["body"],
    fields: {
      body: {
        validate: assertNodeType("Program")
      }
    },
    aliases: ["Expression"]
  });

  var bool = assertValueType("boolean");
  var tSFunctionTypeAnnotationCommon = {
    returnType: {
      validate: assertNodeType("TSTypeAnnotation", "Noop"),
      optional: true
    },
    typeParameters: {
      validate: assertNodeType("TSTypeParameterDeclaration", "Noop"),
      optional: true
    }
  };
  defineType("TSParameterProperty", {
    aliases: ["LVal"],
    visitor: ["parameter"],
    fields: {
      accessibility: {
        validate: assertOneOf("public", "private", "protected"),
        optional: true
      },
      readonly: {
        validate: assertValueType("boolean"),
        optional: true
      },
      parameter: {
        validate: assertNodeType("Identifier", "AssignmentPattern")
      }
    }
  });
  defineType("TSDeclareFunction", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, functionDeclarationCommon, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSDeclareMethod", {
    visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
    fields: Object.assign({}, classMethodOrDeclareMethodCommon, tSFunctionTypeAnnotationCommon)
  });
  defineType("TSQualifiedName", {
    aliases: ["TSEntityName"],
    visitor: ["left", "right"],
    fields: {
      left: validateType("TSEntityName"),
      right: validateType("Identifier")
    }
  });
  var signatureDeclarationCommon = {
    typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
    parameters: validateArrayOfType(["Identifier", "RestElement"]),
    typeAnnotation: validateOptionalType("TSTypeAnnotation")
  };
  var callConstructSignatureDeclaration = {
    aliases: ["TSTypeElement"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"],
    fields: signatureDeclarationCommon
  };
  defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
  defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
  var namedTypeElementCommon = {
    key: validateType("Expression"),
    computed: validate$2(bool),
    optional: validateOptional(bool)
  };
  defineType("TSPropertySignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeAnnotation", "initializer"],
    fields: Object.assign({}, namedTypeElementCommon, {
      readonly: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      initializer: validateOptionalType("Expression")
    })
  });
  defineType("TSMethodSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
    fields: Object.assign({}, signatureDeclarationCommon, namedTypeElementCommon, {
      kind: {
        validate: assertOneOf("method", "get", "set")
      }
    })
  });
  defineType("TSIndexSignature", {
    aliases: ["TSTypeElement"],
    visitor: ["parameters", "typeAnnotation"],
    fields: {
      readonly: validateOptional(bool),
      "static": validateOptional(bool),
      parameters: validateArrayOfType("Identifier"),
      typeAnnotation: validateOptionalType("TSTypeAnnotation")
    }
  });
  var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];

  for (var _i$2 = 0, _tsKeywordTypes = tsKeywordTypes; _i$2 < _tsKeywordTypes.length; _i$2++) {
    var type$1 = _tsKeywordTypes[_i$2];
    defineType(type$1, {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
  }

  defineType("TSThisType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: [],
    fields: {}
  });
  var fnOrCtrBase = {
    aliases: ["TSType"],
    visitor: ["typeParameters", "parameters", "typeAnnotation"]
  };
  defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
    fields: signatureDeclarationCommon
  }));
  defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
    fields: Object.assign({}, signatureDeclarationCommon, {
      "abstract": validateOptional(bool)
    })
  }));
  defineType("TSTypeReference", {
    aliases: ["TSType"],
    visitor: ["typeName", "typeParameters"],
    fields: {
      typeName: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSTypePredicate", {
    aliases: ["TSType"],
    visitor: ["parameterName", "typeAnnotation"],
    builder: ["parameterName", "typeAnnotation", "asserts"],
    fields: {
      parameterName: validateType(["Identifier", "TSThisType"]),
      typeAnnotation: validateOptionalType("TSTypeAnnotation"),
      asserts: validateOptional(bool)
    }
  });
  defineType("TSTypeQuery", {
    aliases: ["TSType"],
    visitor: ["exprName"],
    fields: {
      exprName: validateType(["TSEntityName", "TSImportType"])
    }
  });
  defineType("TSTypeLiteral", {
    aliases: ["TSType"],
    visitor: ["members"],
    fields: {
      members: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSArrayType", {
    aliases: ["TSType"],
    visitor: ["elementType"],
    fields: {
      elementType: validateType("TSType")
    }
  });
  defineType("TSTupleType", {
    aliases: ["TSType"],
    visitor: ["elementTypes"],
    fields: {
      elementTypes: validateArrayOfType(["TSType", "TSNamedTupleMember"])
    }
  });
  defineType("TSOptionalType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSRestType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSNamedTupleMember", {
    visitor: ["label", "elementType"],
    builder: ["label", "elementType", "optional"],
    fields: {
      label: validateType("Identifier"),
      optional: {
        validate: bool,
        "default": false
      },
      elementType: validateType("TSType")
    }
  });
  var unionOrIntersection = {
    aliases: ["TSType"],
    visitor: ["types"],
    fields: {
      types: validateArrayOfType("TSType")
    }
  };
  defineType("TSUnionType", unionOrIntersection);
  defineType("TSIntersectionType", unionOrIntersection);
  defineType("TSConditionalType", {
    aliases: ["TSType"],
    visitor: ["checkType", "extendsType", "trueType", "falseType"],
    fields: {
      checkType: validateType("TSType"),
      extendsType: validateType("TSType"),
      trueType: validateType("TSType"),
      falseType: validateType("TSType")
    }
  });
  defineType("TSInferType", {
    aliases: ["TSType"],
    visitor: ["typeParameter"],
    fields: {
      typeParameter: validateType("TSTypeParameter")
    }
  });
  defineType("TSParenthesizedType", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeOperator", {
    aliases: ["TSType"],
    visitor: ["typeAnnotation"],
    fields: {
      operator: validate$2(assertValueType("string")),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSIndexedAccessType", {
    aliases: ["TSType"],
    visitor: ["objectType", "indexType"],
    fields: {
      objectType: validateType("TSType"),
      indexType: validateType("TSType")
    }
  });
  defineType("TSMappedType", {
    aliases: ["TSType"],
    visitor: ["typeParameter", "typeAnnotation", "nameType"],
    fields: {
      readonly: validateOptional(bool),
      typeParameter: validateType("TSTypeParameter"),
      optional: validateOptional(bool),
      typeAnnotation: validateOptionalType("TSType"),
      nameType: validateOptionalType("TSType")
    }
  });
  defineType("TSLiteralType", {
    aliases: ["TSType", "TSBaseType"],
    visitor: ["literal"],
    fields: {
      literal: validateType(["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral"])
    }
  });
  defineType("TSExpressionWithTypeArguments", {
    aliases: ["TSType"],
    visitor: ["expression", "typeParameters"],
    fields: {
      expression: validateType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSInterfaceDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "extends", "body"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      "extends": validateOptional(arrayOfType("TSExpressionWithTypeArguments")),
      body: validateType("TSInterfaceBody")
    }
  });
  defineType("TSInterfaceBody", {
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("TSTypeElement")
    }
  });
  defineType("TSTypeAliasDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "typeParameters", "typeAnnotation"],
    fields: {
      declare: validateOptional(bool),
      id: validateType("Identifier"),
      typeParameters: validateOptionalType("TSTypeParameterDeclaration"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSAsExpression", {
    aliases: ["Expression"],
    visitor: ["expression", "typeAnnotation"],
    fields: {
      expression: validateType("Expression"),
      typeAnnotation: validateType("TSType")
    }
  });
  defineType("TSTypeAssertion", {
    aliases: ["Expression"],
    visitor: ["typeAnnotation", "expression"],
    fields: {
      typeAnnotation: validateType("TSType"),
      expression: validateType("Expression")
    }
  });
  defineType("TSEnumDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "members"],
    fields: {
      declare: validateOptional(bool),
      "const": validateOptional(bool),
      id: validateType("Identifier"),
      members: validateArrayOfType("TSEnumMember"),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSEnumMember", {
    visitor: ["id", "initializer"],
    fields: {
      id: validateType(["Identifier", "StringLiteral"]),
      initializer: validateOptionalType("Expression")
    }
  });
  defineType("TSModuleDeclaration", {
    aliases: ["Statement", "Declaration"],
    visitor: ["id", "body"],
    fields: {
      declare: validateOptional(bool),
      global: validateOptional(bool),
      id: validateType(["Identifier", "StringLiteral"]),
      body: validateType(["TSModuleBlock", "TSModuleDeclaration"])
    }
  });
  defineType("TSModuleBlock", {
    aliases: ["Scopable", "Block", "BlockParent"],
    visitor: ["body"],
    fields: {
      body: validateArrayOfType("Statement")
    }
  });
  defineType("TSImportType", {
    aliases: ["TSType"],
    visitor: ["argument", "qualifier", "typeParameters"],
    fields: {
      argument: validateType("StringLiteral"),
      qualifier: validateOptionalType("TSEntityName"),
      typeParameters: validateOptionalType("TSTypeParameterInstantiation")
    }
  });
  defineType("TSImportEqualsDeclaration", {
    aliases: ["Statement"],
    visitor: ["id", "moduleReference"],
    fields: {
      isExport: validate$2(bool),
      id: validateType("Identifier"),
      moduleReference: validateType(["TSEntityName", "TSExternalModuleReference"])
    }
  });
  defineType("TSExternalModuleReference", {
    visitor: ["expression"],
    fields: {
      expression: validateType("StringLiteral")
    }
  });
  defineType("TSNonNullExpression", {
    aliases: ["Expression"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSExportAssignment", {
    aliases: ["Statement"],
    visitor: ["expression"],
    fields: {
      expression: validateType("Expression")
    }
  });
  defineType("TSNamespaceExportDeclaration", {
    aliases: ["Statement"],
    visitor: ["id"],
    fields: {
      id: validateType("Identifier")
    }
  });
  defineType("TSTypeAnnotation", {
    visitor: ["typeAnnotation"],
    fields: {
      typeAnnotation: {
        validate: assertNodeType("TSType")
      }
    }
  });
  defineType("TSTypeParameterInstantiation", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSType")))
      }
    }
  });
  defineType("TSTypeParameterDeclaration", {
    visitor: ["params"],
    fields: {
      params: {
        validate: chain$1(assertValueType("array"), assertEach(assertNodeType("TSTypeParameter")))
      }
    }
  });
  defineType("TSTypeParameter", {
    builder: ["constraint", "default", "name"],
    visitor: ["constraint", "default"],
    fields: {
      name: {
        validate: assertValueType("string")
      },
      constraint: {
        validate: assertNodeType("TSType"),
        optional: true
      },
      "default": {
        validate: assertNodeType("TSType"),
        optional: true
      }
    }
  });

  toFastProperties(VISITOR_KEYS);
  toFastProperties(ALIAS_KEYS);
  toFastProperties(FLIPPED_ALIAS_KEYS);
  toFastProperties(NODE_FIELDS);
  toFastProperties(BUILDER_KEYS);
  toFastProperties(DEPRECATED_KEYS);
  toFastProperties(PLACEHOLDERS_ALIAS);
  toFastProperties(PLACEHOLDERS_FLIPPED_ALIAS);
  var TYPES = Object.keys(VISITOR_KEYS).concat(Object.keys(FLIPPED_ALIAS_KEYS)).concat(Object.keys(DEPRECATED_KEYS));

  function builder(type) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var keys = BUILDER_KEYS[type];
    var countArgs = args.length;

    if (countArgs > keys.length) {
      throw new Error(type + ": Too many arguments passed. Received " + countArgs + " but can receive no more than " + keys.length);
    }

    var node = {
      type: type
    };
    var i = 0;
    keys.forEach(function (key) {
      var field = NODE_FIELDS[type][key];
      var arg;
      if (i < countArgs) arg = args[i];

      if (arg === undefined) {
        arg = Array.isArray(field["default"]) ? [] : field["default"];
      }

      node[key] = arg;
      i++;
    });

    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      validate$3(node, key, node[key]);
    }

    return node;
  }

  function arrayExpression(elements) {
    return builder.apply(void 0, ["ArrayExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function assignmentExpression(operator, left, right) {
    return builder.apply(void 0, ["AssignmentExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function binaryExpression(operator, left, right) {
    return builder.apply(void 0, ["BinaryExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function interpreterDirective(value) {
    return builder.apply(void 0, ["InterpreterDirective"].concat(Array.prototype.slice.call(arguments)));
  }
  function directive(value) {
    return builder.apply(void 0, ["Directive"].concat(Array.prototype.slice.call(arguments)));
  }
  function directiveLiteral(value) {
    return builder.apply(void 0, ["DirectiveLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function blockStatement(body, directives) {
    return builder.apply(void 0, ["BlockStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function breakStatement(label) {
    return builder.apply(void 0, ["BreakStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function callExpression(callee, _arguments) {
    return builder.apply(void 0, ["CallExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function catchClause(param, body) {
    return builder.apply(void 0, ["CatchClause"].concat(Array.prototype.slice.call(arguments)));
  }
  function conditionalExpression(test, consequent, alternate) {
    return builder.apply(void 0, ["ConditionalExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function continueStatement(label) {
    return builder.apply(void 0, ["ContinueStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function debuggerStatement() {
    return builder.apply(void 0, ["DebuggerStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function doWhileStatement(test, body) {
    return builder.apply(void 0, ["DoWhileStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function emptyStatement() {
    return builder.apply(void 0, ["EmptyStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function expressionStatement(expression) {
    return builder.apply(void 0, ["ExpressionStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function file(program, comments, tokens) {
    return builder.apply(void 0, ["File"].concat(Array.prototype.slice.call(arguments)));
  }
  function forInStatement(left, right, body) {
    return builder.apply(void 0, ["ForInStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function forStatement(init, test, update, body) {
    return builder.apply(void 0, ["ForStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionDeclaration(id, params, body, generator, async) {
    return builder.apply(void 0, ["FunctionDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionExpression(id, params, body, generator, async) {
    return builder.apply(void 0, ["FunctionExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function identifier(name) {
    return builder.apply(void 0, ["Identifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function ifStatement(test, consequent, alternate) {
    return builder.apply(void 0, ["IfStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function labeledStatement(label, body) {
    return builder.apply(void 0, ["LabeledStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringLiteral(value) {
    return builder.apply(void 0, ["StringLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function numericLiteral(value) {
    return builder.apply(void 0, ["NumericLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullLiteral() {
    return builder.apply(void 0, ["NullLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanLiteral(value) {
    return builder.apply(void 0, ["BooleanLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function regExpLiteral(pattern, flags) {
    return builder.apply(void 0, ["RegExpLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function logicalExpression(operator, left, right) {
    return builder.apply(void 0, ["LogicalExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function memberExpression(object, property, computed, optional) {
    return builder.apply(void 0, ["MemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function newExpression(callee, _arguments) {
    return builder.apply(void 0, ["NewExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function program$2(body, directives, sourceType, interpreter) {
    return builder.apply(void 0, ["Program"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectExpression(properties) {
    return builder.apply(void 0, ["ObjectExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectMethod(kind, key, params, body, computed, generator, async) {
    return builder.apply(void 0, ["ObjectMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectProperty(key, value, computed, shorthand, decorators) {
    return builder.apply(void 0, ["ObjectProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function restElement(argument) {
    return builder.apply(void 0, ["RestElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function returnStatement(argument) {
    return builder.apply(void 0, ["ReturnStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function sequenceExpression(expressions) {
    return builder.apply(void 0, ["SequenceExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function parenthesizedExpression(expression) {
    return builder.apply(void 0, ["ParenthesizedExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function switchCase(test, consequent) {
    return builder.apply(void 0, ["SwitchCase"].concat(Array.prototype.slice.call(arguments)));
  }
  function switchStatement(discriminant, cases) {
    return builder.apply(void 0, ["SwitchStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function thisExpression() {
    return builder.apply(void 0, ["ThisExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function throwStatement(argument) {
    return builder.apply(void 0, ["ThrowStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function tryStatement(block, handler, finalizer) {
    return builder.apply(void 0, ["TryStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function unaryExpression(operator, argument, prefix) {
    return builder.apply(void 0, ["UnaryExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function updateExpression(operator, argument, prefix) {
    return builder.apply(void 0, ["UpdateExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function variableDeclaration(kind, declarations) {
    return builder.apply(void 0, ["VariableDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function variableDeclarator(id, init) {
    return builder.apply(void 0, ["VariableDeclarator"].concat(Array.prototype.slice.call(arguments)));
  }
  function whileStatement(test, body) {
    return builder.apply(void 0, ["WhileStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function withStatement(object, body) {
    return builder.apply(void 0, ["WithStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function assignmentPattern(left, right) {
    return builder.apply(void 0, ["AssignmentPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrayPattern(elements) {
    return builder.apply(void 0, ["ArrayPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrowFunctionExpression(params, body, async) {
    return builder.apply(void 0, ["ArrowFunctionExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classBody(body) {
    return builder.apply(void 0, ["ClassBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function classExpression(id, superClass, body, decorators) {
    return builder.apply(void 0, ["ClassExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classDeclaration(id, superClass, body, decorators) {
    return builder.apply(void 0, ["ClassDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportAllDeclaration(source) {
    return builder.apply(void 0, ["ExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportDefaultDeclaration(declaration) {
    return builder.apply(void 0, ["ExportDefaultDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportNamedDeclaration(declaration, specifiers, source) {
    return builder.apply(void 0, ["ExportNamedDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportSpecifier(local, exported) {
    return builder.apply(void 0, ["ExportSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function forOfStatement(left, right, body, _await) {
    return builder.apply(void 0, ["ForOfStatement"].concat(Array.prototype.slice.call(arguments)));
  }
  function importDeclaration(specifiers, source) {
    return builder.apply(void 0, ["ImportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function importDefaultSpecifier(local) {
    return builder.apply(void 0, ["ImportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function importNamespaceSpecifier(local) {
    return builder.apply(void 0, ["ImportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function importSpecifier(local, imported) {
    return builder.apply(void 0, ["ImportSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function metaProperty(meta, property) {
    return builder.apply(void 0, ["MetaProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function classMethod(kind, key, params, body, computed, _static, generator, async) {
    return builder.apply(void 0, ["ClassMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectPattern(properties) {
    return builder.apply(void 0, ["ObjectPattern"].concat(Array.prototype.slice.call(arguments)));
  }
  function spreadElement(argument) {
    return builder.apply(void 0, ["SpreadElement"].concat(Array.prototype.slice.call(arguments)));
  }

  function _super() {
    return builder.apply(void 0, ["Super"].concat(Array.prototype.slice.call(arguments)));
  }
  function taggedTemplateExpression(tag, quasi) {
    return builder.apply(void 0, ["TaggedTemplateExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function templateElement(value, tail) {
    return builder.apply(void 0, ["TemplateElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function templateLiteral(quasis, expressions) {
    return builder.apply(void 0, ["TemplateLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function yieldExpression(argument, delegate) {
    return builder.apply(void 0, ["YieldExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function awaitExpression(argument) {
    return builder.apply(void 0, ["AwaitExpression"].concat(Array.prototype.slice.call(arguments)));
  }

  function _import() {
    return builder.apply(void 0, ["Import"].concat(Array.prototype.slice.call(arguments)));
  }
  function bigIntLiteral(value) {
    return builder.apply(void 0, ["BigIntLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportNamespaceSpecifier(exported) {
    return builder.apply(void 0, ["ExportNamespaceSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function optionalMemberExpression(object, property, computed, optional) {
    return builder.apply(void 0, ["OptionalMemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function optionalCallExpression(callee, _arguments, optional) {
    return builder.apply(void 0, ["OptionalCallExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function anyTypeAnnotation() {
    return builder.apply(void 0, ["AnyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function arrayTypeAnnotation(elementType) {
    return builder.apply(void 0, ["ArrayTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanTypeAnnotation() {
    return builder.apply(void 0, ["BooleanTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function booleanLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["BooleanLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullLiteralTypeAnnotation() {
    return builder.apply(void 0, ["NullLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function classImplements(id, typeParameters) {
    return builder.apply(void 0, ["ClassImplements"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareClass(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["DeclareClass"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareFunction(id) {
    return builder.apply(void 0, ["DeclareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareInterface(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["DeclareInterface"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareModule(id, body, kind) {
    return builder.apply(void 0, ["DeclareModule"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareModuleExports(typeAnnotation) {
    return builder.apply(void 0, ["DeclareModuleExports"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareTypeAlias(id, typeParameters, right) {
    return builder.apply(void 0, ["DeclareTypeAlias"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareOpaqueType(id, typeParameters, supertype) {
    return builder.apply(void 0, ["DeclareOpaqueType"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareVariable(id) {
    return builder.apply(void 0, ["DeclareVariable"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareExportDeclaration(declaration, specifiers, source) {
    return builder.apply(void 0, ["DeclareExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function declareExportAllDeclaration(source) {
    return builder.apply(void 0, ["DeclareExportAllDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function declaredPredicate(value) {
    return builder.apply(void 0, ["DeclaredPredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function existsTypeAnnotation() {
    return builder.apply(void 0, ["ExistsTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionTypeAnnotation(typeParameters, params, rest, returnType) {
    return builder.apply(void 0, ["FunctionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function functionTypeParam(name, typeAnnotation) {
    return builder.apply(void 0, ["FunctionTypeParam"].concat(Array.prototype.slice.call(arguments)));
  }
  function genericTypeAnnotation(id, typeParameters) {
    return builder.apply(void 0, ["GenericTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function inferredPredicate() {
    return builder.apply(void 0, ["InferredPredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceExtends(id, typeParameters) {
    return builder.apply(void 0, ["InterfaceExtends"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceDeclaration(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["InterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function interfaceTypeAnnotation(_extends, body) {
    return builder.apply(void 0, ["InterfaceTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function intersectionTypeAnnotation(types) {
    return builder.apply(void 0, ["IntersectionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function mixedTypeAnnotation() {
    return builder.apply(void 0, ["MixedTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function emptyTypeAnnotation() {
    return builder.apply(void 0, ["EmptyTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function nullableTypeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["NullableTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function numberLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["NumberLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function numberTypeAnnotation() {
    return builder.apply(void 0, ["NumberTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeAnnotation(properties, indexers, callProperties, internalSlots, exact) {
    return builder.apply(void 0, ["ObjectTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeInternalSlot(id, value, optional, _static, method) {
    return builder.apply(void 0, ["ObjectTypeInternalSlot"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeCallProperty(value) {
    return builder.apply(void 0, ["ObjectTypeCallProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeIndexer(id, key, value, variance) {
    return builder.apply(void 0, ["ObjectTypeIndexer"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeProperty(key, value, variance) {
    return builder.apply(void 0, ["ObjectTypeProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function objectTypeSpreadProperty(argument) {
    return builder.apply(void 0, ["ObjectTypeSpreadProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function opaqueType(id, typeParameters, supertype, impltype) {
    return builder.apply(void 0, ["OpaqueType"].concat(Array.prototype.slice.call(arguments)));
  }
  function qualifiedTypeIdentifier(id, qualification) {
    return builder.apply(void 0, ["QualifiedTypeIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringLiteralTypeAnnotation(value) {
    return builder.apply(void 0, ["StringLiteralTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function stringTypeAnnotation() {
    return builder.apply(void 0, ["StringTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function symbolTypeAnnotation() {
    return builder.apply(void 0, ["SymbolTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function thisTypeAnnotation() {
    return builder.apply(void 0, ["ThisTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tupleTypeAnnotation(types) {
    return builder.apply(void 0, ["TupleTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeofTypeAnnotation(argument) {
    return builder.apply(void 0, ["TypeofTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeAlias(id, typeParameters, right) {
    return builder.apply(void 0, ["TypeAlias"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["TypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeCastExpression(expression, typeAnnotation) {
    return builder.apply(void 0, ["TypeCastExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameter(bound, _default, variance) {
    return builder.apply(void 0, ["TypeParameter"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameterDeclaration(params) {
    return builder.apply(void 0, ["TypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function typeParameterInstantiation(params) {
    return builder.apply(void 0, ["TypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
  }
  function unionTypeAnnotation(types) {
    return builder.apply(void 0, ["UnionTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function variance(kind) {
    return builder.apply(void 0, ["Variance"].concat(Array.prototype.slice.call(arguments)));
  }
  function voidTypeAnnotation() {
    return builder.apply(void 0, ["VoidTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumDeclaration(id, body) {
    return builder.apply(void 0, ["EnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumBooleanBody(members) {
    return builder.apply(void 0, ["EnumBooleanBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumNumberBody(members) {
    return builder.apply(void 0, ["EnumNumberBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumStringBody(members) {
    return builder.apply(void 0, ["EnumStringBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumSymbolBody(members) {
    return builder.apply(void 0, ["EnumSymbolBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumBooleanMember(id) {
    return builder.apply(void 0, ["EnumBooleanMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumNumberMember(id, init) {
    return builder.apply(void 0, ["EnumNumberMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumStringMember(id, init) {
    return builder.apply(void 0, ["EnumStringMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function enumDefaultedMember(id) {
    return builder.apply(void 0, ["EnumDefaultedMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function indexedAccessType(objectType, indexType) {
    return builder.apply(void 0, ["IndexedAccessType"].concat(Array.prototype.slice.call(arguments)));
  }
  function optionalIndexedAccessType(objectType, indexType) {
    return builder.apply(void 0, ["OptionalIndexedAccessType"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxAttribute(name, value) {
    return builder.apply(void 0, ["JSXAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxClosingElement(name) {
    return builder.apply(void 0, ["JSXClosingElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxElement(openingElement, closingElement, children, selfClosing) {
    return builder.apply(void 0, ["JSXElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxEmptyExpression() {
    return builder.apply(void 0, ["JSXEmptyExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxExpressionContainer(expression) {
    return builder.apply(void 0, ["JSXExpressionContainer"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxSpreadChild(expression) {
    return builder.apply(void 0, ["JSXSpreadChild"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxIdentifier(name) {
    return builder.apply(void 0, ["JSXIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxMemberExpression(object, property) {
    return builder.apply(void 0, ["JSXMemberExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxNamespacedName(namespace, name) {
    return builder.apply(void 0, ["JSXNamespacedName"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxOpeningElement(name, attributes, selfClosing) {
    return builder.apply(void 0, ["JSXOpeningElement"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxSpreadAttribute(argument) {
    return builder.apply(void 0, ["JSXSpreadAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxText(value) {
    return builder.apply(void 0, ["JSXText"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxFragment(openingFragment, closingFragment, children) {
    return builder.apply(void 0, ["JSXFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxOpeningFragment() {
    return builder.apply(void 0, ["JSXOpeningFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function jsxClosingFragment() {
    return builder.apply(void 0, ["JSXClosingFragment"].concat(Array.prototype.slice.call(arguments)));
  }
  function noop$1() {
    return builder.apply(void 0, ["Noop"].concat(Array.prototype.slice.call(arguments)));
  }
  function placeholder(expectedNode, name) {
    return builder.apply(void 0, ["Placeholder"].concat(Array.prototype.slice.call(arguments)));
  }
  function v8IntrinsicIdentifier(name) {
    return builder.apply(void 0, ["V8IntrinsicIdentifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function argumentPlaceholder() {
    return builder.apply(void 0, ["ArgumentPlaceholder"].concat(Array.prototype.slice.call(arguments)));
  }
  function bindExpression(object, callee) {
    return builder.apply(void 0, ["BindExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function classProperty(key, value, typeAnnotation, decorators, computed, _static) {
    return builder.apply(void 0, ["ClassProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelineTopicExpression(expression) {
    return builder.apply(void 0, ["PipelineTopicExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelineBareFunction(callee) {
    return builder.apply(void 0, ["PipelineBareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function pipelinePrimaryTopicReference() {
    return builder.apply(void 0, ["PipelinePrimaryTopicReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function classPrivateProperty(key, value, decorators, _static) {
    return builder.apply(void 0, ["ClassPrivateProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function classPrivateMethod(kind, key, params, body, _static) {
    return builder.apply(void 0, ["ClassPrivateMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function importAttribute(key, value) {
    return builder.apply(void 0, ["ImportAttribute"].concat(Array.prototype.slice.call(arguments)));
  }
  function decorator(expression) {
    return builder.apply(void 0, ["Decorator"].concat(Array.prototype.slice.call(arguments)));
  }
  function doExpression(body, async) {
    return builder.apply(void 0, ["DoExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function exportDefaultSpecifier(exported) {
    return builder.apply(void 0, ["ExportDefaultSpecifier"].concat(Array.prototype.slice.call(arguments)));
  }
  function privateName(id) {
    return builder.apply(void 0, ["PrivateName"].concat(Array.prototype.slice.call(arguments)));
  }
  function recordExpression(properties) {
    return builder.apply(void 0, ["RecordExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tupleExpression(elements) {
    return builder.apply(void 0, ["TupleExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function decimalLiteral(value) {
    return builder.apply(void 0, ["DecimalLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function staticBlock(body) {
    return builder.apply(void 0, ["StaticBlock"].concat(Array.prototype.slice.call(arguments)));
  }
  function moduleExpression(body) {
    return builder.apply(void 0, ["ModuleExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsParameterProperty(parameter) {
    return builder.apply(void 0, ["TSParameterProperty"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsDeclareFunction(id, typeParameters, params, returnType) {
    return builder.apply(void 0, ["TSDeclareFunction"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsDeclareMethod(decorators, key, typeParameters, params, returnType) {
    return builder.apply(void 0, ["TSDeclareMethod"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsQualifiedName(left, right) {
    return builder.apply(void 0, ["TSQualifiedName"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsCallSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSCallSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConstructSignatureDeclaration(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSConstructSignatureDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsPropertySignature(key, typeAnnotation, initializer) {
    return builder.apply(void 0, ["TSPropertySignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsMethodSignature(key, typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSMethodSignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIndexSignature(parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSIndexSignature"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsAnyKeyword() {
    return builder.apply(void 0, ["TSAnyKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsBooleanKeyword() {
    return builder.apply(void 0, ["TSBooleanKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsBigIntKeyword() {
    return builder.apply(void 0, ["TSBigIntKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIntrinsicKeyword() {
    return builder.apply(void 0, ["TSIntrinsicKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNeverKeyword() {
    return builder.apply(void 0, ["TSNeverKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNullKeyword() {
    return builder.apply(void 0, ["TSNullKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNumberKeyword() {
    return builder.apply(void 0, ["TSNumberKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsObjectKeyword() {
    return builder.apply(void 0, ["TSObjectKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsStringKeyword() {
    return builder.apply(void 0, ["TSStringKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsSymbolKeyword() {
    return builder.apply(void 0, ["TSSymbolKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUndefinedKeyword() {
    return builder.apply(void 0, ["TSUndefinedKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUnknownKeyword() {
    return builder.apply(void 0, ["TSUnknownKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsVoidKeyword() {
    return builder.apply(void 0, ["TSVoidKeyword"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsThisType() {
    return builder.apply(void 0, ["TSThisType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsFunctionType(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSFunctionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConstructorType(typeParameters, parameters, typeAnnotation) {
    return builder.apply(void 0, ["TSConstructorType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeReference(typeName, typeParameters) {
    return builder.apply(void 0, ["TSTypeReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypePredicate(parameterName, typeAnnotation, asserts) {
    return builder.apply(void 0, ["TSTypePredicate"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeQuery(exprName) {
    return builder.apply(void 0, ["TSTypeQuery"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeLiteral(members) {
    return builder.apply(void 0, ["TSTypeLiteral"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsArrayType(elementType) {
    return builder.apply(void 0, ["TSArrayType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTupleType(elementTypes) {
    return builder.apply(void 0, ["TSTupleType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsOptionalType(typeAnnotation) {
    return builder.apply(void 0, ["TSOptionalType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsRestType(typeAnnotation) {
    return builder.apply(void 0, ["TSRestType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNamedTupleMember(label, elementType, optional) {
    return builder.apply(void 0, ["TSNamedTupleMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsUnionType(types) {
    return builder.apply(void 0, ["TSUnionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIntersectionType(types) {
    return builder.apply(void 0, ["TSIntersectionType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsConditionalType(checkType, extendsType, trueType, falseType) {
    return builder.apply(void 0, ["TSConditionalType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInferType(typeParameter) {
    return builder.apply(void 0, ["TSInferType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsParenthesizedType(typeAnnotation) {
    return builder.apply(void 0, ["TSParenthesizedType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeOperator(typeAnnotation) {
    return builder.apply(void 0, ["TSTypeOperator"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsIndexedAccessType(objectType, indexType) {
    return builder.apply(void 0, ["TSIndexedAccessType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsMappedType(typeParameter, typeAnnotation, nameType) {
    return builder.apply(void 0, ["TSMappedType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsLiteralType(literal) {
    return builder.apply(void 0, ["TSLiteralType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExpressionWithTypeArguments(expression, typeParameters) {
    return builder.apply(void 0, ["TSExpressionWithTypeArguments"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInterfaceDeclaration(id, typeParameters, _extends, body) {
    return builder.apply(void 0, ["TSInterfaceDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsInterfaceBody(body) {
    return builder.apply(void 0, ["TSInterfaceBody"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAliasDeclaration(id, typeParameters, typeAnnotation) {
    return builder.apply(void 0, ["TSTypeAliasDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsAsExpression(expression, typeAnnotation) {
    return builder.apply(void 0, ["TSAsExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAssertion(typeAnnotation, expression) {
    return builder.apply(void 0, ["TSTypeAssertion"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsEnumDeclaration(id, members) {
    return builder.apply(void 0, ["TSEnumDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsEnumMember(id, initializer) {
    return builder.apply(void 0, ["TSEnumMember"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsModuleDeclaration(id, body) {
    return builder.apply(void 0, ["TSModuleDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsModuleBlock(body) {
    return builder.apply(void 0, ["TSModuleBlock"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsImportType(argument, qualifier, typeParameters) {
    return builder.apply(void 0, ["TSImportType"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsImportEqualsDeclaration(id, moduleReference) {
    return builder.apply(void 0, ["TSImportEqualsDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExternalModuleReference(expression) {
    return builder.apply(void 0, ["TSExternalModuleReference"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNonNullExpression(expression) {
    return builder.apply(void 0, ["TSNonNullExpression"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsExportAssignment(expression) {
    return builder.apply(void 0, ["TSExportAssignment"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsNamespaceExportDeclaration(id) {
    return builder.apply(void 0, ["TSNamespaceExportDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeAnnotation(typeAnnotation) {
    return builder.apply(void 0, ["TSTypeAnnotation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameterInstantiation(params) {
    return builder.apply(void 0, ["TSTypeParameterInstantiation"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameterDeclaration(params) {
    return builder.apply(void 0, ["TSTypeParameterDeclaration"].concat(Array.prototype.slice.call(arguments)));
  }
  function tsTypeParameter(constraint, _default, name) {
    return builder.apply(void 0, ["TSTypeParameter"].concat(Array.prototype.slice.call(arguments)));
  }

  function NumberLiteral() {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return builder.apply(void 0, ["NumberLiteral"].concat(args));
  }

  function RegexLiteral() {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return builder.apply(void 0, ["RegexLiteral"].concat(args));
  }

  function RestProperty$1() {
    console.trace("The node type RestProperty has been renamed to RestElement");

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    return builder.apply(void 0, ["RestProperty"].concat(args));
  }

  function SpreadProperty$1() {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");

    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return builder.apply(void 0, ["SpreadProperty"].concat(args));
  }

  function cleanJSXElementLiteralChild(child, args) {
    var lines = child.value.split(/\r\n|\n|\r/);
    var lastNonEmptyLine = 0;

    for (var i = 0; i < lines.length; i++) {
      if (lines[i].match(/[^ \t]/)) {
        lastNonEmptyLine = i;
      }
    }

    var str = "";

    for (var _i = 0; _i < lines.length; _i++) {
      var line = lines[_i];
      var isFirstLine = _i === 0;
      var isLastLine = _i === lines.length - 1;
      var isLastNonEmptyLine = _i === lastNonEmptyLine;
      var trimmedLine = line.replace(/\t/g, " ");

      if (!isFirstLine) {
        trimmedLine = trimmedLine.replace(/^[ ]+/, "");
      }

      if (!isLastLine) {
        trimmedLine = trimmedLine.replace(/[ ]+$/, "");
      }

      if (trimmedLine) {
        if (!isLastNonEmptyLine) {
          trimmedLine += " ";
        }

        str += trimmedLine;
      }
    }

    if (str) args.push(stringLiteral(str));
  }

  function buildChildren(node) {
    var elements = [];

    for (var i = 0; i < node.children.length; i++) {
      var child = node.children[i];

      if (isJSXText(child)) {
        cleanJSXElementLiteralChild(child, elements);
        continue;
      }

      if (isJSXExpressionContainer(child)) child = child.expression;
      if (isJSXEmptyExpression(child)) continue;
      elements.push(child);
    }

    return elements;
  }

  function isNode(node) {
    return !!(node && VISITOR_KEYS[node.type]);
  }

  function assertNode(node) {
    if (!isNode(node)) {
      var _node$type;

      var type = (_node$type = node == null ? void 0 : node.type) != null ? _node$type : JSON.stringify(node);
      throw new TypeError("Not a valid node of type \"" + type + "\"");
    }
  }

  function assert$1(type, node, opts) {
    if (!is$1(type, node, opts)) {
      throw new Error("Expected type \"" + type + "\" with option " + JSON.stringify(opts) + ", " + ("but instead got \"" + node.type + "\"."));
    }
  }

  function assertArrayExpression(node, opts) {
    assert$1("ArrayExpression", node, opts);
  }
  function assertAssignmentExpression(node, opts) {
    assert$1("AssignmentExpression", node, opts);
  }
  function assertBinaryExpression(node, opts) {
    assert$1("BinaryExpression", node, opts);
  }
  function assertInterpreterDirective(node, opts) {
    assert$1("InterpreterDirective", node, opts);
  }
  function assertDirective(node, opts) {
    assert$1("Directive", node, opts);
  }
  function assertDirectiveLiteral(node, opts) {
    assert$1("DirectiveLiteral", node, opts);
  }
  function assertBlockStatement(node, opts) {
    assert$1("BlockStatement", node, opts);
  }
  function assertBreakStatement(node, opts) {
    assert$1("BreakStatement", node, opts);
  }
  function assertCallExpression(node, opts) {
    assert$1("CallExpression", node, opts);
  }
  function assertCatchClause(node, opts) {
    assert$1("CatchClause", node, opts);
  }
  function assertConditionalExpression(node, opts) {
    assert$1("ConditionalExpression", node, opts);
  }
  function assertContinueStatement(node, opts) {
    assert$1("ContinueStatement", node, opts);
  }
  function assertDebuggerStatement(node, opts) {
    assert$1("DebuggerStatement", node, opts);
  }
  function assertDoWhileStatement(node, opts) {
    assert$1("DoWhileStatement", node, opts);
  }
  function assertEmptyStatement(node, opts) {
    assert$1("EmptyStatement", node, opts);
  }
  function assertExpressionStatement(node, opts) {
    assert$1("ExpressionStatement", node, opts);
  }
  function assertFile(node, opts) {
    assert$1("File", node, opts);
  }
  function assertForInStatement(node, opts) {
    assert$1("ForInStatement", node, opts);
  }
  function assertForStatement(node, opts) {
    assert$1("ForStatement", node, opts);
  }
  function assertFunctionDeclaration(node, opts) {
    assert$1("FunctionDeclaration", node, opts);
  }
  function assertFunctionExpression(node, opts) {
    assert$1("FunctionExpression", node, opts);
  }
  function assertIdentifier(node, opts) {
    assert$1("Identifier", node, opts);
  }
  function assertIfStatement(node, opts) {
    assert$1("IfStatement", node, opts);
  }
  function assertLabeledStatement(node, opts) {
    assert$1("LabeledStatement", node, opts);
  }
  function assertStringLiteral(node, opts) {
    assert$1("StringLiteral", node, opts);
  }
  function assertNumericLiteral(node, opts) {
    assert$1("NumericLiteral", node, opts);
  }
  function assertNullLiteral(node, opts) {
    assert$1("NullLiteral", node, opts);
  }
  function assertBooleanLiteral(node, opts) {
    assert$1("BooleanLiteral", node, opts);
  }
  function assertRegExpLiteral(node, opts) {
    assert$1("RegExpLiteral", node, opts);
  }
  function assertLogicalExpression(node, opts) {
    assert$1("LogicalExpression", node, opts);
  }
  function assertMemberExpression(node, opts) {
    assert$1("MemberExpression", node, opts);
  }
  function assertNewExpression(node, opts) {
    assert$1("NewExpression", node, opts);
  }
  function assertProgram(node, opts) {
    assert$1("Program", node, opts);
  }
  function assertObjectExpression(node, opts) {
    assert$1("ObjectExpression", node, opts);
  }
  function assertObjectMethod(node, opts) {
    assert$1("ObjectMethod", node, opts);
  }
  function assertObjectProperty(node, opts) {
    assert$1("ObjectProperty", node, opts);
  }
  function assertRestElement(node, opts) {
    assert$1("RestElement", node, opts);
  }
  function assertReturnStatement(node, opts) {
    assert$1("ReturnStatement", node, opts);
  }
  function assertSequenceExpression(node, opts) {
    assert$1("SequenceExpression", node, opts);
  }
  function assertParenthesizedExpression(node, opts) {
    assert$1("ParenthesizedExpression", node, opts);
  }
  function assertSwitchCase(node, opts) {
    assert$1("SwitchCase", node, opts);
  }
  function assertSwitchStatement(node, opts) {
    assert$1("SwitchStatement", node, opts);
  }
  function assertThisExpression(node, opts) {
    assert$1("ThisExpression", node, opts);
  }
  function assertThrowStatement(node, opts) {
    assert$1("ThrowStatement", node, opts);
  }
  function assertTryStatement(node, opts) {
    assert$1("TryStatement", node, opts);
  }
  function assertUnaryExpression(node, opts) {
    assert$1("UnaryExpression", node, opts);
  }
  function assertUpdateExpression(node, opts) {
    assert$1("UpdateExpression", node, opts);
  }
  function assertVariableDeclaration(node, opts) {
    assert$1("VariableDeclaration", node, opts);
  }
  function assertVariableDeclarator(node, opts) {
    assert$1("VariableDeclarator", node, opts);
  }
  function assertWhileStatement(node, opts) {
    assert$1("WhileStatement", node, opts);
  }
  function assertWithStatement(node, opts) {
    assert$1("WithStatement", node, opts);
  }
  function assertAssignmentPattern(node, opts) {
    assert$1("AssignmentPattern", node, opts);
  }
  function assertArrayPattern(node, opts) {
    assert$1("ArrayPattern", node, opts);
  }
  function assertArrowFunctionExpression(node, opts) {
    assert$1("ArrowFunctionExpression", node, opts);
  }
  function assertClassBody(node, opts) {
    assert$1("ClassBody", node, opts);
  }
  function assertClassExpression(node, opts) {
    assert$1("ClassExpression", node, opts);
  }
  function assertClassDeclaration(node, opts) {
    assert$1("ClassDeclaration", node, opts);
  }
  function assertExportAllDeclaration(node, opts) {
    assert$1("ExportAllDeclaration", node, opts);
  }
  function assertExportDefaultDeclaration(node, opts) {
    assert$1("ExportDefaultDeclaration", node, opts);
  }
  function assertExportNamedDeclaration(node, opts) {
    assert$1("ExportNamedDeclaration", node, opts);
  }
  function assertExportSpecifier$1(node, opts) {
    assert$1("ExportSpecifier", node, opts);
  }
  function assertForOfStatement(node, opts) {
    assert$1("ForOfStatement", node, opts);
  }
  function assertImportDeclaration(node, opts) {
    assert$1("ImportDeclaration", node, opts);
  }
  function assertImportDefaultSpecifier(node, opts) {
    assert$1("ImportDefaultSpecifier", node, opts);
  }
  function assertImportNamespaceSpecifier(node, opts) {
    assert$1("ImportNamespaceSpecifier", node, opts);
  }
  function assertImportSpecifier(node, opts) {
    assert$1("ImportSpecifier", node, opts);
  }
  function assertMetaProperty(node, opts) {
    assert$1("MetaProperty", node, opts);
  }
  function assertClassMethod(node, opts) {
    assert$1("ClassMethod", node, opts);
  }
  function assertObjectPattern(node, opts) {
    assert$1("ObjectPattern", node, opts);
  }
  function assertSpreadElement(node, opts) {
    assert$1("SpreadElement", node, opts);
  }
  function assertSuper(node, opts) {
    assert$1("Super", node, opts);
  }
  function assertTaggedTemplateExpression(node, opts) {
    assert$1("TaggedTemplateExpression", node, opts);
  }
  function assertTemplateElement(node, opts) {
    assert$1("TemplateElement", node, opts);
  }
  function assertTemplateLiteral(node, opts) {
    assert$1("TemplateLiteral", node, opts);
  }
  function assertYieldExpression(node, opts) {
    assert$1("YieldExpression", node, opts);
  }
  function assertAwaitExpression(node, opts) {
    assert$1("AwaitExpression", node, opts);
  }
  function assertImport(node, opts) {
    assert$1("Import", node, opts);
  }
  function assertBigIntLiteral(node, opts) {
    assert$1("BigIntLiteral", node, opts);
  }
  function assertExportNamespaceSpecifier(node, opts) {
    assert$1("ExportNamespaceSpecifier", node, opts);
  }
  function assertOptionalMemberExpression(node, opts) {
    assert$1("OptionalMemberExpression", node, opts);
  }
  function assertOptionalCallExpression(node, opts) {
    assert$1("OptionalCallExpression", node, opts);
  }
  function assertAnyTypeAnnotation(node, opts) {
    assert$1("AnyTypeAnnotation", node, opts);
  }
  function assertArrayTypeAnnotation(node, opts) {
    assert$1("ArrayTypeAnnotation", node, opts);
  }
  function assertBooleanTypeAnnotation(node, opts) {
    assert$1("BooleanTypeAnnotation", node, opts);
  }
  function assertBooleanLiteralTypeAnnotation(node, opts) {
    assert$1("BooleanLiteralTypeAnnotation", node, opts);
  }
  function assertNullLiteralTypeAnnotation(node, opts) {
    assert$1("NullLiteralTypeAnnotation", node, opts);
  }
  function assertClassImplements(node, opts) {
    assert$1("ClassImplements", node, opts);
  }
  function assertDeclareClass(node, opts) {
    assert$1("DeclareClass", node, opts);
  }
  function assertDeclareFunction(node, opts) {
    assert$1("DeclareFunction", node, opts);
  }
  function assertDeclareInterface(node, opts) {
    assert$1("DeclareInterface", node, opts);
  }
  function assertDeclareModule(node, opts) {
    assert$1("DeclareModule", node, opts);
  }
  function assertDeclareModuleExports(node, opts) {
    assert$1("DeclareModuleExports", node, opts);
  }
  function assertDeclareTypeAlias(node, opts) {
    assert$1("DeclareTypeAlias", node, opts);
  }
  function assertDeclareOpaqueType(node, opts) {
    assert$1("DeclareOpaqueType", node, opts);
  }
  function assertDeclareVariable(node, opts) {
    assert$1("DeclareVariable", node, opts);
  }
  function assertDeclareExportDeclaration(node, opts) {
    assert$1("DeclareExportDeclaration", node, opts);
  }
  function assertDeclareExportAllDeclaration(node, opts) {
    assert$1("DeclareExportAllDeclaration", node, opts);
  }
  function assertDeclaredPredicate(node, opts) {
    assert$1("DeclaredPredicate", node, opts);
  }
  function assertExistsTypeAnnotation(node, opts) {
    assert$1("ExistsTypeAnnotation", node, opts);
  }
  function assertFunctionTypeAnnotation(node, opts) {
    assert$1("FunctionTypeAnnotation", node, opts);
  }
  function assertFunctionTypeParam(node, opts) {
    assert$1("FunctionTypeParam", node, opts);
  }
  function assertGenericTypeAnnotation(node, opts) {
    assert$1("GenericTypeAnnotation", node, opts);
  }
  function assertInferredPredicate(node, opts) {
    assert$1("InferredPredicate", node, opts);
  }
  function assertInterfaceExtends(node, opts) {
    assert$1("InterfaceExtends", node, opts);
  }
  function assertInterfaceDeclaration(node, opts) {
    assert$1("InterfaceDeclaration", node, opts);
  }
  function assertInterfaceTypeAnnotation(node, opts) {
    assert$1("InterfaceTypeAnnotation", node, opts);
  }
  function assertIntersectionTypeAnnotation(node, opts) {
    assert$1("IntersectionTypeAnnotation", node, opts);
  }
  function assertMixedTypeAnnotation(node, opts) {
    assert$1("MixedTypeAnnotation", node, opts);
  }
  function assertEmptyTypeAnnotation(node, opts) {
    assert$1("EmptyTypeAnnotation", node, opts);
  }
  function assertNullableTypeAnnotation(node, opts) {
    assert$1("NullableTypeAnnotation", node, opts);
  }
  function assertNumberLiteralTypeAnnotation(node, opts) {
    assert$1("NumberLiteralTypeAnnotation", node, opts);
  }
  function assertNumberTypeAnnotation(node, opts) {
    assert$1("NumberTypeAnnotation", node, opts);
  }
  function assertObjectTypeAnnotation(node, opts) {
    assert$1("ObjectTypeAnnotation", node, opts);
  }
  function assertObjectTypeInternalSlot(node, opts) {
    assert$1("ObjectTypeInternalSlot", node, opts);
  }
  function assertObjectTypeCallProperty(node, opts) {
    assert$1("ObjectTypeCallProperty", node, opts);
  }
  function assertObjectTypeIndexer(node, opts) {
    assert$1("ObjectTypeIndexer", node, opts);
  }
  function assertObjectTypeProperty(node, opts) {
    assert$1("ObjectTypeProperty", node, opts);
  }
  function assertObjectTypeSpreadProperty(node, opts) {
    assert$1("ObjectTypeSpreadProperty", node, opts);
  }
  function assertOpaqueType(node, opts) {
    assert$1("OpaqueType", node, opts);
  }
  function assertQualifiedTypeIdentifier(node, opts) {
    assert$1("QualifiedTypeIdentifier", node, opts);
  }
  function assertStringLiteralTypeAnnotation(node, opts) {
    assert$1("StringLiteralTypeAnnotation", node, opts);
  }
  function assertStringTypeAnnotation(node, opts) {
    assert$1("StringTypeAnnotation", node, opts);
  }
  function assertSymbolTypeAnnotation(node, opts) {
    assert$1("SymbolTypeAnnotation", node, opts);
  }
  function assertThisTypeAnnotation(node, opts) {
    assert$1("ThisTypeAnnotation", node, opts);
  }
  function assertTupleTypeAnnotation(node, opts) {
    assert$1("TupleTypeAnnotation", node, opts);
  }
  function assertTypeofTypeAnnotation(node, opts) {
    assert$1("TypeofTypeAnnotation", node, opts);
  }
  function assertTypeAlias(node, opts) {
    assert$1("TypeAlias", node, opts);
  }
  function assertTypeAnnotation(node, opts) {
    assert$1("TypeAnnotation", node, opts);
  }
  function assertTypeCastExpression(node, opts) {
    assert$1("TypeCastExpression", node, opts);
  }
  function assertTypeParameter(node, opts) {
    assert$1("TypeParameter", node, opts);
  }
  function assertTypeParameterDeclaration(node, opts) {
    assert$1("TypeParameterDeclaration", node, opts);
  }
  function assertTypeParameterInstantiation(node, opts) {
    assert$1("TypeParameterInstantiation", node, opts);
  }
  function assertUnionTypeAnnotation(node, opts) {
    assert$1("UnionTypeAnnotation", node, opts);
  }
  function assertVariance(node, opts) {
    assert$1("Variance", node, opts);
  }
  function assertVoidTypeAnnotation(node, opts) {
    assert$1("VoidTypeAnnotation", node, opts);
  }
  function assertEnumDeclaration(node, opts) {
    assert$1("EnumDeclaration", node, opts);
  }
  function assertEnumBooleanBody(node, opts) {
    assert$1("EnumBooleanBody", node, opts);
  }
  function assertEnumNumberBody(node, opts) {
    assert$1("EnumNumberBody", node, opts);
  }
  function assertEnumStringBody(node, opts) {
    assert$1("EnumStringBody", node, opts);
  }
  function assertEnumSymbolBody(node, opts) {
    assert$1("EnumSymbolBody", node, opts);
  }
  function assertEnumBooleanMember(node, opts) {
    assert$1("EnumBooleanMember", node, opts);
  }
  function assertEnumNumberMember(node, opts) {
    assert$1("EnumNumberMember", node, opts);
  }
  function assertEnumStringMember(node, opts) {
    assert$1("EnumStringMember", node, opts);
  }
  function assertEnumDefaultedMember(node, opts) {
    assert$1("EnumDefaultedMember", node, opts);
  }
  function assertIndexedAccessType(node, opts) {
    assert$1("IndexedAccessType", node, opts);
  }
  function assertOptionalIndexedAccessType(node, opts) {
    assert$1("OptionalIndexedAccessType", node, opts);
  }
  function assertJSXAttribute(node, opts) {
    assert$1("JSXAttribute", node, opts);
  }
  function assertJSXClosingElement(node, opts) {
    assert$1("JSXClosingElement", node, opts);
  }
  function assertJSXElement(node, opts) {
    assert$1("JSXElement", node, opts);
  }
  function assertJSXEmptyExpression(node, opts) {
    assert$1("JSXEmptyExpression", node, opts);
  }
  function assertJSXExpressionContainer(node, opts) {
    assert$1("JSXExpressionContainer", node, opts);
  }
  function assertJSXSpreadChild(node, opts) {
    assert$1("JSXSpreadChild", node, opts);
  }
  function assertJSXIdentifier(node, opts) {
    assert$1("JSXIdentifier", node, opts);
  }
  function assertJSXMemberExpression(node, opts) {
    assert$1("JSXMemberExpression", node, opts);
  }
  function assertJSXNamespacedName(node, opts) {
    assert$1("JSXNamespacedName", node, opts);
  }
  function assertJSXOpeningElement(node, opts) {
    assert$1("JSXOpeningElement", node, opts);
  }
  function assertJSXSpreadAttribute(node, opts) {
    assert$1("JSXSpreadAttribute", node, opts);
  }
  function assertJSXText(node, opts) {
    assert$1("JSXText", node, opts);
  }
  function assertJSXFragment(node, opts) {
    assert$1("JSXFragment", node, opts);
  }
  function assertJSXOpeningFragment(node, opts) {
    assert$1("JSXOpeningFragment", node, opts);
  }
  function assertJSXClosingFragment(node, opts) {
    assert$1("JSXClosingFragment", node, opts);
  }
  function assertNoop(node, opts) {
    assert$1("Noop", node, opts);
  }
  function assertPlaceholder(node, opts) {
    assert$1("Placeholder", node, opts);
  }
  function assertV8IntrinsicIdentifier(node, opts) {
    assert$1("V8IntrinsicIdentifier", node, opts);
  }
  function assertArgumentPlaceholder(node, opts) {
    assert$1("ArgumentPlaceholder", node, opts);
  }
  function assertBindExpression(node, opts) {
    assert$1("BindExpression", node, opts);
  }
  function assertClassProperty(node, opts) {
    assert$1("ClassProperty", node, opts);
  }
  function assertPipelineTopicExpression(node, opts) {
    assert$1("PipelineTopicExpression", node, opts);
  }
  function assertPipelineBareFunction(node, opts) {
    assert$1("PipelineBareFunction", node, opts);
  }
  function assertPipelinePrimaryTopicReference(node, opts) {
    assert$1("PipelinePrimaryTopicReference", node, opts);
  }
  function assertClassPrivateProperty(node, opts) {
    assert$1("ClassPrivateProperty", node, opts);
  }
  function assertClassPrivateMethod(node, opts) {
    assert$1("ClassPrivateMethod", node, opts);
  }
  function assertImportAttribute(node, opts) {
    assert$1("ImportAttribute", node, opts);
  }
  function assertDecorator(node, opts) {
    assert$1("Decorator", node, opts);
  }
  function assertDoExpression(node, opts) {
    assert$1("DoExpression", node, opts);
  }
  function assertExportDefaultSpecifier(node, opts) {
    assert$1("ExportDefaultSpecifier", node, opts);
  }
  function assertPrivateName(node, opts) {
    assert$1("PrivateName", node, opts);
  }
  function assertRecordExpression(node, opts) {
    assert$1("RecordExpression", node, opts);
  }
  function assertTupleExpression(node, opts) {
    assert$1("TupleExpression", node, opts);
  }
  function assertDecimalLiteral(node, opts) {
    assert$1("DecimalLiteral", node, opts);
  }
  function assertStaticBlock(node, opts) {
    assert$1("StaticBlock", node, opts);
  }
  function assertModuleExpression(node, opts) {
    assert$1("ModuleExpression", node, opts);
  }
  function assertTSParameterProperty(node, opts) {
    assert$1("TSParameterProperty", node, opts);
  }
  function assertTSDeclareFunction(node, opts) {
    assert$1("TSDeclareFunction", node, opts);
  }
  function assertTSDeclareMethod(node, opts) {
    assert$1("TSDeclareMethod", node, opts);
  }
  function assertTSQualifiedName(node, opts) {
    assert$1("TSQualifiedName", node, opts);
  }
  function assertTSCallSignatureDeclaration(node, opts) {
    assert$1("TSCallSignatureDeclaration", node, opts);
  }
  function assertTSConstructSignatureDeclaration(node, opts) {
    assert$1("TSConstructSignatureDeclaration", node, opts);
  }
  function assertTSPropertySignature(node, opts) {
    assert$1("TSPropertySignature", node, opts);
  }
  function assertTSMethodSignature(node, opts) {
    assert$1("TSMethodSignature", node, opts);
  }
  function assertTSIndexSignature(node, opts) {
    assert$1("TSIndexSignature", node, opts);
  }
  function assertTSAnyKeyword(node, opts) {
    assert$1("TSAnyKeyword", node, opts);
  }
  function assertTSBooleanKeyword(node, opts) {
    assert$1("TSBooleanKeyword", node, opts);
  }
  function assertTSBigIntKeyword(node, opts) {
    assert$1("TSBigIntKeyword", node, opts);
  }
  function assertTSIntrinsicKeyword(node, opts) {
    assert$1("TSIntrinsicKeyword", node, opts);
  }
  function assertTSNeverKeyword(node, opts) {
    assert$1("TSNeverKeyword", node, opts);
  }
  function assertTSNullKeyword(node, opts) {
    assert$1("TSNullKeyword", node, opts);
  }
  function assertTSNumberKeyword(node, opts) {
    assert$1("TSNumberKeyword", node, opts);
  }
  function assertTSObjectKeyword(node, opts) {
    assert$1("TSObjectKeyword", node, opts);
  }
  function assertTSStringKeyword(node, opts) {
    assert$1("TSStringKeyword", node, opts);
  }
  function assertTSSymbolKeyword(node, opts) {
    assert$1("TSSymbolKeyword", node, opts);
  }
  function assertTSUndefinedKeyword(node, opts) {
    assert$1("TSUndefinedKeyword", node, opts);
  }
  function assertTSUnknownKeyword(node, opts) {
    assert$1("TSUnknownKeyword", node, opts);
  }
  function assertTSVoidKeyword(node, opts) {
    assert$1("TSVoidKeyword", node, opts);
  }
  function assertTSThisType(node, opts) {
    assert$1("TSThisType", node, opts);
  }
  function assertTSFunctionType(node, opts) {
    assert$1("TSFunctionType", node, opts);
  }
  function assertTSConstructorType(node, opts) {
    assert$1("TSConstructorType", node, opts);
  }
  function assertTSTypeReference(node, opts) {
    assert$1("TSTypeReference", node, opts);
  }
  function assertTSTypePredicate(node, opts) {
    assert$1("TSTypePredicate", node, opts);
  }
  function assertTSTypeQuery(node, opts) {
    assert$1("TSTypeQuery", node, opts);
  }
  function assertTSTypeLiteral(node, opts) {
    assert$1("TSTypeLiteral", node, opts);
  }
  function assertTSArrayType(node, opts) {
    assert$1("TSArrayType", node, opts);
  }
  function assertTSTupleType(node, opts) {
    assert$1("TSTupleType", node, opts);
  }
  function assertTSOptionalType(node, opts) {
    assert$1("TSOptionalType", node, opts);
  }
  function assertTSRestType(node, opts) {
    assert$1("TSRestType", node, opts);
  }
  function assertTSNamedTupleMember(node, opts) {
    assert$1("TSNamedTupleMember", node, opts);
  }
  function assertTSUnionType(node, opts) {
    assert$1("TSUnionType", node, opts);
  }
  function assertTSIntersectionType(node, opts) {
    assert$1("TSIntersectionType", node, opts);
  }
  function assertTSConditionalType(node, opts) {
    assert$1("TSConditionalType", node, opts);
  }
  function assertTSInferType(node, opts) {
    assert$1("TSInferType", node, opts);
  }
  function assertTSParenthesizedType(node, opts) {
    assert$1("TSParenthesizedType", node, opts);
  }
  function assertTSTypeOperator(node, opts) {
    assert$1("TSTypeOperator", node, opts);
  }
  function assertTSIndexedAccessType(node, opts) {
    assert$1("TSIndexedAccessType", node, opts);
  }
  function assertTSMappedType(node, opts) {
    assert$1("TSMappedType", node, opts);
  }
  function assertTSLiteralType(node, opts) {
    assert$1("TSLiteralType", node, opts);
  }
  function assertTSExpressionWithTypeArguments(node, opts) {
    assert$1("TSExpressionWithTypeArguments", node, opts);
  }
  function assertTSInterfaceDeclaration(node, opts) {
    assert$1("TSInterfaceDeclaration", node, opts);
  }
  function assertTSInterfaceBody(node, opts) {
    assert$1("TSInterfaceBody", node, opts);
  }
  function assertTSTypeAliasDeclaration(node, opts) {
    assert$1("TSTypeAliasDeclaration", node, opts);
  }
  function assertTSAsExpression(node, opts) {
    assert$1("TSAsExpression", node, opts);
  }
  function assertTSTypeAssertion(node, opts) {
    assert$1("TSTypeAssertion", node, opts);
  }
  function assertTSEnumDeclaration(node, opts) {
    assert$1("TSEnumDeclaration", node, opts);
  }
  function assertTSEnumMember(node, opts) {
    assert$1("TSEnumMember", node, opts);
  }
  function assertTSModuleDeclaration(node, opts) {
    assert$1("TSModuleDeclaration", node, opts);
  }
  function assertTSModuleBlock(node, opts) {
    assert$1("TSModuleBlock", node, opts);
  }
  function assertTSImportType(node, opts) {
    assert$1("TSImportType", node, opts);
  }
  function assertTSImportEqualsDeclaration(node, opts) {
    assert$1("TSImportEqualsDeclaration", node, opts);
  }
  function assertTSExternalModuleReference(node, opts) {
    assert$1("TSExternalModuleReference", node, opts);
  }
  function assertTSNonNullExpression(node, opts) {
    assert$1("TSNonNullExpression", node, opts);
  }
  function assertTSExportAssignment(node, opts) {
    assert$1("TSExportAssignment", node, opts);
  }
  function assertTSNamespaceExportDeclaration(node, opts) {
    assert$1("TSNamespaceExportDeclaration", node, opts);
  }
  function assertTSTypeAnnotation(node, opts) {
    assert$1("TSTypeAnnotation", node, opts);
  }
  function assertTSTypeParameterInstantiation(node, opts) {
    assert$1("TSTypeParameterInstantiation", node, opts);
  }
  function assertTSTypeParameterDeclaration(node, opts) {
    assert$1("TSTypeParameterDeclaration", node, opts);
  }
  function assertTSTypeParameter(node, opts) {
    assert$1("TSTypeParameter", node, opts);
  }
  function assertExpression(node, opts) {
    assert$1("Expression", node, opts);
  }
  function assertBinary(node, opts) {
    assert$1("Binary", node, opts);
  }
  function assertScopable(node, opts) {
    assert$1("Scopable", node, opts);
  }
  function assertBlockParent(node, opts) {
    assert$1("BlockParent", node, opts);
  }
  function assertBlock(node, opts) {
    assert$1("Block", node, opts);
  }
  function assertStatement(node, opts) {
    assert$1("Statement", node, opts);
  }
  function assertTerminatorless(node, opts) {
    assert$1("Terminatorless", node, opts);
  }
  function assertCompletionStatement(node, opts) {
    assert$1("CompletionStatement", node, opts);
  }
  function assertConditional(node, opts) {
    assert$1("Conditional", node, opts);
  }
  function assertLoop(node, opts) {
    assert$1("Loop", node, opts);
  }
  function assertWhile(node, opts) {
    assert$1("While", node, opts);
  }
  function assertExpressionWrapper(node, opts) {
    assert$1("ExpressionWrapper", node, opts);
  }
  function assertFor(node, opts) {
    assert$1("For", node, opts);
  }
  function assertForXStatement(node, opts) {
    assert$1("ForXStatement", node, opts);
  }
  function assertFunction$1(node, opts) {
    assert$1("Function", node, opts);
  }
  function assertFunctionParent(node, opts) {
    assert$1("FunctionParent", node, opts);
  }
  function assertPureish(node, opts) {
    assert$1("Pureish", node, opts);
  }
  function assertDeclaration(node, opts) {
    assert$1("Declaration", node, opts);
  }
  function assertPatternLike(node, opts) {
    assert$1("PatternLike", node, opts);
  }
  function assertLVal(node, opts) {
    assert$1("LVal", node, opts);
  }
  function assertTSEntityName(node, opts) {
    assert$1("TSEntityName", node, opts);
  }
  function assertLiteral(node, opts) {
    assert$1("Literal", node, opts);
  }
  function assertImmutable(node, opts) {
    assert$1("Immutable", node, opts);
  }
  function assertUserWhitespacable(node, opts) {
    assert$1("UserWhitespacable", node, opts);
  }
  function assertMethod(node, opts) {
    assert$1("Method", node, opts);
  }
  function assertObjectMember(node, opts) {
    assert$1("ObjectMember", node, opts);
  }
  function assertProperty(node, opts) {
    assert$1("Property", node, opts);
  }
  function assertUnaryLike(node, opts) {
    assert$1("UnaryLike", node, opts);
  }
  function assertPattern(node, opts) {
    assert$1("Pattern", node, opts);
  }
  function assertClass(node, opts) {
    assert$1("Class", node, opts);
  }
  function assertModuleDeclaration(node, opts) {
    assert$1("ModuleDeclaration", node, opts);
  }
  function assertExportDeclaration(node, opts) {
    assert$1("ExportDeclaration", node, opts);
  }
  function assertModuleSpecifier(node, opts) {
    assert$1("ModuleSpecifier", node, opts);
  }
  function assertFlow(node, opts) {
    assert$1("Flow", node, opts);
  }
  function assertFlowType(node, opts) {
    assert$1("FlowType", node, opts);
  }
  function assertFlowBaseAnnotation(node, opts) {
    assert$1("FlowBaseAnnotation", node, opts);
  }
  function assertFlowDeclaration(node, opts) {
    assert$1("FlowDeclaration", node, opts);
  }
  function assertFlowPredicate(node, opts) {
    assert$1("FlowPredicate", node, opts);
  }
  function assertEnumBody(node, opts) {
    assert$1("EnumBody", node, opts);
  }
  function assertEnumMember(node, opts) {
    assert$1("EnumMember", node, opts);
  }
  function assertJSX(node, opts) {
    assert$1("JSX", node, opts);
  }
  function assertPrivate(node, opts) {
    assert$1("Private", node, opts);
  }
  function assertTSTypeElement(node, opts) {
    assert$1("TSTypeElement", node, opts);
  }
  function assertTSType(node, opts) {
    assert$1("TSType", node, opts);
  }
  function assertTSBaseType(node, opts) {
    assert$1("TSBaseType", node, opts);
  }
  function assertNumberLiteral(node, opts) {
    console.trace("The node type NumberLiteral has been renamed to NumericLiteral");
    assert$1("NumberLiteral", node, opts);
  }
  function assertRegexLiteral(node, opts) {
    console.trace("The node type RegexLiteral has been renamed to RegExpLiteral");
    assert$1("RegexLiteral", node, opts);
  }
  function assertRestProperty(node, opts) {
    console.trace("The node type RestProperty has been renamed to RestElement");
    assert$1("RestProperty", node, opts);
  }
  function assertSpreadProperty(node, opts) {
    console.trace("The node type SpreadProperty has been renamed to SpreadElement");
    assert$1("SpreadProperty", node, opts);
  }

  function createTypeAnnotationBasedOnTypeof(type) {
    if (type === "string") {
      return stringTypeAnnotation();
    } else if (type === "number") {
      return numberTypeAnnotation();
    } else if (type === "undefined") {
      return voidTypeAnnotation();
    } else if (type === "boolean") {
      return booleanTypeAnnotation();
    } else if (type === "function") {
      return genericTypeAnnotation(identifier("Function"));
    } else if (type === "object") {
      return genericTypeAnnotation(identifier("Object"));
    } else if (type === "symbol") {
      return genericTypeAnnotation(identifier("Symbol"));
    } else if (type === "bigint") {
      return anyTypeAnnotation();
    } else {
      throw new Error("Invalid typeof value: " + type);
    }
  }

  function getQualifiedName(node) {
    return isIdentifier(node) ? node.name : node.id.name + "." + getQualifiedName(node.qualification);
  }

  function removeTypeDuplicates$1(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if (isAnyTypeAnnotation(node)) {
        return [node];
      }

      if (isFlowBaseAnnotation(node)) {
        bases[node.type] = node;
        continue;
      }

      if (isUnionTypeAnnotation(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      if (isGenericTypeAnnotation(node)) {
        var name = getQualifiedName(node.id);

        if (generics[name]) {
          var existing = generics[name];

          if (existing.typeParameters) {
            if (node.typeParameters) {
              existing.typeParameters.params = removeTypeDuplicates$1(existing.typeParameters.params.concat(node.typeParameters.params));
            }
          } else {
            existing = node.typeParameters;
          }
        } else {
          generics[name] = node;
        }

        continue;
      }

      types.push(node);
    }

    for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      types.push(bases[type]);
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
      var _name = _Object$keys2[_i2];
      types.push(generics[_name]);
    }

    return types;
  }

  function createFlowUnionType(types) {
    var flattened = removeTypeDuplicates$1(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return unionTypeAnnotation(flattened);
    }
  }

  function removeTypeDuplicates(nodes) {
    var generics = {};
    var bases = {};
    var typeGroups = [];
    var types = [];

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) continue;

      if (types.indexOf(node) >= 0) {
        continue;
      }

      if (isTSAnyKeyword(node)) {
        return [node];
      }

      if (isTSBaseType(node)) {
        bases[node.type] = node;
        continue;
      }

      if (isTSUnionType(node)) {
        if (typeGroups.indexOf(node.types) < 0) {
          nodes = nodes.concat(node.types);
          typeGroups.push(node.types);
        }

        continue;
      }

      types.push(node);
    }

    for (var _i = 0, _Object$keys = Object.keys(bases); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      types.push(bases[type]);
    }

    for (var _i2 = 0, _Object$keys2 = Object.keys(generics); _i2 < _Object$keys2.length; _i2++) {
      var name = _Object$keys2[_i2];
      types.push(generics[name]);
    }

    return types;
  }

  function createTSUnionType(typeAnnotations) {
    var types = typeAnnotations.map(function (type) {
      return type.typeAnnotation;
    });
    var flattened = removeTypeDuplicates(types);

    if (flattened.length === 1) {
      return flattened[0];
    } else {
      return tsUnionType(flattened);
    }
  }

  var has$d = Function.call.bind(Object.prototype.hasOwnProperty);

  function cloneIfNode(obj, deep, withoutLoc) {
    if (obj && typeof obj.type === "string") {
      return cloneNode(obj, deep, withoutLoc);
    }

    return obj;
  }

  function cloneIfNodeOrArray(obj, deep, withoutLoc) {
    if (Array.isArray(obj)) {
      return obj.map(function (node) {
        return cloneIfNode(node, deep, withoutLoc);
      });
    }

    return cloneIfNode(obj, deep, withoutLoc);
  }

  function cloneNode(node, deep, withoutLoc) {
    if (deep === void 0) {
      deep = true;
    }

    if (withoutLoc === void 0) {
      withoutLoc = false;
    }

    if (!node) return node;
    var type = node.type;
    var newNode = {
      type: node.type
    };

    if (isIdentifier(node)) {
      newNode.name = node.name;

      if (has$d(node, "optional") && typeof node.optional === "boolean") {
        newNode.optional = node.optional;
      }

      if (has$d(node, "typeAnnotation")) {
        newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc) : node.typeAnnotation;
      }
    } else if (!has$d(NODE_FIELDS, type)) {
      throw new Error("Unknown node type: \"" + type + "\"");
    } else {
      for (var _i = 0, _Object$keys = Object.keys(NODE_FIELDS[type]); _i < _Object$keys.length; _i++) {
        var field = _Object$keys[_i];

        if (has$d(node, field)) {
          if (deep) {
            newNode[field] = isFile(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc) : cloneIfNodeOrArray(node[field], true, withoutLoc);
          } else {
            newNode[field] = node[field];
          }
        }
      }
    }

    if (has$d(node, "loc")) {
      if (withoutLoc) {
        newNode.loc = null;
      } else {
        newNode.loc = node.loc;
      }
    }

    if (has$d(node, "leadingComments")) {
      newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc);
    }

    if (has$d(node, "innerComments")) {
      newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc);
    }

    if (has$d(node, "trailingComments")) {
      newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc);
    }

    if (has$d(node, "extra")) {
      newNode.extra = Object.assign({}, node.extra);
    }

    return newNode;
  }

  function maybeCloneComments(comments, deep, withoutLoc) {
    if (!comments || !deep) {
      return comments;
    }

    return comments.map(function (_ref) {
      var type = _ref.type,
          value = _ref.value,
          loc = _ref.loc;

      if (withoutLoc) {
        return {
          type: type,
          value: value,
          loc: null
        };
      }

      return {
        type: type,
        value: value,
        loc: loc
      };
    });
  }

  function clone(node) {
    return cloneNode(node, false);
  }

  function cloneDeep$1(node) {
    return cloneNode(node);
  }

  function cloneDeepWithoutLoc(node) {
    return cloneNode(node, true, true);
  }

  function cloneWithoutLoc(node) {
    return cloneNode(node, false, true);
  }

  function addComments$1(node, type, comments) {
    if (!comments || !node) return node;
    var key = type + "Comments";

    if (node[key]) {
      if (type === "leading") {
        node[key] = comments.concat(node[key]);
      } else {
        node[key] = node[key].concat(comments);
      }
    } else {
      node[key] = comments;
    }

    return node;
  }

  function addComment$1(node, type, content, line) {
    return addComments$1(node, type, [{
      type: line ? "CommentLine" : "CommentBlock",
      value: content
    }]);
  }

  function inherit(key, child, parent) {
    if (child && parent) {
      child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
    }
  }

  function inheritInnerComments(child, parent) {
    inherit("innerComments", child, parent);
  }

  function inheritLeadingComments(child, parent) {
    inherit("leadingComments", child, parent);
  }

  function inheritTrailingComments(child, parent) {
    inherit("trailingComments", child, parent);
  }

  function inheritsComments(child, parent) {
    inheritTrailingComments(child, parent);
    inheritLeadingComments(child, parent);
    inheritInnerComments(child, parent);
    return child;
  }

  function removeComments(node) {
    COMMENT_KEYS.forEach(function (key) {
      node[key] = null;
    });
    return node;
  }

  var EXPRESSION_TYPES = FLIPPED_ALIAS_KEYS["Expression"];
  var BINARY_TYPES = FLIPPED_ALIAS_KEYS["Binary"];
  var SCOPABLE_TYPES = FLIPPED_ALIAS_KEYS["Scopable"];
  var BLOCKPARENT_TYPES = FLIPPED_ALIAS_KEYS["BlockParent"];
  var BLOCK_TYPES = FLIPPED_ALIAS_KEYS["Block"];
  var STATEMENT_TYPES = FLIPPED_ALIAS_KEYS["Statement"];
  var TERMINATORLESS_TYPES = FLIPPED_ALIAS_KEYS["Terminatorless"];
  var COMPLETIONSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["CompletionStatement"];
  var CONDITIONAL_TYPES = FLIPPED_ALIAS_KEYS["Conditional"];
  var LOOP_TYPES = FLIPPED_ALIAS_KEYS["Loop"];
  var WHILE_TYPES = FLIPPED_ALIAS_KEYS["While"];
  var EXPRESSIONWRAPPER_TYPES = FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
  var FOR_TYPES = FLIPPED_ALIAS_KEYS["For"];
  var FORXSTATEMENT_TYPES = FLIPPED_ALIAS_KEYS["ForXStatement"];
  var FUNCTION_TYPES = FLIPPED_ALIAS_KEYS["Function"];
  var FUNCTIONPARENT_TYPES = FLIPPED_ALIAS_KEYS["FunctionParent"];
  var PUREISH_TYPES = FLIPPED_ALIAS_KEYS["Pureish"];
  var DECLARATION_TYPES = FLIPPED_ALIAS_KEYS["Declaration"];
  var PATTERNLIKE_TYPES = FLIPPED_ALIAS_KEYS["PatternLike"];
  var LVAL_TYPES = FLIPPED_ALIAS_KEYS["LVal"];
  var TSENTITYNAME_TYPES = FLIPPED_ALIAS_KEYS["TSEntityName"];
  var LITERAL_TYPES = FLIPPED_ALIAS_KEYS["Literal"];
  var IMMUTABLE_TYPES = FLIPPED_ALIAS_KEYS["Immutable"];
  var USERWHITESPACABLE_TYPES = FLIPPED_ALIAS_KEYS["UserWhitespacable"];
  var METHOD_TYPES = FLIPPED_ALIAS_KEYS["Method"];
  var OBJECTMEMBER_TYPES = FLIPPED_ALIAS_KEYS["ObjectMember"];
  var PROPERTY_TYPES = FLIPPED_ALIAS_KEYS["Property"];
  var UNARYLIKE_TYPES = FLIPPED_ALIAS_KEYS["UnaryLike"];
  var PATTERN_TYPES = FLIPPED_ALIAS_KEYS["Pattern"];
  var CLASS_TYPES = FLIPPED_ALIAS_KEYS["Class"];
  var MODULEDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ModuleDeclaration"];
  var EXPORTDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["ExportDeclaration"];
  var MODULESPECIFIER_TYPES = FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
  var FLOW_TYPES = FLIPPED_ALIAS_KEYS["Flow"];
  var FLOWTYPE_TYPES = FLIPPED_ALIAS_KEYS["FlowType"];
  var FLOWBASEANNOTATION_TYPES = FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
  var FLOWDECLARATION_TYPES = FLIPPED_ALIAS_KEYS["FlowDeclaration"];
  var FLOWPREDICATE_TYPES = FLIPPED_ALIAS_KEYS["FlowPredicate"];
  var ENUMBODY_TYPES = FLIPPED_ALIAS_KEYS["EnumBody"];
  var ENUMMEMBER_TYPES = FLIPPED_ALIAS_KEYS["EnumMember"];
  var JSX_TYPES = FLIPPED_ALIAS_KEYS["JSX"];
  var PRIVATE_TYPES = FLIPPED_ALIAS_KEYS["Private"];
  var TSTYPEELEMENT_TYPES = FLIPPED_ALIAS_KEYS["TSTypeElement"];
  var TSTYPE_TYPES = FLIPPED_ALIAS_KEYS["TSType"];
  var TSBASETYPE_TYPES = FLIPPED_ALIAS_KEYS["TSBaseType"];

  function toBlock(node, parent) {
    if (isBlockStatement(node)) {
      return node;
    }

    var blockNodes = [];

    if (isEmptyStatement(node)) {
      blockNodes = [];
    } else {
      if (!isStatement(node)) {
        if (isFunction$1(parent)) {
          node = returnStatement(node);
        } else {
          node = expressionStatement(node);
        }
      }

      blockNodes = [node];
    }

    return blockStatement(blockNodes);
  }

  function ensureBlock$1(node, key) {
    if (key === void 0) {
      key = "body";
    }

    return node[key] = toBlock(node[key], node);
  }

  function toIdentifier(input) {
    input = input + "";
    var name = "";

    for (var _iterator = _createForOfIteratorHelperLoose(input), _step; !(_step = _iterator()).done;) {
      var c = _step.value;
      name += isIdentifierChar(c.codePointAt(0)) ? c : "-";
    }

    name = name.replace(/^[-0-9]+/, "");
    name = name.replace(/[-\s]+(.)?/g, function (match, c) {
      return c ? c.toUpperCase() : "";
    });

    if (!isValidIdentifier(name)) {
      name = "_" + name;
    }

    return name || "_";
  }

  function toBindingIdentifierName(name) {
    name = toIdentifier(name);
    if (name === "eval" || name === "arguments") name = "_" + name;
    return name;
  }

  function toComputedKey$1(node, key) {
    if (key === void 0) {
      key = node.key || node.property;
    }

    if (!node.computed && isIdentifier(key)) key = stringLiteral(key.name);
    return key;
  }

  function toExpression(node) {
    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    if (isExpression(node)) {
      return node;
    }

    if (isClass(node)) {
      node.type = "ClassExpression";
    } else if (isFunction$1(node)) {
      node.type = "FunctionExpression";
    }

    if (!isExpression(node)) {
      throw new Error("cannot turn " + node.type + " to an expression");
    }

    return node;
  }

  function traverseFast(node, enter, opts) {
    if (!node) return;
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    opts = opts || {};
    enter(node, opts);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(subNode), _step2; !(_step2 = _iterator2()).done;) {
          var _node = _step2.value;
          traverseFast(_node, enter, opts);
        }
      } else {
        traverseFast(subNode, enter, opts);
      }
    }
  }

  var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
  var CLEAR_KEYS_PLUS_COMMENTS = COMMENT_KEYS.concat(["comments"]).concat(CLEAR_KEYS);
  function removeProperties(node, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;

    for (var _iterator = _createForOfIteratorHelperLoose(map), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;
      if (node[_key] != null) node[_key] = undefined;
    }

    for (var _i = 0, _Object$keys = Object.keys(node); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && node[key] != null) node[key] = undefined;
    }

    var symbols = Object.getOwnPropertySymbols(node);

    for (var _iterator2 = _createForOfIteratorHelperLoose(symbols), _step2; !(_step2 = _iterator2()).done;) {
      var sym = _step2.value;
      node[sym] = null;
    }
  }

  function removePropertiesDeep(tree, opts) {
    traverseFast(tree, removeProperties, opts);
    return tree;
  }

  function toKeyAlias(node, key) {
    if (key === void 0) {
      key = node.key;
    }

    var alias;

    if (node.kind === "method") {
      return toKeyAlias.increment() + "";
    } else if (isIdentifier(key)) {
      alias = key.name;
    } else if (isStringLiteral(key)) {
      alias = JSON.stringify(key.value);
    } else {
      alias = JSON.stringify(removePropertiesDeep(cloneNode(key)));
    }

    if (node.computed) {
      alias = "[" + alias + "]";
    }

    if (node["static"]) {
      alias = "static:" + alias;
    }

    return alias;
  }
  toKeyAlias.uid = 0;

  toKeyAlias.increment = function () {
    if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
      return toKeyAlias.uid = 0;
    } else {
      return toKeyAlias.uid++;
    }
  };

  function getBindingIdentifiers$1(node, duplicates, outerOnly) {
    var search = [].concat(node);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      var keys = getBindingIdentifiers$1.keys[id.type];

      if (isIdentifier(id)) {
        if (duplicates) {
          var _ids = ids[id.name] = ids[id.name] || [];

          _ids.push(id);
        } else {
          ids[id.name] = id;
        }

        continue;
      }

      if (isExportDeclaration(id) && !isExportAllDeclaration(id)) {
        if (isDeclaration(id.declaration)) {
          search.push(id.declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (isFunctionDeclaration(id)) {
          search.push(id.id);
          continue;
        }

        if (isFunctionExpression(id)) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];

          if (id[key]) {
            search = search.concat(id[key]);
          }
        }
      }
    }

    return ids;
  }

  getBindingIdentifiers$1.keys = {
    DeclareClass: ["id"],
    DeclareFunction: ["id"],
    DeclareModule: ["id"],
    DeclareVariable: ["id"],
    DeclareInterface: ["id"],
    DeclareTypeAlias: ["id"],
    DeclareOpaqueType: ["id"],
    InterfaceDeclaration: ["id"],
    TypeAlias: ["id"],
    OpaqueType: ["id"],
    CatchClause: ["param"],
    LabeledStatement: ["label"],
    UnaryExpression: ["argument"],
    AssignmentExpression: ["left"],
    ImportSpecifier: ["local"],
    ImportNamespaceSpecifier: ["local"],
    ImportDefaultSpecifier: ["local"],
    ImportDeclaration: ["specifiers"],
    ExportSpecifier: ["exported"],
    ExportNamespaceSpecifier: ["exported"],
    ExportDefaultSpecifier: ["exported"],
    FunctionDeclaration: ["id", "params"],
    FunctionExpression: ["id", "params"],
    ArrowFunctionExpression: ["params"],
    ObjectMethod: ["params"],
    ClassMethod: ["params"],
    ForInStatement: ["left"],
    ForOfStatement: ["left"],
    ClassDeclaration: ["id"],
    ClassExpression: ["id"],
    RestElement: ["argument"],
    UpdateExpression: ["argument"],
    ObjectProperty: ["value"],
    AssignmentPattern: ["left"],
    ArrayPattern: ["elements"],
    ObjectPattern: ["properties"],
    VariableDeclaration: ["declarations"],
    VariableDeclarator: ["id"]
  };

  function gatherSequenceExpressions(nodes, scope, declars) {
    var exprs = [];
    var ensureLastUndefined = true;

    for (var _iterator = _createForOfIteratorHelperLoose(nodes), _step; !(_step = _iterator()).done;) {
      var node = _step.value;

      if (!isEmptyStatement(node)) {
        ensureLastUndefined = false;
      }

      if (isExpression(node)) {
        exprs.push(node);
      } else if (isExpressionStatement(node)) {
        exprs.push(node.expression);
      } else if (isVariableDeclaration(node)) {
        if (node.kind !== "var") return;

        for (var _iterator2 = _createForOfIteratorHelperLoose(node.declarations), _step2; !(_step2 = _iterator2()).done;) {
          var declar = _step2.value;
          var bindings = getBindingIdentifiers$1(declar);

          for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            declars.push({
              kind: node.kind,
              id: cloneNode(bindings[key])
            });
          }

          if (declar.init) {
            exprs.push(assignmentExpression("=", declar.id, declar.init));
          }
        }

        ensureLastUndefined = true;
      } else if (isIfStatement(node)) {
        var consequent = node.consequent ? gatherSequenceExpressions([node.consequent], scope, declars) : scope.buildUndefinedNode();
        var alternate = node.alternate ? gatherSequenceExpressions([node.alternate], scope, declars) : scope.buildUndefinedNode();
        if (!consequent || !alternate) return;
        exprs.push(conditionalExpression(node.test, consequent, alternate));
      } else if (isBlockStatement(node)) {
        var body = gatherSequenceExpressions(node.body, scope, declars);
        if (!body) return;
        exprs.push(body);
      } else if (isEmptyStatement(node)) {
        if (nodes.indexOf(node) === 0) {
          ensureLastUndefined = true;
        }
      } else {
        return;
      }
    }

    if (ensureLastUndefined) {
      exprs.push(scope.buildUndefinedNode());
    }

    if (exprs.length === 1) {
      return exprs[0];
    } else {
      return sequenceExpression(exprs);
    }
  }

  function toSequenceExpression(nodes, scope) {
    if (!(nodes != null && nodes.length)) return;
    var declars = [];
    var result = gatherSequenceExpressions(nodes, scope, declars);
    if (!result) return;

    for (var _i = 0, _declars = declars; _i < _declars.length; _i++) {
      var declar = _declars[_i];
      scope.push(declar);
    }

    return result;
  }

  function toStatement(node, ignore) {
    if (isStatement(node)) {
      return node;
    }

    var mustHaveId = false;
    var newType;

    if (isClass(node)) {
      mustHaveId = true;
      newType = "ClassDeclaration";
    } else if (isFunction$1(node)) {
      mustHaveId = true;
      newType = "FunctionDeclaration";
    } else if (isAssignmentExpression(node)) {
      return expressionStatement(node);
    }

    if (mustHaveId && !node.id) {
      newType = false;
    }

    if (!newType) {
      if (ignore) {
        return false;
      } else {
        throw new Error("cannot turn " + node.type + " to a statement");
      }
    }

    node.type = newType;
    return node;
  }

  var objectToString = Function.call.bind(Object.prototype.toString);

  function isRegExp(value) {
    return objectToString(value) === "[object RegExp]";
  }

  function isPlainObject(value) {
    if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }

    var proto = Object.getPrototypeOf(value);
    return proto === null || Object.getPrototypeOf(proto) === null;
  }

  function valueToNode(value) {
    if (value === undefined) {
      return identifier("undefined");
    }

    if (value === true || value === false) {
      return booleanLiteral(value);
    }

    if (value === null) {
      return nullLiteral();
    }

    if (typeof value === "string") {
      return stringLiteral(value);
    }

    if (typeof value === "number") {
      var result;

      if (Number.isFinite(value)) {
        result = numericLiteral(Math.abs(value));
      } else {
        var numerator;

        if (Number.isNaN(value)) {
          numerator = numericLiteral(0);
        } else {
          numerator = numericLiteral(1);
        }

        result = binaryExpression("/", numerator, numericLiteral(0));
      }

      if (value < 0 || Object.is(value, -0)) {
        result = unaryExpression("-", result);
      }

      return result;
    }

    if (isRegExp(value)) {
      var pattern = value.source;
      var flags = value.toString().match(/\/([a-z]+|)$/)[1];
      return regExpLiteral(pattern, flags);
    }

    if (Array.isArray(value)) {
      return arrayExpression(value.map(valueToNode));
    }

    if (isPlainObject(value)) {
      var props = [];

      for (var _i = 0, _Object$keys = Object.keys(value); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var nodeKey = void 0;

        if (isValidIdentifier(key)) {
          nodeKey = identifier(key);
        } else {
          nodeKey = stringLiteral(key);
        }

        props.push(objectProperty(nodeKey, valueToNode(value[key])));
      }

      return objectExpression(props);
    }

    throw new Error("don't know how to turn this value into a node");
  }

  function appendToMemberExpression(member, append, computed) {
    if (computed === void 0) {
      computed = false;
    }

    member.object = memberExpression(member.object, member.property, member.computed);
    member.property = append;
    member.computed = !!computed;
    return member;
  }

  function inherits(child, parent) {
    if (!child || !parent) return child;

    for (var _iterator = _createForOfIteratorHelperLoose(INHERIT_KEYS.optional), _step; !(_step = _iterator()).done;) {
      var _key = _step.value;

      if (child[_key] == null) {
        child[_key] = parent[_key];
      }
    }

    for (var _i = 0, _Object$keys = Object.keys(parent); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (key[0] === "_" && key !== "__clone") child[key] = parent[key];
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(INHERIT_KEYS.force), _step2; !(_step2 = _iterator2()).done;) {
      var _key2 = _step2.value;
      child[_key2] = parent[_key2];
    }

    inheritsComments(child, parent);
    return child;
  }

  function prependToMemberExpression(member, prepend) {
    member.object = memberExpression(prepend, member.object);
    return member;
  }

  function getOuterBindingIdentifiers$1(node, duplicates) {
    return getBindingIdentifiers$1(node, duplicates, true);
  }

  function traverse$1(node, handlers, state) {
    if (typeof handlers === "function") {
      handlers = {
        enter: handlers
      };
    }

    var _ref = handlers,
        enter = _ref.enter,
        exit = _ref.exit;
    traverseSimpleImpl(node, enter, exit, state, []);
  }

  function traverseSimpleImpl(node, enter, exit, state, ancestors) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    if (enter) enter(node, ancestors, state);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var subNode = node[key];

      if (Array.isArray(subNode)) {
        for (var i = 0; i < subNode.length; i++) {
          var child = subNode[i];
          if (!child) continue;
          ancestors.push({
            node: node,
            key: key,
            index: i
          });
          traverseSimpleImpl(child, enter, exit, state, ancestors);
          ancestors.pop();
        }
      } else if (subNode) {
        ancestors.push({
          node: node,
          key: key
        });
        traverseSimpleImpl(subNode, enter, exit, state, ancestors);
        ancestors.pop();
      }
    }

    if (exit) exit(node, ancestors, state);
  }

  function isBinding(node, parent, grandparent) {
    if (grandparent && node.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
      return false;
    }

    var keys = getBindingIdentifiers$1.keys[parent.type];

    if (keys) {
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var val = parent[key];

        if (Array.isArray(val)) {
          if (val.indexOf(node) >= 0) return true;
        } else {
          if (val === node) return true;
        }
      }
    }

    return false;
  }

  function isLet(node) {
    return isVariableDeclaration(node) && (node.kind !== "var" || node[BLOCK_SCOPED_SYMBOL]);
  }

  function isBlockScoped$1(node) {
    return isFunctionDeclaration(node) || isClassDeclaration(node) || isLet(node);
  }

  function isImmutable(node) {
    if (isType$1(node.type, "Immutable")) return true;

    if (isIdentifier(node)) {
      if (node.name === "undefined") {
        return true;
      } else {
        return false;
      }
    }

    return false;
  }

  function isNodesEquivalent(a, b) {
    if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
      return a === b;
    }

    if (a.type !== b.type) {
      return false;
    }

    var fields = Object.keys(NODE_FIELDS[a.type] || a.type);
    var visitorKeys = VISITOR_KEYS[a.type];

    for (var _i = 0, _fields = fields; _i < _fields.length; _i++) {
      var field = _fields[_i];

      if (typeof a[field] !== typeof b[field]) {
        return false;
      }

      if (a[field] == null && b[field] == null) {
        continue;
      } else if (a[field] == null || b[field] == null) {
        return false;
      }

      if (Array.isArray(a[field])) {
        if (!Array.isArray(b[field])) {
          return false;
        }

        if (a[field].length !== b[field].length) {
          return false;
        }

        for (var i = 0; i < a[field].length; i++) {
          if (!isNodesEquivalent(a[field][i], b[field][i])) {
            return false;
          }
        }

        continue;
      }

      if (typeof a[field] === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
        for (var _i2 = 0, _Object$keys = Object.keys(a[field]); _i2 < _Object$keys.length; _i2++) {
          var key = _Object$keys[_i2];

          if (a[field][key] !== b[field][key]) {
            return false;
          }
        }

        continue;
      }

      if (!isNodesEquivalent(a[field], b[field])) {
        return false;
      }
    }

    return true;
  }

  function isReferenced(node, parent, grandparent) {
    switch (parent.type) {
      case "MemberExpression":
      case "JSXMemberExpression":
      case "OptionalMemberExpression":
        if (parent.property === node) {
          return !!parent.computed;
        }

        return parent.object === node;

      case "VariableDeclarator":
        return parent.init === node;

      case "ArrowFunctionExpression":
        return parent.body === node;

      case "PrivateName":
        return false;

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        if (parent.params.includes(node)) {
          return false;
        }

      case "ObjectProperty":
      case "ClassProperty":
      case "ClassPrivateProperty":
        if (parent.key === node) {
          return !!parent.computed;
        }

        if (parent.value === node) {
          return !grandparent || grandparent.type !== "ObjectPattern";
        }

        return true;

      case "ClassDeclaration":
      case "ClassExpression":
        return parent.superClass === node;

      case "AssignmentExpression":
        return parent.right === node;

      case "AssignmentPattern":
        return parent.right === node;

      case "LabeledStatement":
        return false;

      case "CatchClause":
        return false;

      case "RestElement":
        return false;

      case "BreakStatement":
      case "ContinueStatement":
        return false;

      case "FunctionDeclaration":
      case "FunctionExpression":
        return false;

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return false;

      case "ExportSpecifier":
        if (grandparent != null && grandparent.source) {
          return false;
        }

        return parent.local === node;

      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
        return false;

      case "JSXAttribute":
        return false;

      case "ObjectPattern":
      case "ArrayPattern":
        return false;

      case "MetaProperty":
        return false;

      case "ObjectTypeProperty":
        return parent.key !== node;

      case "TSEnumMember":
        return parent.id !== node;

      case "TSPropertySignature":
        if (parent.key === node) {
          return !!parent.computed;
        }

        return true;
    }

    return true;
  }

  function isScope(node, parent) {
    if (isBlockStatement(node) && (isFunction$1(parent) || isCatchClause(parent))) {
      return false;
    }

    if (isPattern(node) && (isFunction$1(parent) || isCatchClause(parent))) {
      return true;
    }

    return isScopable(node);
  }

  function isSpecifierDefault(specifier) {
    return isImportDefaultSpecifier(specifier) || isIdentifier(specifier.imported || specifier.exported, {
      name: "default"
    });
  }

  var RESERVED_WORDS_ES3_ONLY = new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
  function isValidES3Identifier(name) {
    return isValidIdentifier(name) && !RESERVED_WORDS_ES3_ONLY.has(name);
  }

  function isVar$1(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !node[BLOCK_SCOPED_SYMBOL];
  }

  var react = {
    isReactComponent: isReactComponent,
    isCompatTag: isCompatTag,
    buildChildren: buildChildren
  };

  var t$p = /*#__PURE__*/Object.freeze({
    __proto__: null,
    react: react,
    assertNode: assertNode,
    createTypeAnnotationBasedOnTypeof: createTypeAnnotationBasedOnTypeof,
    createUnionTypeAnnotation: createFlowUnionType,
    createFlowUnionType: createFlowUnionType,
    createTSUnionType: createTSUnionType,
    cloneNode: cloneNode,
    clone: clone,
    cloneDeep: cloneDeep$1,
    cloneDeepWithoutLoc: cloneDeepWithoutLoc,
    cloneWithoutLoc: cloneWithoutLoc,
    addComment: addComment$1,
    addComments: addComments$1,
    inheritInnerComments: inheritInnerComments,
    inheritLeadingComments: inheritLeadingComments,
    inheritsComments: inheritsComments,
    inheritTrailingComments: inheritTrailingComments,
    removeComments: removeComments,
    ensureBlock: ensureBlock$1,
    toBindingIdentifierName: toBindingIdentifierName,
    toBlock: toBlock,
    toComputedKey: toComputedKey$1,
    toExpression: toExpression,
    toIdentifier: toIdentifier,
    toKeyAlias: toKeyAlias,
    toSequenceExpression: toSequenceExpression,
    toStatement: toStatement,
    valueToNode: valueToNode,
    appendToMemberExpression: appendToMemberExpression,
    inherits: inherits,
    prependToMemberExpression: prependToMemberExpression,
    removeProperties: removeProperties,
    removePropertiesDeep: removePropertiesDeep,
    removeTypeDuplicates: removeTypeDuplicates$1,
    getBindingIdentifiers: getBindingIdentifiers$1,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers$1,
    traverse: traverse$1,
    traverseFast: traverseFast,
    shallowEqual: shallowEqual,
    is: is$1,
    isBinding: isBinding,
    isBlockScoped: isBlockScoped$1,
    isImmutable: isImmutable,
    isLet: isLet,
    isNode: isNode,
    isNodesEquivalent: isNodesEquivalent,
    isPlaceholderType: isPlaceholderType,
    isReferenced: isReferenced,
    isScope: isScope,
    isSpecifierDefault: isSpecifierDefault,
    isType: isType$1,
    isValidES3Identifier: isValidES3Identifier,
    isValidIdentifier: isValidIdentifier,
    isVar: isVar$1,
    matchesPattern: matchesPattern$1,
    validate: validate$3,
    buildMatchMemberExpression: buildMatchMemberExpression,
    assertArrayExpression: assertArrayExpression,
    assertAssignmentExpression: assertAssignmentExpression,
    assertBinaryExpression: assertBinaryExpression,
    assertInterpreterDirective: assertInterpreterDirective,
    assertDirective: assertDirective,
    assertDirectiveLiteral: assertDirectiveLiteral,
    assertBlockStatement: assertBlockStatement,
    assertBreakStatement: assertBreakStatement,
    assertCallExpression: assertCallExpression,
    assertCatchClause: assertCatchClause,
    assertConditionalExpression: assertConditionalExpression,
    assertContinueStatement: assertContinueStatement,
    assertDebuggerStatement: assertDebuggerStatement,
    assertDoWhileStatement: assertDoWhileStatement,
    assertEmptyStatement: assertEmptyStatement,
    assertExpressionStatement: assertExpressionStatement,
    assertFile: assertFile,
    assertForInStatement: assertForInStatement,
    assertForStatement: assertForStatement,
    assertFunctionDeclaration: assertFunctionDeclaration,
    assertFunctionExpression: assertFunctionExpression,
    assertIdentifier: assertIdentifier,
    assertIfStatement: assertIfStatement,
    assertLabeledStatement: assertLabeledStatement,
    assertStringLiteral: assertStringLiteral,
    assertNumericLiteral: assertNumericLiteral,
    assertNullLiteral: assertNullLiteral,
    assertBooleanLiteral: assertBooleanLiteral,
    assertRegExpLiteral: assertRegExpLiteral,
    assertLogicalExpression: assertLogicalExpression,
    assertMemberExpression: assertMemberExpression,
    assertNewExpression: assertNewExpression,
    assertProgram: assertProgram,
    assertObjectExpression: assertObjectExpression,
    assertObjectMethod: assertObjectMethod,
    assertObjectProperty: assertObjectProperty,
    assertRestElement: assertRestElement,
    assertReturnStatement: assertReturnStatement,
    assertSequenceExpression: assertSequenceExpression,
    assertParenthesizedExpression: assertParenthesizedExpression,
    assertSwitchCase: assertSwitchCase,
    assertSwitchStatement: assertSwitchStatement,
    assertThisExpression: assertThisExpression,
    assertThrowStatement: assertThrowStatement,
    assertTryStatement: assertTryStatement,
    assertUnaryExpression: assertUnaryExpression,
    assertUpdateExpression: assertUpdateExpression,
    assertVariableDeclaration: assertVariableDeclaration,
    assertVariableDeclarator: assertVariableDeclarator,
    assertWhileStatement: assertWhileStatement,
    assertWithStatement: assertWithStatement,
    assertAssignmentPattern: assertAssignmentPattern,
    assertArrayPattern: assertArrayPattern,
    assertArrowFunctionExpression: assertArrowFunctionExpression,
    assertClassBody: assertClassBody,
    assertClassExpression: assertClassExpression,
    assertClassDeclaration: assertClassDeclaration,
    assertExportAllDeclaration: assertExportAllDeclaration,
    assertExportDefaultDeclaration: assertExportDefaultDeclaration,
    assertExportNamedDeclaration: assertExportNamedDeclaration,
    assertExportSpecifier: assertExportSpecifier$1,
    assertForOfStatement: assertForOfStatement,
    assertImportDeclaration: assertImportDeclaration,
    assertImportDefaultSpecifier: assertImportDefaultSpecifier,
    assertImportNamespaceSpecifier: assertImportNamespaceSpecifier,
    assertImportSpecifier: assertImportSpecifier,
    assertMetaProperty: assertMetaProperty,
    assertClassMethod: assertClassMethod,
    assertObjectPattern: assertObjectPattern,
    assertSpreadElement: assertSpreadElement,
    assertSuper: assertSuper,
    assertTaggedTemplateExpression: assertTaggedTemplateExpression,
    assertTemplateElement: assertTemplateElement,
    assertTemplateLiteral: assertTemplateLiteral,
    assertYieldExpression: assertYieldExpression,
    assertAwaitExpression: assertAwaitExpression,
    assertImport: assertImport,
    assertBigIntLiteral: assertBigIntLiteral,
    assertExportNamespaceSpecifier: assertExportNamespaceSpecifier,
    assertOptionalMemberExpression: assertOptionalMemberExpression,
    assertOptionalCallExpression: assertOptionalCallExpression,
    assertAnyTypeAnnotation: assertAnyTypeAnnotation,
    assertArrayTypeAnnotation: assertArrayTypeAnnotation,
    assertBooleanTypeAnnotation: assertBooleanTypeAnnotation,
    assertBooleanLiteralTypeAnnotation: assertBooleanLiteralTypeAnnotation,
    assertNullLiteralTypeAnnotation: assertNullLiteralTypeAnnotation,
    assertClassImplements: assertClassImplements,
    assertDeclareClass: assertDeclareClass,
    assertDeclareFunction: assertDeclareFunction,
    assertDeclareInterface: assertDeclareInterface,
    assertDeclareModule: assertDeclareModule,
    assertDeclareModuleExports: assertDeclareModuleExports,
    assertDeclareTypeAlias: assertDeclareTypeAlias,
    assertDeclareOpaqueType: assertDeclareOpaqueType,
    assertDeclareVariable: assertDeclareVariable,
    assertDeclareExportDeclaration: assertDeclareExportDeclaration,
    assertDeclareExportAllDeclaration: assertDeclareExportAllDeclaration,
    assertDeclaredPredicate: assertDeclaredPredicate,
    assertExistsTypeAnnotation: assertExistsTypeAnnotation,
    assertFunctionTypeAnnotation: assertFunctionTypeAnnotation,
    assertFunctionTypeParam: assertFunctionTypeParam,
    assertGenericTypeAnnotation: assertGenericTypeAnnotation,
    assertInferredPredicate: assertInferredPredicate,
    assertInterfaceExtends: assertInterfaceExtends,
    assertInterfaceDeclaration: assertInterfaceDeclaration,
    assertInterfaceTypeAnnotation: assertInterfaceTypeAnnotation,
    assertIntersectionTypeAnnotation: assertIntersectionTypeAnnotation,
    assertMixedTypeAnnotation: assertMixedTypeAnnotation,
    assertEmptyTypeAnnotation: assertEmptyTypeAnnotation,
    assertNullableTypeAnnotation: assertNullableTypeAnnotation,
    assertNumberLiteralTypeAnnotation: assertNumberLiteralTypeAnnotation,
    assertNumberTypeAnnotation: assertNumberTypeAnnotation,
    assertObjectTypeAnnotation: assertObjectTypeAnnotation,
    assertObjectTypeInternalSlot: assertObjectTypeInternalSlot,
    assertObjectTypeCallProperty: assertObjectTypeCallProperty,
    assertObjectTypeIndexer: assertObjectTypeIndexer,
    assertObjectTypeProperty: assertObjectTypeProperty,
    assertObjectTypeSpreadProperty: assertObjectTypeSpreadProperty,
    assertOpaqueType: assertOpaqueType,
    assertQualifiedTypeIdentifier: assertQualifiedTypeIdentifier,
    assertStringLiteralTypeAnnotation: assertStringLiteralTypeAnnotation,
    assertStringTypeAnnotation: assertStringTypeAnnotation,
    assertSymbolTypeAnnotation: assertSymbolTypeAnnotation,
    assertThisTypeAnnotation: assertThisTypeAnnotation,
    assertTupleTypeAnnotation: assertTupleTypeAnnotation,
    assertTypeofTypeAnnotation: assertTypeofTypeAnnotation,
    assertTypeAlias: assertTypeAlias,
    assertTypeAnnotation: assertTypeAnnotation,
    assertTypeCastExpression: assertTypeCastExpression,
    assertTypeParameter: assertTypeParameter,
    assertTypeParameterDeclaration: assertTypeParameterDeclaration,
    assertTypeParameterInstantiation: assertTypeParameterInstantiation,
    assertUnionTypeAnnotation: assertUnionTypeAnnotation,
    assertVariance: assertVariance,
    assertVoidTypeAnnotation: assertVoidTypeAnnotation,
    assertEnumDeclaration: assertEnumDeclaration,
    assertEnumBooleanBody: assertEnumBooleanBody,
    assertEnumNumberBody: assertEnumNumberBody,
    assertEnumStringBody: assertEnumStringBody,
    assertEnumSymbolBody: assertEnumSymbolBody,
    assertEnumBooleanMember: assertEnumBooleanMember,
    assertEnumNumberMember: assertEnumNumberMember,
    assertEnumStringMember: assertEnumStringMember,
    assertEnumDefaultedMember: assertEnumDefaultedMember,
    assertIndexedAccessType: assertIndexedAccessType,
    assertOptionalIndexedAccessType: assertOptionalIndexedAccessType,
    assertJSXAttribute: assertJSXAttribute,
    assertJSXClosingElement: assertJSXClosingElement,
    assertJSXElement: assertJSXElement,
    assertJSXEmptyExpression: assertJSXEmptyExpression,
    assertJSXExpressionContainer: assertJSXExpressionContainer,
    assertJSXSpreadChild: assertJSXSpreadChild,
    assertJSXIdentifier: assertJSXIdentifier,
    assertJSXMemberExpression: assertJSXMemberExpression,
    assertJSXNamespacedName: assertJSXNamespacedName,
    assertJSXOpeningElement: assertJSXOpeningElement,
    assertJSXSpreadAttribute: assertJSXSpreadAttribute,
    assertJSXText: assertJSXText,
    assertJSXFragment: assertJSXFragment,
    assertJSXOpeningFragment: assertJSXOpeningFragment,
    assertJSXClosingFragment: assertJSXClosingFragment,
    assertNoop: assertNoop,
    assertPlaceholder: assertPlaceholder,
    assertV8IntrinsicIdentifier: assertV8IntrinsicIdentifier,
    assertArgumentPlaceholder: assertArgumentPlaceholder,
    assertBindExpression: assertBindExpression,
    assertClassProperty: assertClassProperty,
    assertPipelineTopicExpression: assertPipelineTopicExpression,
    assertPipelineBareFunction: assertPipelineBareFunction,
    assertPipelinePrimaryTopicReference: assertPipelinePrimaryTopicReference,
    assertClassPrivateProperty: assertClassPrivateProperty,
    assertClassPrivateMethod: assertClassPrivateMethod,
    assertImportAttribute: assertImportAttribute,
    assertDecorator: assertDecorator,
    assertDoExpression: assertDoExpression,
    assertExportDefaultSpecifier: assertExportDefaultSpecifier,
    assertPrivateName: assertPrivateName,
    assertRecordExpression: assertRecordExpression,
    assertTupleExpression: assertTupleExpression,
    assertDecimalLiteral: assertDecimalLiteral,
    assertStaticBlock: assertStaticBlock,
    assertModuleExpression: assertModuleExpression,
    assertTSParameterProperty: assertTSParameterProperty,
    assertTSDeclareFunction: assertTSDeclareFunction,
    assertTSDeclareMethod: assertTSDeclareMethod,
    assertTSQualifiedName: assertTSQualifiedName,
    assertTSCallSignatureDeclaration: assertTSCallSignatureDeclaration,
    assertTSConstructSignatureDeclaration: assertTSConstructSignatureDeclaration,
    assertTSPropertySignature: assertTSPropertySignature,
    assertTSMethodSignature: assertTSMethodSignature,
    assertTSIndexSignature: assertTSIndexSignature,
    assertTSAnyKeyword: assertTSAnyKeyword,
    assertTSBooleanKeyword: assertTSBooleanKeyword,
    assertTSBigIntKeyword: assertTSBigIntKeyword,
    assertTSIntrinsicKeyword: assertTSIntrinsicKeyword,
    assertTSNeverKeyword: assertTSNeverKeyword,
    assertTSNullKeyword: assertTSNullKeyword,
    assertTSNumberKeyword: assertTSNumberKeyword,
    assertTSObjectKeyword: assertTSObjectKeyword,
    assertTSStringKeyword: assertTSStringKeyword,
    assertTSSymbolKeyword: assertTSSymbolKeyword,
    assertTSUndefinedKeyword: assertTSUndefinedKeyword,
    assertTSUnknownKeyword: assertTSUnknownKeyword,
    assertTSVoidKeyword: assertTSVoidKeyword,
    assertTSThisType: assertTSThisType,
    assertTSFunctionType: assertTSFunctionType,
    assertTSConstructorType: assertTSConstructorType,
    assertTSTypeReference: assertTSTypeReference,
    assertTSTypePredicate: assertTSTypePredicate,
    assertTSTypeQuery: assertTSTypeQuery,
    assertTSTypeLiteral: assertTSTypeLiteral,
    assertTSArrayType: assertTSArrayType,
    assertTSTupleType: assertTSTupleType,
    assertTSOptionalType: assertTSOptionalType,
    assertTSRestType: assertTSRestType,
    assertTSNamedTupleMember: assertTSNamedTupleMember,
    assertTSUnionType: assertTSUnionType,
    assertTSIntersectionType: assertTSIntersectionType,
    assertTSConditionalType: assertTSConditionalType,
    assertTSInferType: assertTSInferType,
    assertTSParenthesizedType: assertTSParenthesizedType,
    assertTSTypeOperator: assertTSTypeOperator,
    assertTSIndexedAccessType: assertTSIndexedAccessType,
    assertTSMappedType: assertTSMappedType,
    assertTSLiteralType: assertTSLiteralType,
    assertTSExpressionWithTypeArguments: assertTSExpressionWithTypeArguments,
    assertTSInterfaceDeclaration: assertTSInterfaceDeclaration,
    assertTSInterfaceBody: assertTSInterfaceBody,
    assertTSTypeAliasDeclaration: assertTSTypeAliasDeclaration,
    assertTSAsExpression: assertTSAsExpression,
    assertTSTypeAssertion: assertTSTypeAssertion,
    assertTSEnumDeclaration: assertTSEnumDeclaration,
    assertTSEnumMember: assertTSEnumMember,
    assertTSModuleDeclaration: assertTSModuleDeclaration,
    assertTSModuleBlock: assertTSModuleBlock,
    assertTSImportType: assertTSImportType,
    assertTSImportEqualsDeclaration: assertTSImportEqualsDeclaration,
    assertTSExternalModuleReference: assertTSExternalModuleReference,
    assertTSNonNullExpression: assertTSNonNullExpression,
    assertTSExportAssignment: assertTSExportAssignment,
    assertTSNamespaceExportDeclaration: assertTSNamespaceExportDeclaration,
    assertTSTypeAnnotation: assertTSTypeAnnotation,
    assertTSTypeParameterInstantiation: assertTSTypeParameterInstantiation,
    assertTSTypeParameterDeclaration: assertTSTypeParameterDeclaration,
    assertTSTypeParameter: assertTSTypeParameter,
    assertExpression: assertExpression,
    assertBinary: assertBinary,
    assertScopable: assertScopable,
    assertBlockParent: assertBlockParent,
    assertBlock: assertBlock,
    assertStatement: assertStatement,
    assertTerminatorless: assertTerminatorless,
    assertCompletionStatement: assertCompletionStatement,
    assertConditional: assertConditional,
    assertLoop: assertLoop,
    assertWhile: assertWhile,
    assertExpressionWrapper: assertExpressionWrapper,
    assertFor: assertFor,
    assertForXStatement: assertForXStatement,
    assertFunction: assertFunction$1,
    assertFunctionParent: assertFunctionParent,
    assertPureish: assertPureish,
    assertDeclaration: assertDeclaration,
    assertPatternLike: assertPatternLike,
    assertLVal: assertLVal,
    assertTSEntityName: assertTSEntityName,
    assertLiteral: assertLiteral,
    assertImmutable: assertImmutable,
    assertUserWhitespacable: assertUserWhitespacable,
    assertMethod: assertMethod,
    assertObjectMember: assertObjectMember,
    assertProperty: assertProperty,
    assertUnaryLike: assertUnaryLike,
    assertPattern: assertPattern,
    assertClass: assertClass,
    assertModuleDeclaration: assertModuleDeclaration,
    assertExportDeclaration: assertExportDeclaration,
    assertModuleSpecifier: assertModuleSpecifier,
    assertFlow: assertFlow,
    assertFlowType: assertFlowType,
    assertFlowBaseAnnotation: assertFlowBaseAnnotation,
    assertFlowDeclaration: assertFlowDeclaration,
    assertFlowPredicate: assertFlowPredicate,
    assertEnumBody: assertEnumBody,
    assertEnumMember: assertEnumMember,
    assertJSX: assertJSX,
    assertPrivate: assertPrivate,
    assertTSTypeElement: assertTSTypeElement,
    assertTSType: assertTSType,
    assertTSBaseType: assertTSBaseType,
    assertNumberLiteral: assertNumberLiteral,
    assertRegexLiteral: assertRegexLiteral,
    assertRestProperty: assertRestProperty,
    assertSpreadProperty: assertSpreadProperty,
    arrayExpression: arrayExpression,
    assignmentExpression: assignmentExpression,
    binaryExpression: binaryExpression,
    interpreterDirective: interpreterDirective,
    directive: directive,
    directiveLiteral: directiveLiteral,
    blockStatement: blockStatement,
    breakStatement: breakStatement,
    callExpression: callExpression,
    catchClause: catchClause,
    conditionalExpression: conditionalExpression,
    continueStatement: continueStatement,
    debuggerStatement: debuggerStatement,
    doWhileStatement: doWhileStatement,
    emptyStatement: emptyStatement,
    expressionStatement: expressionStatement,
    file: file,
    forInStatement: forInStatement,
    forStatement: forStatement,
    functionDeclaration: functionDeclaration,
    functionExpression: functionExpression,
    identifier: identifier,
    ifStatement: ifStatement,
    labeledStatement: labeledStatement,
    stringLiteral: stringLiteral,
    numericLiteral: numericLiteral,
    nullLiteral: nullLiteral,
    booleanLiteral: booleanLiteral,
    regExpLiteral: regExpLiteral,
    logicalExpression: logicalExpression,
    memberExpression: memberExpression,
    newExpression: newExpression,
    program: program$2,
    objectExpression: objectExpression,
    objectMethod: objectMethod,
    objectProperty: objectProperty,
    restElement: restElement,
    returnStatement: returnStatement,
    sequenceExpression: sequenceExpression,
    parenthesizedExpression: parenthesizedExpression,
    switchCase: switchCase,
    switchStatement: switchStatement,
    thisExpression: thisExpression,
    throwStatement: throwStatement,
    tryStatement: tryStatement,
    unaryExpression: unaryExpression,
    updateExpression: updateExpression,
    variableDeclaration: variableDeclaration,
    variableDeclarator: variableDeclarator,
    whileStatement: whileStatement,
    withStatement: withStatement,
    assignmentPattern: assignmentPattern,
    arrayPattern: arrayPattern,
    arrowFunctionExpression: arrowFunctionExpression,
    classBody: classBody,
    classExpression: classExpression,
    classDeclaration: classDeclaration,
    exportAllDeclaration: exportAllDeclaration,
    exportDefaultDeclaration: exportDefaultDeclaration,
    exportNamedDeclaration: exportNamedDeclaration,
    exportSpecifier: exportSpecifier,
    forOfStatement: forOfStatement,
    importDeclaration: importDeclaration,
    importDefaultSpecifier: importDefaultSpecifier,
    importNamespaceSpecifier: importNamespaceSpecifier,
    importSpecifier: importSpecifier,
    metaProperty: metaProperty,
    classMethod: classMethod,
    objectPattern: objectPattern,
    spreadElement: spreadElement,
    'super': _super,
    taggedTemplateExpression: taggedTemplateExpression,
    templateElement: templateElement,
    templateLiteral: templateLiteral,
    yieldExpression: yieldExpression,
    awaitExpression: awaitExpression,
    'import': _import,
    bigIntLiteral: bigIntLiteral,
    exportNamespaceSpecifier: exportNamespaceSpecifier,
    optionalMemberExpression: optionalMemberExpression,
    optionalCallExpression: optionalCallExpression,
    anyTypeAnnotation: anyTypeAnnotation,
    arrayTypeAnnotation: arrayTypeAnnotation,
    booleanTypeAnnotation: booleanTypeAnnotation,
    booleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    nullLiteralTypeAnnotation: nullLiteralTypeAnnotation,
    classImplements: classImplements,
    declareClass: declareClass,
    declareFunction: declareFunction,
    declareInterface: declareInterface,
    declareModule: declareModule,
    declareModuleExports: declareModuleExports,
    declareTypeAlias: declareTypeAlias,
    declareOpaqueType: declareOpaqueType,
    declareVariable: declareVariable,
    declareExportDeclaration: declareExportDeclaration,
    declareExportAllDeclaration: declareExportAllDeclaration,
    declaredPredicate: declaredPredicate,
    existsTypeAnnotation: existsTypeAnnotation,
    functionTypeAnnotation: functionTypeAnnotation,
    functionTypeParam: functionTypeParam,
    genericTypeAnnotation: genericTypeAnnotation,
    inferredPredicate: inferredPredicate,
    interfaceExtends: interfaceExtends,
    interfaceDeclaration: interfaceDeclaration,
    interfaceTypeAnnotation: interfaceTypeAnnotation,
    intersectionTypeAnnotation: intersectionTypeAnnotation,
    mixedTypeAnnotation: mixedTypeAnnotation,
    emptyTypeAnnotation: emptyTypeAnnotation,
    nullableTypeAnnotation: nullableTypeAnnotation,
    numberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    numberTypeAnnotation: numberTypeAnnotation,
    objectTypeAnnotation: objectTypeAnnotation,
    objectTypeInternalSlot: objectTypeInternalSlot,
    objectTypeCallProperty: objectTypeCallProperty,
    objectTypeIndexer: objectTypeIndexer,
    objectTypeProperty: objectTypeProperty,
    objectTypeSpreadProperty: objectTypeSpreadProperty,
    opaqueType: opaqueType,
    qualifiedTypeIdentifier: qualifiedTypeIdentifier,
    stringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    stringTypeAnnotation: stringTypeAnnotation,
    symbolTypeAnnotation: symbolTypeAnnotation,
    thisTypeAnnotation: thisTypeAnnotation,
    tupleTypeAnnotation: tupleTypeAnnotation,
    typeofTypeAnnotation: typeofTypeAnnotation,
    typeAlias: typeAlias,
    typeAnnotation: typeAnnotation,
    typeCastExpression: typeCastExpression,
    typeParameter: typeParameter,
    typeParameterDeclaration: typeParameterDeclaration,
    typeParameterInstantiation: typeParameterInstantiation,
    unionTypeAnnotation: unionTypeAnnotation,
    variance: variance,
    voidTypeAnnotation: voidTypeAnnotation,
    enumDeclaration: enumDeclaration,
    enumBooleanBody: enumBooleanBody,
    enumNumberBody: enumNumberBody,
    enumStringBody: enumStringBody,
    enumSymbolBody: enumSymbolBody,
    enumBooleanMember: enumBooleanMember,
    enumNumberMember: enumNumberMember,
    enumStringMember: enumStringMember,
    enumDefaultedMember: enumDefaultedMember,
    indexedAccessType: indexedAccessType,
    optionalIndexedAccessType: optionalIndexedAccessType,
    jsxAttribute: jsxAttribute,
    jSXAttribute: jsxAttribute,
    jsxClosingElement: jsxClosingElement,
    jSXClosingElement: jsxClosingElement,
    jsxElement: jsxElement,
    jSXElement: jsxElement,
    jsxEmptyExpression: jsxEmptyExpression,
    jSXEmptyExpression: jsxEmptyExpression,
    jsxExpressionContainer: jsxExpressionContainer,
    jSXExpressionContainer: jsxExpressionContainer,
    jsxSpreadChild: jsxSpreadChild,
    jSXSpreadChild: jsxSpreadChild,
    jsxIdentifier: jsxIdentifier,
    jSXIdentifier: jsxIdentifier,
    jsxMemberExpression: jsxMemberExpression,
    jSXMemberExpression: jsxMemberExpression,
    jsxNamespacedName: jsxNamespacedName,
    jSXNamespacedName: jsxNamespacedName,
    jsxOpeningElement: jsxOpeningElement,
    jSXOpeningElement: jsxOpeningElement,
    jsxSpreadAttribute: jsxSpreadAttribute,
    jSXSpreadAttribute: jsxSpreadAttribute,
    jsxText: jsxText,
    jSXText: jsxText,
    jsxFragment: jsxFragment,
    jSXFragment: jsxFragment,
    jsxOpeningFragment: jsxOpeningFragment,
    jSXOpeningFragment: jsxOpeningFragment,
    jsxClosingFragment: jsxClosingFragment,
    jSXClosingFragment: jsxClosingFragment,
    noop: noop$1,
    placeholder: placeholder,
    v8IntrinsicIdentifier: v8IntrinsicIdentifier,
    argumentPlaceholder: argumentPlaceholder,
    bindExpression: bindExpression,
    classProperty: classProperty,
    pipelineTopicExpression: pipelineTopicExpression,
    pipelineBareFunction: pipelineBareFunction,
    pipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    classPrivateProperty: classPrivateProperty,
    classPrivateMethod: classPrivateMethod,
    importAttribute: importAttribute,
    decorator: decorator,
    doExpression: doExpression,
    exportDefaultSpecifier: exportDefaultSpecifier,
    privateName: privateName,
    recordExpression: recordExpression,
    tupleExpression: tupleExpression,
    decimalLiteral: decimalLiteral,
    staticBlock: staticBlock,
    moduleExpression: moduleExpression,
    tsParameterProperty: tsParameterProperty,
    tSParameterProperty: tsParameterProperty,
    tsDeclareFunction: tsDeclareFunction,
    tSDeclareFunction: tsDeclareFunction,
    tsDeclareMethod: tsDeclareMethod,
    tSDeclareMethod: tsDeclareMethod,
    tsQualifiedName: tsQualifiedName,
    tSQualifiedName: tsQualifiedName,
    tsCallSignatureDeclaration: tsCallSignatureDeclaration,
    tSCallSignatureDeclaration: tsCallSignatureDeclaration,
    tsConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    tsPropertySignature: tsPropertySignature,
    tSPropertySignature: tsPropertySignature,
    tsMethodSignature: tsMethodSignature,
    tSMethodSignature: tsMethodSignature,
    tsIndexSignature: tsIndexSignature,
    tSIndexSignature: tsIndexSignature,
    tsAnyKeyword: tsAnyKeyword,
    tSAnyKeyword: tsAnyKeyword,
    tsBooleanKeyword: tsBooleanKeyword,
    tSBooleanKeyword: tsBooleanKeyword,
    tsBigIntKeyword: tsBigIntKeyword,
    tSBigIntKeyword: tsBigIntKeyword,
    tsIntrinsicKeyword: tsIntrinsicKeyword,
    tSIntrinsicKeyword: tsIntrinsicKeyword,
    tsNeverKeyword: tsNeverKeyword,
    tSNeverKeyword: tsNeverKeyword,
    tsNullKeyword: tsNullKeyword,
    tSNullKeyword: tsNullKeyword,
    tsNumberKeyword: tsNumberKeyword,
    tSNumberKeyword: tsNumberKeyword,
    tsObjectKeyword: tsObjectKeyword,
    tSObjectKeyword: tsObjectKeyword,
    tsStringKeyword: tsStringKeyword,
    tSStringKeyword: tsStringKeyword,
    tsSymbolKeyword: tsSymbolKeyword,
    tSSymbolKeyword: tsSymbolKeyword,
    tsUndefinedKeyword: tsUndefinedKeyword,
    tSUndefinedKeyword: tsUndefinedKeyword,
    tsUnknownKeyword: tsUnknownKeyword,
    tSUnknownKeyword: tsUnknownKeyword,
    tsVoidKeyword: tsVoidKeyword,
    tSVoidKeyword: tsVoidKeyword,
    tsThisType: tsThisType,
    tSThisType: tsThisType,
    tsFunctionType: tsFunctionType,
    tSFunctionType: tsFunctionType,
    tsConstructorType: tsConstructorType,
    tSConstructorType: tsConstructorType,
    tsTypeReference: tsTypeReference,
    tSTypeReference: tsTypeReference,
    tsTypePredicate: tsTypePredicate,
    tSTypePredicate: tsTypePredicate,
    tsTypeQuery: tsTypeQuery,
    tSTypeQuery: tsTypeQuery,
    tsTypeLiteral: tsTypeLiteral,
    tSTypeLiteral: tsTypeLiteral,
    tsArrayType: tsArrayType,
    tSArrayType: tsArrayType,
    tsTupleType: tsTupleType,
    tSTupleType: tsTupleType,
    tsOptionalType: tsOptionalType,
    tSOptionalType: tsOptionalType,
    tsRestType: tsRestType,
    tSRestType: tsRestType,
    tsNamedTupleMember: tsNamedTupleMember,
    tSNamedTupleMember: tsNamedTupleMember,
    tsUnionType: tsUnionType,
    tSUnionType: tsUnionType,
    tsIntersectionType: tsIntersectionType,
    tSIntersectionType: tsIntersectionType,
    tsConditionalType: tsConditionalType,
    tSConditionalType: tsConditionalType,
    tsInferType: tsInferType,
    tSInferType: tsInferType,
    tsParenthesizedType: tsParenthesizedType,
    tSParenthesizedType: tsParenthesizedType,
    tsTypeOperator: tsTypeOperator,
    tSTypeOperator: tsTypeOperator,
    tsIndexedAccessType: tsIndexedAccessType,
    tSIndexedAccessType: tsIndexedAccessType,
    tsMappedType: tsMappedType,
    tSMappedType: tsMappedType,
    tsLiteralType: tsLiteralType,
    tSLiteralType: tsLiteralType,
    tsExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    tsInterfaceDeclaration: tsInterfaceDeclaration,
    tSInterfaceDeclaration: tsInterfaceDeclaration,
    tsInterfaceBody: tsInterfaceBody,
    tSInterfaceBody: tsInterfaceBody,
    tsTypeAliasDeclaration: tsTypeAliasDeclaration,
    tSTypeAliasDeclaration: tsTypeAliasDeclaration,
    tsAsExpression: tsAsExpression,
    tSAsExpression: tsAsExpression,
    tsTypeAssertion: tsTypeAssertion,
    tSTypeAssertion: tsTypeAssertion,
    tsEnumDeclaration: tsEnumDeclaration,
    tSEnumDeclaration: tsEnumDeclaration,
    tsEnumMember: tsEnumMember,
    tSEnumMember: tsEnumMember,
    tsModuleDeclaration: tsModuleDeclaration,
    tSModuleDeclaration: tsModuleDeclaration,
    tsModuleBlock: tsModuleBlock,
    tSModuleBlock: tsModuleBlock,
    tsImportType: tsImportType,
    tSImportType: tsImportType,
    tsImportEqualsDeclaration: tsImportEqualsDeclaration,
    tSImportEqualsDeclaration: tsImportEqualsDeclaration,
    tsExternalModuleReference: tsExternalModuleReference,
    tSExternalModuleReference: tsExternalModuleReference,
    tsNonNullExpression: tsNonNullExpression,
    tSNonNullExpression: tsNonNullExpression,
    tsExportAssignment: tsExportAssignment,
    tSExportAssignment: tsExportAssignment,
    tsNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    tsTypeAnnotation: tsTypeAnnotation,
    tSTypeAnnotation: tsTypeAnnotation,
    tsTypeParameterInstantiation: tsTypeParameterInstantiation,
    tSTypeParameterInstantiation: tsTypeParameterInstantiation,
    tsTypeParameterDeclaration: tsTypeParameterDeclaration,
    tSTypeParameterDeclaration: tsTypeParameterDeclaration,
    tsTypeParameter: tsTypeParameter,
    tSTypeParameter: tsTypeParameter,
    numberLiteral: NumberLiteral,
    regexLiteral: RegexLiteral,
    restProperty: RestProperty$1,
    spreadProperty: SpreadProperty$1,
    ArrayExpression: arrayExpression,
    AssignmentExpression: assignmentExpression,
    BinaryExpression: binaryExpression,
    InterpreterDirective: interpreterDirective,
    Directive: directive,
    DirectiveLiteral: directiveLiteral,
    BlockStatement: blockStatement,
    BreakStatement: breakStatement,
    CallExpression: callExpression,
    CatchClause: catchClause,
    ConditionalExpression: conditionalExpression,
    ContinueStatement: continueStatement,
    DebuggerStatement: debuggerStatement,
    DoWhileStatement: doWhileStatement,
    EmptyStatement: emptyStatement,
    ExpressionStatement: expressionStatement,
    File: file,
    ForInStatement: forInStatement,
    ForStatement: forStatement,
    FunctionDeclaration: functionDeclaration,
    FunctionExpression: functionExpression,
    Identifier: identifier,
    IfStatement: ifStatement,
    LabeledStatement: labeledStatement,
    StringLiteral: stringLiteral,
    NumericLiteral: numericLiteral,
    NullLiteral: nullLiteral,
    BooleanLiteral: booleanLiteral,
    RegExpLiteral: regExpLiteral,
    LogicalExpression: logicalExpression,
    MemberExpression: memberExpression,
    NewExpression: newExpression,
    Program: program$2,
    ObjectExpression: objectExpression,
    ObjectMethod: objectMethod,
    ObjectProperty: objectProperty,
    RestElement: restElement,
    ReturnStatement: returnStatement,
    SequenceExpression: sequenceExpression,
    ParenthesizedExpression: parenthesizedExpression,
    SwitchCase: switchCase,
    SwitchStatement: switchStatement,
    ThisExpression: thisExpression,
    ThrowStatement: throwStatement,
    TryStatement: tryStatement,
    UnaryExpression: unaryExpression,
    UpdateExpression: updateExpression,
    VariableDeclaration: variableDeclaration,
    VariableDeclarator: variableDeclarator,
    WhileStatement: whileStatement,
    WithStatement: withStatement,
    AssignmentPattern: assignmentPattern,
    ArrayPattern: arrayPattern,
    ArrowFunctionExpression: arrowFunctionExpression,
    ClassBody: classBody,
    ClassExpression: classExpression,
    ClassDeclaration: classDeclaration,
    ExportAllDeclaration: exportAllDeclaration,
    ExportDefaultDeclaration: exportDefaultDeclaration,
    ExportNamedDeclaration: exportNamedDeclaration,
    ExportSpecifier: exportSpecifier,
    ForOfStatement: forOfStatement,
    ImportDeclaration: importDeclaration,
    ImportDefaultSpecifier: importDefaultSpecifier,
    ImportNamespaceSpecifier: importNamespaceSpecifier,
    ImportSpecifier: importSpecifier,
    MetaProperty: metaProperty,
    ClassMethod: classMethod,
    ObjectPattern: objectPattern,
    SpreadElement: spreadElement,
    Super: _super,
    TaggedTemplateExpression: taggedTemplateExpression,
    TemplateElement: templateElement,
    TemplateLiteral: templateLiteral,
    YieldExpression: yieldExpression,
    AwaitExpression: awaitExpression,
    Import: _import,
    BigIntLiteral: bigIntLiteral,
    ExportNamespaceSpecifier: exportNamespaceSpecifier,
    OptionalMemberExpression: optionalMemberExpression,
    OptionalCallExpression: optionalCallExpression,
    AnyTypeAnnotation: anyTypeAnnotation,
    ArrayTypeAnnotation: arrayTypeAnnotation,
    BooleanTypeAnnotation: booleanTypeAnnotation,
    BooleanLiteralTypeAnnotation: booleanLiteralTypeAnnotation,
    NullLiteralTypeAnnotation: nullLiteralTypeAnnotation,
    ClassImplements: classImplements,
    DeclareClass: declareClass,
    DeclareFunction: declareFunction,
    DeclareInterface: declareInterface,
    DeclareModule: declareModule,
    DeclareModuleExports: declareModuleExports,
    DeclareTypeAlias: declareTypeAlias,
    DeclareOpaqueType: declareOpaqueType,
    DeclareVariable: declareVariable,
    DeclareExportDeclaration: declareExportDeclaration,
    DeclareExportAllDeclaration: declareExportAllDeclaration,
    DeclaredPredicate: declaredPredicate,
    ExistsTypeAnnotation: existsTypeAnnotation,
    FunctionTypeAnnotation: functionTypeAnnotation,
    FunctionTypeParam: functionTypeParam,
    GenericTypeAnnotation: genericTypeAnnotation,
    InferredPredicate: inferredPredicate,
    InterfaceExtends: interfaceExtends,
    InterfaceDeclaration: interfaceDeclaration,
    InterfaceTypeAnnotation: interfaceTypeAnnotation,
    IntersectionTypeAnnotation: intersectionTypeAnnotation,
    MixedTypeAnnotation: mixedTypeAnnotation,
    EmptyTypeAnnotation: emptyTypeAnnotation,
    NullableTypeAnnotation: nullableTypeAnnotation,
    NumberLiteralTypeAnnotation: numberLiteralTypeAnnotation,
    NumberTypeAnnotation: numberTypeAnnotation,
    ObjectTypeAnnotation: objectTypeAnnotation,
    ObjectTypeInternalSlot: objectTypeInternalSlot,
    ObjectTypeCallProperty: objectTypeCallProperty,
    ObjectTypeIndexer: objectTypeIndexer,
    ObjectTypeProperty: objectTypeProperty,
    ObjectTypeSpreadProperty: objectTypeSpreadProperty,
    OpaqueType: opaqueType,
    QualifiedTypeIdentifier: qualifiedTypeIdentifier,
    StringLiteralTypeAnnotation: stringLiteralTypeAnnotation,
    StringTypeAnnotation: stringTypeAnnotation,
    SymbolTypeAnnotation: symbolTypeAnnotation,
    ThisTypeAnnotation: thisTypeAnnotation,
    TupleTypeAnnotation: tupleTypeAnnotation,
    TypeofTypeAnnotation: typeofTypeAnnotation,
    TypeAlias: typeAlias,
    TypeAnnotation: typeAnnotation,
    TypeCastExpression: typeCastExpression,
    TypeParameter: typeParameter,
    TypeParameterDeclaration: typeParameterDeclaration,
    TypeParameterInstantiation: typeParameterInstantiation,
    UnionTypeAnnotation: unionTypeAnnotation,
    Variance: variance,
    VoidTypeAnnotation: voidTypeAnnotation,
    EnumDeclaration: enumDeclaration,
    EnumBooleanBody: enumBooleanBody,
    EnumNumberBody: enumNumberBody,
    EnumStringBody: enumStringBody,
    EnumSymbolBody: enumSymbolBody,
    EnumBooleanMember: enumBooleanMember,
    EnumNumberMember: enumNumberMember,
    EnumStringMember: enumStringMember,
    EnumDefaultedMember: enumDefaultedMember,
    IndexedAccessType: indexedAccessType,
    OptionalIndexedAccessType: optionalIndexedAccessType,
    JSXAttribute: jsxAttribute,
    JSXClosingElement: jsxClosingElement,
    JSXElement: jsxElement,
    JSXEmptyExpression: jsxEmptyExpression,
    JSXExpressionContainer: jsxExpressionContainer,
    JSXSpreadChild: jsxSpreadChild,
    JSXIdentifier: jsxIdentifier,
    JSXMemberExpression: jsxMemberExpression,
    JSXNamespacedName: jsxNamespacedName,
    JSXOpeningElement: jsxOpeningElement,
    JSXSpreadAttribute: jsxSpreadAttribute,
    JSXText: jsxText,
    JSXFragment: jsxFragment,
    JSXOpeningFragment: jsxOpeningFragment,
    JSXClosingFragment: jsxClosingFragment,
    Noop: noop$1,
    Placeholder: placeholder,
    V8IntrinsicIdentifier: v8IntrinsicIdentifier,
    ArgumentPlaceholder: argumentPlaceholder,
    BindExpression: bindExpression,
    ClassProperty: classProperty,
    PipelineTopicExpression: pipelineTopicExpression,
    PipelineBareFunction: pipelineBareFunction,
    PipelinePrimaryTopicReference: pipelinePrimaryTopicReference,
    ClassPrivateProperty: classPrivateProperty,
    ClassPrivateMethod: classPrivateMethod,
    ImportAttribute: importAttribute,
    Decorator: decorator,
    DoExpression: doExpression,
    ExportDefaultSpecifier: exportDefaultSpecifier,
    PrivateName: privateName,
    RecordExpression: recordExpression,
    TupleExpression: tupleExpression,
    DecimalLiteral: decimalLiteral,
    StaticBlock: staticBlock,
    ModuleExpression: moduleExpression,
    TSParameterProperty: tsParameterProperty,
    TSDeclareFunction: tsDeclareFunction,
    TSDeclareMethod: tsDeclareMethod,
    TSQualifiedName: tsQualifiedName,
    TSCallSignatureDeclaration: tsCallSignatureDeclaration,
    TSConstructSignatureDeclaration: tsConstructSignatureDeclaration,
    TSPropertySignature: tsPropertySignature,
    TSMethodSignature: tsMethodSignature,
    TSIndexSignature: tsIndexSignature,
    TSAnyKeyword: tsAnyKeyword,
    TSBooleanKeyword: tsBooleanKeyword,
    TSBigIntKeyword: tsBigIntKeyword,
    TSIntrinsicKeyword: tsIntrinsicKeyword,
    TSNeverKeyword: tsNeverKeyword,
    TSNullKeyword: tsNullKeyword,
    TSNumberKeyword: tsNumberKeyword,
    TSObjectKeyword: tsObjectKeyword,
    TSStringKeyword: tsStringKeyword,
    TSSymbolKeyword: tsSymbolKeyword,
    TSUndefinedKeyword: tsUndefinedKeyword,
    TSUnknownKeyword: tsUnknownKeyword,
    TSVoidKeyword: tsVoidKeyword,
    TSThisType: tsThisType,
    TSFunctionType: tsFunctionType,
    TSConstructorType: tsConstructorType,
    TSTypeReference: tsTypeReference,
    TSTypePredicate: tsTypePredicate,
    TSTypeQuery: tsTypeQuery,
    TSTypeLiteral: tsTypeLiteral,
    TSArrayType: tsArrayType,
    TSTupleType: tsTupleType,
    TSOptionalType: tsOptionalType,
    TSRestType: tsRestType,
    TSNamedTupleMember: tsNamedTupleMember,
    TSUnionType: tsUnionType,
    TSIntersectionType: tsIntersectionType,
    TSConditionalType: tsConditionalType,
    TSInferType: tsInferType,
    TSParenthesizedType: tsParenthesizedType,
    TSTypeOperator: tsTypeOperator,
    TSIndexedAccessType: tsIndexedAccessType,
    TSMappedType: tsMappedType,
    TSLiteralType: tsLiteralType,
    TSExpressionWithTypeArguments: tsExpressionWithTypeArguments,
    TSInterfaceDeclaration: tsInterfaceDeclaration,
    TSInterfaceBody: tsInterfaceBody,
    TSTypeAliasDeclaration: tsTypeAliasDeclaration,
    TSAsExpression: tsAsExpression,
    TSTypeAssertion: tsTypeAssertion,
    TSEnumDeclaration: tsEnumDeclaration,
    TSEnumMember: tsEnumMember,
    TSModuleDeclaration: tsModuleDeclaration,
    TSModuleBlock: tsModuleBlock,
    TSImportType: tsImportType,
    TSImportEqualsDeclaration: tsImportEqualsDeclaration,
    TSExternalModuleReference: tsExternalModuleReference,
    TSNonNullExpression: tsNonNullExpression,
    TSExportAssignment: tsExportAssignment,
    TSNamespaceExportDeclaration: tsNamespaceExportDeclaration,
    TSTypeAnnotation: tsTypeAnnotation,
    TSTypeParameterInstantiation: tsTypeParameterInstantiation,
    TSTypeParameterDeclaration: tsTypeParameterDeclaration,
    TSTypeParameter: tsTypeParameter,
    NumberLiteral: NumberLiteral,
    RegexLiteral: RegexLiteral,
    RestProperty: RestProperty$1,
    SpreadProperty: SpreadProperty$1,
    EXPRESSION_TYPES: EXPRESSION_TYPES,
    BINARY_TYPES: BINARY_TYPES,
    SCOPABLE_TYPES: SCOPABLE_TYPES,
    BLOCKPARENT_TYPES: BLOCKPARENT_TYPES,
    BLOCK_TYPES: BLOCK_TYPES,
    STATEMENT_TYPES: STATEMENT_TYPES,
    TERMINATORLESS_TYPES: TERMINATORLESS_TYPES,
    COMPLETIONSTATEMENT_TYPES: COMPLETIONSTATEMENT_TYPES,
    CONDITIONAL_TYPES: CONDITIONAL_TYPES,
    LOOP_TYPES: LOOP_TYPES,
    WHILE_TYPES: WHILE_TYPES,
    EXPRESSIONWRAPPER_TYPES: EXPRESSIONWRAPPER_TYPES,
    FOR_TYPES: FOR_TYPES,
    FORXSTATEMENT_TYPES: FORXSTATEMENT_TYPES,
    FUNCTION_TYPES: FUNCTION_TYPES,
    FUNCTIONPARENT_TYPES: FUNCTIONPARENT_TYPES,
    PUREISH_TYPES: PUREISH_TYPES,
    DECLARATION_TYPES: DECLARATION_TYPES,
    PATTERNLIKE_TYPES: PATTERNLIKE_TYPES,
    LVAL_TYPES: LVAL_TYPES,
    TSENTITYNAME_TYPES: TSENTITYNAME_TYPES,
    LITERAL_TYPES: LITERAL_TYPES,
    IMMUTABLE_TYPES: IMMUTABLE_TYPES,
    USERWHITESPACABLE_TYPES: USERWHITESPACABLE_TYPES,
    METHOD_TYPES: METHOD_TYPES,
    OBJECTMEMBER_TYPES: OBJECTMEMBER_TYPES,
    PROPERTY_TYPES: PROPERTY_TYPES,
    UNARYLIKE_TYPES: UNARYLIKE_TYPES,
    PATTERN_TYPES: PATTERN_TYPES,
    CLASS_TYPES: CLASS_TYPES,
    MODULEDECLARATION_TYPES: MODULEDECLARATION_TYPES,
    EXPORTDECLARATION_TYPES: EXPORTDECLARATION_TYPES,
    MODULESPECIFIER_TYPES: MODULESPECIFIER_TYPES,
    FLOW_TYPES: FLOW_TYPES,
    FLOWTYPE_TYPES: FLOWTYPE_TYPES,
    FLOWBASEANNOTATION_TYPES: FLOWBASEANNOTATION_TYPES,
    FLOWDECLARATION_TYPES: FLOWDECLARATION_TYPES,
    FLOWPREDICATE_TYPES: FLOWPREDICATE_TYPES,
    ENUMBODY_TYPES: ENUMBODY_TYPES,
    ENUMMEMBER_TYPES: ENUMMEMBER_TYPES,
    JSX_TYPES: JSX_TYPES,
    PRIVATE_TYPES: PRIVATE_TYPES,
    TSTYPEELEMENT_TYPES: TSTYPEELEMENT_TYPES,
    TSTYPE_TYPES: TSTYPE_TYPES,
    TSBASETYPE_TYPES: TSBASETYPE_TYPES,
    STATEMENT_OR_BLOCK_KEYS: STATEMENT_OR_BLOCK_KEYS,
    FLATTENABLE_KEYS: FLATTENABLE_KEYS,
    FOR_INIT_KEYS: FOR_INIT_KEYS,
    COMMENT_KEYS: COMMENT_KEYS,
    LOGICAL_OPERATORS: LOGICAL_OPERATORS,
    UPDATE_OPERATORS: UPDATE_OPERATORS,
    BOOLEAN_NUMBER_BINARY_OPERATORS: BOOLEAN_NUMBER_BINARY_OPERATORS,
    EQUALITY_BINARY_OPERATORS: EQUALITY_BINARY_OPERATORS,
    COMPARISON_BINARY_OPERATORS: COMPARISON_BINARY_OPERATORS,
    BOOLEAN_BINARY_OPERATORS: BOOLEAN_BINARY_OPERATORS,
    NUMBER_BINARY_OPERATORS: NUMBER_BINARY_OPERATORS,
    BINARY_OPERATORS: BINARY_OPERATORS,
    ASSIGNMENT_OPERATORS: ASSIGNMENT_OPERATORS,
    BOOLEAN_UNARY_OPERATORS: BOOLEAN_UNARY_OPERATORS,
    NUMBER_UNARY_OPERATORS: NUMBER_UNARY_OPERATORS,
    STRING_UNARY_OPERATORS: STRING_UNARY_OPERATORS,
    UNARY_OPERATORS: UNARY_OPERATORS,
    INHERIT_KEYS: INHERIT_KEYS,
    BLOCK_SCOPED_SYMBOL: BLOCK_SCOPED_SYMBOL,
    NOT_LOCAL_BINDING: NOT_LOCAL_BINDING,
    VISITOR_KEYS: VISITOR_KEYS,
    ALIAS_KEYS: ALIAS_KEYS,
    FLIPPED_ALIAS_KEYS: FLIPPED_ALIAS_KEYS,
    NODE_FIELDS: NODE_FIELDS,
    BUILDER_KEYS: BUILDER_KEYS,
    DEPRECATED_KEYS: DEPRECATED_KEYS,
    NODE_PARENT_VALIDATIONS: NODE_PARENT_VALIDATIONS,
    PLACEHOLDERS: PLACEHOLDERS,
    PLACEHOLDERS_ALIAS: PLACEHOLDERS_ALIAS,
    PLACEHOLDERS_FLIPPED_ALIAS: PLACEHOLDERS_FLIPPED_ALIAS,
    TYPES: TYPES,
    isArrayExpression: isArrayExpression,
    isAssignmentExpression: isAssignmentExpression,
    isBinaryExpression: isBinaryExpression,
    isInterpreterDirective: isInterpreterDirective,
    isDirective: isDirective,
    isDirectiveLiteral: isDirectiveLiteral,
    isBlockStatement: isBlockStatement,
    isBreakStatement: isBreakStatement,
    isCallExpression: isCallExpression,
    isCatchClause: isCatchClause,
    isConditionalExpression: isConditionalExpression,
    isContinueStatement: isContinueStatement,
    isDebuggerStatement: isDebuggerStatement,
    isDoWhileStatement: isDoWhileStatement,
    isEmptyStatement: isEmptyStatement,
    isExpressionStatement: isExpressionStatement,
    isFile: isFile,
    isForInStatement: isForInStatement,
    isForStatement: isForStatement,
    isFunctionDeclaration: isFunctionDeclaration,
    isFunctionExpression: isFunctionExpression,
    isIdentifier: isIdentifier,
    isIfStatement: isIfStatement,
    isLabeledStatement: isLabeledStatement,
    isStringLiteral: isStringLiteral,
    isNumericLiteral: isNumericLiteral,
    isNullLiteral: isNullLiteral,
    isBooleanLiteral: isBooleanLiteral,
    isRegExpLiteral: isRegExpLiteral,
    isLogicalExpression: isLogicalExpression,
    isMemberExpression: isMemberExpression,
    isNewExpression: isNewExpression,
    isProgram: isProgram,
    isObjectExpression: isObjectExpression,
    isObjectMethod: isObjectMethod,
    isObjectProperty: isObjectProperty,
    isRestElement: isRestElement,
    isReturnStatement: isReturnStatement,
    isSequenceExpression: isSequenceExpression,
    isParenthesizedExpression: isParenthesizedExpression,
    isSwitchCase: isSwitchCase,
    isSwitchStatement: isSwitchStatement,
    isThisExpression: isThisExpression,
    isThrowStatement: isThrowStatement,
    isTryStatement: isTryStatement,
    isUnaryExpression: isUnaryExpression,
    isUpdateExpression: isUpdateExpression,
    isVariableDeclaration: isVariableDeclaration,
    isVariableDeclarator: isVariableDeclarator,
    isWhileStatement: isWhileStatement,
    isWithStatement: isWithStatement,
    isAssignmentPattern: isAssignmentPattern,
    isArrayPattern: isArrayPattern,
    isArrowFunctionExpression: isArrowFunctionExpression,
    isClassBody: isClassBody,
    isClassExpression: isClassExpression,
    isClassDeclaration: isClassDeclaration,
    isExportAllDeclaration: isExportAllDeclaration,
    isExportDefaultDeclaration: isExportDefaultDeclaration,
    isExportNamedDeclaration: isExportNamedDeclaration,
    isExportSpecifier: isExportSpecifier,
    isForOfStatement: isForOfStatement,
    isImportDeclaration: isImportDeclaration,
    isImportDefaultSpecifier: isImportDefaultSpecifier,
    isImportNamespaceSpecifier: isImportNamespaceSpecifier,
    isImportSpecifier: isImportSpecifier,
    isMetaProperty: isMetaProperty,
    isClassMethod: isClassMethod,
    isObjectPattern: isObjectPattern,
    isSpreadElement: isSpreadElement,
    isSuper: isSuper,
    isTaggedTemplateExpression: isTaggedTemplateExpression,
    isTemplateElement: isTemplateElement,
    isTemplateLiteral: isTemplateLiteral,
    isYieldExpression: isYieldExpression,
    isAwaitExpression: isAwaitExpression,
    isImport: isImport,
    isBigIntLiteral: isBigIntLiteral,
    isExportNamespaceSpecifier: isExportNamespaceSpecifier,
    isOptionalMemberExpression: isOptionalMemberExpression,
    isOptionalCallExpression: isOptionalCallExpression,
    isAnyTypeAnnotation: isAnyTypeAnnotation,
    isArrayTypeAnnotation: isArrayTypeAnnotation,
    isBooleanTypeAnnotation: isBooleanTypeAnnotation,
    isBooleanLiteralTypeAnnotation: isBooleanLiteralTypeAnnotation,
    isNullLiteralTypeAnnotation: isNullLiteralTypeAnnotation,
    isClassImplements: isClassImplements,
    isDeclareClass: isDeclareClass,
    isDeclareFunction: isDeclareFunction,
    isDeclareInterface: isDeclareInterface,
    isDeclareModule: isDeclareModule,
    isDeclareModuleExports: isDeclareModuleExports,
    isDeclareTypeAlias: isDeclareTypeAlias,
    isDeclareOpaqueType: isDeclareOpaqueType,
    isDeclareVariable: isDeclareVariable,
    isDeclareExportDeclaration: isDeclareExportDeclaration,
    isDeclareExportAllDeclaration: isDeclareExportAllDeclaration,
    isDeclaredPredicate: isDeclaredPredicate,
    isExistsTypeAnnotation: isExistsTypeAnnotation,
    isFunctionTypeAnnotation: isFunctionTypeAnnotation,
    isFunctionTypeParam: isFunctionTypeParam,
    isGenericTypeAnnotation: isGenericTypeAnnotation,
    isInferredPredicate: isInferredPredicate,
    isInterfaceExtends: isInterfaceExtends,
    isInterfaceDeclaration: isInterfaceDeclaration,
    isInterfaceTypeAnnotation: isInterfaceTypeAnnotation,
    isIntersectionTypeAnnotation: isIntersectionTypeAnnotation,
    isMixedTypeAnnotation: isMixedTypeAnnotation,
    isEmptyTypeAnnotation: isEmptyTypeAnnotation,
    isNullableTypeAnnotation: isNullableTypeAnnotation,
    isNumberLiteralTypeAnnotation: isNumberLiteralTypeAnnotation,
    isNumberTypeAnnotation: isNumberTypeAnnotation,
    isObjectTypeAnnotation: isObjectTypeAnnotation,
    isObjectTypeInternalSlot: isObjectTypeInternalSlot,
    isObjectTypeCallProperty: isObjectTypeCallProperty,
    isObjectTypeIndexer: isObjectTypeIndexer,
    isObjectTypeProperty: isObjectTypeProperty,
    isObjectTypeSpreadProperty: isObjectTypeSpreadProperty,
    isOpaqueType: isOpaqueType,
    isQualifiedTypeIdentifier: isQualifiedTypeIdentifier,
    isStringLiteralTypeAnnotation: isStringLiteralTypeAnnotation,
    isStringTypeAnnotation: isStringTypeAnnotation,
    isSymbolTypeAnnotation: isSymbolTypeAnnotation,
    isThisTypeAnnotation: isThisTypeAnnotation,
    isTupleTypeAnnotation: isTupleTypeAnnotation,
    isTypeofTypeAnnotation: isTypeofTypeAnnotation,
    isTypeAlias: isTypeAlias,
    isTypeAnnotation: isTypeAnnotation,
    isTypeCastExpression: isTypeCastExpression,
    isTypeParameter: isTypeParameter,
    isTypeParameterDeclaration: isTypeParameterDeclaration,
    isTypeParameterInstantiation: isTypeParameterInstantiation,
    isUnionTypeAnnotation: isUnionTypeAnnotation,
    isVariance: isVariance,
    isVoidTypeAnnotation: isVoidTypeAnnotation,
    isEnumDeclaration: isEnumDeclaration,
    isEnumBooleanBody: isEnumBooleanBody,
    isEnumNumberBody: isEnumNumberBody,
    isEnumStringBody: isEnumStringBody,
    isEnumSymbolBody: isEnumSymbolBody,
    isEnumBooleanMember: isEnumBooleanMember,
    isEnumNumberMember: isEnumNumberMember,
    isEnumStringMember: isEnumStringMember,
    isEnumDefaultedMember: isEnumDefaultedMember,
    isIndexedAccessType: isIndexedAccessType,
    isOptionalIndexedAccessType: isOptionalIndexedAccessType,
    isJSXAttribute: isJSXAttribute,
    isJSXClosingElement: isJSXClosingElement,
    isJSXElement: isJSXElement,
    isJSXEmptyExpression: isJSXEmptyExpression,
    isJSXExpressionContainer: isJSXExpressionContainer,
    isJSXSpreadChild: isJSXSpreadChild,
    isJSXIdentifier: isJSXIdentifier,
    isJSXMemberExpression: isJSXMemberExpression,
    isJSXNamespacedName: isJSXNamespacedName,
    isJSXOpeningElement: isJSXOpeningElement,
    isJSXSpreadAttribute: isJSXSpreadAttribute,
    isJSXText: isJSXText,
    isJSXFragment: isJSXFragment,
    isJSXOpeningFragment: isJSXOpeningFragment,
    isJSXClosingFragment: isJSXClosingFragment,
    isNoop: isNoop,
    isPlaceholder: isPlaceholder,
    isV8IntrinsicIdentifier: isV8IntrinsicIdentifier,
    isArgumentPlaceholder: isArgumentPlaceholder,
    isBindExpression: isBindExpression,
    isClassProperty: isClassProperty,
    isPipelineTopicExpression: isPipelineTopicExpression,
    isPipelineBareFunction: isPipelineBareFunction,
    isPipelinePrimaryTopicReference: isPipelinePrimaryTopicReference,
    isClassPrivateProperty: isClassPrivateProperty,
    isClassPrivateMethod: isClassPrivateMethod,
    isImportAttribute: isImportAttribute,
    isDecorator: isDecorator,
    isDoExpression: isDoExpression,
    isExportDefaultSpecifier: isExportDefaultSpecifier,
    isPrivateName: isPrivateName,
    isRecordExpression: isRecordExpression,
    isTupleExpression: isTupleExpression,
    isDecimalLiteral: isDecimalLiteral,
    isStaticBlock: isStaticBlock,
    isModuleExpression: isModuleExpression,
    isTSParameterProperty: isTSParameterProperty,
    isTSDeclareFunction: isTSDeclareFunction,
    isTSDeclareMethod: isTSDeclareMethod,
    isTSQualifiedName: isTSQualifiedName,
    isTSCallSignatureDeclaration: isTSCallSignatureDeclaration,
    isTSConstructSignatureDeclaration: isTSConstructSignatureDeclaration,
    isTSPropertySignature: isTSPropertySignature,
    isTSMethodSignature: isTSMethodSignature,
    isTSIndexSignature: isTSIndexSignature,
    isTSAnyKeyword: isTSAnyKeyword,
    isTSBooleanKeyword: isTSBooleanKeyword,
    isTSBigIntKeyword: isTSBigIntKeyword,
    isTSIntrinsicKeyword: isTSIntrinsicKeyword,
    isTSNeverKeyword: isTSNeverKeyword,
    isTSNullKeyword: isTSNullKeyword,
    isTSNumberKeyword: isTSNumberKeyword,
    isTSObjectKeyword: isTSObjectKeyword,
    isTSStringKeyword: isTSStringKeyword,
    isTSSymbolKeyword: isTSSymbolKeyword,
    isTSUndefinedKeyword: isTSUndefinedKeyword,
    isTSUnknownKeyword: isTSUnknownKeyword,
    isTSVoidKeyword: isTSVoidKeyword,
    isTSThisType: isTSThisType,
    isTSFunctionType: isTSFunctionType,
    isTSConstructorType: isTSConstructorType,
    isTSTypeReference: isTSTypeReference,
    isTSTypePredicate: isTSTypePredicate,
    isTSTypeQuery: isTSTypeQuery,
    isTSTypeLiteral: isTSTypeLiteral,
    isTSArrayType: isTSArrayType,
    isTSTupleType: isTSTupleType,
    isTSOptionalType: isTSOptionalType,
    isTSRestType: isTSRestType,
    isTSNamedTupleMember: isTSNamedTupleMember,
    isTSUnionType: isTSUnionType,
    isTSIntersectionType: isTSIntersectionType,
    isTSConditionalType: isTSConditionalType,
    isTSInferType: isTSInferType,
    isTSParenthesizedType: isTSParenthesizedType,
    isTSTypeOperator: isTSTypeOperator,
    isTSIndexedAccessType: isTSIndexedAccessType,
    isTSMappedType: isTSMappedType,
    isTSLiteralType: isTSLiteralType,
    isTSExpressionWithTypeArguments: isTSExpressionWithTypeArguments,
    isTSInterfaceDeclaration: isTSInterfaceDeclaration,
    isTSInterfaceBody: isTSInterfaceBody,
    isTSTypeAliasDeclaration: isTSTypeAliasDeclaration,
    isTSAsExpression: isTSAsExpression,
    isTSTypeAssertion: isTSTypeAssertion,
    isTSEnumDeclaration: isTSEnumDeclaration,
    isTSEnumMember: isTSEnumMember,
    isTSModuleDeclaration: isTSModuleDeclaration,
    isTSModuleBlock: isTSModuleBlock,
    isTSImportType: isTSImportType,
    isTSImportEqualsDeclaration: isTSImportEqualsDeclaration,
    isTSExternalModuleReference: isTSExternalModuleReference,
    isTSNonNullExpression: isTSNonNullExpression,
    isTSExportAssignment: isTSExportAssignment,
    isTSNamespaceExportDeclaration: isTSNamespaceExportDeclaration,
    isTSTypeAnnotation: isTSTypeAnnotation,
    isTSTypeParameterInstantiation: isTSTypeParameterInstantiation,
    isTSTypeParameterDeclaration: isTSTypeParameterDeclaration,
    isTSTypeParameter: isTSTypeParameter,
    isExpression: isExpression,
    isBinary: isBinary,
    isScopable: isScopable,
    isBlockParent: isBlockParent,
    isBlock: isBlock,
    isStatement: isStatement,
    isTerminatorless: isTerminatorless,
    isCompletionStatement: isCompletionStatement,
    isConditional: isConditional,
    isLoop: isLoop$1,
    isWhile: isWhile,
    isExpressionWrapper: isExpressionWrapper,
    isFor: isFor,
    isForXStatement: isForXStatement,
    isFunction: isFunction$1,
    isFunctionParent: isFunctionParent,
    isPureish: isPureish,
    isDeclaration: isDeclaration,
    isPatternLike: isPatternLike,
    isLVal: isLVal,
    isTSEntityName: isTSEntityName,
    isLiteral: isLiteral,
    isUserWhitespacable: isUserWhitespacable,
    isMethod: isMethod,
    isObjectMember: isObjectMember,
    isProperty: isProperty,
    isUnaryLike: isUnaryLike,
    isPattern: isPattern,
    isClass: isClass,
    isModuleDeclaration: isModuleDeclaration,
    isExportDeclaration: isExportDeclaration,
    isModuleSpecifier: isModuleSpecifier,
    isFlow: isFlow,
    isFlowType: isFlowType,
    isFlowBaseAnnotation: isFlowBaseAnnotation,
    isFlowDeclaration: isFlowDeclaration,
    isFlowPredicate: isFlowPredicate,
    isEnumBody: isEnumBody,
    isEnumMember: isEnumMember,
    isJSX: isJSX,
    isPrivate: isPrivate,
    isTSTypeElement: isTSTypeElement,
    isTSType: isTSType,
    isTSBaseType: isTSBaseType,
    isNumberLiteral: isNumberLiteral,
    isRegexLiteral: isRegexLiteral,
    isRestProperty: isRestProperty,
    isSpreadProperty: isSpreadProperty
  });

  var ReferencedIdentifier = {
    types: ["Identifier", "JSXIdentifier"],
    checkPath: function checkPath(path, opts) {
      var node = path.node,
          parent = path.parent;

      if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node, opts)) {
          if (react.isCompatTag(node.name)) return false;
        } else {
          return false;
        }
      }

      return isReferenced(node, parent, path.parentPath.parent);
    }
  };
  var ReferencedMemberExpression = {
    types: ["MemberExpression"],
    checkPath: function checkPath(_ref) {
      var node = _ref.node,
          parent = _ref.parent;
      return isMemberExpression(node) && isReferenced(node, parent);
    }
  };
  var BindingIdentifier = {
    types: ["Identifier"],
    checkPath: function checkPath(path) {
      var node = path.node,
          parent = path.parent;
      var grandparent = path.parentPath.parent;
      return isIdentifier(node) && isBinding(node, parent, grandparent);
    }
  };
  var Statement = {
    types: ["Statement"],
    checkPath: function checkPath(_ref2) {
      var node = _ref2.node,
          parent = _ref2.parent;

      if (isStatement(node)) {
        if (isVariableDeclaration(node)) {
          if (isForXStatement(parent, {
            left: node
          })) return false;
          if (isForStatement(parent, {
            init: node
          })) return false;
        }

        return true;
      } else {
        return false;
      }
    }
  };
  var Expression = {
    types: ["Expression"],
    checkPath: function checkPath(path) {
      if (path.isIdentifier()) {
        return path.isReferencedIdentifier();
      } else {
        return isExpression(path.node);
      }
    }
  };
  var Scope$2 = {
    types: ["Scopable", "Pattern"],
    checkPath: function checkPath(path) {
      return isScope(path.node, path.parent);
    }
  };
  var Referenced = {
    checkPath: function checkPath(path) {
      return isReferenced(path.node, path.parent);
    }
  };
  var BlockScoped = {
    checkPath: function checkPath(path) {
      return isBlockScoped$1(path.node);
    }
  };
  var Var = {
    types: ["VariableDeclaration"],
    checkPath: function checkPath(path) {
      return isVar$1(path.node);
    }
  };
  var User = {
    checkPath: function checkPath(path) {
      return path.node && !!path.node.loc;
    }
  };
  var Generated = {
    checkPath: function checkPath(path) {
      return !path.isUser();
    }
  };
  var Pure = {
    checkPath: function checkPath(path, opts) {
      return path.scope.isPure(path.node, opts);
    }
  };
  var Flow = {
    types: ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"],
    checkPath: function checkPath(_ref3) {
      var node = _ref3.node;

      if (isFlow(node)) {
        return true;
      } else if (isImportDeclaration(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else if (isExportDeclaration(node)) {
        return node.exportKind === "type";
      } else if (isImportSpecifier(node)) {
        return node.importKind === "type" || node.importKind === "typeof";
      } else {
        return false;
      }
    }
  };
  var RestProperty = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectPattern();
    }
  };
  var SpreadProperty = {
    types: ["RestElement"],
    checkPath: function checkPath(path) {
      return path.parentPath && path.parentPath.isObjectExpression();
    }
  };
  var ExistentialTypeParam = {
    types: ["ExistsTypeAnnotation"]
  };
  var NumericLiteralTypeAnnotation = {
    types: ["NumberLiteralTypeAnnotation"]
  };
  var ForAwaitStatement = {
    types: ["ForOfStatement"],
    checkPath: function checkPath(_ref4) {
      var node = _ref4.node;
      return node["await"] === true;
    }
  };

  var virtualTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ReferencedIdentifier: ReferencedIdentifier,
    ReferencedMemberExpression: ReferencedMemberExpression,
    BindingIdentifier: BindingIdentifier,
    Statement: Statement,
    Expression: Expression,
    Scope: Scope$2,
    Referenced: Referenced,
    BlockScoped: BlockScoped,
    Var: Var,
    User: User,
    Generated: Generated,
    Pure: Pure,
    Flow: Flow,
    RestProperty: RestProperty,
    SpreadProperty: SpreadProperty,
    ExistentialTypeParam: ExistentialTypeParam,
    NumericLiteralTypeAnnotation: NumericLiteralTypeAnnotation,
    ForAwaitStatement: ForAwaitStatement
  });

  var s$1 = 1000;
  var m$2 = s$1 * 60;
  var h$1 = m$2 * 60;
  var d$1 = h$1 * 24;
  var w$1 = d$1 * 7;
  var y$1 = d$1 * 365.25;

  var ms$1 = function ms(val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse$9(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong$1(val) : fmtShort$1(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  function parse$9(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y$1;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w$1;

      case 'days':
      case 'day':
      case 'd':
        return n * d$1;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h$1;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m$2;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s$1;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }

  function fmtShort$1(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d$1) {
      return Math.round(ms / d$1) + 'd';
    }

    if (msAbs >= h$1) {
      return Math.round(ms / h$1) + 'h';
    }

    if (msAbs >= m$2) {
      return Math.round(ms / m$2) + 'm';
    }

    if (msAbs >= s$1) {
      return Math.round(ms / s$1) + 's';
    }

    return ms + 'ms';
  }

  function fmtLong$1(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d$1) {
      return plural$1(ms, msAbs, d$1, 'day');
    }

    if (msAbs >= h$1) {
      return plural$1(ms, msAbs, h$1, 'hour');
    }

    if (msAbs >= m$2) {
      return plural$1(ms, msAbs, m$2, 'minute');
    }

    if (msAbs >= s$1) {
      return plural$1(ms, msAbs, s$1, 'second');
    }

    return ms + ' ms';
  }

  function plural$1(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  function setup$2(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms$1;
    createDebug.destroy = destroy;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;

    function createDebug(namespace) {
      var prevTime;
      var enableOverride = null;
      var namespacesCache;
      var enabledCache;

      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!debug.enabled) {
          return;
        }

        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return '%';
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }

          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: function get() {
          if (enableOverride !== null) {
            return enableOverride;
          }

          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }

          return enabledCache;
        },
        set: function set(v) {
          enableOverride = v;
        }
      });

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      return debug;
    }

    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    function disable() {
      var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      }))).join(',');
      createDebug.enable('');
      return namespaces;
    }

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common$1 = setup$2;

  var browser$5 = createCommonjsModule(function (module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    exports.destroy = function () {
      var warned = false;
      return function () {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    }();

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    function useColors() {
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    exports.log = console.debug || console.log || function () {};

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }

    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {}

      if (!r && typeof browser$6 !== 'undefined' && 'env' in browser$6) {
        r = browser$6.env.DEBUG;
      }

      return r;
    }

    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }

    module.exports = common$1(exports);
    var formatters = module.exports.formatters;

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  }, "/$$rollup_base$$/packages/babel-traverse/node_modules/debug/src");

  var Binding = function () {
    function Binding(_ref) {
      var identifier = _ref.identifier,
          scope = _ref.scope,
          path = _ref.path,
          kind = _ref.kind;
      this.identifier = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.kind = void 0;
      this.constantViolations = [];
      this.constant = true;
      this.referencePaths = [];
      this.referenced = false;
      this.references = 0;
      this.identifier = identifier;
      this.scope = scope;
      this.path = path;
      this.kind = kind;
      this.clearValue();
    }

    var _proto = Binding.prototype;

    _proto.deoptValue = function deoptValue() {
      this.clearValue();
      this.hasDeoptedValue = true;
    };

    _proto.setValue = function setValue(value) {
      if (this.hasDeoptedValue) return;
      this.hasValue = true;
      this.value = value;
    };

    _proto.clearValue = function clearValue() {
      this.hasDeoptedValue = false;
      this.hasValue = false;
      this.value = null;
    };

    _proto.reassign = function reassign(path) {
      this.constant = false;

      if (this.constantViolations.indexOf(path) !== -1) {
        return;
      }

      this.constantViolations.push(path);
    };

    _proto.reference = function reference(path) {
      if (this.referencePaths.indexOf(path) !== -1) {
        return;
      }

      this.referenced = true;
      this.references++;
      this.referencePaths.push(path);
    };

    _proto.dereference = function dereference() {
      this.references--;
      this.referenced = !!this.references;
    };

    return Binding;
  }();

  function splitExportDeclaration(exportDeclaration) {
    if (!exportDeclaration.isExportDeclaration()) {
      throw new Error("Only export declarations can be split.");
    }

    var isDefault = exportDeclaration.isExportDefaultDeclaration();
    var declaration = exportDeclaration.get("declaration");
    var isClassDeclaration = declaration.isClassDeclaration();

    if (isDefault) {
      var standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;
      var scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
      var id = declaration.node.id;
      var needBindingRegistration = false;

      if (!id) {
        needBindingRegistration = true;
        id = scope.generateUidIdentifier("default");

        if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {
          declaration.node.id = cloneNode(id);
        }
      }

      var updatedDeclaration = standaloneDeclaration ? declaration : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
      var updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
      exportDeclaration.insertAfter(updatedExportDeclaration);
      exportDeclaration.replaceWith(updatedDeclaration);

      if (needBindingRegistration) {
        scope.registerDeclaration(exportDeclaration);
      }

      return exportDeclaration;
    }

    if (exportDeclaration.get("specifiers").length > 0) {
      throw new Error("It doesn't make sense to split exported specifiers.");
    }

    var bindingIdentifiers = declaration.getOuterBindingIdentifiers();
    var specifiers = Object.keys(bindingIdentifiers).map(function (name) {
      return exportSpecifier(identifier(name), identifier(name));
    });
    var aliasDeclar = exportNamedDeclaration(null, specifiers);
    exportDeclaration.insertAfter(aliasDeclar);
    exportDeclaration.replaceWith(declaration.node);
    return exportDeclaration;
  }

  var renameVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(_ref, state) {
      var node = _ref.node;

      if (node.name === state.oldName) {
        node.name = state.newName;
      }
    },
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
        skipAllButComputedMethodKey(path);
      }
    },
    "AssignmentExpression|Declaration|VariableDeclarator": function AssignmentExpressionDeclarationVariableDeclarator(path, state) {
      if (path.isVariableDeclaration()) return;
      var ids = path.getOuterBindingIdentifiers();

      for (var name in ids) {
        if (name === state.oldName) ids[name].name = state.newName;
      }
    }
  };

  var Renamer = function () {
    function Renamer(binding, oldName, newName) {
      this.newName = newName;
      this.oldName = oldName;
      this.binding = binding;
    }

    var _proto = Renamer.prototype;

    _proto.maybeConvertFromExportDeclaration = function maybeConvertFromExportDeclaration(parentDeclar) {
      var maybeExportDeclar = parentDeclar.parentPath;

      if (!maybeExportDeclar.isExportDeclaration()) {
        return;
      }

      if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get("declaration").node.id) {
        return;
      }

      splitExportDeclaration(maybeExportDeclar);
    };

    _proto.maybeConvertFromClassFunctionDeclaration = function maybeConvertFromClassFunctionDeclaration(path) {
      return;
    };

    _proto.maybeConvertFromClassFunctionExpression = function maybeConvertFromClassFunctionExpression(path) {
      return;
    };

    _proto.rename = function rename(block) {
      var _this = this;

      var binding = this.binding,
          oldName = this.oldName,
          newName = this.newName;
      var scope = binding.scope,
          path = binding.path;
      var parentDeclar = path.find(function (path) {
        return path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression();
      });

      if (parentDeclar) {
        var bindingIds = parentDeclar.getOuterBindingIdentifiers();

        if (bindingIds[oldName] === binding.identifier) {
          this.maybeConvertFromExportDeclaration(parentDeclar);
        }
      }

      var blockToTraverse = block || scope.block;

      if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === "SwitchStatement") {
        blockToTraverse.cases.forEach(function (c) {
          scope.traverse(c, renameVisitor, _this);
        });
      } else {
        scope.traverse(blockToTraverse, renameVisitor, this);
      }

      if (!block) {
        scope.removeOwnBinding(oldName);
        scope.bindings[newName] = binding;
        this.binding.identifier.name = newName;
      }

      if (parentDeclar) {
        this.maybeConvertFromClassFunctionDeclaration(parentDeclar);
        this.maybeConvertFromClassFunctionExpression(parentDeclar);
      }
    };

    return Renamer;
  }();

  function skipAllButComputedMethodKey(path) {
    if (!path.isMethod() || !path.node.computed) {
      path.skip();
      return;
    }

    var keys = VISITOR_KEYS[path.type];

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  }

  var builtin$1 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	BigInt: false,
  	BigInt64Array: false,
  	BigUint64Array: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	globalThis: false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es5$1 = {
  	"Array": false,
  	"Boolean": false,
  	constructor: false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	propertyIsEnumerable: false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"RegExp": false,
  	"String": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false
  };
  var es2015$1 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es2017$1 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var browser$4 = {
  	AbortController: false,
  	AbortSignal: false,
  	addEventListener: false,
  	alert: false,
  	AnalyserNode: false,
  	Animation: false,
  	AnimationEffectReadOnly: false,
  	AnimationEffectTiming: false,
  	AnimationEffectTimingReadOnly: false,
  	AnimationEvent: false,
  	AnimationPlaybackEvent: false,
  	AnimationTimeline: false,
  	applicationCache: false,
  	ApplicationCache: false,
  	ApplicationCacheErrorEvent: false,
  	atob: false,
  	Attr: false,
  	Audio: false,
  	AudioBuffer: false,
  	AudioBufferSourceNode: false,
  	AudioContext: false,
  	AudioDestinationNode: false,
  	AudioListener: false,
  	AudioNode: false,
  	AudioParam: false,
  	AudioProcessingEvent: false,
  	AudioScheduledSourceNode: false,
  	"AudioWorkletGlobalScope ": false,
  	AudioWorkletNode: false,
  	AudioWorkletProcessor: false,
  	BarProp: false,
  	BaseAudioContext: false,
  	BatteryManager: false,
  	BeforeUnloadEvent: false,
  	BiquadFilterNode: false,
  	Blob: false,
  	BlobEvent: false,
  	blur: false,
  	BroadcastChannel: false,
  	btoa: false,
  	BudgetService: false,
  	ByteLengthQueuingStrategy: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	cancelAnimationFrame: false,
  	cancelIdleCallback: false,
  	CanvasCaptureMediaStreamTrack: false,
  	CanvasGradient: false,
  	CanvasPattern: false,
  	CanvasRenderingContext2D: false,
  	ChannelMergerNode: false,
  	ChannelSplitterNode: false,
  	CharacterData: false,
  	clearInterval: false,
  	clearTimeout: false,
  	clientInformation: false,
  	ClipboardEvent: false,
  	close: false,
  	closed: false,
  	CloseEvent: false,
  	Comment: false,
  	CompositionEvent: false,
  	confirm: false,
  	console: false,
  	ConstantSourceNode: false,
  	ConvolverNode: false,
  	CountQueuingStrategy: false,
  	createImageBitmap: false,
  	Credential: false,
  	CredentialsContainer: false,
  	crypto: false,
  	Crypto: false,
  	CryptoKey: false,
  	CSS: false,
  	CSSConditionRule: false,
  	CSSFontFaceRule: false,
  	CSSGroupingRule: false,
  	CSSImportRule: false,
  	CSSKeyframeRule: false,
  	CSSKeyframesRule: false,
  	CSSMediaRule: false,
  	CSSNamespaceRule: false,
  	CSSPageRule: false,
  	CSSRule: false,
  	CSSRuleList: false,
  	CSSStyleDeclaration: false,
  	CSSStyleRule: false,
  	CSSStyleSheet: false,
  	CSSSupportsRule: false,
  	CustomElementRegistry: false,
  	customElements: false,
  	CustomEvent: false,
  	DataTransfer: false,
  	DataTransferItem: false,
  	DataTransferItemList: false,
  	defaultstatus: false,
  	defaultStatus: false,
  	DelayNode: false,
  	DeviceMotionEvent: false,
  	DeviceOrientationEvent: false,
  	devicePixelRatio: false,
  	dispatchEvent: false,
  	document: false,
  	Document: false,
  	DocumentFragment: false,
  	DocumentType: false,
  	DOMError: false,
  	DOMException: false,
  	DOMImplementation: false,
  	DOMMatrix: false,
  	DOMMatrixReadOnly: false,
  	DOMParser: false,
  	DOMPoint: false,
  	DOMPointReadOnly: false,
  	DOMQuad: false,
  	DOMRect: false,
  	DOMRectReadOnly: false,
  	DOMStringList: false,
  	DOMStringMap: false,
  	DOMTokenList: false,
  	DragEvent: false,
  	DynamicsCompressorNode: false,
  	Element: false,
  	ErrorEvent: false,
  	event: false,
  	Event: false,
  	EventSource: false,
  	EventTarget: false,
  	external: false,
  	fetch: false,
  	File: false,
  	FileList: false,
  	FileReader: false,
  	find: false,
  	focus: false,
  	FocusEvent: false,
  	FontFace: false,
  	FontFaceSetLoadEvent: false,
  	FormData: false,
  	frameElement: false,
  	frames: false,
  	GainNode: false,
  	Gamepad: false,
  	GamepadButton: false,
  	GamepadEvent: false,
  	getComputedStyle: false,
  	getSelection: false,
  	HashChangeEvent: false,
  	Headers: false,
  	history: false,
  	History: false,
  	HTMLAllCollection: false,
  	HTMLAnchorElement: false,
  	HTMLAreaElement: false,
  	HTMLAudioElement: false,
  	HTMLBaseElement: false,
  	HTMLBodyElement: false,
  	HTMLBRElement: false,
  	HTMLButtonElement: false,
  	HTMLCanvasElement: false,
  	HTMLCollection: false,
  	HTMLContentElement: false,
  	HTMLDataElement: false,
  	HTMLDataListElement: false,
  	HTMLDetailsElement: false,
  	HTMLDialogElement: false,
  	HTMLDirectoryElement: false,
  	HTMLDivElement: false,
  	HTMLDListElement: false,
  	HTMLDocument: false,
  	HTMLElement: false,
  	HTMLEmbedElement: false,
  	HTMLFieldSetElement: false,
  	HTMLFontElement: false,
  	HTMLFormControlsCollection: false,
  	HTMLFormElement: false,
  	HTMLFrameElement: false,
  	HTMLFrameSetElement: false,
  	HTMLHeadElement: false,
  	HTMLHeadingElement: false,
  	HTMLHRElement: false,
  	HTMLHtmlElement: false,
  	HTMLIFrameElement: false,
  	HTMLImageElement: false,
  	HTMLInputElement: false,
  	HTMLLabelElement: false,
  	HTMLLegendElement: false,
  	HTMLLIElement: false,
  	HTMLLinkElement: false,
  	HTMLMapElement: false,
  	HTMLMarqueeElement: false,
  	HTMLMediaElement: false,
  	HTMLMenuElement: false,
  	HTMLMetaElement: false,
  	HTMLMeterElement: false,
  	HTMLModElement: false,
  	HTMLObjectElement: false,
  	HTMLOListElement: false,
  	HTMLOptGroupElement: false,
  	HTMLOptionElement: false,
  	HTMLOptionsCollection: false,
  	HTMLOutputElement: false,
  	HTMLParagraphElement: false,
  	HTMLParamElement: false,
  	HTMLPictureElement: false,
  	HTMLPreElement: false,
  	HTMLProgressElement: false,
  	HTMLQuoteElement: false,
  	HTMLScriptElement: false,
  	HTMLSelectElement: false,
  	HTMLShadowElement: false,
  	HTMLSlotElement: false,
  	HTMLSourceElement: false,
  	HTMLSpanElement: false,
  	HTMLStyleElement: false,
  	HTMLTableCaptionElement: false,
  	HTMLTableCellElement: false,
  	HTMLTableColElement: false,
  	HTMLTableElement: false,
  	HTMLTableRowElement: false,
  	HTMLTableSectionElement: false,
  	HTMLTemplateElement: false,
  	HTMLTextAreaElement: false,
  	HTMLTimeElement: false,
  	HTMLTitleElement: false,
  	HTMLTrackElement: false,
  	HTMLUListElement: false,
  	HTMLUnknownElement: false,
  	HTMLVideoElement: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	IdleDeadline: false,
  	IIRFilterNode: false,
  	Image: false,
  	ImageBitmap: false,
  	ImageBitmapRenderingContext: false,
  	ImageCapture: false,
  	ImageData: false,
  	indexedDB: false,
  	innerHeight: false,
  	innerWidth: false,
  	InputEvent: false,
  	IntersectionObserver: false,
  	IntersectionObserverEntry: false,
  	"Intl": false,
  	isSecureContext: false,
  	KeyboardEvent: false,
  	KeyframeEffect: false,
  	KeyframeEffectReadOnly: false,
  	length: false,
  	localStorage: false,
  	location: true,
  	Location: false,
  	locationbar: false,
  	matchMedia: false,
  	MediaDeviceInfo: false,
  	MediaDevices: false,
  	MediaElementAudioSourceNode: false,
  	MediaEncryptedEvent: false,
  	MediaError: false,
  	MediaKeyMessageEvent: false,
  	MediaKeySession: false,
  	MediaKeyStatusMap: false,
  	MediaKeySystemAccess: false,
  	MediaList: false,
  	MediaQueryList: false,
  	MediaQueryListEvent: false,
  	MediaRecorder: false,
  	MediaSettingsRange: false,
  	MediaSource: false,
  	MediaStream: false,
  	MediaStreamAudioDestinationNode: false,
  	MediaStreamAudioSourceNode: false,
  	MediaStreamEvent: false,
  	MediaStreamTrack: false,
  	MediaStreamTrackEvent: false,
  	menubar: false,
  	MessageChannel: false,
  	MessageEvent: false,
  	MessagePort: false,
  	MIDIAccess: false,
  	MIDIConnectionEvent: false,
  	MIDIInput: false,
  	MIDIInputMap: false,
  	MIDIMessageEvent: false,
  	MIDIOutput: false,
  	MIDIOutputMap: false,
  	MIDIPort: false,
  	MimeType: false,
  	MimeTypeArray: false,
  	MouseEvent: false,
  	moveBy: false,
  	moveTo: false,
  	MutationEvent: false,
  	MutationObserver: false,
  	MutationRecord: false,
  	name: false,
  	NamedNodeMap: false,
  	NavigationPreloadManager: false,
  	navigator: false,
  	Navigator: false,
  	NetworkInformation: false,
  	Node: false,
  	NodeFilter: false,
  	NodeIterator: false,
  	NodeList: false,
  	Notification: false,
  	OfflineAudioCompletionEvent: false,
  	OfflineAudioContext: false,
  	offscreenBuffering: false,
  	OffscreenCanvas: true,
  	onabort: true,
  	onafterprint: true,
  	onanimationend: true,
  	onanimationiteration: true,
  	onanimationstart: true,
  	onappinstalled: true,
  	onauxclick: true,
  	onbeforeinstallprompt: true,
  	onbeforeprint: true,
  	onbeforeunload: true,
  	onblur: true,
  	oncancel: true,
  	oncanplay: true,
  	oncanplaythrough: true,
  	onchange: true,
  	onclick: true,
  	onclose: true,
  	oncontextmenu: true,
  	oncuechange: true,
  	ondblclick: true,
  	ondevicemotion: true,
  	ondeviceorientation: true,
  	ondeviceorientationabsolute: true,
  	ondrag: true,
  	ondragend: true,
  	ondragenter: true,
  	ondragleave: true,
  	ondragover: true,
  	ondragstart: true,
  	ondrop: true,
  	ondurationchange: true,
  	onemptied: true,
  	onended: true,
  	onerror: true,
  	onfocus: true,
  	ongotpointercapture: true,
  	onhashchange: true,
  	oninput: true,
  	oninvalid: true,
  	onkeydown: true,
  	onkeypress: true,
  	onkeyup: true,
  	onlanguagechange: true,
  	onload: true,
  	onloadeddata: true,
  	onloadedmetadata: true,
  	onloadstart: true,
  	onlostpointercapture: true,
  	onmessage: true,
  	onmessageerror: true,
  	onmousedown: true,
  	onmouseenter: true,
  	onmouseleave: true,
  	onmousemove: true,
  	onmouseout: true,
  	onmouseover: true,
  	onmouseup: true,
  	onmousewheel: true,
  	onoffline: true,
  	ononline: true,
  	onpagehide: true,
  	onpageshow: true,
  	onpause: true,
  	onplay: true,
  	onplaying: true,
  	onpointercancel: true,
  	onpointerdown: true,
  	onpointerenter: true,
  	onpointerleave: true,
  	onpointermove: true,
  	onpointerout: true,
  	onpointerover: true,
  	onpointerup: true,
  	onpopstate: true,
  	onprogress: true,
  	onratechange: true,
  	onrejectionhandled: true,
  	onreset: true,
  	onresize: true,
  	onscroll: true,
  	onsearch: true,
  	onseeked: true,
  	onseeking: true,
  	onselect: true,
  	onstalled: true,
  	onstorage: true,
  	onsubmit: true,
  	onsuspend: true,
  	ontimeupdate: true,
  	ontoggle: true,
  	ontransitionend: true,
  	onunhandledrejection: true,
  	onunload: true,
  	onvolumechange: true,
  	onwaiting: true,
  	onwheel: true,
  	open: false,
  	openDatabase: false,
  	opener: false,
  	Option: false,
  	origin: false,
  	OscillatorNode: false,
  	outerHeight: false,
  	outerWidth: false,
  	PageTransitionEvent: false,
  	pageXOffset: false,
  	pageYOffset: false,
  	PannerNode: false,
  	parent: false,
  	Path2D: false,
  	PaymentAddress: false,
  	PaymentRequest: false,
  	PaymentRequestUpdateEvent: false,
  	PaymentResponse: false,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceLongTaskTiming: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceNavigationTiming: false,
  	PerformanceObserver: false,
  	PerformanceObserverEntryList: false,
  	PerformancePaintTiming: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	PeriodicWave: false,
  	Permissions: false,
  	PermissionStatus: false,
  	personalbar: false,
  	PhotoCapabilities: false,
  	Plugin: false,
  	PluginArray: false,
  	PointerEvent: false,
  	PopStateEvent: false,
  	postMessage: false,
  	Presentation: false,
  	PresentationAvailability: false,
  	PresentationConnection: false,
  	PresentationConnectionAvailableEvent: false,
  	PresentationConnectionCloseEvent: false,
  	PresentationConnectionList: false,
  	PresentationReceiver: false,
  	PresentationRequest: false,
  	print: false,
  	ProcessingInstruction: false,
  	ProgressEvent: false,
  	PromiseRejectionEvent: false,
  	prompt: false,
  	PushManager: false,
  	PushSubscription: false,
  	PushSubscriptionOptions: false,
  	queueMicrotask: false,
  	RadioNodeList: false,
  	Range: false,
  	ReadableStream: false,
  	registerProcessor: false,
  	RemotePlayback: false,
  	removeEventListener: false,
  	Request: false,
  	requestAnimationFrame: false,
  	requestIdleCallback: false,
  	resizeBy: false,
  	ResizeObserver: false,
  	ResizeObserverEntry: false,
  	resizeTo: false,
  	Response: false,
  	RTCCertificate: false,
  	RTCDataChannel: false,
  	RTCDataChannelEvent: false,
  	RTCDtlsTransport: false,
  	RTCIceCandidate: false,
  	RTCIceGatherer: false,
  	RTCIceTransport: false,
  	RTCPeerConnection: false,
  	RTCPeerConnectionIceEvent: false,
  	RTCRtpContributingSource: false,
  	RTCRtpReceiver: false,
  	RTCRtpSender: false,
  	RTCSctpTransport: false,
  	RTCSessionDescription: false,
  	RTCStatsReport: false,
  	RTCTrackEvent: false,
  	screen: false,
  	Screen: false,
  	screenLeft: false,
  	ScreenOrientation: false,
  	screenTop: false,
  	screenX: false,
  	screenY: false,
  	ScriptProcessorNode: false,
  	scroll: false,
  	scrollbars: false,
  	scrollBy: false,
  	scrollTo: false,
  	scrollX: false,
  	scrollY: false,
  	SecurityPolicyViolationEvent: false,
  	Selection: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerRegistration: false,
  	sessionStorage: false,
  	setInterval: false,
  	setTimeout: false,
  	ShadowRoot: false,
  	SharedWorker: false,
  	SourceBuffer: false,
  	SourceBufferList: false,
  	speechSynthesis: false,
  	SpeechSynthesisEvent: false,
  	SpeechSynthesisUtterance: false,
  	StaticRange: false,
  	status: false,
  	statusbar: false,
  	StereoPannerNode: false,
  	stop: false,
  	Storage: false,
  	StorageEvent: false,
  	StorageManager: false,
  	styleMedia: false,
  	StyleSheet: false,
  	StyleSheetList: false,
  	SubtleCrypto: false,
  	SVGAElement: false,
  	SVGAngle: false,
  	SVGAnimatedAngle: false,
  	SVGAnimatedBoolean: false,
  	SVGAnimatedEnumeration: false,
  	SVGAnimatedInteger: false,
  	SVGAnimatedLength: false,
  	SVGAnimatedLengthList: false,
  	SVGAnimatedNumber: false,
  	SVGAnimatedNumberList: false,
  	SVGAnimatedPreserveAspectRatio: false,
  	SVGAnimatedRect: false,
  	SVGAnimatedString: false,
  	SVGAnimatedTransformList: false,
  	SVGAnimateElement: false,
  	SVGAnimateMotionElement: false,
  	SVGAnimateTransformElement: false,
  	SVGAnimationElement: false,
  	SVGCircleElement: false,
  	SVGClipPathElement: false,
  	SVGComponentTransferFunctionElement: false,
  	SVGDefsElement: false,
  	SVGDescElement: false,
  	SVGDiscardElement: false,
  	SVGElement: false,
  	SVGEllipseElement: false,
  	SVGFEBlendElement: false,
  	SVGFEColorMatrixElement: false,
  	SVGFEComponentTransferElement: false,
  	SVGFECompositeElement: false,
  	SVGFEConvolveMatrixElement: false,
  	SVGFEDiffuseLightingElement: false,
  	SVGFEDisplacementMapElement: false,
  	SVGFEDistantLightElement: false,
  	SVGFEDropShadowElement: false,
  	SVGFEFloodElement: false,
  	SVGFEFuncAElement: false,
  	SVGFEFuncBElement: false,
  	SVGFEFuncGElement: false,
  	SVGFEFuncRElement: false,
  	SVGFEGaussianBlurElement: false,
  	SVGFEImageElement: false,
  	SVGFEMergeElement: false,
  	SVGFEMergeNodeElement: false,
  	SVGFEMorphologyElement: false,
  	SVGFEOffsetElement: false,
  	SVGFEPointLightElement: false,
  	SVGFESpecularLightingElement: false,
  	SVGFESpotLightElement: false,
  	SVGFETileElement: false,
  	SVGFETurbulenceElement: false,
  	SVGFilterElement: false,
  	SVGForeignObjectElement: false,
  	SVGGElement: false,
  	SVGGeometryElement: false,
  	SVGGradientElement: false,
  	SVGGraphicsElement: false,
  	SVGImageElement: false,
  	SVGLength: false,
  	SVGLengthList: false,
  	SVGLinearGradientElement: false,
  	SVGLineElement: false,
  	SVGMarkerElement: false,
  	SVGMaskElement: false,
  	SVGMatrix: false,
  	SVGMetadataElement: false,
  	SVGMPathElement: false,
  	SVGNumber: false,
  	SVGNumberList: false,
  	SVGPathElement: false,
  	SVGPatternElement: false,
  	SVGPoint: false,
  	SVGPointList: false,
  	SVGPolygonElement: false,
  	SVGPolylineElement: false,
  	SVGPreserveAspectRatio: false,
  	SVGRadialGradientElement: false,
  	SVGRect: false,
  	SVGRectElement: false,
  	SVGScriptElement: false,
  	SVGSetElement: false,
  	SVGStopElement: false,
  	SVGStringList: false,
  	SVGStyleElement: false,
  	SVGSVGElement: false,
  	SVGSwitchElement: false,
  	SVGSymbolElement: false,
  	SVGTextContentElement: false,
  	SVGTextElement: false,
  	SVGTextPathElement: false,
  	SVGTextPositioningElement: false,
  	SVGTitleElement: false,
  	SVGTransform: false,
  	SVGTransformList: false,
  	SVGTSpanElement: false,
  	SVGUnitTypes: false,
  	SVGUseElement: false,
  	SVGViewElement: false,
  	TaskAttributionTiming: false,
  	Text: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	TextEvent: false,
  	TextMetrics: false,
  	TextTrack: false,
  	TextTrackCue: false,
  	TextTrackCueList: false,
  	TextTrackList: false,
  	TimeRanges: false,
  	toolbar: false,
  	top: false,
  	Touch: false,
  	TouchEvent: false,
  	TouchList: false,
  	TrackEvent: false,
  	TransitionEvent: false,
  	TreeWalker: false,
  	UIEvent: false,
  	URL: false,
  	URLSearchParams: false,
  	ValidityState: false,
  	visualViewport: false,
  	VisualViewport: false,
  	VTTCue: false,
  	WaveShaperNode: false,
  	WebAssembly: false,
  	WebGL2RenderingContext: false,
  	WebGLActiveInfo: false,
  	WebGLBuffer: false,
  	WebGLContextEvent: false,
  	WebGLFramebuffer: false,
  	WebGLProgram: false,
  	WebGLQuery: false,
  	WebGLRenderbuffer: false,
  	WebGLRenderingContext: false,
  	WebGLSampler: false,
  	WebGLShader: false,
  	WebGLShaderPrecisionFormat: false,
  	WebGLSync: false,
  	WebGLTexture: false,
  	WebGLTransformFeedback: false,
  	WebGLUniformLocation: false,
  	WebGLVertexArrayObject: false,
  	WebSocket: false,
  	WheelEvent: false,
  	window: false,
  	Window: false,
  	Worker: false,
  	WritableStream: false,
  	XMLDocument: false,
  	XMLHttpRequest: false,
  	XMLHttpRequestEventTarget: false,
  	XMLHttpRequestUpload: false,
  	XMLSerializer: false,
  	XPathEvaluator: false,
  	XPathExpression: false,
  	XPathResult: false,
  	XSLTProcessor: false
  };
  var worker$1 = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	clearInterval: false,
  	clearTimeout: false,
  	close: true,
  	console: false,
  	fetch: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: true,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onoffline: true,
  	ononline: true,
  	onrejectionhandled: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: true,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var node$1 = {
  	__dirname: false,
  	__filename: false,
  	Buffer: false,
  	clearImmediate: false,
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	exports: true,
  	global: false,
  	"Intl": false,
  	module: false,
  	process: false,
  	queueMicrotask: false,
  	require: false,
  	setImmediate: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false
  };
  var commonjs$1 = {
  	exports: true,
  	global: false,
  	module: false,
  	require: false
  };
  var amd$1 = {
  	define: false,
  	require: false
  };
  var mocha$1 = {
  	after: false,
  	afterEach: false,
  	before: false,
  	beforeEach: false,
  	context: false,
  	describe: false,
  	it: false,
  	mocha: false,
  	run: false,
  	setup: false,
  	specify: false,
  	suite: false,
  	suiteSetup: false,
  	suiteTeardown: false,
  	teardown: false,
  	test: false,
  	xcontext: false,
  	xdescribe: false,
  	xit: false,
  	xspecify: false
  };
  var jasmine$1 = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fail: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jasmine: false,
  	pending: false,
  	runs: false,
  	spyOn: false,
  	spyOnProperty: false,
  	waits: false,
  	waitsFor: false,
  	xdescribe: false,
  	xit: false
  };
  var jest$1 = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jest: false,
  	pit: false,
  	require: false,
  	test: false,
  	xdescribe: false,
  	xit: false,
  	xtest: false
  };
  var qunit$1 = {
  	asyncTest: false,
  	deepEqual: false,
  	equal: false,
  	expect: false,
  	module: false,
  	notDeepEqual: false,
  	notEqual: false,
  	notOk: false,
  	notPropEqual: false,
  	notStrictEqual: false,
  	ok: false,
  	propEqual: false,
  	QUnit: false,
  	raises: false,
  	start: false,
  	stop: false,
  	strictEqual: false,
  	test: false,
  	throws: false
  };
  var phantomjs$1 = {
  	console: true,
  	exports: true,
  	phantom: true,
  	require: true,
  	WebPage: true
  };
  var couch$1 = {
  	emit: false,
  	exports: false,
  	getRow: false,
  	log: false,
  	module: false,
  	provides: false,
  	require: false,
  	respond: false,
  	send: false,
  	start: false,
  	sum: false
  };
  var rhino$1 = {
  	defineClass: false,
  	deserialize: false,
  	gc: false,
  	help: false,
  	importClass: false,
  	importPackage: false,
  	java: false,
  	load: false,
  	loadClass: false,
  	Packages: false,
  	print: false,
  	quit: false,
  	readFile: false,
  	readUrl: false,
  	runCommand: false,
  	seal: false,
  	serialize: false,
  	spawn: false,
  	sync: false,
  	toint32: false,
  	version: false
  };
  var nashorn$1 = {
  	__DIR__: false,
  	__FILE__: false,
  	__LINE__: false,
  	com: false,
  	edu: false,
  	exit: false,
  	java: false,
  	Java: false,
  	javafx: false,
  	JavaImporter: false,
  	javax: false,
  	JSAdapter: false,
  	load: false,
  	loadWithNewGlobal: false,
  	org: false,
  	Packages: false,
  	print: false,
  	quit: false
  };
  var wsh$1 = {
  	ActiveXObject: true,
  	Enumerator: true,
  	GetObject: true,
  	ScriptEngine: true,
  	ScriptEngineBuildVersion: true,
  	ScriptEngineMajorVersion: true,
  	ScriptEngineMinorVersion: true,
  	VBArray: true,
  	WScript: true,
  	WSH: true,
  	XDomainRequest: true
  };
  var jquery$1 = {
  	$: false,
  	jQuery: false
  };
  var yui$1 = {
  	YAHOO: false,
  	YAHOO_config: false,
  	YUI: false,
  	YUI_config: false
  };
  var shelljs$1 = {
  	cat: false,
  	cd: false,
  	chmod: false,
  	config: false,
  	cp: false,
  	dirs: false,
  	echo: false,
  	env: false,
  	error: false,
  	exec: false,
  	exit: false,
  	find: false,
  	grep: false,
  	ln: false,
  	ls: false,
  	mkdir: false,
  	mv: false,
  	popd: false,
  	pushd: false,
  	pwd: false,
  	rm: false,
  	sed: false,
  	set: false,
  	target: false,
  	tempdir: false,
  	test: false,
  	touch: false,
  	which: false
  };
  var prototypejs$1 = {
  	$: false,
  	$$: false,
  	$A: false,
  	$break: false,
  	$continue: false,
  	$F: false,
  	$H: false,
  	$R: false,
  	$w: false,
  	Abstract: false,
  	Ajax: false,
  	Autocompleter: false,
  	Builder: false,
  	Class: false,
  	Control: false,
  	Draggable: false,
  	Draggables: false,
  	Droppables: false,
  	Effect: false,
  	Element: false,
  	Enumerable: false,
  	Event: false,
  	Field: false,
  	Form: false,
  	Hash: false,
  	Insertion: false,
  	ObjectRange: false,
  	PeriodicalExecuter: false,
  	Position: false,
  	Prototype: false,
  	Scriptaculous: false,
  	Selector: false,
  	Sortable: false,
  	SortableObserver: false,
  	Sound: false,
  	Template: false,
  	Toggle: false,
  	Try: false
  };
  var meteor$1 = {
  	_: false,
  	$: false,
  	Accounts: false,
  	AccountsClient: false,
  	AccountsCommon: false,
  	AccountsServer: false,
  	App: false,
  	Assets: false,
  	Blaze: false,
  	check: false,
  	Cordova: false,
  	DDP: false,
  	DDPRateLimiter: false,
  	DDPServer: false,
  	Deps: false,
  	EJSON: false,
  	Email: false,
  	HTTP: false,
  	Log: false,
  	Match: false,
  	Meteor: false,
  	Mongo: false,
  	MongoInternals: false,
  	Npm: false,
  	Package: false,
  	Plugin: false,
  	process: false,
  	Random: false,
  	ReactiveDict: false,
  	ReactiveVar: false,
  	Router: false,
  	ServiceConfiguration: false,
  	Session: false,
  	share: false,
  	Spacebars: false,
  	Template: false,
  	Tinytest: false,
  	Tracker: false,
  	UI: false,
  	Utils: false,
  	WebApp: false,
  	WebAppInternals: false
  };
  var mongo$1 = {
  	_isWindows: false,
  	_rand: false,
  	BulkWriteResult: false,
  	cat: false,
  	cd: false,
  	connect: false,
  	db: false,
  	getHostName: false,
  	getMemInfo: false,
  	hostname: false,
  	ISODate: false,
  	listFiles: false,
  	load: false,
  	ls: false,
  	md5sumFile: false,
  	mkdir: false,
  	Mongo: false,
  	NumberInt: false,
  	NumberLong: false,
  	ObjectId: false,
  	PlanCache: false,
  	print: false,
  	printjson: false,
  	pwd: false,
  	quit: false,
  	removeFile: false,
  	rs: false,
  	sh: false,
  	UUID: false,
  	version: false,
  	WriteResult: false
  };
  var applescript$1 = {
  	$: false,
  	Application: false,
  	Automation: false,
  	console: false,
  	delay: false,
  	Library: false,
  	ObjC: false,
  	ObjectSpecifier: false,
  	Path: false,
  	Progress: false,
  	Ref: false
  };
  var serviceworker$1 = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	clearInterval: false,
  	clearTimeout: false,
  	Client: false,
  	clients: false,
  	Clients: false,
  	close: true,
  	console: false,
  	ExtendableEvent: false,
  	ExtendableMessageEvent: false,
  	fetch: false,
  	FetchEvent: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: false,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onfetch: true,
  	oninstall: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onmessageerror: true,
  	onnotificationclick: true,
  	onnotificationclose: true,
  	onoffline: true,
  	ononline: true,
  	onpush: true,
  	onpushsubscriptionchange: true,
  	onrejectionhandled: true,
  	onsync: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	registration: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerGlobalScope: false,
  	ServiceWorkerMessageEvent: false,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	skipWaiting: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	WindowClient: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var atomtest$1 = {
  	advanceClock: false,
  	fakeClearInterval: false,
  	fakeClearTimeout: false,
  	fakeSetInterval: false,
  	fakeSetTimeout: false,
  	resetTimeouts: false,
  	waitsForPromise: false
  };
  var embertest$1 = {
  	andThen: false,
  	click: false,
  	currentPath: false,
  	currentRouteName: false,
  	currentURL: false,
  	fillIn: false,
  	find: false,
  	findAll: false,
  	findWithAssert: false,
  	keyEvent: false,
  	pauseTest: false,
  	resumeTest: false,
  	triggerEvent: false,
  	visit: false,
  	wait: false
  };
  var protractor$1 = {
  	$: false,
  	$$: false,
  	browser: false,
  	by: false,
  	By: false,
  	DartObject: false,
  	element: false,
  	protractor: false
  };
  var webextensions$1 = {
  	browser: false,
  	chrome: false,
  	opr: false
  };
  var greasemonkey$1 = {
  	cloneInto: false,
  	createObjectIn: false,
  	exportFunction: false,
  	GM: false,
  	GM_addStyle: false,
  	GM_deleteValue: false,
  	GM_getResourceText: false,
  	GM_getResourceURL: false,
  	GM_getValue: false,
  	GM_info: false,
  	GM_listValues: false,
  	GM_log: false,
  	GM_openInTab: false,
  	GM_registerMenuCommand: false,
  	GM_setClipboard: false,
  	GM_setValue: false,
  	GM_xmlhttpRequest: false,
  	unsafeWindow: false
  };
  var devtools$1 = {
  	$: false,
  	$_: false,
  	$$: false,
  	$0: false,
  	$1: false,
  	$2: false,
  	$3: false,
  	$4: false,
  	$x: false,
  	chrome: false,
  	clear: false,
  	copy: false,
  	debug: false,
  	dir: false,
  	dirxml: false,
  	getEventListeners: false,
  	inspect: false,
  	keys: false,
  	monitor: false,
  	monitorEvents: false,
  	profile: false,
  	profileEnd: false,
  	queryObjects: false,
  	table: false,
  	undebug: false,
  	unmonitor: false,
  	unmonitorEvents: false,
  	values: false
  };
  var require$$0$8 = {
  	builtin: builtin$1,
  	es5: es5$1,
  	es2015: es2015$1,
  	es2017: es2017$1,
  	browser: browser$4,
  	worker: worker$1,
  	node: node$1,
  	commonjs: commonjs$1,
  	amd: amd$1,
  	mocha: mocha$1,
  	jasmine: jasmine$1,
  	jest: jest$1,
  	qunit: qunit$1,
  	phantomjs: phantomjs$1,
  	couch: couch$1,
  	rhino: rhino$1,
  	nashorn: nashorn$1,
  	wsh: wsh$1,
  	jquery: jquery$1,
  	yui: yui$1,
  	shelljs: shelljs$1,
  	prototypejs: prototypejs$1,
  	meteor: meteor$1,
  	mongo: mongo$1,
  	applescript: applescript$1,
  	serviceworker: serviceworker$1,
  	atomtest: atomtest$1,
  	embertest: embertest$1,
  	protractor: protractor$1,
  	"shared-node-browser": {
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	setInterval: false,
  	setTimeout: false,
  	URL: false,
  	URLSearchParams: false
  },
  	webextensions: webextensions$1,
  	greasemonkey: greasemonkey$1,
  	devtools: devtools$1
  };

  var globalsBABEL_8_BREAKINGFalse$1 = require$$0$8;

  var globals$1 = globalsBABEL_8_BREAKINGFalse$1;

  var path$3 = new WeakMap();
  var scope = new WeakMap();
  function clear() {
    clearPath();
    clearScope();
  }
  function clearPath() {
    path$3 = new WeakMap();
  }
  function clearScope() {
    scope = new WeakMap();
  }

  var cache$4 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get path () { return path$3; },
    get scope () { return scope; },
    clear: clear,
    clearPath: clearPath,
    clearScope: clearScope
  });

  function gatherNodeParts(node, parts) {
    switch (node == null ? void 0 : node.type) {
      default:
        if (isModuleDeclaration(node)) {
          if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {
            gatherNodeParts(node.source, parts);
          } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {
            for (var _iterator = _createForOfIteratorHelperLoose(node.specifiers), _step; !(_step = _iterator()).done;) {
              var e = _step.value;
              gatherNodeParts(e, parts);
            }
          } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {
            gatherNodeParts(node.declaration, parts);
          }
        } else if (isModuleSpecifier(node)) {
          gatherNodeParts(node.local, parts);
        } else if (isLiteral(node)) {
          parts.push(node.value);
        }

        break;

      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        gatherNodeParts(node.object, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "Identifier":
      case "JSXIdentifier":
        parts.push(node.name);
        break;

      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        gatherNodeParts(node.callee, parts);
        break;

      case "ObjectExpression":
      case "ObjectPattern":
        for (var _iterator2 = _createForOfIteratorHelperLoose(node.properties), _step2; !(_step2 = _iterator2()).done;) {
          var _e = _step2.value;
          gatherNodeParts(_e, parts);
        }

        break;

      case "SpreadElement":
      case "RestElement":
        gatherNodeParts(node.argument, parts);
        break;

      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        gatherNodeParts(node.key, parts);
        break;

      case "ThisExpression":
        parts.push("this");
        break;

      case "Super":
        parts.push("super");
        break;

      case "Import":
        parts.push("import");
        break;

      case "DoExpression":
        parts.push("do");
        break;

      case "YieldExpression":
        parts.push("yield");
        gatherNodeParts(node.argument, parts);
        break;

      case "AwaitExpression":
        parts.push("await");
        gatherNodeParts(node.argument, parts);
        break;

      case "AssignmentExpression":
        gatherNodeParts(node.left, parts);
        break;

      case "VariableDeclarator":
        gatherNodeParts(node.id, parts);
        break;

      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
        gatherNodeParts(node.id, parts);
        break;

      case "PrivateName":
        gatherNodeParts(node.id, parts);
        break;

      case "ParenthesizedExpression":
        gatherNodeParts(node.expression, parts);
        break;

      case "UnaryExpression":
      case "UpdateExpression":
        gatherNodeParts(node.argument, parts);
        break;

      case "MetaProperty":
        gatherNodeParts(node.meta, parts);
        gatherNodeParts(node.property, parts);
        break;

      case "JSXElement":
        gatherNodeParts(node.openingElement, parts);
        break;

      case "JSXOpeningElement":
        parts.push(node.name);
        break;

      case "JSXFragment":
        gatherNodeParts(node.openingFragment, parts);
        break;

      case "JSXOpeningFragment":
        parts.push("Fragment");
        break;

      case "JSXNamespacedName":
        gatherNodeParts(node.namespace, parts);
        gatherNodeParts(node.name, parts);
        break;
    }
  }

  var collectorVisitor = {
    For: function For(path) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(FOR_INIT_KEYS), _step3; !(_step3 = _iterator3()).done;) {
        var key = _step3.value;
        var declar = path.get(key);

        if (declar.isVar()) {
          var parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      }
    },
    Declaration: function Declaration(path) {
      if (path.isBlockScoped()) return;
      if (path.isExportDeclaration()) return;
      var parent = path.scope.getFunctionParent() || path.scope.getProgramParent();
      parent.registerDeclaration(path);
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      state.references.push(path);
    },
    ForXStatement: function ForXStatement(path, state) {
      var left = path.get("left");

      if (left.isPattern() || left.isIdentifier()) {
        state.constantViolations.push(path);
      }
    },
    ExportDeclaration: {
      exit: function exit(path) {
        var node = path.node,
            scope = path.scope;
        if (isExportAllDeclaration(node)) return;
        var declar = node.declaration;

        if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
          var id = declar.id;
          if (!id) return;
          var binding = scope.getBinding(id.name);
          if (binding) binding.reference(path);
        } else if (isVariableDeclaration(declar)) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(declar.declarations), _step4; !(_step4 = _iterator4()).done;) {
            var decl = _step4.value;

            for (var _i = 0, _Object$keys = Object.keys(getBindingIdentifiers$1(decl)); _i < _Object$keys.length; _i++) {
              var _name = _Object$keys[_i];

              var _binding = scope.getBinding(_name);

              if (_binding) _binding.reference(path);
            }
          }
        }
      }
    },
    LabeledStatement: function LabeledStatement(path) {
      path.scope.getBlockParent().registerDeclaration(path);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      state.assignments.push(path);
    },
    UpdateExpression: function UpdateExpression(path, state) {
      state.constantViolations.push(path);
    },
    UnaryExpression: function UnaryExpression(path, state) {
      if (path.node.operator === "delete") {
        state.constantViolations.push(path);
      }
    },
    BlockScoped: function BlockScoped(path) {
      var scope = path.scope;
      if (scope.path === path) scope = scope.parent;
      var parent = scope.getBlockParent();
      parent.registerDeclaration(path);

      if (path.isClassDeclaration() && path.node.id) {
        var id = path.node.id;
        var _name2 = id.name;
        path.scope.bindings[_name2] = path.scope.parent.getBinding(_name2);
      }
    },
    CatchClause: function CatchClause(path) {
      path.scope.registerBinding("let", path);
    },
    Function: function Function(path) {
      if (path.isFunctionExpression() && path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path.get("id"), path);
      }

      var params = path.get("params");

      for (var _iterator5 = _createForOfIteratorHelperLoose(params), _step5; !(_step5 = _iterator5()).done;) {
        var param = _step5.value;
        path.scope.registerBinding("param", param);
      }
    },
    ClassExpression: function ClassExpression(path) {
      if (path.has("id") && !path.get("id").node[NOT_LOCAL_BINDING]) {
        path.scope.registerBinding("local", path);
      }
    }
  };
  var uid = 0;

  var Scope$1 = function () {
    function Scope(path) {
      this.uid = void 0;
      this.path = void 0;
      this.block = void 0;
      this.labels = void 0;
      this.inited = void 0;
      this.bindings = void 0;
      this.references = void 0;
      this.globals = void 0;
      this.uids = void 0;
      this.data = void 0;
      this.crawling = void 0;
      var node = path.node;
      var cached = scope.get(node);

      if ((cached == null ? void 0 : cached.path) === path) {
        return cached;
      }

      scope.set(node, this);
      this.uid = uid++;
      this.block = node;
      this.path = path;
      this.labels = new Map();
      this.inited = false;
    }

    var _proto = Scope.prototype;

    _proto.traverse = function traverse$1(node, opts, state) {
      traverse(node, opts, this, state, this.path);
    };

    _proto.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier(name) {
      var id = this.generateUidIdentifier(name);
      this.push({
        id: id
      });
      return cloneNode(id);
    };

    _proto.generateUidIdentifier = function generateUidIdentifier(name) {
      return identifier(this.generateUid(name));
    };

    _proto.generateUid = function generateUid(name) {
      if (name === void 0) {
        name = "temp";
      }

      name = toIdentifier(name).replace(/^_+/, "").replace(/[0-9]+$/g, "");
      var uid;
      var i = 1;

      do {
        uid = this._generateUid(name, i);
        i++;
      } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));

      var program = this.getProgramParent();
      program.references[uid] = true;
      program.uids[uid] = true;
      return uid;
    };

    _proto._generateUid = function _generateUid(name, i) {
      var id = name;
      if (i > 1) id += i;
      return "_" + id;
    };

    _proto.generateUidBasedOnNode = function generateUidBasedOnNode(node, defaultName) {
      var parts = [];
      gatherNodeParts(node, parts);
      var id = parts.join("$");
      id = id.replace(/^_/, "") || defaultName || "ref";
      return this.generateUid(id.slice(0, 20));
    };

    _proto.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(node, defaultName) {
      return identifier(this.generateUidBasedOnNode(node, defaultName));
    };

    _proto.isStatic = function isStatic(node) {
      if (isThisExpression(node) || isSuper(node)) {
        return true;
      }

      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding) {
          return binding.constant;
        } else {
          return this.hasBinding(node.name);
        }
      }

      return false;
    };

    _proto.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {
      if (this.isStatic(node)) {
        return null;
      } else {
        var id = this.generateUidIdentifierBasedOnNode(node);

        if (!dontPush) {
          this.push({
            id: id
          });
          return cloneNode(id);
        }

        return id;
      }
    };

    _proto.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {
      if (kind === "param") return;
      if (local.kind === "local") return;
      var duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && (kind === "let" || kind === "const");

      if (duplicate) {
        throw this.hub.buildError(id, "Duplicate declaration \"" + name + "\"", TypeError);
      }
    };

    _proto.rename = function rename(oldName, newName, block) {
      var binding = this.getBinding(oldName);

      if (binding) {
        newName = newName || this.generateUidIdentifier(oldName).name;
        return new Renamer(binding, oldName, newName).rename(block);
      }
    };

    _proto._renameFromMap = function _renameFromMap(map, oldName, newName, value) {
      if (map[oldName]) {
        map[newName] = value;
        map[oldName] = null;
      }
    };

    _proto.dump = function dump() {
      var sep = "-".repeat(60);
      console.log(sep);
      var scope = this;

      do {
        console.log("#", scope.block.type);

        for (var _i2 = 0, _Object$keys2 = Object.keys(scope.bindings); _i2 < _Object$keys2.length; _i2++) {
          var _name3 = _Object$keys2[_i2];
          var binding = scope.bindings[_name3];
          console.log(" -", _name3, {
            constant: binding.constant,
            references: binding.references,
            violations: binding.constantViolations.length,
            kind: binding.kind
          });
        }
      } while (scope = scope.parent);

      console.log(sep);
    };

    _proto.toArray = function toArray(node, i, arrayLikeIsIterable) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);

        if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
          return node;
        }
      }

      if (isArrayExpression(node)) {
        return node;
      }

      if (isIdentifier(node, {
        name: "arguments"
      })) {
        return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node]);
      }

      var helperName;
      var args = [node];

      if (i === true) {
        helperName = "toConsumableArray";
      } else if (i) {
        args.push(numericLiteral(i));
        helperName = "slicedToArray";
      } else {
        helperName = "toArray";
      }

      if (arrayLikeIsIterable) {
        args.unshift(this.hub.addHelper(helperName));
        helperName = "maybeArrayLike";
      }

      return callExpression(this.hub.addHelper(helperName), args);
    };

    _proto.hasLabel = function hasLabel(name) {
      return !!this.getLabel(name);
    };

    _proto.getLabel = function getLabel(name) {
      return this.labels.get(name);
    };

    _proto.registerLabel = function registerLabel(path) {
      this.labels.set(path.node.label.name, path);
    };

    _proto.registerDeclaration = function registerDeclaration(path) {
      if (path.isLabeledStatement()) {
        this.registerLabel(path);
      } else if (path.isFunctionDeclaration()) {
        this.registerBinding("hoisted", path.get("id"), path);
      } else if (path.isVariableDeclaration()) {
        var declarations = path.get("declarations");

        for (var _iterator6 = _createForOfIteratorHelperLoose(declarations), _step6; !(_step6 = _iterator6()).done;) {
          var declar = _step6.value;
          this.registerBinding(path.node.kind, declar);
        }
      } else if (path.isClassDeclaration()) {
        this.registerBinding("let", path);
      } else if (path.isImportDeclaration()) {
        var specifiers = path.get("specifiers");

        for (var _iterator7 = _createForOfIteratorHelperLoose(specifiers), _step7; !(_step7 = _iterator7()).done;) {
          var specifier = _step7.value;
          this.registerBinding("module", specifier);
        }
      } else if (path.isExportDeclaration()) {
        var _declar = path.get("declaration");

        if (_declar.isClassDeclaration() || _declar.isFunctionDeclaration() || _declar.isVariableDeclaration()) {
          this.registerDeclaration(_declar);
        }
      } else {
        this.registerBinding("unknown", path);
      }
    };

    _proto.buildUndefinedNode = function buildUndefinedNode() {
      return unaryExpression("void", numericLiteral(0), true);
    };

    _proto.registerConstantViolation = function registerConstantViolation(path) {
      var ids = path.getBindingIdentifiers();

      for (var _i3 = 0, _Object$keys3 = Object.keys(ids); _i3 < _Object$keys3.length; _i3++) {
        var _name4 = _Object$keys3[_i3];
        var binding = this.getBinding(_name4);
        if (binding) binding.reassign(path);
      }
    };

    _proto.registerBinding = function registerBinding(kind, path, bindingPath) {
      if (bindingPath === void 0) {
        bindingPath = path;
      }

      if (!kind) throw new ReferenceError("no `kind`");

      if (path.isVariableDeclaration()) {
        var declarators = path.get("declarations");

        for (var _iterator8 = _createForOfIteratorHelperLoose(declarators), _step8; !(_step8 = _iterator8()).done;) {
          var declar = _step8.value;
          this.registerBinding(kind, declar);
        }

        return;
      }

      var parent = this.getProgramParent();
      var ids = path.getOuterBindingIdentifiers(true);

      for (var _i4 = 0, _Object$keys4 = Object.keys(ids); _i4 < _Object$keys4.length; _i4++) {
        var _name5 = _Object$keys4[_i4];
        parent.references[_name5] = true;

        for (var _iterator9 = _createForOfIteratorHelperLoose(ids[_name5]), _step9; !(_step9 = _iterator9()).done;) {
          var id = _step9.value;
          var local = this.getOwnBinding(_name5);

          if (local) {
            if (local.identifier === id) continue;
            this.checkBlockScopedCollisions(local, kind, _name5, id);
          }

          if (local) {
            this.registerConstantViolation(bindingPath);
          } else {
            this.bindings[_name5] = new Binding({
              identifier: id,
              scope: this,
              path: bindingPath,
              kind: kind
            });
          }
        }
      }
    };

    _proto.addGlobal = function addGlobal(node) {
      this.globals[node.name] = node;
    };

    _proto.hasUid = function hasUid(name) {
      var scope = this;

      do {
        if (scope.uids[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasGlobal = function hasGlobal(name) {
      var scope = this;

      do {
        if (scope.globals[name]) return true;
      } while (scope = scope.parent);

      return false;
    };

    _proto.hasReference = function hasReference(name) {
      return !!this.getProgramParent().references[name];
    };

    _proto.isPure = function isPure(node, constantsOnly) {
      if (isIdentifier(node)) {
        var binding = this.getBinding(node.name);
        if (!binding) return false;
        if (constantsOnly) return binding.constant;
        return true;
      } else if (isClass(node)) {
        if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {
          return false;
        }

        return this.isPure(node.body, constantsOnly);
      } else if (isClassBody(node)) {
        for (var _iterator10 = _createForOfIteratorHelperLoose(node.body), _step10; !(_step10 = _iterator10()).done;) {
          var method = _step10.value;
          if (!this.isPure(method, constantsOnly)) return false;
        }

        return true;
      } else if (isBinary(node)) {
        return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);
      } else if (isArrayExpression(node)) {
        for (var _iterator11 = _createForOfIteratorHelperLoose(node.elements), _step11; !(_step11 = _iterator11()).done;) {
          var elem = _step11.value;
          if (!this.isPure(elem, constantsOnly)) return false;
        }

        return true;
      } else if (isObjectExpression(node)) {
        for (var _iterator12 = _createForOfIteratorHelperLoose(node.properties), _step12; !(_step12 = _iterator12()).done;) {
          var prop = _step12.value;
          if (!this.isPure(prop, constantsOnly)) return false;
        }

        return true;
      } else if (isMethod(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        if (node.kind === "get" || node.kind === "set") return false;
        return true;
      } else if (isProperty(node)) {
        if (node.computed && !this.isPure(node.key, constantsOnly)) return false;
        return this.isPure(node.value, constantsOnly);
      } else if (isUnaryExpression(node)) {
        return this.isPure(node.argument, constantsOnly);
      } else if (isTaggedTemplateExpression(node)) {
        return matchesPattern$1(node.tag, "String.raw") && !this.hasBinding("String", true) && this.isPure(node.quasi, constantsOnly);
      } else if (isTemplateLiteral(node)) {
        for (var _iterator13 = _createForOfIteratorHelperLoose(node.expressions), _step13; !(_step13 = _iterator13()).done;) {
          var expression = _step13.value;
          if (!this.isPure(expression, constantsOnly)) return false;
        }

        return true;
      } else {
        return isPureish(node);
      }
    };

    _proto.setData = function setData(key, val) {
      return this.data[key] = val;
    };

    _proto.getData = function getData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) return data;
      } while (scope = scope.parent);
    };

    _proto.removeData = function removeData(key) {
      var scope = this;

      do {
        var data = scope.data[key];
        if (data != null) scope.data[key] = null;
      } while (scope = scope.parent);
    };

    _proto.init = function init() {
      if (!this.inited) {
        this.inited = true;
        this.crawl();
      }
    };

    _proto.crawl = function crawl() {
      var path = this.path;
      this.references = Object.create(null);
      this.bindings = Object.create(null);
      this.globals = Object.create(null);
      this.uids = Object.create(null);
      this.data = Object.create(null);
      var programParent = this.getProgramParent();
      if (programParent.crawling) return;
      var state = {
        references: [],
        constantViolations: [],
        assignments: []
      };
      this.crawling = true;

      if (path.type !== "Program" && collectorVisitor._exploded) {
        for (var _iterator14 = _createForOfIteratorHelperLoose(collectorVisitor.enter), _step14; !(_step14 = _iterator14()).done;) {
          var _visit = _step14.value;

          _visit(path, state);
        }

        var typeVisitors = collectorVisitor[path.type];

        if (typeVisitors) {
          for (var _iterator15 = _createForOfIteratorHelperLoose(typeVisitors.enter), _step15; !(_step15 = _iterator15()).done;) {
            var visit = _step15.value;
            visit(path, state);
          }
        }
      }

      path.traverse(collectorVisitor, state);
      this.crawling = false;

      for (var _iterator16 = _createForOfIteratorHelperLoose(state.assignments), _step16; !(_step16 = _iterator16()).done;) {
        var _path = _step16.value;

        var ids = _path.getBindingIdentifiers();

        for (var _i5 = 0, _Object$keys5 = Object.keys(ids); _i5 < _Object$keys5.length; _i5++) {
          var _name6 = _Object$keys5[_i5];
          if (_path.scope.getBinding(_name6)) continue;
          programParent.addGlobal(ids[_name6]);
        }

        _path.scope.registerConstantViolation(_path);
      }

      for (var _iterator17 = _createForOfIteratorHelperLoose(state.references), _step17; !(_step17 = _iterator17()).done;) {
        var ref = _step17.value;
        var binding = ref.scope.getBinding(ref.node.name);

        if (binding) {
          binding.reference(ref);
        } else {
          programParent.addGlobal(ref.node);
        }
      }

      for (var _iterator18 = _createForOfIteratorHelperLoose(state.constantViolations), _step18; !(_step18 = _iterator18()).done;) {
        var _path2 = _step18.value;

        _path2.scope.registerConstantViolation(_path2);
      }
    };

    _proto.push = function push(opts) {
      var path = this.path;

      if (!path.isBlockStatement() && !path.isProgram()) {
        path = this.getBlockParent().path;
      }

      if (path.isSwitchStatement()) {
        path = (this.getFunctionParent() || this.getProgramParent()).path;
      }

      if (path.isLoop() || path.isCatchClause() || path.isFunction()) {
        path.ensureBlock();
        path = path.get("body");
      }

      var unique = opts.unique;
      var kind = opts.kind || "var";
      var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
      var dataKey = "declaration:" + kind + ":" + blockHoist;
      var declarPath = !unique && path.getData(dataKey);

      if (!declarPath) {
        var declar = variableDeclaration(kind, []);
        declar._blockHoist = blockHoist;

        var _path$unshiftContaine = path.unshiftContainer("body", [declar]);

        var _path$unshiftContaine2 = _slicedToArray$2(_path$unshiftContaine, 1);

        declarPath = _path$unshiftContaine2[0];
        if (!unique) path.setData(dataKey, declarPath);
      }

      var declarator = variableDeclarator(opts.id, opts.init);
      declarPath.node.declarations.push(declarator);
      this.registerBinding(kind, declarPath.get("declarations").pop());
    };

    _proto.getProgramParent = function getProgramParent() {
      var scope = this;

      do {
        if (scope.path.isProgram()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("Couldn't find a Program");
    };

    _proto.getFunctionParent = function getFunctionParent() {
      var scope = this;

      do {
        if (scope.path.isFunctionParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      return null;
    };

    _proto.getBlockParent = function getBlockParent() {
      var scope = this;

      do {
        if (scope.path.isBlockParent()) {
          return scope;
        }
      } while (scope = scope.parent);

      throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
    };

    _proto.getAllBindings = function getAllBindings() {
      var ids = Object.create(null);
      var scope = this;

      do {
        for (var _i6 = 0, _Object$keys6 = Object.keys(scope.bindings); _i6 < _Object$keys6.length; _i6++) {
          var key = _Object$keys6[_i6];

          if (key in ids === false) {
            ids[key] = scope.bindings[key];
          }
        }

        scope = scope.parent;
      } while (scope);

      return ids;
    };

    _proto.getAllBindingsOfKind = function getAllBindingsOfKind() {
      var ids = Object.create(null);

      for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {
        kinds[_key] = arguments[_key];
      }

      for (var _i7 = 0, _kinds = kinds; _i7 < _kinds.length; _i7++) {
        var kind = _kinds[_i7];
        var scope = this;

        do {
          for (var _i8 = 0, _Object$keys7 = Object.keys(scope.bindings); _i8 < _Object$keys7.length; _i8++) {
            var _name7 = _Object$keys7[_i8];
            var binding = scope.bindings[_name7];
            if (binding.kind === kind) ids[_name7] = binding;
          }

          scope = scope.parent;
        } while (scope);
      }

      return ids;
    };

    _proto.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {
      return this.getBindingIdentifier(name) === node;
    };

    _proto.getBinding = function getBinding(name) {
      var scope = this;
      var previousPath;

      do {
        var binding = scope.getOwnBinding(name);

        if (binding) {
          var _previousPath;

          if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param") ; else {
            return binding;
          }
        }

        previousPath = scope.path;
      } while (scope = scope.parent);
    };

    _proto.getOwnBinding = function getOwnBinding(name) {
      return this.bindings[name];
    };

    _proto.getBindingIdentifier = function getBindingIdentifier(name) {
      var _this$getBinding;

      return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;
    };

    _proto.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {
      var binding = this.bindings[name];
      return binding == null ? void 0 : binding.identifier;
    };

    _proto.hasOwnBinding = function hasOwnBinding(name) {
      return !!this.getOwnBinding(name);
    };

    _proto.hasBinding = function hasBinding(name, noGlobals) {
      if (!name) return false;
      if (this.hasOwnBinding(name)) return true;
      if (this.parentHasBinding(name, noGlobals)) return true;
      if (this.hasUid(name)) return true;
      if (!noGlobals && Scope.globals.includes(name)) return true;
      if (!noGlobals && Scope.contextVariables.includes(name)) return true;
      return false;
    };

    _proto.parentHasBinding = function parentHasBinding(name, noGlobals) {
      var _this$parent;

      return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);
    };

    _proto.moveBindingTo = function moveBindingTo(name, scope) {
      var info = this.getBinding(name);

      if (info) {
        info.scope.removeOwnBinding(name);
        info.scope = scope;
        scope.bindings[name] = info;
      }
    };

    _proto.removeOwnBinding = function removeOwnBinding(name) {
      delete this.bindings[name];
    };

    _proto.removeBinding = function removeBinding(name) {
      var _this$getBinding2;

      (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);
      var scope = this;

      do {
        if (scope.uids[name]) {
          scope.uids[name] = false;
        }
      } while (scope = scope.parent);
    };

    _createClass(Scope, [{
      key: "parent",
      get: function get() {
        var _parent;

        var parent,
            path = this.path;

        do {
          var isKey = path.key === "key";
          path = path.parentPath;
          if (isKey && path.isMethod()) path = path.parentPath;
          if (path && path.isScope()) parent = path;
        } while (path && !parent);

        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
    }, {
      key: "parentBlock",
      get: function get() {
        return this.path.parent;
      }
    }, {
      key: "hub",
      get: function get() {
        return this.path.hub;
      }
    }]);

    return Scope;
  }();

  Scope$1.globals = Object.keys(globals$1.builtin);
  Scope$1.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];

  var intToCharMap$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var encode$3 = function encode(number) {
    if (0 <= number && number < intToCharMap$1.length) {
      return intToCharMap$1[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };

  var decode$3 = function decode(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode == plus) {
      return 62;
    }

    if (charCode == slash) {
      return 63;
    }

    return -1;
  };

  var base64$1 = {
    encode: encode$3,
    decode: decode$3
  };

  var VLQ_BASE_SHIFT$1 = 5;
  var VLQ_BASE$1 = 1 << VLQ_BASE_SHIFT$1;
  var VLQ_BASE_MASK$1 = VLQ_BASE$1 - 1;
  var VLQ_CONTINUATION_BIT$1 = VLQ_BASE$1;

  function toVLQSigned$1(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function fromVLQSigned$1(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  var encode$2 = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned$1(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK$1;
      vlq >>>= VLQ_BASE_SHIFT$1;

      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT$1;
      }

      encoded += base64$1.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  var decode$2 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64$1.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT$1);
      digit &= VLQ_BASE_MASK$1;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT$1;
    } while (continuation);

    aOutParam.value = fromVLQSigned$1(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq$1 = {
    encode: encode$2,
    decode: decode$2
  };

  var util$6 = createCommonjsModule(function (module, exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }

    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;

    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);

      if (!match) {
        return null;
      }

      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }

    exports.urlParse = urlParse;

    function urlGenerate(aParsedUrl) {
      var url = '';

      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }

      url += '//';

      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }

      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }

      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }

      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }

      return url;
    }

    exports.urlGenerate = urlGenerate;

    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);

      if (url) {
        if (!url.path) {
          return aPath;
        }

        path = url.path;
      }

      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);

      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];

        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }

      path = parts.join('/');

      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }

      if (url) {
        url.path = path;
        return urlGenerate(url);
      }

      return path;
    }

    exports.normalize = normalize;

    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      if (aPath === "") {
        aPath = ".";
      }

      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);

      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }

      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }

        return urlGenerate(aPathUrl);
      }

      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }

      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }

      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }

      return joined;
    }

    exports.join = join;

    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
    };

    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      aRoot = aRoot.replace(/\/$/, '');
      var level = 0;

      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");

        if (index < 0) {
          return aPath;
        }

        aRoot = aRoot.slice(0, index);

        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }

        ++level;
      }

      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }

    exports.relative = relative;

    var supportsNullProto = function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }();

    function identity(s) {
      return s;
    }

    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }

      return aStr;
    }

    exports.toSetString = supportsNullProto ? identity : toSetString;

    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }

      return aStr;
    }

    exports.fromSetString = supportsNullProto ? identity : fromSetString;

    function isProtoString(s) {
      if (!s) {
        return false;
      }

      var length = s.length;

      if (length < 9) {
          return false;
        }

      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }

      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
            return false;
          }
      }

      return true;
    }

    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByOriginalPositions = compareByOriginalPositions;

    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }

      cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }

      if (aStr1 > aStr2) {
        return 1;
      }

      return -1;
    }

    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }, "/$$rollup_base$$/packages/babel-generator/node_modules/source-map/lib");

  var has$c = Object.prototype.hasOwnProperty;
  var hasNativeMap$1 = typeof Map !== "undefined";

  function ArraySet$5() {
    this._array = [];
    this._set = hasNativeMap$1 ? new Map() : Object.create(null);
  }

  ArraySet$5.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$5();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };

  ArraySet$5.prototype.size = function ArraySet_size() {
    return hasNativeMap$1 ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  ArraySet$5.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap$1 ? aStr : util$6.toSetString(aStr);
    var isDuplicate = hasNativeMap$1 ? this.has(aStr) : has$c.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap$1) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  ArraySet$5.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap$1) {
      return this._set.has(aStr);
    } else {
      var sStr = util$6.toSetString(aStr);
      return has$c.call(this._set, sStr);
    }
  };

  ArraySet$5.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap$1) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util$6.toSetString(aStr);

      if (has$c.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  ArraySet$5.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };

  ArraySet$5.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1$1 = ArraySet$5;
  var arraySet$1 = {
    ArraySet: ArraySet_1$1
  };

  function generatedPositionAfter$1(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util$6.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  function MappingList$3() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  MappingList$3.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  MappingList$3.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter$1(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };

  MappingList$3.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$6.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1$1 = MappingList$3;
  var mappingList$1 = {
    MappingList: MappingList_1$1
  };

  var ArraySet$4 = arraySet$1.ArraySet;
  var MappingList$2 = mappingList$1.MappingList;

  function SourceMapGenerator$5(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util$6.getArg(aArgs, 'file', null);
    this._sourceRoot = util$6.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util$6.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$4();
    this._names = new ArraySet$4();
    this._mappings = new MappingList$2();
    this._sourcesContents = null;
  }

  SourceMapGenerator$5.prototype._version = 3;

  SourceMapGenerator$5.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator$5({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util$6.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  SourceMapGenerator$5.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util$6.getArg(aArgs, 'generated');
    var original = util$6.getArg(aArgs, 'original', null);
    var source = util$6.getArg(aArgs, 'source', null);
    var name = util$6.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  SourceMapGenerator$5.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util$6.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util$6.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util$6.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  SourceMapGenerator$5.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot;

    if (sourceRoot != null) {
      sourceFile = util$6.relative(sourceRoot, sourceFile);
    }

    var newSources = new ArraySet$4();
    var newNames = new ArraySet$4();

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util$6.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util$6.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util$6.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util$6.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  SourceMapGenerator$5.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  SourceMapGenerator$5.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util$6.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq$1.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq$1.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64Vlq$1.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq$1.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq$1.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator$5.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util$6.relative(aSourceRoot, source);
      }

      var key = util$6.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  SourceMapGenerator$5.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

  SourceMapGenerator$5.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1$1 = SourceMapGenerator$5;
  var sourceMapGenerator$1 = {
    SourceMapGenerator: SourceMapGenerator_1$1
  };

  var binarySearch$1 = createCommonjsModule(function (module, exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);

      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }

    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }

      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

      if (index < 0) {
        return -1;
      }

      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }

        --index;
      }

      return index;
    };
  }, "/$$rollup_base$$/packages/babel-generator/node_modules/source-map/lib");

  function swap$1(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  function randomIntInRange$1(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  function doQuickSort$1(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange$1(p, r);
      var i = p - 1;
      swap$1(ary, pivotIndex, r);
      var pivot = ary[r];

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap$1(ary, i, j);
        }
      }

      swap$1(ary, i + 1, j);
      var q = i + 1;
      doQuickSort$1(ary, comparator, p, q - 1);
      doQuickSort$1(ary, comparator, q + 1, r);
    }
  }

  var quickSort_1$1 = function quickSort_1(ary, comparator) {
    doQuickSort$1(ary, comparator, 0, ary.length - 1);
  };

  var quickSort$3 = {
    quickSort: quickSort_1$1
  };

  var ArraySet$3 = arraySet$1.ArraySet;
  var quickSort$2 = quickSort$3.quickSort;

  function SourceMapConsumer$3(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer$1(sourceMap) : new BasicSourceMapConsumer$1(sourceMap);
  }

  SourceMapConsumer$3.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer$1.fromSourceMap(aSourceMap);
  };

  SourceMapConsumer$3.prototype._version = 3;
  SourceMapConsumer$3.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer$3.prototype, '_generatedMappings', {
    get: function get() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer$3.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer$3.prototype, '_originalMappings', {
    get: function get() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer$3.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  SourceMapConsumer$3.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer$3.GENERATED_ORDER = 1;
  SourceMapConsumer$3.ORIGINAL_ORDER = 2;
  SourceMapConsumer$3.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer$3.LEAST_UPPER_BOUND = 2;

  SourceMapConsumer$3.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer$3.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer$3.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer$3.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);

      if (source != null && sourceRoot != null) {
        source = util$6.join(sourceRoot, source);
      }

      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  SourceMapConsumer$3.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util$6.getArg(aArgs, 'line');
    var needle = {
      source: util$6.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util$6.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util$6.relative(this.sourceRoot, needle.source);
    }

    if (!this._sources.has(needle.source)) {
      return [];
    }

    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$6.compareByOriginalPositions, binarySearch$1.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util$6.getArg(mapping, 'generatedLine', null),
            column: util$6.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$6.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util$6.getArg(mapping, 'generatedLine', null),
            column: util$6.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$6.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1$1 = SourceMapConsumer$3;

  function BasicSourceMapConsumer$1(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$6.getArg(sourceMap, 'version');
    var sources = util$6.getArg(sourceMap, 'sources');
    var names = util$6.getArg(sourceMap, 'names', []);
    var sourceRoot = util$6.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util$6.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util$6.getArg(sourceMap, 'mappings');
    var file = util$6.getArg(sourceMap, 'file', null);

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources.map(String).map(util$6.normalize).map(function (source) {
      return sourceRoot && util$6.isAbsolute(sourceRoot) && util$6.isAbsolute(source) ? util$6.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet$3.fromArray(names.map(String), true);
    this._sources = ArraySet$3.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer$1.prototype = Object.create(SourceMapConsumer$3.prototype);
  BasicSourceMapConsumer$1.prototype.consumer = SourceMapConsumer$3;

  BasicSourceMapConsumer$1.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer$1.prototype);
    var names = smc._names = ArraySet$3.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet$3.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping$1();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort$2(smc.__originalMappings, util$6.compareByOriginalPositions);
    return smc;
  };

  BasicSourceMapConsumer$1.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer$1.prototype, 'sources', {
    get: function get() {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util$6.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  function Mapping$1() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  BasicSourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping$1();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64Vlq$1.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort$2(generatedMappings, util$6.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort$2(originalMappings, util$6.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  BasicSourceMapConsumer$1.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch$1.search(aNeedle, aMappings, aComparator, aBias);
  };

  BasicSourceMapConsumer$1.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      mapping.lastGeneratedColumn = Infinity;
    }
  };

  BasicSourceMapConsumer$1.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$6.getArg(aArgs, 'line'),
      generatedColumn: util$6.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$6.compareByGeneratedPositionsDeflated, util$6.getArg(aArgs, 'bias', SourceMapConsumer$3.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util$6.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);

          if (this.sourceRoot != null) {
            source = util$6.join(this.sourceRoot, source);
          }
        }

        var name = util$6.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util$6.getArg(mapping, 'originalLine', null),
          column: util$6.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  BasicSourceMapConsumer$1.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  BasicSourceMapConsumer$1.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util$6.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;

    if (this.sourceRoot != null && (url = util$6.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  BasicSourceMapConsumer$1.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util$6.getArg(aArgs, 'source');

    if (this.sourceRoot != null) {
      source = util$6.relative(this.sourceRoot, source);
    }

    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util$6.getArg(aArgs, 'line'),
      originalColumn: util$6.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$6.compareByOriginalPositions, util$6.getArg(aArgs, 'bias', SourceMapConsumer$3.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util$6.getArg(mapping, 'generatedLine', null),
          column: util$6.getArg(mapping, 'generatedColumn', null),
          lastColumn: util$6.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  var BasicSourceMapConsumer_1$1 = BasicSourceMapConsumer$1;

  function IndexedSourceMapConsumer$1(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$6.getArg(sourceMap, 'version');
    var sections = util$6.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet$3();
    this._names = new ArraySet$3();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util$6.getArg(s, 'offset');
      var offsetLine = util$6.getArg(offset, 'line');
      var offsetColumn = util$6.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer$3(util$6.getArg(s, 'map'))
      };
    });
  }

  IndexedSourceMapConsumer$1.prototype = Object.create(SourceMapConsumer$3.prototype);
  IndexedSourceMapConsumer$1.prototype.constructor = SourceMapConsumer$3;
  IndexedSourceMapConsumer$1.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer$1.prototype, 'sources', {
    get: function get() {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });

  IndexedSourceMapConsumer$1.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$6.getArg(aArgs, 'line'),
      generatedColumn: util$6.getArg(aArgs, 'column')
    };
    var sectionIndex = binarySearch$1.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  IndexedSourceMapConsumer$1.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  IndexedSourceMapConsumer$1.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  IndexedSourceMapConsumer$1.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      if (section.consumer.sources.indexOf(util$6.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

  IndexedSourceMapConsumer$1.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        if (section.consumer.sourceRoot !== null) {
          source = util$6.join(section.consumer.sourceRoot, source);
        }

        this._sources.add(source);

        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort$2(this.__generatedMappings, util$6.compareByGeneratedPositionsDeflated);
    quickSort$2(this.__originalMappings, util$6.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1$1 = IndexedSourceMapConsumer$1;
  var sourceMapConsumer$1 = {
    SourceMapConsumer: SourceMapConsumer_1$1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1$1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1$1
  };

  var SourceMapGenerator$4 = sourceMapGenerator$1.SourceMapGenerator;
  var REGEX_NEWLINE$1 = /(\r?\n)/;
  var NEWLINE_CODE$1 = 10;
  var isSourceNode$1 = "$$$isSourceNode$$$";

  function SourceNode$3(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode$1] = true;
    if (aChunks != null) this.add(aChunks);
  }

  SourceNode$3.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode$3();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE$1);
    var remainingLinesIndex = 0;

    var shiftNextLine = function shiftNextLine() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }

      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this);

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }

      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util$6.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util$6.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode$3(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  SourceNode$3.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode$1] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode$3.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode$1] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode$3.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode$1]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  SourceNode$3.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };

  SourceNode$3.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode$1]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };

  SourceNode$3.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util$6.toSetString(aSourceFile)] = aSourceContent;
  };

  SourceNode$3.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode$1]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util$6.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  SourceNode$3.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  SourceNode$3.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$4(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE$1) {
          generated.line++;
          generated.column = 0;

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  var SourceNode_1$1 = SourceNode$3;
  var sourceNode$1 = {
    SourceNode: SourceNode_1$1
  };

  var SourceMapGenerator$3 = sourceMapGenerator$1.SourceMapGenerator;
  var SourceMapConsumer$2 = sourceMapConsumer$1.SourceMapConsumer;
  var SourceNode$2 = sourceNode$1.SourceNode;
  var sourceMap$1 = {
    SourceMapGenerator: SourceMapGenerator$3,
    SourceMapConsumer: SourceMapConsumer$2,
    SourceNode: SourceNode$2
  };

  var SourceMap = function () {
    function SourceMap(opts, code) {
      this._cachedMap = void 0;
      this._code = void 0;
      this._opts = void 0;
      this._rawMappings = void 0;
      this._lastGenLine = void 0;
      this._lastSourceLine = void 0;
      this._lastSourceColumn = void 0;
      this._cachedMap = null;
      this._code = code;
      this._opts = opts;
      this._rawMappings = [];
    }

    var _proto = SourceMap.prototype;

    _proto.get = function get() {
      if (!this._cachedMap) {
        var map = this._cachedMap = new sourceMap$1.SourceMapGenerator({
          sourceRoot: this._opts.sourceRoot
        });
        var code = this._code;

        if (typeof code === "string") {
          map.setSourceContent(this._opts.sourceFileName.replace(/\\/g, "/"), code);
        } else if (typeof code === "object") {
          Object.keys(code).forEach(function (sourceFileName) {
            map.setSourceContent(sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          });
        }

        this._rawMappings.forEach(function (mapping) {
          return map.addMapping(mapping);
        }, map);
      }

      return this._cachedMap.toJSON();
    };

    _proto.getRawMappings = function getRawMappings() {
      return this._rawMappings.slice();
    };

    _proto.mark = function mark(generatedLine, generatedColumn, line, column, identifierName, filename, force) {
      if (this._lastGenLine !== generatedLine && line === null) return;

      if (!force && this._lastGenLine === generatedLine && this._lastSourceLine === line && this._lastSourceColumn === column) {
        return;
      }

      this._cachedMap = null;
      this._lastGenLine = generatedLine;
      this._lastSourceLine = line;
      this._lastSourceColumn = column;

      this._rawMappings.push({
        name: identifierName || undefined,
        generated: {
          line: generatedLine,
          column: generatedColumn
        },
        source: line == null ? undefined : (filename || this._opts.sourceFileName).replace(/\\/g, "/"),
        original: line == null ? undefined : {
          line: line,
          column: column
        }
      });
    };

    return SourceMap;
  }();

  var SPACES_RE = /^[ \t]+$/;

  var Buffer = function () {
    function Buffer(map) {
      this._map = null;
      this._buf = [];
      this._last = "";
      this._queue = [];
      this._position = {
        line: 1,
        column: 0
      };
      this._sourcePosition = {
        identifierName: null,
        line: null,
        column: null,
        filename: null
      };
      this._disallowedPop = null;
      this._map = map;
    }

    var _proto = Buffer.prototype;

    _proto.get = function get() {
      this._flush();

      var map = this._map;
      var result = {
        code: this._buf.join("").trimRight(),
        map: null,
        rawMappings: map == null ? void 0 : map.getRawMappings()
      };

      if (map) {
        Object.defineProperty(result, "map", {
          configurable: true,
          enumerable: true,
          get: function get() {
            return this.map = map.get();
          },
          set: function set(value) {
            Object.defineProperty(this, "map", {
              value: value,
              writable: true
            });
          }
        });
      }

      return result;
    };

    _proto.append = function append(str) {
      this._flush();

      var _this$_sourcePosition = this._sourcePosition,
          line = _this$_sourcePosition.line,
          column = _this$_sourcePosition.column,
          filename = _this$_sourcePosition.filename,
          identifierName = _this$_sourcePosition.identifierName,
          force = _this$_sourcePosition.force;

      this._append(str, line, column, identifierName, filename, force);
    };

    _proto.queue = function queue(str) {
      if (str === "\n") {
        while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {
          this._queue.shift();
        }
      }

      var _this$_sourcePosition2 = this._sourcePosition,
          line = _this$_sourcePosition2.line,
          column = _this$_sourcePosition2.column,
          filename = _this$_sourcePosition2.filename,
          identifierName = _this$_sourcePosition2.identifierName,
          force = _this$_sourcePosition2.force;

      this._queue.unshift([str, line, column, identifierName, filename, force]);
    };

    _proto._flush = function _flush() {
      var item;

      while (item = this._queue.pop()) {
        this._append.apply(this, _toConsumableArray(item));
      }
    };

    _proto._append = function _append(str, line, column, identifierName, filename, force) {
      this._buf.push(str);

      this._last = str[str.length - 1];
      var i = str.indexOf("\n");
      var last = 0;

      if (i !== 0) {
        this._mark(line, column, identifierName, filename, force);
      }

      while (i !== -1) {
        this._position.line++;
        this._position.column = 0;
        last = i + 1;

        if (last < str.length) {
          this._mark(++line, 0, identifierName, filename, force);
        }

        i = str.indexOf("\n", last);
      }

      this._position.column += str.length - last;
    };

    _proto._mark = function _mark(line, column, identifierName, filename, force) {
      var _this$_map;

      (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      if (this._queue.length > 0 && this._queue[0][0] === "\n") {
        this._queue.shift();
      }
    };

    _proto.removeLastSemicolon = function removeLastSemicolon() {
      if (this._queue.length > 0 && this._queue[0][0] === ";") {
        this._queue.shift();
      }
    };

    _proto.endsWith = function endsWith(suffix) {
      if (suffix.length === 1) {
        var last;

        if (this._queue.length > 0) {
          var _str = this._queue[0][0];
          last = _str[_str.length - 1];
        } else {
          last = this._last;
        }

        return last === suffix;
      }

      var end = this._last + this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      if (suffix.length <= end.length) {
        return end.slice(-suffix.length) === suffix;
      }

      return false;
    };

    _proto.hasContent = function hasContent() {
      return this._queue.length > 0 || !!this._last;
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this.source("start", loc, true);
      cb();
      this.source("end", loc);

      this._disallowPop("start", loc);
    };

    _proto.source = function source(prop, loc, force) {
      if (prop && !loc) return;

      this._normalizePosition(prop, loc, this._sourcePosition, force);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      if (!this._map) return cb();
      var originalLine = this._sourcePosition.line;
      var originalColumn = this._sourcePosition.column;
      var originalFilename = this._sourcePosition.filename;
      var originalIdentifierName = this._sourcePosition.identifierName;
      this.source(prop, loc);
      cb();

      if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {
        this._sourcePosition.line = originalLine;
        this._sourcePosition.column = originalColumn;
        this._sourcePosition.filename = originalFilename;
        this._sourcePosition.identifierName = originalIdentifierName;
        this._sourcePosition.force = false;
        this._disallowedPop = null;
      }
    };

    _proto._disallowPop = function _disallowPop(prop, loc) {
      if (prop && !loc) return;
      this._disallowedPop = this._normalizePosition(prop, loc);
    };

    _proto._normalizePosition = function _normalizePosition(prop, loc, targetObj, force) {
      var pos = loc ? loc[prop] : null;

      if (targetObj === undefined) {
        targetObj = {
          identifierName: null,
          line: null,
          column: null,
          filename: null,
          force: false
        };
      }

      var origLine = targetObj.line;
      var origColumn = targetObj.column;
      var origFilename = targetObj.filename;
      targetObj.identifierName = prop === "start" && (loc == null ? void 0 : loc.identifierName) || null;
      targetObj.line = pos == null ? void 0 : pos.line;
      targetObj.column = pos == null ? void 0 : pos.column;
      targetObj.filename = loc == null ? void 0 : loc.filename;

      if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {
        targetObj.force = force;
      }

      return targetObj;
    };

    _proto.getCurrentColumn = function getCurrentColumn() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var lastIndex = extra.lastIndexOf("\n");
      return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;
    };

    _proto.getCurrentLine = function getCurrentLine() {
      var extra = this._queue.reduce(function (acc, item) {
        return item[0] + acc;
      }, "");

      var count = 0;

      for (var i = 0; i < extra.length; i++) {
        if (extra[i] === "\n") count++;
      }

      return this._position.line + count;
    };

    return Buffer;
  }();

  function crawl(node, state) {
    if (state === void 0) {
      state = {};
    }

    if (isMemberExpression(node) || isOptionalMemberExpression(node)) {
      crawl(node.object, state);
      if (node.computed) crawl(node.property, state);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      crawl(node.left, state);
      crawl(node.right, state);
    } else if (isCallExpression(node) || isOptionalCallExpression(node)) {
      state.hasCall = true;
      crawl(node.callee, state);
    } else if (isFunction$1(node)) {
      state.hasFunction = true;
    } else if (isIdentifier(node)) {
      state.hasHelper = state.hasHelper || isHelper(node.callee);
    }

    return state;
  }

  function isHelper(node) {
    if (isMemberExpression(node)) {
      return isHelper(node.object) || isHelper(node.property);
    } else if (isIdentifier(node)) {
      return node.name === "require" || node.name[0] === "_";
    } else if (isCallExpression(node)) {
      return isHelper(node.callee);
    } else if (isBinary(node) || isAssignmentExpression(node)) {
      return isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);
    } else {
      return false;
    }
  }

  function isType(node) {
    return isLiteral(node) || isObjectExpression(node) || isArrayExpression(node) || isIdentifier(node) || isMemberExpression(node);
  }

  var nodes = {
    AssignmentExpression: function (_AssignmentExpression) {
      function AssignmentExpression(_x) {
        return _AssignmentExpression.apply(this, arguments);
      }

      AssignmentExpression.toString = function () {
        return _AssignmentExpression.toString();
      };

      return AssignmentExpression;
    }(function (node) {
      var state = crawl(node.right);

      if (state.hasCall && state.hasHelper || state.hasFunction) {
        return {
          before: state.hasFunction,
          after: true
        };
      }
    }),
    SwitchCase: function (_SwitchCase) {
      function SwitchCase(_x2, _x3) {
        return _SwitchCase.apply(this, arguments);
      }

      SwitchCase.toString = function () {
        return _SwitchCase.toString();
      };

      return SwitchCase;
    }(function (node, parent) {
      return {
        before: !!node.consequent.length || parent.cases[0] === node,
        after: !node.consequent.length && parent.cases[parent.cases.length - 1] === node
      };
    }),
    LogicalExpression: function (_LogicalExpression) {
      function LogicalExpression(_x4) {
        return _LogicalExpression.apply(this, arguments);
      }

      LogicalExpression.toString = function () {
        return _LogicalExpression.toString();
      };

      return LogicalExpression;
    }(function (node) {
      if (isFunction$1(node.left) || isFunction$1(node.right)) {
        return {
          after: true
        };
      }
    }),
    Literal: function (_Literal) {
      function Literal(_x5) {
        return _Literal.apply(this, arguments);
      }

      Literal.toString = function () {
        return _Literal.toString();
      };

      return Literal;
    }(function (node) {
      if (isStringLiteral(node) && node.value === "use strict") {
        return {
          after: true
        };
      }
    }),
    CallExpression: function (_CallExpression) {
      function CallExpression(_x6) {
        return _CallExpression.apply(this, arguments);
      }

      CallExpression.toString = function () {
        return _CallExpression.toString();
      };

      return CallExpression;
    }(function (node) {
      if (isFunction$1(node.callee) || isHelper(node)) {
        return {
          before: true,
          after: true
        };
      }
    }),
    OptionalCallExpression: function (_OptionalCallExpression) {
      function OptionalCallExpression(_x7) {
        return _OptionalCallExpression.apply(this, arguments);
      }

      OptionalCallExpression.toString = function () {
        return _OptionalCallExpression.toString();
      };

      return OptionalCallExpression;
    }(function (node) {
      if (isFunction$1(node.callee)) {
        return {
          before: true,
          after: true
        };
      }
    }),
    VariableDeclaration: function (_VariableDeclaration) {
      function VariableDeclaration(_x8) {
        return _VariableDeclaration.apply(this, arguments);
      }

      VariableDeclaration.toString = function () {
        return _VariableDeclaration.toString();
      };

      return VariableDeclaration;
    }(function (node) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        var enabled = isHelper(declar.id) && !isType(declar.init);

        if (!enabled) {
          var state = crawl(declar.init);
          enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
        }

        if (enabled) {
          return {
            before: true,
            after: true
          };
        }
      }
    }),
    IfStatement: function (_IfStatement) {
      function IfStatement(_x9) {
        return _IfStatement.apply(this, arguments);
      }

      IfStatement.toString = function () {
        return _IfStatement.toString();
      };

      return IfStatement;
    }(function (node) {
      if (isBlockStatement(node.consequent)) {
        return {
          before: true,
          after: true
        };
      }
    })
  };

  nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function (node, parent) {
    if (parent.properties[0] === node) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeCallProperty = function (node, parent) {
    var _parent$properties;

    if (parent.callProperties[0] === node && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeIndexer = function (node, parent) {
    var _parent$properties2, _parent$callPropertie;

    if (parent.indexers[0] === node && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
      return {
        before: true
      };
    }
  };

  nodes.ObjectTypeInternalSlot = function (node, parent) {
    var _parent$properties3, _parent$callPropertie2, _parent$indexers;

    if (parent.internalSlots[0] === node && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
      return {
        before: true
      };
    }
  };

  var list$1 = {
    VariableDeclaration: function (_VariableDeclaration2) {
      function VariableDeclaration(_x10) {
        return _VariableDeclaration2.apply(this, arguments);
      }

      VariableDeclaration.toString = function () {
        return _VariableDeclaration2.toString();
      };

      return VariableDeclaration;
    }(function (node) {
      return node.declarations.map(function (decl) {
        return decl.init;
      });
    }),
    ArrayExpression: function (_ArrayExpression) {
      function ArrayExpression(_x11) {
        return _ArrayExpression.apply(this, arguments);
      }

      ArrayExpression.toString = function () {
        return _ArrayExpression.toString();
      };

      return ArrayExpression;
    }(function (node) {
      return node.elements;
    }),
    ObjectExpression: function (_ObjectExpression) {
      function ObjectExpression(_x12) {
        return _ObjectExpression.apply(this, arguments);
      }

      ObjectExpression.toString = function () {
        return _ObjectExpression.toString();
      };

      return ObjectExpression;
    }(function (node) {
      return node.properties;
    })
  };
  [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function (_ref) {
    var _ref2 = _slicedToArray$2(_ref, 2),
        type = _ref2[0],
        amounts = _ref2[1];

    if (typeof amounts === "boolean") {
      amounts = {
        after: amounts,
        before: amounts
      };
    }

    [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function (type) {
      nodes[type] = function () {
        return amounts;
      };
    });
  });

  var PRECEDENCE = {
    "||": 0,
    "??": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    "in": 6,
    "instanceof": 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10
  };

  var isClassExtendsClause = function isClassExtendsClause(node, parent) {
    return (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;
  };

  var hasPostfixPart = function hasPostfixPart(node, parent) {
    return (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);
  };

  function NullableTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation(parent);
  }
  function FunctionTypeAnnotation$1(node, parent, printStack) {
    return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);
  }
  function UpdateExpression$2(node, parent) {
    return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);
  }
  function ObjectExpression$2(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      arrowBody: true
    });
  }
  function DoExpression$1(node, parent, printStack) {
    return !node.async && isFirstInContext(printStack, {
      expressionStatement: true
    });
  }
  function Binary(node, parent) {
    if (node.operator === "**" && isBinaryExpression(parent, {
      operator: "**"
    })) {
      return parent.left === node;
    }

    if (isClassExtendsClause(node, parent)) {
      return true;
    }

    if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {
      return true;
    }

    if (isBinary(parent)) {
      var parentOp = parent.operator;
      var parentPos = PRECEDENCE[parentOp];
      var nodeOp = node.operator;
      var nodePos = PRECEDENCE[nodeOp];

      if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {
        return true;
      }
    }
  }
  function UnionTypeAnnotation$1(node, parent) {
    return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);
  }
  function OptionalIndexedAccessType$1(node, parent) {
    return isIndexedAccessType(parent, {
      objectType: node
    });
  }
  function TSAsExpression$1() {
    return true;
  }
  function TSTypeAssertion$1() {
    return true;
  }
  function TSUnionType$1(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);
  }
  function TSInferType$1(node, parent) {
    return isTSArrayType(parent) || isTSOptionalType(parent);
  }
  function BinaryExpression$1(node, parent) {
    return node.operator === "in" && (isVariableDeclarator(parent) || isFor(parent));
  }
  function SequenceExpression$2(node, parent) {
    if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {
      return false;
    }

    return true;
  }
  function YieldExpression$1(node, parent) {
    return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);
  }
  function ClassExpression(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      exportDefault: true
    });
  }
  function UnaryLike(node, parent) {
    return hasPostfixPart(node, parent) || isBinaryExpression(parent, {
      operator: "**",
      left: node
    }) || isClassExtendsClause(node, parent);
  }
  function FunctionExpression$1(node, parent, printStack) {
    return isFirstInContext(printStack, {
      expressionStatement: true,
      exportDefault: true
    });
  }
  function ArrowFunctionExpression$1(node, parent) {
    return isExportDeclaration(parent) || ConditionalExpression$2(node, parent);
  }
  function ConditionalExpression$2(node, parent) {
    if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {
      test: node
    }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {
      return true;
    }

    return UnaryLike(node, parent);
  }
  function OptionalMemberExpression$1(node, parent) {
    return isCallExpression(parent, {
      callee: node
    }) || isMemberExpression(parent, {
      object: node
    });
  }
  function AssignmentExpression$2(node, parent) {
    if (isObjectPattern(node.left)) {
      return true;
    } else {
      return ConditionalExpression$2(node, parent);
    }
  }
  function LogicalExpression$1(node, parent) {
    switch (node.operator) {
      case "||":
        if (!isLogicalExpression(parent)) return false;
        return parent.operator === "??" || parent.operator === "&&";

      case "&&":
        return isLogicalExpression(parent, {
          operator: "??"
        });

      case "??":
        return isLogicalExpression(parent) && parent.operator !== "??";
    }
  }
  function Identifier$1(node, parent, printStack) {
    if (node.name === "let") {
      var isFollowedByBracket = isMemberExpression(parent, {
        object: node,
        computed: true
      }) || isOptionalMemberExpression(parent, {
        object: node,
        computed: true,
        optional: false
      });
      return isFirstInContext(printStack, {
        expressionStatement: isFollowedByBracket,
        forHead: isFollowedByBracket,
        forInHead: isFollowedByBracket,
        forOfHead: true
      });
    }

    return node.name === "async" && isForOfStatement(parent) && node === parent.left;
  }

  function isFirstInContext(printStack, _ref) {
    var _ref$expressionStatem = _ref.expressionStatement,
        expressionStatement = _ref$expressionStatem === void 0 ? false : _ref$expressionStatem,
        _ref$arrowBody = _ref.arrowBody,
        arrowBody = _ref$arrowBody === void 0 ? false : _ref$arrowBody,
        _ref$exportDefault = _ref.exportDefault,
        exportDefault = _ref$exportDefault === void 0 ? false : _ref$exportDefault,
        _ref$forHead = _ref.forHead,
        forHead = _ref$forHead === void 0 ? false : _ref$forHead,
        _ref$forInHead = _ref.forInHead,
        forInHead = _ref$forInHead === void 0 ? false : _ref$forInHead,
        _ref$forOfHead = _ref.forOfHead,
        forOfHead = _ref$forOfHead === void 0 ? false : _ref$forOfHead;
    var i = printStack.length - 1;
    var node = printStack[i];
    i--;
    var parent = printStack[i];

    while (i >= 0) {
      if (expressionStatement && isExpressionStatement(parent, {
        expression: node
      }) || exportDefault && isExportDefaultDeclaration(parent, {
        declaration: node
      }) || arrowBody && isArrowFunctionExpression(parent, {
        body: node
      }) || forHead && isForStatement(parent, {
        init: node
      }) || forInHead && isForInStatement(parent, {
        left: node
      }) || forOfHead && isForOfStatement(parent, {
        left: node
      })) {
        return true;
      }

      if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {
        test: node
      }) || isBinary(parent, {
        left: node
      }) || isAssignmentExpression(parent, {
        left: node
      })) {
        node = parent;
        i--;
        parent = printStack[i];
      } else {
        return false;
      }
    }

    return false;
  }

  var parens = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NullableTypeAnnotation: NullableTypeAnnotation$1,
    FunctionTypeAnnotation: FunctionTypeAnnotation$1,
    UpdateExpression: UpdateExpression$2,
    ObjectExpression: ObjectExpression$2,
    DoExpression: DoExpression$1,
    Binary: Binary,
    UnionTypeAnnotation: UnionTypeAnnotation$1,
    IntersectionTypeAnnotation: UnionTypeAnnotation$1,
    OptionalIndexedAccessType: OptionalIndexedAccessType$1,
    TSAsExpression: TSAsExpression$1,
    TSTypeAssertion: TSTypeAssertion$1,
    TSUnionType: TSUnionType$1,
    TSIntersectionType: TSUnionType$1,
    TSInferType: TSInferType$1,
    BinaryExpression: BinaryExpression$1,
    SequenceExpression: SequenceExpression$2,
    YieldExpression: YieldExpression$1,
    AwaitExpression: YieldExpression$1,
    ClassExpression: ClassExpression,
    UnaryLike: UnaryLike,
    FunctionExpression: FunctionExpression$1,
    ArrowFunctionExpression: ArrowFunctionExpression$1,
    ConditionalExpression: ConditionalExpression$2,
    OptionalMemberExpression: OptionalMemberExpression$1,
    OptionalCallExpression: OptionalMemberExpression$1,
    AssignmentExpression: AssignmentExpression$2,
    LogicalExpression: LogicalExpression$1,
    Identifier: Identifier$1
  });

  function expandAliases(obj) {
    var newObj = {};

    function add(type, func) {
      var fn = newObj[type];
      newObj[type] = fn ? function (node, parent, stack) {
        var result = fn(node, parent, stack);
        return result == null ? func(node, parent, stack) : result;
      } : func;
    }

    for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
      var type = _Object$keys[_i];
      var aliases = FLIPPED_ALIAS_KEYS[type];

      if (aliases) {
        for (var _iterator = _createForOfIteratorHelperLoose(aliases), _step; !(_step = _iterator()).done;) {
          var alias = _step.value;
          add(alias, obj[type]);
        }
      } else {
        add(type, obj[type]);
      }
    }

    return newObj;
  }

  var expandedParens = expandAliases(parens);
  var expandedWhitespaceNodes = expandAliases(nodes);
  var expandedWhitespaceList = expandAliases(list$1);

  function find$2(obj, node, parent, printStack) {
    var fn = obj[node.type];
    return fn ? fn(node, parent, printStack) : null;
  }

  function isOrHasCallExpression(node) {
    if (isCallExpression(node)) {
      return true;
    }

    return isMemberExpression(node) && isOrHasCallExpression(node.object);
  }

  function needsWhitespace(node, parent, type) {
    if (!node) return 0;

    if (isExpressionStatement(node)) {
      node = node.expression;
    }

    var linesInfo = find$2(expandedWhitespaceNodes, node, parent);

    if (!linesInfo) {
      var items = find$2(expandedWhitespaceList, node, parent);

      if (items) {
        for (var i = 0; i < items.length; i++) {
          linesInfo = needsWhitespace(items[i], node, type);
          if (linesInfo) break;
        }
      }
    }

    if (typeof linesInfo === "object" && linesInfo !== null) {
      return linesInfo[type] || 0;
    }

    return 0;
  }
  function needsWhitespaceBefore(node, parent) {
    return needsWhitespace(node, parent, "before");
  }
  function needsWhitespaceAfter(node, parent) {
    return needsWhitespace(node, parent, "after");
  }
  function needsParens(node, parent, printStack) {
    if (!parent) return false;

    if (isNewExpression(parent) && parent.callee === node) {
      if (isOrHasCallExpression(node)) return true;
    }

    return find$2(expandedParens, node, parent, printStack);
  }

  function TaggedTemplateExpression$1(node) {
    this.print(node.tag, node);
    this.print(node.typeParameters, node);
    this.print(node.quasi, node);
  }
  function TemplateElement(node, parent) {
    var isFirst = parent.quasis[0] === node;
    var isLast = parent.quasis[parent.quasis.length - 1] === node;
    var value = (isFirst ? "`" : "}") + node.value.raw + (isLast ? "`" : "${");
    this.token(value);
  }
  function TemplateLiteral$1(node) {
    var quasis = node.quasis;

    for (var i = 0; i < quasis.length; i++) {
      this.print(quasis[i], node);

      if (i + 1 < quasis.length) {
        this.print(node.expressions[i], node);
      }
    }
  }

  function UnaryExpression$1(node) {
    if (node.operator === "void" || node.operator === "delete" || node.operator === "typeof" || node.operator === "throw") {
      this.word(node.operator);
      this.space();
    } else {
      this.token(node.operator);
    }

    this.print(node.argument, node);
  }
  function DoExpression(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("do");
    this.space();
    this.print(node.body, node);
  }
  function ParenthesizedExpression$1(node) {
    this.token("(");
    this.print(node.expression, node);
    this.token(")");
  }
  function UpdateExpression$1(node) {
    if (node.prefix) {
      this.token(node.operator);
      this.print(node.argument, node);
    } else {
      this.startTerminatorless(true);
      this.print(node.argument, node);
      this.endTerminatorless();
      this.token(node.operator);
    }
  }
  function ConditionalExpression$1(node) {
    this.print(node.test, node);
    this.space();
    this.token("?");
    this.space();
    this.print(node.consequent, node);
    this.space();
    this.token(":");
    this.space();
    this.print(node.alternate, node);
  }
  function NewExpression$1(node, parent) {
    this.word("new");
    this.space();
    this.print(node.callee, node);

    if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {
      callee: node
    }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
      return;
    }

    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function SequenceExpression$1(node) {
    this.printList(node.expressions, node);
  }
  function ThisExpression() {
    this.word("this");
  }
  function Super() {
    this.word("super");
  }
  function Decorator(node) {
    this.token("@");
    this.print(node.expression, node);
    this.newline();
  }
  function OptionalMemberExpression(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (node.optional) {
      this.token("?.");
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      if (!node.optional) {
        this.token(".");
      }

      this.print(node.property, node);
    }
  }
  function OptionalCallExpression(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function CallExpression$1(node) {
    this.print(node.callee, node);
    this.print(node.typeArguments, node);
    this.print(node.typeParameters, node);
    this.token("(");
    this.printList(node.arguments, node);
    this.token(")");
  }
  function Import() {
    this.word("import");
  }

  function buildYieldAwait(keyword) {
    return function (node) {
      this.word(keyword);

      if (node.delegate) {
        this.token("*");
      }

      if (node.argument) {
        this.space();
        var terminatorState = this.startTerminatorless();
        this.print(node.argument, node);
        this.endTerminatorless(terminatorState);
      }
    };
  }

  var YieldExpression = buildYieldAwait("yield");
  var AwaitExpression = buildYieldAwait("await");
  function EmptyStatement() {
    this.semicolon(true);
  }
  function ExpressionStatement(node) {
    this.print(node.expression, node);
    this.semicolon();
  }
  function AssignmentPattern(node) {
    this.print(node.left, node);
    if (node.left.optional) this.token("?");
    this.print(node.left.typeAnnotation, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
  }
  function AssignmentExpression$1(node, parent) {
    var parens = this.inForStatementInitCounter && node.operator === "in" && !needsParens(node, parent);

    if (parens) {
      this.token("(");
    }

    this.print(node.left, node);
    this.space();

    if (node.operator === "in" || node.operator === "instanceof") {
      this.word(node.operator);
    } else {
      this.token(node.operator);
    }

    this.space();
    this.print(node.right, node);

    if (parens) {
      this.token(")");
    }
  }
  function BindExpression(node) {
    this.print(node.object, node);
    this.token("::");
    this.print(node.callee, node);
  }
  function MemberExpression(node) {
    this.print(node.object, node);

    if (!node.computed && isMemberExpression(node.property)) {
      throw new TypeError("Got a MemberExpression for MemberExpression property");
    }

    var computed = node.computed;

    if (isLiteral(node.property) && typeof node.property.value === "number") {
      computed = true;
    }

    if (computed) {
      this.token("[");
      this.print(node.property, node);
      this.token("]");
    } else {
      this.token(".");
      this.print(node.property, node);
    }
  }
  function MetaProperty(node) {
    this.print(node.meta, node);
    this.token(".");
    this.print(node.property, node);
  }
  function PrivateName(node) {
    this.token("#");
    this.print(node.id, node);
  }
  function V8IntrinsicIdentifier(node) {
    this.token("%");
    this.word(node.name);
  }
  function ModuleExpression(node) {
    this.word("module");
    this.space();
    this.token("{");

    if (node.body.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.printSequence(node.body.body, node, {
        indent: true
      });
      this.rightBrace();
    }
  }

  function WithStatement(node) {
    this.word("with");
    this.space();
    this.token("(");
    this.print(node.object, node);
    this.token(")");
    this.printBlock(node);
  }
  function IfStatement(node) {
    this.word("if");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.space();
    var needsBlock = node.alternate && isIfStatement(getLastStatement(node.consequent));

    if (needsBlock) {
      this.token("{");
      this.newline();
      this.indent();
    }

    this.printAndIndentOnComments(node.consequent, node);

    if (needsBlock) {
      this.dedent();
      this.newline();
      this.token("}");
    }

    if (node.alternate) {
      if (this.endsWith("}")) this.space();
      this.word("else");
      this.space();
      this.printAndIndentOnComments(node.alternate, node);
    }
  }

  function getLastStatement(statement) {
    if (!isStatement(statement.body)) return statement;
    return getLastStatement(statement.body);
  }

  function ForStatement(node) {
    this.word("for");
    this.space();
    this.token("(");
    this.inForStatementInitCounter++;
    this.print(node.init, node);
    this.inForStatementInitCounter--;
    this.token(";");

    if (node.test) {
      this.space();
      this.print(node.test, node);
    }

    this.token(";");

    if (node.update) {
      this.space();
      this.print(node.update, node);
    }

    this.token(")");
    this.printBlock(node);
  }
  function WhileStatement(node) {
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.printBlock(node);
  }

  var buildForXStatement = function buildForXStatement(op) {
    return function (node) {
      this.word("for");
      this.space();

      if (op === "of" && node["await"]) {
        this.word("await");
        this.space();
      }

      this.token("(");
      this.print(node.left, node);
      this.space();
      this.word(op);
      this.space();
      this.print(node.right, node);
      this.token(")");
      this.printBlock(node);
    };
  };

  var ForInStatement = buildForXStatement("in");
  var ForOfStatement = buildForXStatement("of");
  function DoWhileStatement(node) {
    this.word("do");
    this.space();
    this.print(node.body, node);
    this.space();
    this.word("while");
    this.space();
    this.token("(");
    this.print(node.test, node);
    this.token(")");
    this.semicolon();
  }

  function buildLabelStatement(prefix, key) {
    if (key === void 0) {
      key = "label";
    }

    return function (node) {
      this.word(prefix);
      var label = node[key];

      if (label) {
        this.space();
        var isLabel = key == "label";
        var terminatorState = this.startTerminatorless(isLabel);
        this.print(label, node);
        this.endTerminatorless(terminatorState);
      }

      this.semicolon();
    };
  }

  var ContinueStatement = buildLabelStatement("continue");
  var ReturnStatement = buildLabelStatement("return", "argument");
  var BreakStatement = buildLabelStatement("break");
  var ThrowStatement = buildLabelStatement("throw", "argument");
  function LabeledStatement(node) {
    this.print(node.label, node);
    this.token(":");
    this.space();
    this.print(node.body, node);
  }
  function TryStatement(node) {
    this.word("try");
    this.space();
    this.print(node.block, node);
    this.space();

    if (node.handlers) {
      this.print(node.handlers[0], node);
    } else {
      this.print(node.handler, node);
    }

    if (node.finalizer) {
      this.space();
      this.word("finally");
      this.space();
      this.print(node.finalizer, node);
    }
  }
  function CatchClause(node) {
    this.word("catch");
    this.space();

    if (node.param) {
      this.token("(");
      this.print(node.param, node);
      this.print(node.param.typeAnnotation, node);
      this.token(")");
      this.space();
    }

    this.print(node.body, node);
  }
  function SwitchStatement(node) {
    this.word("switch");
    this.space();
    this.token("(");
    this.print(node.discriminant, node);
    this.token(")");
    this.space();
    this.token("{");
    this.printSequence(node.cases, node, {
      indent: true,
      addNewlines: function addNewlines(leading, cas) {
        if (!leading && node.cases[node.cases.length - 1] === cas) return -1;
      }
    });
    this.token("}");
  }
  function SwitchCase(node) {
    if (node.test) {
      this.word("case");
      this.space();
      this.print(node.test, node);
      this.token(":");
    } else {
      this.word("default");
      this.token(":");
    }

    if (node.consequent.length) {
      this.newline();
      this.printSequence(node.consequent, node, {
        indent: true
      });
    }
  }
  function DebuggerStatement() {
    this.word("debugger");
    this.semicolon();
  }

  function variableDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 4; i++) {
      this.space(true);
    }
  }

  function constDeclarationIndent() {
    this.token(",");
    this.newline();
    if (this.endsWith("\n")) for (var i = 0; i < 6; i++) {
      this.space(true);
    }
  }

  function VariableDeclaration(node, parent) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this.word(node.kind);
    this.space();
    var hasInits = false;

    if (!isFor(parent)) {
      for (var _iterator = _createForOfIteratorHelperLoose(node.declarations), _step; !(_step = _iterator()).done;) {
        var declar = _step.value;

        if (declar.init) {
          hasInits = true;
        }
      }
    }

    var separator;

    if (hasInits) {
      separator = node.kind === "const" ? constDeclarationIndent : variableDeclarationIndent;
    }

    this.printList(node.declarations, node, {
      separator: separator
    });

    if (isFor(parent)) {
      if (isForStatement(parent)) {
        if (parent.init === node) return;
      } else {
        if (parent.left === node) return;
      }
    }

    this.semicolon();
  }
  function VariableDeclarator$1(node) {
    this.print(node.id, node);
    if (node.definite) this.token("!");
    this.print(node.id.typeAnnotation, node);

    if (node.init) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.init, node);
    }
  }

  function ClassDeclaration(node, parent) {
    if (!this.format.decoratorsBeforeExport || !isExportDefaultDeclaration(parent) && !isExportNamedDeclaration(parent)) {
      this.printJoin(node.decorators, node);
    }

    if (node.declare) {
      this.word("declare");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    this.word("class");

    if (node.id) {
      this.space();
      this.print(node.id, node);
    }

    this.print(node.typeParameters, node);

    if (node.superClass) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.superClass, node);
      this.print(node.superTypeParameters, node);
    }

    if (node["implements"]) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function ClassBody(node) {
    this.token("{");
    this.printInnerComments(node);

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.indent();
      this.printSequence(node.body, node);
      this.dedent();
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    }
  }
  function ClassProperty(node) {
    this.printJoin(node.decorators, node);
    this.source("end", node.key.loc);
    this.tsPrintClassMemberModifiers(node, true);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      this._variance(node);

      this.print(node.key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    if (node.definite) {
      this.token("!");
    }

    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassPrivateProperty(node) {
    this.printJoin(node.decorators, node);

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.key, node);
    this.print(node.typeAnnotation, node);

    if (node.value) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.value, node);
    }

    this.semicolon();
  }
  function ClassMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ClassPrivateMethod(node) {
    this._classMethodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function _classMethodHead(node) {
    this.printJoin(node.decorators, node);
    this.source("end", node.key.loc);
    this.tsPrintClassMemberModifiers(node, false);

    this._methodHead(node);
  }
  function StaticBlock(node) {
    this.word("static");
    this.space();
    this.token("{");

    if (node.body.length === 0) {
      this.token("}");
    } else {
      this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.rightBrace();
    }
  }

  function _params(node) {
    this.print(node.typeParameters, node);
    this.token("(");

    this._parameters(node.params, node);

    this.token(")");
    this.print(node.returnType, node);
  }
  function _parameters(parameters, parent) {
    for (var i = 0; i < parameters.length; i++) {
      this._param(parameters[i], parent);

      if (i < parameters.length - 1) {
        this.token(",");
        this.space();
      }
    }
  }
  function _param(parameter, parent) {
    this.printJoin(parameter.decorators, parameter);
    this.print(parameter, parent);
    if (parameter.optional) this.token("?");
    this.print(parameter.typeAnnotation, parameter);
  }
  function _methodHead(node) {
    var kind = node.kind;
    var key = node.key;

    if (kind === "get" || kind === "set") {
      this.word(kind);
      this.space();
    }

    if (node.async) {
      this._catchUp("start", key.loc);

      this.word("async");
      this.space();
    }

    if (kind === "method" || kind === "init") {
      if (node.generator) {
        this.token("*");
      }
    }

    if (node.computed) {
      this.token("[");
      this.print(key, node);
      this.token("]");
    } else {
      this.print(key, node);
    }

    if (node.optional) {
      this.token("?");
    }

    this._params(node);
  }
  function _predicate(node) {
    if (node.predicate) {
      if (!node.returnType) {
        this.token(":");
      }

      this.space();
      this.print(node.predicate, node);
    }
  }
  function _functionHead(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    this.word("function");
    if (node.generator) this.token("*");
    this.space();

    if (node.id) {
      this.print(node.id, node);
    }

    this._params(node);

    this._predicate(node);
  }
  function FunctionExpression(node) {
    this._functionHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ArrowFunctionExpression(node) {
    if (node.async) {
      this.word("async");
      this.space();
    }

    var firstParam = node.params[0];

    if (!this.format.retainLines && !this.format.auxiliaryCommentBefore && !this.format.auxiliaryCommentAfter && node.params.length === 1 && isIdentifier(firstParam) && !hasTypesOrComments(node, firstParam)) {
      this.print(firstParam, node);
    } else {
      this._params(node);
    }

    this._predicate(node);

    this.space();
    this.token("=>");
    this.space();
    this.print(node.body, node);
  }

  function hasTypesOrComments(node, param) {
    var _param$leadingComment, _param$trailingCommen;

    return !!(node.typeParameters || node.returnType || node.predicate || param.typeAnnotation || param.optional || (_param$leadingComment = param.leadingComments) != null && _param$leadingComment.length || (_param$trailingCommen = param.trailingComments) != null && _param$trailingCommen.length);
  }

  function ImportSpecifier(node) {
    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    this.print(node.imported, node);

    if (node.local && node.local.name !== node.imported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.local, node);
    }
  }
  function ImportDefaultSpecifier(node) {
    this.print(node.local, node);
  }
  function ExportDefaultSpecifier(node) {
    this.print(node.exported, node);
  }
  function ExportSpecifier(node) {
    this.print(node.local, node);

    if (node.exported && node.local.name !== node.exported.name) {
      this.space();
      this.word("as");
      this.space();
      this.print(node.exported, node);
    }
  }
  function ExportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.exported, node);
  }
  function ExportAllDeclaration(node) {
    this.word("export");
    this.space();

    if (node.exportKind === "type") {
      this.word("type");
      this.space();
    }

    this.token("*");
    this.space();
    this.word("from");
    this.space();
    this.print(node.source, node);
    this.printAssertions(node);
    this.semicolon();
  }
  function ExportNamedDeclaration(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }
  function ExportDefaultDeclaration(node) {
    if (this.format.decoratorsBeforeExport && isClassDeclaration(node.declaration)) {
      this.printJoin(node.declaration.decorators, node);
    }

    this.word("export");
    this.space();
    this.word("default");
    this.space();
    ExportDeclaration.apply(this, arguments);
  }

  function ExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      if (node.exportKind === "type") {
        this.word("type");
        this.space();
      }

      var specifiers = node.specifiers.slice(0);
      var hasSpecial = false;

      for (;;) {
        var first = specifiers[0];

        if (isExportDefaultSpecifier(first) || isExportNamespaceSpecifier(first)) {
          hasSpecial = true;
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length || !specifiers.length && !hasSpecial) {
        this.token("{");

        if (specifiers.length) {
          this.space();
          this.printList(specifiers, node);
          this.space();
        }

        this.token("}");
      }

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
        this.printAssertions(node);
      }

      this.semicolon();
    }
  }

  function ImportDeclaration(node) {
    this.word("import");
    this.space();

    if (node.importKind === "type" || node.importKind === "typeof") {
      this.word(node.importKind);
      this.space();
    }

    var specifiers = node.specifiers.slice(0);

    if (specifiers != null && specifiers.length) {
      for (;;) {
        var first = specifiers[0];

        if (isImportDefaultSpecifier(first) || isImportNamespaceSpecifier(first)) {
          this.print(specifiers.shift(), node);

          if (specifiers.length) {
            this.token(",");
            this.space();
          }
        } else {
          break;
        }
      }

      if (specifiers.length) {
        this.token("{");
        this.space();
        this.printList(specifiers, node);
        this.space();
        this.token("}");
      }

      this.space();
      this.word("from");
      this.space();
    }

    this.print(node.source, node);
    this.printAssertions(node);
    {
      var _node$attributes;

      if ((_node$attributes = node.attributes) != null && _node$attributes.length) {
        this.space();
        this.word("with");
        this.space();
        this.printList(node.attributes, node);
      }
    }
    this.semicolon();
  }
  function ImportAttribute(node) {
    this.print(node.key);
    this.token(":");
    this.space();
    this.print(node.value);
  }
  function ImportNamespaceSpecifier(node) {
    this.token("*");
    this.space();
    this.word("as");
    this.space();
    this.print(node.local, node);
  }

  var byteLength_1 = byteLength;
  var toByteArray_1 = toByteArray;
  var fromByteArray_1 = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }

  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3;
    var parts = [];
    var maxChunkLength = 16383;

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }

    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }

  var base64Js = {
    byteLength: byteLength_1,
    toByteArray: toByteArray_1,
    fromByteArray: fromByteArray_1
  };

  var read = function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  var write = function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  var ieee754 = {
    read: read,
    write: write
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  var buffer = createCommonjsModule(function (module, exports) {

    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      try {
        var arr = new Uint8Array(1);
        arr.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function foo() {
            return 42;
          }
        };
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }

      var buf = new Uint8Array(length);
      buf.__proto__ = Buffer.prototype;
      return buf;
    }

    function Buffer(arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
      Object.defineProperty(Buffer, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }

    Buffer.poolSize = 8192;

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayLike(value);
      }

      if (value == null) {
        throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      var valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      var b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }

    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };

    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }

    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }

    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };

    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);

      if (actual !== length) {
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);

      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      var buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }

      buf.__proto__ = Buffer.prototype;
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype;
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          buf = Buffer.from(buf);
        }

        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }

        buf.copy(buffer, pos);
        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
      }

      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false;

      if (start === undefined || start < 0) {
        start = 0;
      }

      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      }

      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset;

      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }

      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      }

      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      }

      if (Buffer.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF;

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function latin1Write(buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
            return asciiWrite(this, string, offset, length);

          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length);

          case 'base64':
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64Js.fromByteArray(buf);
      } else {
        return base64Js.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    }

    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }

      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += toHex(buf[i]);
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = '';

      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
      return newBuf;
    };

    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };

    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds');
      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        this.copyWithin(targetStart, start, end);
      } else if (this === target && start < targetStart && targetStart < end) {
        for (var i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    };

    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      }

      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    };

    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      str = str.split('=')[0];
      str = str.trim().replace(INVALID_BASE64_RE, '');
      if (str.length < 2) return '';

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function toHex(n) {
      if (n < 16) return '0' + n.toString(16);
      return n.toString(16);
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          if (!leadSurrogate) {
            if (codePoint > 0xDBFF) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            }

            leadSurrogate = codePoint;
            continue;
          }

          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          }

          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null;

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64Js.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    }

    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      return obj !== obj;
    }
  }, "/$$rollup_base$$/node_modules/buffer");

  var object = {};
  var hasOwnProperty$2 = object.hasOwnProperty;

  var forOwn = function forOwn(object, callback) {
    for (var key in object) {
      if (hasOwnProperty$2.call(object, key)) {
        callback(key, object[key]);
      }
    }
  };

  var extend = function extend(destination, source) {
    if (!source) {
      return destination;
    }

    forOwn(source, function (key, value) {
      destination[key] = value;
    });
    return destination;
  };

  var forEach = function forEach(array, callback) {
    var length = array.length;
    var index = -1;

    while (++index < length) {
      callback(array[index]);
    }
  };

  var toString = object.toString;
  var isArray$1 = Array.isArray;
  var isBuffer = buffer.Buffer.isBuffer;

  var isObject = function isObject(value) {
    return toString.call(value) == '[object Object]';
  };

  var isString = function isString(value) {
    return typeof value == 'string' || toString.call(value) == '[object String]';
  };

  var isNumber = function isNumber(value) {
    return typeof value == 'number' || toString.call(value) == '[object Number]';
  };

  var isFunction = function isFunction(value) {
    return typeof value == 'function';
  };

  var isMap = function isMap(value) {
    return toString.call(value) == '[object Map]';
  };

  var isSet = function isSet(value) {
    return toString.call(value) == '[object Set]';
  };

  var singleEscapes = {
    '"': '\\"',
    '\'': '\\\'',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t'
  };
  var regexSingleEscape = /["'\\\b\f\n\r\t]/;
  var regexDigit = /[0-9]/;
  var regexWhitelist = /[ !#-&\(-\[\]-_a-~]/;

  var jsesc$1 = function jsesc(argument, options) {
    var increaseIndentation = function increaseIndentation() {
      oldIndent = indent;
      ++options.indentLevel;
      indent = options.indent.repeat(options.indentLevel);
    };

    var defaults = {
      'escapeEverything': false,
      'minimal': false,
      'isScriptContext': false,
      'quotes': 'single',
      'wrap': false,
      'es6': false,
      'json': false,
      'compact': true,
      'lowercaseHex': false,
      'numbers': 'decimal',
      'indent': '\t',
      'indentLevel': 0,
      '__inline1__': false,
      '__inline2__': false
    };
    var json = options && options.json;

    if (json) {
      defaults.quotes = 'double';
      defaults.wrap = true;
    }

    options = extend(defaults, options);

    if (options.quotes != 'single' && options.quotes != 'double' && options.quotes != 'backtick') {
      options.quotes = 'single';
    }

    var quote = options.quotes == 'double' ? '"' : options.quotes == 'backtick' ? '`' : '\'';
    var compact = options.compact;
    var lowercaseHex = options.lowercaseHex;
    var indent = options.indent.repeat(options.indentLevel);
    var oldIndent = '';
    var inline1 = options.__inline1__;
    var inline2 = options.__inline2__;
    var newLine = compact ? '' : '\n';
    var result;
    var isEmpty = true;
    var useBinNumbers = options.numbers == 'binary';
    var useOctNumbers = options.numbers == 'octal';
    var useDecNumbers = options.numbers == 'decimal';
    var useHexNumbers = options.numbers == 'hexadecimal';

    if (json && argument && isFunction(argument.toJSON)) {
      argument = argument.toJSON();
    }

    if (!isString(argument)) {
      if (isMap(argument)) {
        if (argument.size == 0) {
          return 'new Map()';
        }

        if (!compact) {
          options.__inline1__ = true;
          options.__inline2__ = false;
        }

        return 'new Map(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isSet(argument)) {
        if (argument.size == 0) {
          return 'new Set()';
        }

        return 'new Set(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isBuffer(argument)) {
        if (argument.length == 0) {
          return 'Buffer.from([])';
        }

        return 'Buffer.from(' + jsesc(Array.from(argument), options) + ')';
      }

      if (isArray$1(argument)) {
        result = [];
        options.wrap = true;

        if (inline1) {
          options.__inline1__ = false;
          options.__inline2__ = true;
        }

        if (!inline2) {
          increaseIndentation();
        }

        forEach(argument, function (value) {
          isEmpty = false;

          if (inline2) {
            options.__inline2__ = false;
          }

          result.push((compact || inline2 ? '' : indent) + jsesc(value, options));
        });

        if (isEmpty) {
          return '[]';
        }

        if (inline2) {
          return '[' + result.join(', ') + ']';
        }

        return '[' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + ']';
      } else if (isNumber(argument)) {
        if (json) {
          return JSON.stringify(argument);
        }

        if (useDecNumbers) {
          return String(argument);
        }

        if (useHexNumbers) {
          var hexadecimal = argument.toString(16);

          if (!lowercaseHex) {
            hexadecimal = hexadecimal.toUpperCase();
          }

          return '0x' + hexadecimal;
        }

        if (useBinNumbers) {
          return '0b' + argument.toString(2);
        }

        if (useOctNumbers) {
          return '0o' + argument.toString(8);
        }
      } else if (!isObject(argument)) {
        if (json) {
          return JSON.stringify(argument) || 'null';
        }

        return String(argument);
      } else {
        result = [];
        options.wrap = true;
        increaseIndentation();
        forOwn(argument, function (key, value) {
          isEmpty = false;
          result.push((compact ? '' : indent) + jsesc(key, options) + ':' + (compact ? '' : ' ') + jsesc(value, options));
        });

        if (isEmpty) {
          return '{}';
        }

        return '{' + newLine + result.join(',' + newLine) + newLine + (compact ? '' : oldIndent) + '}';
      }
    }

    var string = argument;
    var index = -1;
    var length = string.length;
    result = '';

    while (++index < length) {
      var character = string.charAt(index);

      if (options.es6) {
        var first = string.charCodeAt(index);

        if (first >= 0xD800 && first <= 0xDBFF && length > index + 1) {
            var second = string.charCodeAt(index + 1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              var codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;

              var _hexadecimal2 = codePoint.toString(16);

              if (!lowercaseHex) {
                _hexadecimal2 = _hexadecimal2.toUpperCase();
              }

              result += "\\u{" + _hexadecimal2 + '}';
              ++index;
              continue;
            }
          }
      }

      if (!options.escapeEverything) {
        if (regexWhitelist.test(character)) {
          result += character;
          continue;
        }

        if (character == '"') {
          result += quote == character ? '\\"' : character;
          continue;
        }

        if (character == '`') {
          result += quote == character ? '\\`' : character;
          continue;
        }

        if (character == '\'') {
          result += quote == character ? '\\\'' : character;
          continue;
        }
      }

      if (character == '\0' && !json && !regexDigit.test(string.charAt(index + 1))) {
        result += '\\0';
        continue;
      }

      if (regexSingleEscape.test(character)) {
        result += singleEscapes[character];
        continue;
      }

      var charCode = character.charCodeAt(0);

      if (options.minimal && charCode != 0x2028 && charCode != 0x2029) {
        result += character;
        continue;
      }

      var _hexadecimal = charCode.toString(16);

      if (!lowercaseHex) {
        _hexadecimal = _hexadecimal.toUpperCase();
      }

      var longhand = _hexadecimal.length > 2 || json;

      var escaped = '\\' + (longhand ? 'u' : 'x') + ('0000' + _hexadecimal).slice(longhand ? -4 : -2);

      result += escaped;
      continue;
    }

    if (options.wrap) {
      result = quote + result + quote;
    }

    if (quote == '`') {
      result = result.replace(/\$\{/g, '\\\$\{');
    }

    if (options.isScriptContext) {
      return result.replace(/<\/(script|style)/gi, '<\\/$1').replace(/<!--/g, json ? "\\u003C!--" : '\\x3C!--');
    }

    return result;
  };

  jsesc$1.version = '2.5.2';
  var jsesc_1 = jsesc$1;

  var jsesc = jsesc_1;

  function Identifier(node) {
    var _this = this;

    this.exactSource(node.loc, function () {
      _this.word(node.name);
    });
  }
  function ArgumentPlaceholder() {
    this.token("?");
  }
  function RestElement$1(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function ObjectExpression$1(node) {
    var props = node.properties;
    this.token("{");
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token("}");
  }
  function ObjectMethod(node) {
    this.printJoin(node.decorators, node);

    this._methodHead(node);

    this.space();
    this.print(node.body, node);
  }
  function ObjectProperty(node) {
    this.printJoin(node.decorators, node);

    if (node.computed) {
      this.token("[");
      this.print(node.key, node);
      this.token("]");
    } else {
      if (isAssignmentPattern(node.value) && isIdentifier(node.key) && node.key.name === node.value.left.name) {
        this.print(node.value, node);
        return;
      }

      this.print(node.key, node);

      if (node.shorthand && isIdentifier(node.key) && isIdentifier(node.value) && node.key.name === node.value.name) {
        return;
      }
    }

    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ArrayExpression$1(node) {
    var elems = node.elements;
    var len = elems.length;
    this.token("[");
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      } else {
        this.token(",");
      }
    }

    this.token("]");
  }
  function RecordExpression(node) {
    var props = node.properties;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "{|";
      endToken = "|}";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#{";
      endToken = "}";
    } else {
      throw new Error("The \"recordAndTupleSyntaxType\" generator option must be \"bar\" or \"hash\" (" + JSON.stringify(this.format.recordAndTupleSyntaxType) + " received).");
    }

    this.token(startToken);
    this.printInnerComments(node);

    if (props.length) {
      this.space();
      this.printList(props, node, {
        indent: true,
        statement: true
      });
      this.space();
    }

    this.token(endToken);
  }
  function TupleExpression(node) {
    var elems = node.elements;
    var len = elems.length;
    var startToken;
    var endToken;

    if (this.format.recordAndTupleSyntaxType === "bar") {
      startToken = "[|";
      endToken = "|]";
    } else if (this.format.recordAndTupleSyntaxType === "hash") {
      startToken = "#[";
      endToken = "]";
    } else {
      throw new Error(this.format.recordAndTupleSyntaxType + " is not a valid recordAndTuple syntax type");
    }

    this.token(startToken);
    this.printInnerComments(node);

    for (var i = 0; i < elems.length; i++) {
      var elem = elems[i];

      if (elem) {
        if (i > 0) this.space();
        this.print(elem, node);
        if (i < len - 1) this.token(",");
      }
    }

    this.token(endToken);
  }
  function RegExpLiteral$1(node) {
    this.word("/" + node.pattern + "/" + node.flags);
  }
  function BooleanLiteral$1(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteral$1() {
    this.word("null");
  }
  function NumericLiteral$2(node) {
    var raw = this.getPossibleRaw(node);
    var opts = this.format.jsescOption;
    var value = node.value + "";

    if (opts.numbers) {
      this.number(jsesc(node.value, opts));
    } else if (raw == null) {
      this.number(value);
    } else if (this.format.minified) {
      this.number(raw.length < value.length ? raw : value);
    } else {
      this.number(raw);
    }
  }
  function StringLiteral$2(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.token(raw);
      return;
    }

    var val = jsesc(node.value, Object.assign(this.format.jsescOption, this.format.jsonCompatibleStrings && {
      json: true
    }));
    return this.token(val);
  }
  function BigIntLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "n");
  }
  function DecimalLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (!this.format.minified && raw != null) {
      this.word(raw);
      return;
    }

    this.word(node.value + "m");
  }
  function PipelineTopicExpression(node) {
    this.print(node.expression, node);
  }
  function PipelineBareFunction(node) {
    this.print(node.callee, node);
  }
  function PipelinePrimaryTopicReference() {
    this.token("#");
  }

  function AnyTypeAnnotation() {
    this.word("any");
  }
  function ArrayTypeAnnotation(node) {
    this.print(node.elementType, node);
    this.token("[");
    this.token("]");
  }
  function BooleanTypeAnnotation() {
    this.word("boolean");
  }
  function BooleanLiteralTypeAnnotation(node) {
    this.word(node.value ? "true" : "false");
  }
  function NullLiteralTypeAnnotation() {
    this.word("null");
  }
  function DeclareClass(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("class");
    this.space();

    this._interfaceish(node);
  }
  function DeclareFunction(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("function");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation.typeAnnotation, node);

    if (node.predicate) {
      this.space();
      this.print(node.predicate, node);
    }

    this.semicolon();
  }
  function InferredPredicate() {
    this.token("%");
    this.word("checks");
  }
  function DeclaredPredicate(node) {
    this.token("%");
    this.word("checks");
    this.token("(");
    this.print(node.value, node);
    this.token(")");
  }
  function DeclareInterface(node) {
    this.word("declare");
    this.space();
    this.InterfaceDeclaration(node);
  }
  function DeclareModule(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.space();
    this.print(node.id, node);
    this.space();
    this.print(node.body, node);
  }
  function DeclareModuleExports(node) {
    this.word("declare");
    this.space();
    this.word("module");
    this.token(".");
    this.word("exports");
    this.print(node.typeAnnotation, node);
  }
  function DeclareTypeAlias(node) {
    this.word("declare");
    this.space();
    this.TypeAlias(node);
  }
  function DeclareOpaqueType(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.OpaqueType(node);
  }
  function DeclareVariable(node, parent) {
    if (!isDeclareExportDeclaration(parent)) {
      this.word("declare");
      this.space();
    }

    this.word("var");
    this.space();
    this.print(node.id, node);
    this.print(node.id.typeAnnotation, node);
    this.semicolon();
  }
  function DeclareExportDeclaration(node) {
    this.word("declare");
    this.space();
    this.word("export");
    this.space();

    if (node["default"]) {
      this.word("default");
      this.space();
    }

    FlowExportDeclaration.apply(this, arguments);
  }
  function DeclareExportAllDeclaration() {
    this.word("declare");
    this.space();
    ExportAllDeclaration.apply(this, arguments);
  }
  function EnumDeclaration(node) {
    var id = node.id,
        body = node.body;
    this.word("enum");
    this.space();
    this.print(id, node);
    this.print(body, node);
  }

  function enumExplicitType(context, name, hasExplicitType) {
    if (hasExplicitType) {
      context.space();
      context.word("of");
      context.space();
      context.word(name);
    }

    context.space();
  }

  function enumBody(context, node) {
    var members = node.members;
    context.token("{");
    context.indent();
    context.newline();

    for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
      var member = _step.value;
      context.print(member, node);
      context.newline();
    }

    if (node.hasUnknownMembers) {
      context.token("...");
      context.newline();
    }

    context.dedent();
    context.token("}");
  }

  function EnumBooleanBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "boolean", explicitType);
    enumBody(this, node);
  }
  function EnumNumberBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "number", explicitType);
    enumBody(this, node);
  }
  function EnumStringBody(node) {
    var explicitType = node.explicitType;
    enumExplicitType(this, "string", explicitType);
    enumBody(this, node);
  }
  function EnumSymbolBody(node) {
    enumExplicitType(this, "symbol", true);
    enumBody(this, node);
  }
  function EnumDefaultedMember(node) {
    var id = node.id;
    this.print(id, node);
    this.token(",");
  }

  function enumInitializedMember(context, node) {
    var id = node.id,
        init = node.init;
    context.print(id, node);
    context.space();
    context.token("=");
    context.space();
    context.print(init, node);
    context.token(",");
  }

  function EnumBooleanMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumNumberMember(node) {
    enumInitializedMember(this, node);
  }
  function EnumStringMember(node) {
    enumInitializedMember(this, node);
  }

  function FlowExportDeclaration(node) {
    if (node.declaration) {
      var declar = node.declaration;
      this.print(declar, node);
      if (!isStatement(declar)) this.semicolon();
    } else {
      this.token("{");

      if (node.specifiers.length) {
        this.space();
        this.printList(node.specifiers, node);
        this.space();
      }

      this.token("}");

      if (node.source) {
        this.space();
        this.word("from");
        this.space();
        this.print(node.source, node);
      }

      this.semicolon();
    }
  }

  function ExistsTypeAnnotation() {
    this.token("*");
  }
  function FunctionTypeAnnotation(node, parent) {
    this.print(node.typeParameters, node);
    this.token("(");

    if (node["this"]) {
      this.word("this");
      this.token(":");
      this.space();
      this.print(node["this"].typeAnnotation, node);

      if (node.params.length || node.rest) {
        this.token(",");
        this.space();
      }
    }

    this.printList(node.params, node);

    if (node.rest) {
      if (node.params.length) {
        this.token(",");
        this.space();
      }

      this.token("...");
      this.print(node.rest, node);
    }

    this.token(")");

    if (parent.type === "ObjectTypeCallProperty" || parent.type === "DeclareFunction" || parent.type === "ObjectTypeProperty" && parent.method) {
      this.token(":");
    } else {
      this.space();
      this.token("=>");
    }

    this.space();
    this.print(node.returnType, node);
  }
  function FunctionTypeParam(node) {
    this.print(node.name, node);
    if (node.optional) this.token("?");

    if (node.name) {
      this.token(":");
      this.space();
    }

    this.print(node.typeAnnotation, node);
  }
  function InterfaceExtends(node) {
    this.print(node.id, node);
    this.print(node.typeParameters, node);
  }
  function _interfaceish(node) {
    var _node$extends;

    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if ((_node$extends = node["extends"]) != null && _node$extends.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    if (node.mixins && node.mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins, node);
    }

    if (node["implements"] && node["implements"].length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node["implements"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function _variance(node) {
    if (node.variance) {
      if (node.variance.kind === "plus") {
        this.token("+");
      } else if (node.variance.kind === "minus") {
        this.token("-");
      }
    }
  }
  function InterfaceDeclaration(node) {
    this.word("interface");
    this.space();

    this._interfaceish(node);
  }

  function andSeparator() {
    this.space();
    this.token("&");
    this.space();
  }

  function InterfaceTypeAnnotation(node) {
    this.word("interface");

    if (node["extends"] && node["extends"].length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(node["extends"], node);
    }

    this.space();
    this.print(node.body, node);
  }
  function IntersectionTypeAnnotation(node) {
    this.printJoin(node.types, node, {
      separator: andSeparator
    });
  }
  function MixedTypeAnnotation() {
    this.word("mixed");
  }
  function EmptyTypeAnnotation() {
    this.word("empty");
  }
  function NullableTypeAnnotation(node) {
    this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function NumberTypeAnnotation() {
    this.word("number");
  }
  function StringTypeAnnotation() {
    this.word("string");
  }
  function ThisTypeAnnotation() {
    this.word("this");
  }
  function TupleTypeAnnotation(node) {
    this.token("[");
    this.printList(node.types, node);
    this.token("]");
  }
  function TypeofTypeAnnotation(node) {
    this.word("typeof");
    this.space();
    this.print(node.argument, node);
  }
  function TypeAlias(node) {
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(node.right, node);
    this.semicolon();
  }
  function TypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TypeParameter(node) {
    this._variance(node);

    this.word(node.name);

    if (node.bound) {
      this.print(node.bound, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function OpaqueType(node) {
    this.word("opaque");
    this.space();
    this.word("type");
    this.space();
    this.print(node.id, node);
    this.print(node.typeParameters, node);

    if (node.supertype) {
      this.token(":");
      this.space();
      this.print(node.supertype, node);
    }

    if (node.impltype) {
      this.space();
      this.token("=");
      this.space();
      this.print(node.impltype, node);
    }

    this.semicolon();
  }
  function ObjectTypeAnnotation(node) {
    var _this = this;

    if (node.exact) {
      this.token("{|");
    } else {
      this.token("{");
    }

    var props = [].concat(_toConsumableArray(node.properties), _toConsumableArray(node.callProperties || []), _toConsumableArray(node.indexers || []), _toConsumableArray(node.internalSlots || []));

    if (props.length) {
      this.space();
      this.printJoin(props, node, {
        addNewlines: function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        },
        indent: true,
        statement: true,
        iterator: function iterator() {
          if (props.length !== 1 || node.inexact) {
            _this.token(",");

            _this.space();
          }
        }
      });
      this.space();
    }

    if (node.inexact) {
      this.indent();
      this.token("...");

      if (props.length) {
        this.newline();
      }

      this.dedent();
    }

    if (node.exact) {
      this.token("|}");
    } else {
      this.token("}");
    }
  }
  function ObjectTypeInternalSlot(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.token("[");
    this.token("[");
    this.print(node.id, node);
    this.token("]");
    this.token("]");
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeCallProperty(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeIndexer(node) {
    if (node["static"]) {
      this.word("static");
      this.space();
    }

    this._variance(node);

    this.token("[");

    if (node.id) {
      this.print(node.id, node);
      this.token(":");
      this.space();
    }

    this.print(node.key, node);
    this.token("]");
    this.token(":");
    this.space();
    this.print(node.value, node);
  }
  function ObjectTypeProperty(node) {
    if (node.proto) {
      this.word("proto");
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    if (node.kind === "get" || node.kind === "set") {
      this.word(node.kind);
      this.space();
    }

    this._variance(node);

    this.print(node.key, node);
    if (node.optional) this.token("?");

    if (!node.method) {
      this.token(":");
      this.space();
    }

    this.print(node.value, node);
  }
  function ObjectTypeSpreadProperty(node) {
    this.token("...");
    this.print(node.argument, node);
  }
  function QualifiedTypeIdentifier(node) {
    this.print(node.qualification, node);
    this.token(".");
    this.print(node.id, node);
  }
  function SymbolTypeAnnotation() {
    this.word("symbol");
  }

  function orSeparator() {
    this.space();
    this.token("|");
    this.space();
  }

  function UnionTypeAnnotation(node) {
    this.printJoin(node.types, node, {
      separator: orSeparator
    });
  }
  function TypeCastExpression$1(node) {
    this.token("(");
    this.print(node.expression, node);
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function Variance(node) {
    if (node.kind === "plus") {
      this.token("+");
    } else {
      this.token("-");
    }
  }
  function VoidTypeAnnotation() {
    this.word("void");
  }
  function IndexedAccessType(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }
  function OptionalIndexedAccessType(node) {
    this.print(node.objectType, node);

    if (node.optional) {
      this.token("?.");
    }

    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }

  function File$1(node) {
    if (node.program) {
      this.print(node.program.interpreter, node);
    }

    this.print(node.program, node);
  }
  function Program(node) {
    this.printInnerComments(node, false);
    this.printSequence(node.directives, node);
    if (node.directives && node.directives.length) this.newline();
    this.printSequence(node.body, node);
  }
  function BlockStatement(node) {
    var _node$directives;

    this.token("{");
    this.printInnerComments(node);
    var hasDirectives = (_node$directives = node.directives) == null ? void 0 : _node$directives.length;

    if (node.body.length || hasDirectives) {
      this.newline();
      this.printSequence(node.directives, node, {
        indent: true
      });
      if (hasDirectives) this.newline();
      this.printSequence(node.body, node, {
        indent: true
      });
      this.removeTrailingNewline();
      this.source("end", node.loc);
      if (!this.endsWith("\n")) this.newline();
      this.rightBrace();
    } else {
      this.source("end", node.loc);
      this.token("}");
    }
  }
  function Directive(node) {
    this.print(node.value, node);
    this.semicolon();
  }
  var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
  var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
  function DirectiveLiteral(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
      return;
    }

    var value = node.value;

    if (!unescapedDoubleQuoteRE.test(value)) {
      this.token("\"" + value + "\"");
    } else if (!unescapedSingleQuoteRE.test(value)) {
      this.token("'" + value + "'");
    } else {
      throw new Error("Malformed AST: it is not possible to print a directive containing" + " both unescaped single and double quotes.");
    }
  }
  function InterpreterDirective(node) {
    this.token("#!" + node.value + "\n");
  }
  function Placeholder(node) {
    this.token("%%");
    this.print(node.name);
    this.token("%%");

    if (node.expectedNode === "Statement") {
      this.semicolon();
    }
  }

  function JSXAttribute(node) {
    this.print(node.name, node);

    if (node.value) {
      this.token("=");
      this.print(node.value, node);
    }
  }
  function JSXIdentifier$1(node) {
    this.word(node.name);
  }
  function JSXNamespacedName(node) {
    this.print(node.namespace, node);
    this.token(":");
    this.print(node.name, node);
  }
  function JSXMemberExpression(node) {
    this.print(node.object, node);
    this.token(".");
    this.print(node.property, node);
  }
  function JSXSpreadAttribute(node) {
    this.token("{");
    this.token("...");
    this.print(node.argument, node);
    this.token("}");
  }
  function JSXExpressionContainer(node) {
    this.token("{");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXSpreadChild(node) {
    this.token("{");
    this.token("...");
    this.print(node.expression, node);
    this.token("}");
  }
  function JSXText$1(node) {
    var raw = this.getPossibleRaw(node);

    if (raw != null) {
      this.token(raw);
    } else {
      this.token(node.value);
    }
  }
  function JSXElement(node) {
    var open = node.openingElement;
    this.print(open, node);
    if (open.selfClosing) return;
    this.indent();

    for (var _iterator = _createForOfIteratorHelperLoose(node.children), _step; !(_step = _iterator()).done;) {
      var child = _step.value;
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingElement, node);
  }

  function spaceSeparator() {
    this.space();
  }

  function JSXOpeningElement(node) {
    this.token("<");
    this.print(node.name, node);
    this.print(node.typeParameters, node);

    if (node.attributes.length > 0) {
      this.space();
      this.printJoin(node.attributes, node, {
        separator: spaceSeparator
      });
    }

    if (node.selfClosing) {
      this.space();
      this.token("/>");
    } else {
      this.token(">");
    }
  }
  function JSXClosingElement(node) {
    this.token("</");
    this.print(node.name, node);
    this.token(">");
  }
  function JSXEmptyExpression(node) {
    this.printInnerComments(node);
  }
  function JSXFragment(node) {
    this.print(node.openingFragment, node);
    this.indent();

    for (var _iterator2 = _createForOfIteratorHelperLoose(node.children), _step2; !(_step2 = _iterator2()).done;) {
      var child = _step2.value;
      this.print(child, node);
    }

    this.dedent();
    this.print(node.closingFragment, node);
  }
  function JSXOpeningFragment() {
    this.token("<");
    this.token(">");
  }
  function JSXClosingFragment() {
    this.token("</");
    this.token(">");
  }

  function TSTypeAnnotation(node) {
    this.token(":");
    this.space();
    if (node.optional) this.token("?");
    this.print(node.typeAnnotation, node);
  }
  function TSTypeParameterInstantiation(node) {
    this.token("<");
    this.printList(node.params, node, {});
    this.token(">");
  }
  function TSTypeParameter(node) {
    this.word(node.name);

    if (node.constraint) {
      this.space();
      this.word("extends");
      this.space();
      this.print(node.constraint, node);
    }

    if (node["default"]) {
      this.space();
      this.token("=");
      this.space();
      this.print(node["default"], node);
    }
  }
  function TSParameterProperty(node) {
    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node.readonly) {
      this.word("readonly");
      this.space();
    }

    this._param(node.parameter);
  }
  function TSDeclareFunction(node) {
    if (node.declare) {
      this.word("declare");
      this.space();
    }

    this._functionHead(node);

    this.token(";");
  }
  function TSDeclareMethod(node) {
    this._classMethodHead(node);

    this.token(";");
  }
  function TSQualifiedName(node) {
    this.print(node.left, node);
    this.token(".");
    this.print(node.right, node);
  }
  function TSCallSignatureDeclaration(node) {
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSConstructSignatureDeclaration(node) {
    this.word("new");
    this.space();
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSPropertySignature(node) {
    var readonly = node.readonly,
        initializer = node.initializer;

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.print(node.typeAnnotation, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(";");
  }
  function tsPrintPropertyOrMethodName(node) {
    if (node.computed) {
      this.token("[");
    }

    this.print(node.key, node);

    if (node.computed) {
      this.token("]");
    }

    if (node.optional) {
      this.token("?");
    }
  }
  function TSMethodSignature(node) {
    var kind = node.kind;

    if (kind === "set" || kind === "get") {
      this.word(kind);
      this.space();
    }

    this.tsPrintPropertyOrMethodName(node);
    this.tsPrintSignatureDeclarationBase(node);
    this.token(";");
  }
  function TSIndexSignature(node) {
    var readonly = node.readonly,
        isStatic = node["static"];

    if (isStatic) {
      this.word("static");
      this.space();
    }

    if (readonly) {
      this.word("readonly");
      this.space();
    }

    this.token("[");

    this._parameters(node.parameters, node);

    this.token("]");
    this.print(node.typeAnnotation, node);
    this.token(";");
  }
  function TSAnyKeyword() {
    this.word("any");
  }
  function TSBigIntKeyword() {
    this.word("bigint");
  }
  function TSUnknownKeyword() {
    this.word("unknown");
  }
  function TSNumberKeyword() {
    this.word("number");
  }
  function TSObjectKeyword() {
    this.word("object");
  }
  function TSBooleanKeyword() {
    this.word("boolean");
  }
  function TSStringKeyword() {
    this.word("string");
  }
  function TSSymbolKeyword() {
    this.word("symbol");
  }
  function TSVoidKeyword() {
    this.word("void");
  }
  function TSUndefinedKeyword() {
    this.word("undefined");
  }
  function TSNullKeyword() {
    this.word("null");
  }
  function TSNeverKeyword() {
    this.word("never");
  }
  function TSIntrinsicKeyword() {
    this.word("intrinsic");
  }
  function TSThisType() {
    this.word("this");
  }
  function TSFunctionType(node) {
    this.tsPrintFunctionOrConstructorType(node);
  }
  function TSConstructorType(node) {
    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    this.word("new");
    this.space();
    this.tsPrintFunctionOrConstructorType(node);
  }
  function tsPrintFunctionOrConstructorType(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.space();
    this.token("=>");
    this.space();
    this.print(node.typeAnnotation.typeAnnotation, node);
  }
  function TSTypeReference(node) {
    this.print(node.typeName, node);
    this.print(node.typeParameters, node);
  }
  function TSTypePredicate(node) {
    if (node.asserts) {
      this.word("asserts");
      this.space();
    }

    this.print(node.parameterName);

    if (node.typeAnnotation) {
      this.space();
      this.word("is");
      this.space();
      this.print(node.typeAnnotation.typeAnnotation);
    }
  }
  function TSTypeQuery(node) {
    this.word("typeof");
    this.space();
    this.print(node.exprName);
  }
  function TSTypeLiteral(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);
  }
  function tsPrintTypeLiteralOrInterfaceBody(members, node) {
    this.tsPrintBraced(members, node);
  }
  function tsPrintBraced(members, node) {
    this.token("{");

    if (members.length) {
      this.indent();
      this.newline();

      for (var _iterator = _createForOfIteratorHelperLoose(members), _step; !(_step = _iterator()).done;) {
        var member = _step.value;
        this.print(member, node);
        this.newline();
      }

      this.dedent();
      this.rightBrace();
    } else {
      this.token("}");
    }
  }
  function TSArrayType(node) {
    this.print(node.elementType, node);
    this.token("[]");
  }
  function TSTupleType(node) {
    this.token("[");
    this.printList(node.elementTypes, node);
    this.token("]");
  }
  function TSOptionalType(node) {
    this.print(node.typeAnnotation, node);
    this.token("?");
  }
  function TSRestType(node) {
    this.token("...");
    this.print(node.typeAnnotation, node);
  }
  function TSNamedTupleMember(node) {
    this.print(node.label, node);
    if (node.optional) this.token("?");
    this.token(":");
    this.space();
    this.print(node.elementType, node);
  }
  function TSUnionType(node) {
    this.tsPrintUnionOrIntersectionType(node, "|");
  }
  function TSIntersectionType(node) {
    this.tsPrintUnionOrIntersectionType(node, "&");
  }
  function tsPrintUnionOrIntersectionType(node, sep) {
    this.printJoin(node.types, node, {
      separator: function separator() {
        this.space();
        this.token(sep);
        this.space();
      }
    });
  }
  function TSConditionalType(node) {
    this.print(node.checkType);
    this.space();
    this.word("extends");
    this.space();
    this.print(node.extendsType);
    this.space();
    this.token("?");
    this.space();
    this.print(node.trueType);
    this.space();
    this.token(":");
    this.space();
    this.print(node.falseType);
  }
  function TSInferType(node) {
    this.token("infer");
    this.space();
    this.print(node.typeParameter);
  }
  function TSParenthesizedType(node) {
    this.token("(");
    this.print(node.typeAnnotation, node);
    this.token(")");
  }
  function TSTypeOperator(node) {
    this.word(node.operator);
    this.space();
    this.print(node.typeAnnotation, node);
  }
  function TSIndexedAccessType(node) {
    this.print(node.objectType, node);
    this.token("[");
    this.print(node.indexType, node);
    this.token("]");
  }
  function TSMappedType(node) {
    var nameType = node.nameType,
        optional = node.optional,
        readonly = node.readonly,
        typeParameter = node.typeParameter;
    this.token("{");
    this.space();

    if (readonly) {
      tokenIfPlusMinus(this, readonly);
      this.word("readonly");
      this.space();
    }

    this.token("[");
    this.word(typeParameter.name);
    this.space();
    this.word("in");
    this.space();
    this.print(typeParameter.constraint, typeParameter);

    if (nameType) {
      this.space();
      this.word("as");
      this.space();
      this.print(nameType, node);
    }

    this.token("]");

    if (optional) {
      tokenIfPlusMinus(this, optional);
      this.token("?");
    }

    this.token(":");
    this.space();
    this.print(node.typeAnnotation, node);
    this.space();
    this.token("}");
  }

  function tokenIfPlusMinus(self, tok) {
    if (tok !== true) {
      self.token(tok);
    }
  }

  function TSLiteralType(node) {
    this.print(node.literal, node);
  }
  function TSExpressionWithTypeArguments(node) {
    this.print(node.expression, node);
    this.print(node.typeParameters, node);
  }
  function TSInterfaceDeclaration(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        extendz = node["extends"],
        body = node.body;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("interface");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);

    if (extendz != null && extendz.length) {
      this.space();
      this.word("extends");
      this.space();
      this.printList(extendz, node);
    }

    this.space();
    this.print(body, node);
  }
  function TSInterfaceBody(node) {
    this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);
  }
  function TSTypeAliasDeclaration(node) {
    var declare = node.declare,
        id = node.id,
        typeParameters = node.typeParameters,
        typeAnnotation = node.typeAnnotation;

    if (declare) {
      this.word("declare");
      this.space();
    }

    this.word("type");
    this.space();
    this.print(id, node);
    this.print(typeParameters, node);
    this.space();
    this.token("=");
    this.space();
    this.print(typeAnnotation, node);
    this.token(";");
  }
  function TSAsExpression(node) {
    var expression = node.expression,
        typeAnnotation = node.typeAnnotation;
    this.print(expression, node);
    this.space();
    this.word("as");
    this.space();
    this.print(typeAnnotation, node);
  }
  function TSTypeAssertion(node) {
    var typeAnnotation = node.typeAnnotation,
        expression = node.expression;
    this.token("<");
    this.print(typeAnnotation, node);
    this.token(">");
    this.space();
    this.print(expression, node);
  }
  function TSEnumDeclaration(node) {
    var declare = node.declare,
        isConst = node["const"],
        id = node.id,
        members = node.members;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (isConst) {
      this.word("const");
      this.space();
    }

    this.word("enum");
    this.space();
    this.print(id, node);
    this.space();
    this.tsPrintBraced(members, node);
  }
  function TSEnumMember(node) {
    var id = node.id,
        initializer = node.initializer;
    this.print(id, node);

    if (initializer) {
      this.space();
      this.token("=");
      this.space();
      this.print(initializer, node);
    }

    this.token(",");
  }
  function TSModuleDeclaration(node) {
    var declare = node.declare,
        id = node.id;

    if (declare) {
      this.word("declare");
      this.space();
    }

    if (!node.global) {
      this.word(id.type === "Identifier" ? "namespace" : "module");
      this.space();
    }

    this.print(id, node);

    if (!node.body) {
      this.token(";");
      return;
    }

    var body = node.body;

    while (body.type === "TSModuleDeclaration") {
      this.token(".");
      this.print(body.id, body);
      body = body.body;
    }

    this.space();
    this.print(body, node);
  }
  function TSModuleBlock(node) {
    this.tsPrintBraced(node.body, node);
  }
  function TSImportType(node) {
    var argument = node.argument,
        qualifier = node.qualifier,
        typeParameters = node.typeParameters;
    this.word("import");
    this.token("(");
    this.print(argument, node);
    this.token(")");

    if (qualifier) {
      this.token(".");
      this.print(qualifier, node);
    }

    if (typeParameters) {
      this.print(typeParameters, node);
    }
  }
  function TSImportEqualsDeclaration(node) {
    var isExport = node.isExport,
        id = node.id,
        moduleReference = node.moduleReference;

    if (isExport) {
      this.word("export");
      this.space();
    }

    this.word("import");
    this.space();
    this.print(id, node);
    this.space();
    this.token("=");
    this.space();
    this.print(moduleReference, node);
    this.token(";");
  }
  function TSExternalModuleReference(node) {
    this.token("require(");
    this.print(node.expression, node);
    this.token(")");
  }
  function TSNonNullExpression(node) {
    this.print(node.expression, node);
    this.token("!");
  }
  function TSExportAssignment(node) {
    this.word("export");
    this.space();
    this.token("=");
    this.space();
    this.print(node.expression, node);
    this.token(";");
  }
  function TSNamespaceExportDeclaration(node) {
    this.word("export");
    this.space();
    this.word("as");
    this.space();
    this.word("namespace");
    this.space();
    this.print(node.id, node);
  }
  function tsPrintSignatureDeclarationBase(node) {
    var typeParameters = node.typeParameters,
        parameters = node.parameters;
    this.print(typeParameters, node);
    this.token("(");

    this._parameters(parameters, node);

    this.token(")");
    this.print(node.typeAnnotation, node);
  }
  function tsPrintClassMemberModifiers(node, isField) {
    if (isField && node.declare) {
      this.word("declare");
      this.space();
    }

    if (node.accessibility) {
      this.word(node.accessibility);
      this.space();
    }

    if (node["static"]) {
      this.word("static");
      this.space();
    }

    if (node.override) {
      this.word("override");
      this.space();
    }

    if (node["abstract"]) {
      this.word("abstract");
      this.space();
    }

    if (isField && node.readonly) {
      this.word("readonly");
      this.space();
    }
  }

  var generatorFunctions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    TaggedTemplateExpression: TaggedTemplateExpression$1,
    TemplateElement: TemplateElement,
    TemplateLiteral: TemplateLiteral$1,
    UnaryExpression: UnaryExpression$1,
    DoExpression: DoExpression,
    ParenthesizedExpression: ParenthesizedExpression$1,
    UpdateExpression: UpdateExpression$1,
    ConditionalExpression: ConditionalExpression$1,
    NewExpression: NewExpression$1,
    SequenceExpression: SequenceExpression$1,
    ThisExpression: ThisExpression,
    Super: Super,
    Decorator: Decorator,
    OptionalMemberExpression: OptionalMemberExpression,
    OptionalCallExpression: OptionalCallExpression,
    CallExpression: CallExpression$1,
    Import: Import,
    YieldExpression: YieldExpression,
    AwaitExpression: AwaitExpression,
    EmptyStatement: EmptyStatement,
    ExpressionStatement: ExpressionStatement,
    AssignmentPattern: AssignmentPattern,
    AssignmentExpression: AssignmentExpression$1,
    BindExpression: BindExpression,
    BinaryExpression: AssignmentExpression$1,
    LogicalExpression: AssignmentExpression$1,
    MemberExpression: MemberExpression,
    MetaProperty: MetaProperty,
    PrivateName: PrivateName,
    V8IntrinsicIdentifier: V8IntrinsicIdentifier,
    ModuleExpression: ModuleExpression,
    WithStatement: WithStatement,
    IfStatement: IfStatement,
    ForStatement: ForStatement,
    WhileStatement: WhileStatement,
    ForInStatement: ForInStatement,
    ForOfStatement: ForOfStatement,
    DoWhileStatement: DoWhileStatement,
    ContinueStatement: ContinueStatement,
    ReturnStatement: ReturnStatement,
    BreakStatement: BreakStatement,
    ThrowStatement: ThrowStatement,
    LabeledStatement: LabeledStatement,
    TryStatement: TryStatement,
    CatchClause: CatchClause,
    SwitchStatement: SwitchStatement,
    SwitchCase: SwitchCase,
    DebuggerStatement: DebuggerStatement,
    VariableDeclaration: VariableDeclaration,
    VariableDeclarator: VariableDeclarator$1,
    ClassDeclaration: ClassDeclaration,
    ClassExpression: ClassDeclaration,
    ClassBody: ClassBody,
    ClassProperty: ClassProperty,
    ClassPrivateProperty: ClassPrivateProperty,
    ClassMethod: ClassMethod,
    ClassPrivateMethod: ClassPrivateMethod,
    _classMethodHead: _classMethodHead,
    StaticBlock: StaticBlock,
    _params: _params,
    _parameters: _parameters,
    _param: _param,
    _methodHead: _methodHead,
    _predicate: _predicate,
    _functionHead: _functionHead,
    FunctionExpression: FunctionExpression,
    FunctionDeclaration: FunctionExpression,
    ArrowFunctionExpression: ArrowFunctionExpression,
    ImportSpecifier: ImportSpecifier,
    ImportDefaultSpecifier: ImportDefaultSpecifier,
    ExportDefaultSpecifier: ExportDefaultSpecifier,
    ExportSpecifier: ExportSpecifier,
    ExportNamespaceSpecifier: ExportNamespaceSpecifier,
    ExportAllDeclaration: ExportAllDeclaration,
    ExportNamedDeclaration: ExportNamedDeclaration,
    ExportDefaultDeclaration: ExportDefaultDeclaration,
    ImportDeclaration: ImportDeclaration,
    ImportAttribute: ImportAttribute,
    ImportNamespaceSpecifier: ImportNamespaceSpecifier,
    Identifier: Identifier,
    ArgumentPlaceholder: ArgumentPlaceholder,
    RestElement: RestElement$1,
    SpreadElement: RestElement$1,
    ObjectExpression: ObjectExpression$1,
    ObjectPattern: ObjectExpression$1,
    ObjectMethod: ObjectMethod,
    ObjectProperty: ObjectProperty,
    ArrayExpression: ArrayExpression$1,
    ArrayPattern: ArrayExpression$1,
    RecordExpression: RecordExpression,
    TupleExpression: TupleExpression,
    RegExpLiteral: RegExpLiteral$1,
    BooleanLiteral: BooleanLiteral$1,
    NullLiteral: NullLiteral$1,
    NumericLiteral: NumericLiteral$2,
    StringLiteral: StringLiteral$2,
    BigIntLiteral: BigIntLiteral,
    DecimalLiteral: DecimalLiteral,
    PipelineTopicExpression: PipelineTopicExpression,
    PipelineBareFunction: PipelineBareFunction,
    PipelinePrimaryTopicReference: PipelinePrimaryTopicReference,
    NumberLiteralTypeAnnotation: NumericLiteral$2,
    StringLiteralTypeAnnotation: StringLiteral$2,
    AnyTypeAnnotation: AnyTypeAnnotation,
    ArrayTypeAnnotation: ArrayTypeAnnotation,
    BooleanTypeAnnotation: BooleanTypeAnnotation,
    BooleanLiteralTypeAnnotation: BooleanLiteralTypeAnnotation,
    NullLiteralTypeAnnotation: NullLiteralTypeAnnotation,
    DeclareClass: DeclareClass,
    DeclareFunction: DeclareFunction,
    InferredPredicate: InferredPredicate,
    DeclaredPredicate: DeclaredPredicate,
    DeclareInterface: DeclareInterface,
    DeclareModule: DeclareModule,
    DeclareModuleExports: DeclareModuleExports,
    DeclareTypeAlias: DeclareTypeAlias,
    DeclareOpaqueType: DeclareOpaqueType,
    DeclareVariable: DeclareVariable,
    DeclareExportDeclaration: DeclareExportDeclaration,
    DeclareExportAllDeclaration: DeclareExportAllDeclaration,
    EnumDeclaration: EnumDeclaration,
    EnumBooleanBody: EnumBooleanBody,
    EnumNumberBody: EnumNumberBody,
    EnumStringBody: EnumStringBody,
    EnumSymbolBody: EnumSymbolBody,
    EnumDefaultedMember: EnumDefaultedMember,
    EnumBooleanMember: EnumBooleanMember,
    EnumNumberMember: EnumNumberMember,
    EnumStringMember: EnumStringMember,
    ExistsTypeAnnotation: ExistsTypeAnnotation,
    FunctionTypeAnnotation: FunctionTypeAnnotation,
    FunctionTypeParam: FunctionTypeParam,
    InterfaceExtends: InterfaceExtends,
    ClassImplements: InterfaceExtends,
    GenericTypeAnnotation: InterfaceExtends,
    _interfaceish: _interfaceish,
    _variance: _variance,
    InterfaceDeclaration: InterfaceDeclaration,
    InterfaceTypeAnnotation: InterfaceTypeAnnotation,
    IntersectionTypeAnnotation: IntersectionTypeAnnotation,
    MixedTypeAnnotation: MixedTypeAnnotation,
    EmptyTypeAnnotation: EmptyTypeAnnotation,
    NullableTypeAnnotation: NullableTypeAnnotation,
    NumberTypeAnnotation: NumberTypeAnnotation,
    StringTypeAnnotation: StringTypeAnnotation,
    ThisTypeAnnotation: ThisTypeAnnotation,
    TupleTypeAnnotation: TupleTypeAnnotation,
    TypeofTypeAnnotation: TypeofTypeAnnotation,
    TypeAlias: TypeAlias,
    TypeAnnotation: TypeAnnotation,
    TypeParameterInstantiation: TypeParameterInstantiation,
    TypeParameterDeclaration: TypeParameterInstantiation,
    TypeParameter: TypeParameter,
    OpaqueType: OpaqueType,
    ObjectTypeAnnotation: ObjectTypeAnnotation,
    ObjectTypeInternalSlot: ObjectTypeInternalSlot,
    ObjectTypeCallProperty: ObjectTypeCallProperty,
    ObjectTypeIndexer: ObjectTypeIndexer,
    ObjectTypeProperty: ObjectTypeProperty,
    ObjectTypeSpreadProperty: ObjectTypeSpreadProperty,
    QualifiedTypeIdentifier: QualifiedTypeIdentifier,
    SymbolTypeAnnotation: SymbolTypeAnnotation,
    UnionTypeAnnotation: UnionTypeAnnotation,
    TypeCastExpression: TypeCastExpression$1,
    Variance: Variance,
    VoidTypeAnnotation: VoidTypeAnnotation,
    IndexedAccessType: IndexedAccessType,
    OptionalIndexedAccessType: OptionalIndexedAccessType,
    File: File$1,
    Program: Program,
    BlockStatement: BlockStatement,
    Directive: Directive,
    DirectiveLiteral: DirectiveLiteral,
    InterpreterDirective: InterpreterDirective,
    Placeholder: Placeholder,
    JSXAttribute: JSXAttribute,
    JSXIdentifier: JSXIdentifier$1,
    JSXNamespacedName: JSXNamespacedName,
    JSXMemberExpression: JSXMemberExpression,
    JSXSpreadAttribute: JSXSpreadAttribute,
    JSXExpressionContainer: JSXExpressionContainer,
    JSXSpreadChild: JSXSpreadChild,
    JSXText: JSXText$1,
    JSXElement: JSXElement,
    JSXOpeningElement: JSXOpeningElement,
    JSXClosingElement: JSXClosingElement,
    JSXEmptyExpression: JSXEmptyExpression,
    JSXFragment: JSXFragment,
    JSXOpeningFragment: JSXOpeningFragment,
    JSXClosingFragment: JSXClosingFragment,
    TSTypeAnnotation: TSTypeAnnotation,
    TSTypeParameterInstantiation: TSTypeParameterInstantiation,
    TSTypeParameterDeclaration: TSTypeParameterInstantiation,
    TSTypeParameter: TSTypeParameter,
    TSParameterProperty: TSParameterProperty,
    TSDeclareFunction: TSDeclareFunction,
    TSDeclareMethod: TSDeclareMethod,
    TSQualifiedName: TSQualifiedName,
    TSCallSignatureDeclaration: TSCallSignatureDeclaration,
    TSConstructSignatureDeclaration: TSConstructSignatureDeclaration,
    TSPropertySignature: TSPropertySignature,
    tsPrintPropertyOrMethodName: tsPrintPropertyOrMethodName,
    TSMethodSignature: TSMethodSignature,
    TSIndexSignature: TSIndexSignature,
    TSAnyKeyword: TSAnyKeyword,
    TSBigIntKeyword: TSBigIntKeyword,
    TSUnknownKeyword: TSUnknownKeyword,
    TSNumberKeyword: TSNumberKeyword,
    TSObjectKeyword: TSObjectKeyword,
    TSBooleanKeyword: TSBooleanKeyword,
    TSStringKeyword: TSStringKeyword,
    TSSymbolKeyword: TSSymbolKeyword,
    TSVoidKeyword: TSVoidKeyword,
    TSUndefinedKeyword: TSUndefinedKeyword,
    TSNullKeyword: TSNullKeyword,
    TSNeverKeyword: TSNeverKeyword,
    TSIntrinsicKeyword: TSIntrinsicKeyword,
    TSThisType: TSThisType,
    TSFunctionType: TSFunctionType,
    TSConstructorType: TSConstructorType,
    tsPrintFunctionOrConstructorType: tsPrintFunctionOrConstructorType,
    TSTypeReference: TSTypeReference,
    TSTypePredicate: TSTypePredicate,
    TSTypeQuery: TSTypeQuery,
    TSTypeLiteral: TSTypeLiteral,
    tsPrintTypeLiteralOrInterfaceBody: tsPrintTypeLiteralOrInterfaceBody,
    tsPrintBraced: tsPrintBraced,
    TSArrayType: TSArrayType,
    TSTupleType: TSTupleType,
    TSOptionalType: TSOptionalType,
    TSRestType: TSRestType,
    TSNamedTupleMember: TSNamedTupleMember,
    TSUnionType: TSUnionType,
    TSIntersectionType: TSIntersectionType,
    tsPrintUnionOrIntersectionType: tsPrintUnionOrIntersectionType,
    TSConditionalType: TSConditionalType,
    TSInferType: TSInferType,
    TSParenthesizedType: TSParenthesizedType,
    TSTypeOperator: TSTypeOperator,
    TSIndexedAccessType: TSIndexedAccessType,
    TSMappedType: TSMappedType,
    TSLiteralType: TSLiteralType,
    TSExpressionWithTypeArguments: TSExpressionWithTypeArguments,
    TSInterfaceDeclaration: TSInterfaceDeclaration,
    TSInterfaceBody: TSInterfaceBody,
    TSTypeAliasDeclaration: TSTypeAliasDeclaration,
    TSAsExpression: TSAsExpression,
    TSTypeAssertion: TSTypeAssertion,
    TSEnumDeclaration: TSEnumDeclaration,
    TSEnumMember: TSEnumMember,
    TSModuleDeclaration: TSModuleDeclaration,
    TSModuleBlock: TSModuleBlock,
    TSImportType: TSImportType,
    TSImportEqualsDeclaration: TSImportEqualsDeclaration,
    TSExternalModuleReference: TSExternalModuleReference,
    TSNonNullExpression: TSNonNullExpression,
    TSExportAssignment: TSExportAssignment,
    TSNamespaceExportDeclaration: TSNamespaceExportDeclaration,
    tsPrintSignatureDeclarationBase: tsPrintSignatureDeclarationBase,
    tsPrintClassMemberModifiers: tsPrintClassMemberModifiers
  });

  var SCIENTIFIC_NOTATION = /e/i;
  var ZERO_DECIMAL_INTEGER = /\.0+$/;
  var NON_DECIMAL_LITERAL = /^0[box]/;
  var PURE_ANNOTATION_RE = /^\s*[@#]__PURE__\s*$/;

  var Printer = function () {
    function Printer(format, map) {
      this.inForStatementInitCounter = 0;
      this._printStack = [];
      this._indent = 0;
      this._insideAux = false;
      this._parenPushNewlineState = null;
      this._noLineTerminator = false;
      this._printAuxAfterOnNextUserNode = false;
      this._printedComments = new WeakSet();
      this._endsWithInteger = false;
      this._endsWithWord = false;
      this.format = format;
      this._buf = new Buffer(map);
    }

    var _proto = Printer.prototype;

    _proto.generate = function generate(ast) {
      this.print(ast);

      this._maybeAddAuxComment();

      return this._buf.get();
    };

    _proto.indent = function indent() {
      if (this.format.compact || this.format.concise) return;
      this._indent++;
    };

    _proto.dedent = function dedent() {
      if (this.format.compact || this.format.concise) return;
      this._indent--;
    };

    _proto.semicolon = function semicolon(force) {
      if (force === void 0) {
        force = false;
      }

      this._maybeAddAuxComment();

      this._append(";", !force);
    };

    _proto.rightBrace = function rightBrace() {
      if (this.format.minified) {
        this._buf.removeLastSemicolon();
      }

      this.token("}");
    };

    _proto.space = function space(force) {
      if (force === void 0) {
        force = false;
      }

      if (this.format.compact) return;

      if (this._buf.hasContent() && !this.endsWith(" ") && !this.endsWith("\n") || force) {
        this._space();
      }
    };

    _proto.word = function word(str) {
      if (this._endsWithWord || this.endsWith("/") && str.indexOf("/") === 0) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);

      this._endsWithWord = true;
    };

    _proto.number = function number(str) {
      this.word(str);
      this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str[str.length - 1] !== ".";
    };

    _proto.token = function token(str) {
      if (str === "--" && this.endsWith("!") || str[0] === "+" && this.endsWith("+") || str[0] === "-" && this.endsWith("-") || str[0] === "." && this._endsWithInteger) {
        this._space();
      }

      this._maybeAddAuxComment();

      this._append(str);
    };

    _proto.newline = function newline(i) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      if (this.endsWith("\n\n")) return;
      if (typeof i !== "number") i = 1;
      i = Math.min(2, i);
      if (this.endsWith("{\n") || this.endsWith(":\n")) i--;
      if (i <= 0) return;

      for (var j = 0; j < i; j++) {
        this._newline();
      }
    };

    _proto.endsWith = function endsWith(str) {
      return this._buf.endsWith(str);
    };

    _proto.removeTrailingNewline = function removeTrailingNewline() {
      this._buf.removeTrailingNewline();
    };

    _proto.exactSource = function exactSource(loc, cb) {
      this._catchUp("start", loc);

      this._buf.exactSource(loc, cb);
    };

    _proto.source = function source(prop, loc) {
      this._catchUp(prop, loc);

      this._buf.source(prop, loc);
    };

    _proto.withSource = function withSource(prop, loc, cb) {
      this._catchUp(prop, loc);

      this._buf.withSource(prop, loc, cb);
    };

    _proto._space = function _space() {
      this._append(" ", true);
    };

    _proto._newline = function _newline() {
      this._append("\n", true);
    };

    _proto._append = function _append(str, queue) {
      if (queue === void 0) {
        queue = false;
      }

      this._maybeAddParen(str);

      this._maybeIndent(str);

      if (queue) this._buf.queue(str);else this._buf.append(str);
      this._endsWithWord = false;
      this._endsWithInteger = false;
    };

    _proto._maybeIndent = function _maybeIndent(str) {
      if (this._indent && this.endsWith("\n") && str[0] !== "\n") {
        this._buf.queue(this._getIndent());
      }
    };

    _proto._maybeAddParen = function _maybeAddParen(str) {
      var parenPushNewlineState = this._parenPushNewlineState;
      if (!parenPushNewlineState) return;
      var i;

      for (i = 0; i < str.length && str[i] === " "; i++) {
        continue;
      }

      if (i === str.length) {
        return;
      }

      var cha = str[i];

      if (cha !== "\n") {
        if (cha !== "/" || i + 1 === str.length) {
          this._parenPushNewlineState = null;
          return;
        }

        var chaPost = str[i + 1];

        if (chaPost === "*") {
          if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {
            return;
          }
        } else if (chaPost !== "/") {
          this._parenPushNewlineState = null;
          return;
        }
      }

      this.token("(");
      this.indent();
      parenPushNewlineState.printed = true;
    };

    _proto._catchUp = function _catchUp(prop, loc) {
      if (!this.format.retainLines) return;
      var pos = loc ? loc[prop] : null;

      if ((pos == null ? void 0 : pos.line) != null) {
        var count = pos.line - this._buf.getCurrentLine();

        for (var i = 0; i < count; i++) {
          this._newline();
        }
      }
    };

    _proto._getIndent = function _getIndent() {
      return this.format.indent.style.repeat(this._indent);
    };

    _proto.startTerminatorless = function startTerminatorless(isLabel) {
      if (isLabel === void 0) {
        isLabel = false;
      }

      if (isLabel) {
        this._noLineTerminator = true;
        return null;
      } else {
        return this._parenPushNewlineState = {
          printed: false
        };
      }
    };

    _proto.endTerminatorless = function endTerminatorless(state) {
      this._noLineTerminator = false;

      if (state != null && state.printed) {
        this.dedent();
        this.newline();
        this.token(")");
      }
    };

    _proto.print = function print(node, parent) {
      var _this = this;

      if (!node) return;
      var oldConcise = this.format.concise;

      if (node._compact) {
        this.format.concise = true;
      }

      var printMethod = this[node.type];

      if (!printMethod) {
        throw new ReferenceError("unknown node of type " + JSON.stringify(node.type) + " with constructor " + JSON.stringify(node == null ? void 0 : node.constructor.name));
      }

      this._printStack.push(node);

      var oldInAux = this._insideAux;
      this._insideAux = !node.loc;

      this._maybeAddAuxComment(this._insideAux && !oldInAux);

      var needsParens$1 = needsParens(node, parent, this._printStack);

      if (this.format.retainFunctionParens && node.type === "FunctionExpression" && node.extra && node.extra.parenthesized) {
        needsParens$1 = true;
      }

      if (needsParens$1) this.token("(");

      this._printLeadingComments(node);

      var loc = isProgram(node) || isFile(node) ? null : node.loc;
      this.withSource("start", loc, function () {
        printMethod.call(_this, node, parent);
      });

      this._printTrailingComments(node);

      if (needsParens$1) this.token(")");

      this._printStack.pop();

      this.format.concise = oldConcise;
      this._insideAux = oldInAux;
    };

    _proto._maybeAddAuxComment = function _maybeAddAuxComment(enteredPositionlessNode) {
      if (enteredPositionlessNode) this._printAuxBeforeComment();
      if (!this._insideAux) this._printAuxAfterComment();
    };

    _proto._printAuxBeforeComment = function _printAuxBeforeComment() {
      if (this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = true;
      var comment = this.format.auxiliaryCommentBefore;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto._printAuxAfterComment = function _printAuxAfterComment() {
      if (!this._printAuxAfterOnNextUserNode) return;
      this._printAuxAfterOnNextUserNode = false;
      var comment = this.format.auxiliaryCommentAfter;

      if (comment) {
        this._printComment({
          type: "CommentBlock",
          value: comment
        });
      }
    };

    _proto.getPossibleRaw = function getPossibleRaw(node) {
      var extra = node.extra;

      if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {
        return extra.raw;
      }
    };

    _proto.printJoin = function printJoin(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (!(nodes != null && nodes.length)) return;
      if (opts.indent) this.indent();
      var newlineOpts = {
        addNewlines: opts.addNewlines
      };

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (!node) continue;
        if (opts.statement) this._printNewline(true, node, parent, newlineOpts);
        this.print(node, parent);

        if (opts.iterator) {
          opts.iterator(node, i);
        }

        if (opts.separator && i < nodes.length - 1) {
          opts.separator.call(this);
        }

        if (opts.statement) this._printNewline(false, node, parent, newlineOpts);
      }

      if (opts.indent) this.dedent();
    };

    _proto.printAndIndentOnComments = function printAndIndentOnComments(node, parent) {
      var indent = node.leadingComments && node.leadingComments.length > 0;
      if (indent) this.indent();
      this.print(node, parent);
      if (indent) this.dedent();
    };

    _proto.printBlock = function printBlock(parent) {
      var node = parent.body;

      if (!isEmptyStatement(node)) {
        this.space();
      }

      this.print(node, parent);
    };

    _proto._printTrailingComments = function _printTrailingComments(node) {
      this._printComments(this._getComments(false, node));
    };

    _proto._printLeadingComments = function _printLeadingComments(node) {
      this._printComments(this._getComments(true, node), true);
    };

    _proto.printInnerComments = function printInnerComments(node, indent) {
      var _node$innerComments;

      if (indent === void 0) {
        indent = true;
      }

      if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;
      if (indent) this.indent();

      this._printComments(node.innerComments);

      if (indent) this.dedent();
    };

    _proto.printSequence = function printSequence(nodes, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      opts.statement = true;
      return this.printJoin(nodes, parent, opts);
    };

    _proto.printList = function printList(items, parent, opts) {
      if (opts === void 0) {
        opts = {};
      }

      if (opts.separator == null) {
        opts.separator = commaSeparator;
      }

      return this.printJoin(items, parent, opts);
    };

    _proto._printNewline = function _printNewline(leading, node, parent, opts) {
      if (this.format.retainLines || this.format.compact) return;

      if (this.format.concise) {
        this.space();
        return;
      }

      var lines = 0;

      if (this._buf.hasContent()) {
        if (!leading) lines++;
        if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;
        var needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;
        if (needs(node, parent)) lines++;
      }

      this.newline(lines);
    };

    _proto._getComments = function _getComments(leading, node) {
      return node && (leading ? node.leadingComments : node.trailingComments) || [];
    };

    _proto._printComment = function _printComment(comment, skipNewLines) {
      var _this2 = this;

      if (!this.format.shouldPrintComment(comment.value)) return;
      if (comment.ignore) return;
      if (this._printedComments.has(comment)) return;

      this._printedComments.add(comment);

      var isBlockComment = comment.type === "CommentBlock";
      var printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;
      if (printNewLines && this._buf.hasContent()) this.newline(1);
      if (!this.endsWith("[") && !this.endsWith("{")) this.space();
      var val = !isBlockComment && !this._noLineTerminator ? "//" + comment.value + "\n" : "/*" + comment.value + "*/";

      if (isBlockComment && this.format.indent.adjustMultilineComment) {
        var _comment$loc;

        var offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;

        if (offset) {
          var newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
          val = val.replace(newlineRegex, "\n");
        }

        var indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());
        val = val.replace(/\n(?!$)/g, "\n" + " ".repeat(indentSize));
      }

      if (this.endsWith("/")) this._space();
      this.withSource("start", comment.loc, function () {
        _this2._append(val);
      });
      if (printNewLines) this.newline(1);
    };

    _proto._printComments = function _printComments(comments, inlinePureAnnotation) {
      if (!(comments != null && comments.length)) return;

      if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {
        this._printComment(comments[0], this._buf.hasContent() && !this.endsWith("\n"));
      } else {
        for (var _iterator = _createForOfIteratorHelperLoose(comments), _step; !(_step = _iterator()).done;) {
          var _comment = _step.value;

          this._printComment(_comment);
        }
      }
    };

    _proto.printAssertions = function printAssertions(node) {
      var _node$assertions;

      if ((_node$assertions = node.assertions) != null && _node$assertions.length) {
        this.space();
        this.word("assert");
        this.space();
        this.token("{");
        this.space();
        this.printList(node.assertions, node);
        this.space();
        this.token("}");
      }
    };

    return Printer;
  }();

  Object.assign(Printer.prototype, generatorFunctions);
  {
    Printer.prototype.Noop = function Noop() {};
  }

  function commaSeparator() {
    this.token(",");
    this.space();
  }

  var Generator = function (_Printer) {
    _inherits(Generator, _Printer);

    function Generator(ast, opts, code) {
      var _this;

      if (opts === void 0) {
        opts = {};
      }

      var format = normalizeOptions$6(code, opts);
      var map = opts.sourceMaps ? new SourceMap(opts, code) : null;
      _this = _Printer.call(this, format, map) || this;
      _this.ast = void 0;
      _this.ast = ast;
      return _this;
    }

    var _proto = Generator.prototype;

    _proto.generate = function generate() {
      return _Printer.prototype.generate.call(this, this.ast);
    };

    return Generator;
  }(Printer);

  function normalizeOptions$6(code, opts) {
    var format = {
      auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
      auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
      shouldPrintComment: opts.shouldPrintComment,
      retainLines: opts.retainLines,
      retainFunctionParens: opts.retainFunctionParens,
      comments: opts.comments == null || opts.comments,
      compact: opts.compact,
      minified: opts.minified,
      concise: opts.concise,
      indent: {
        adjustMultilineComment: true,
        style: "  ",
        base: 0
      },
      decoratorsBeforeExport: !!opts.decoratorsBeforeExport,
      jsescOption: Object.assign({
        quotes: "double",
        wrap: true,
        minimal: false
      }, opts.jsescOption),
      recordAndTupleSyntaxType: opts.recordAndTupleSyntaxType
    };
    {
      format.jsonCompatibleStrings = opts.jsonCompatibleStrings;
    }

    if (format.minified) {
      format.compact = true;

      format.shouldPrintComment = format.shouldPrintComment || function () {
        return format.comments;
      };
    } else {
      format.shouldPrintComment = format.shouldPrintComment || function (value) {
        return format.comments || value.indexOf("@license") >= 0 || value.indexOf("@preserve") >= 0;
      };
    }

    if (format.compact === "auto") {
      format.compact = code.length > 500000;

      if (format.compact) {
        console.error("[BABEL] Note: The code generator has deoptimised the styling of " + (opts.filename + " as it exceeds the max of " + "500KB" + "."));
      }
    }

    if (format.compact) {
      format.indent.adjustMultilineComment = false;
    }

    return format;
  }
  function generate$1(ast, opts, code) {
    var gen = new Generator(ast, opts, code);
    return gen.generate();
  }

  function findParent(callback) {
    var path = this;

    while (path = path.parentPath) {
      if (callback(path)) return path;
    }

    return null;
  }
  function find$1(callback) {
    var path = this;

    do {
      if (callback(path)) return path;
    } while (path = path.parentPath);

    return null;
  }
  function getFunctionParent() {
    return this.findParent(function (p) {
      return p.isFunction();
    });
  }
  function getStatementParent() {
    var path = this;

    do {
      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }

    return path;
  }
  function getEarliestCommonAncestorFrom(paths) {
    return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
      var earliest;
      var keys = VISITOR_KEYS[deepest.type];

      for (var _iterator = _createForOfIteratorHelperLoose(ancestries), _step; !(_step = _iterator()).done;) {
        var ancestry = _step.value;
        var path = ancestry[i + 1];

        if (!earliest) {
          earliest = path;
          continue;
        }

        if (path.listKey && earliest.listKey === path.listKey) {
          if (path.key < earliest.key) {
            earliest = path;
            continue;
          }
        }

        var earliestKeyIndex = keys.indexOf(earliest.parentKey);
        var currentKeyIndex = keys.indexOf(path.parentKey);

        if (earliestKeyIndex > currentKeyIndex) {
          earliest = path;
        }
      }

      return earliest;
    });
  }
  function getDeepestCommonAncestorFrom(paths, filter) {
    var _this = this;

    if (!paths.length) {
      return this;
    }

    if (paths.length === 1) {
      return paths[0];
    }

    var minDepth = Infinity;
    var lastCommonIndex, lastCommon;
    var ancestries = paths.map(function (path) {
      var ancestry = [];

      do {
        ancestry.unshift(path);
      } while ((path = path.parentPath) && path !== _this);

      if (ancestry.length < minDepth) {
        minDepth = ancestry.length;
      }

      return ancestry;
    });
    var first = ancestries[0];

    depthLoop: for (var _i = 0; _i < minDepth; _i++) {
      var shouldMatch = first[_i];

      for (var _iterator2 = _createForOfIteratorHelperLoose(ancestries), _step2; !(_step2 = _iterator2()).done;) {
        var ancestry = _step2.value;

        if (ancestry[_i] !== shouldMatch) {
          break depthLoop;
        }
      }

      lastCommonIndex = _i;
      lastCommon = shouldMatch;
    }

    if (lastCommon) {
      if (filter) {
        return filter(lastCommon, lastCommonIndex, ancestries);
      } else {
        return lastCommon;
      }
    } else {
      throw new Error("Couldn't find intersection");
    }
  }
  function getAncestry() {
    var path = this;
    var paths = [];

    do {
      paths.push(path);
    } while (path = path.parentPath);

    return paths;
  }
  function isAncestor(maybeDescendant) {
    return maybeDescendant.isDescendant(this);
  }
  function isDescendant(maybeAncestor) {
    return !!this.findParent(function (parent) {
      return parent === maybeAncestor;
    });
  }
  function inType() {
    var path = this;

    for (var _len = arguments.length, candidateTypes = new Array(_len), _key = 0; _key < _len; _key++) {
      candidateTypes[_key] = arguments[_key];
    }

    while (path) {
      for (var _iterator3 = _createForOfIteratorHelperLoose(candidateTypes), _step3; !(_step3 = _iterator3()).done;) {
        var type = _step3.value;
        if (path.node.type === type) return true;
      }

      path = path.parentPath;
    }

    return false;
  }

  var NodePath_ancestry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    findParent: findParent,
    find: find$1,
    getFunctionParent: getFunctionParent,
    getStatementParent: getStatementParent,
    getEarliestCommonAncestorFrom: getEarliestCommonAncestorFrom,
    getDeepestCommonAncestorFrom: getDeepestCommonAncestorFrom,
    getAncestry: getAncestry,
    isAncestor: isAncestor,
    isDescendant: isDescendant,
    inType: inType
  });

  function infererReference (node) {
    if (!this.isReferenced()) return;
    var binding = this.scope.getBinding(node.name);

    if (binding) {
      if (binding.identifier.typeAnnotation) {
        return binding.identifier.typeAnnotation;
      } else {
        return getTypeAnnotationBindingConstantViolations(binding, this, node.name);
      }
    }

    if (node.name === "undefined") {
      return voidTypeAnnotation();
    } else if (node.name === "NaN" || node.name === "Infinity") {
      return numberTypeAnnotation();
    } else if (node.name === "arguments") ;
  }

  function getTypeAnnotationBindingConstantViolations(binding, path, name) {
    var types = [];
    var functionConstantViolations = [];
    var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);
    var testType = getConditionalAnnotation(binding, path, name);

    if (testType) {
      var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
      constantViolations = constantViolations.filter(function (path) {
        return testConstantViolations.indexOf(path) < 0;
      });
      types.push(testType.typeAnnotation);
    }

    if (constantViolations.length) {
      constantViolations = constantViolations.concat(functionConstantViolations);

      for (var _iterator = _createForOfIteratorHelperLoose(constantViolations), _step; !(_step = _iterator()).done;) {
        var violation = _step.value;
        types.push(violation.getTypeAnnotation());
      }
    }

    if (!types.length) {
      return;
    }

    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
      return createTSUnionType(types);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(types);
    }

    return createFlowUnionType(types);
  }

  function getConstantViolationsBefore(binding, path, functions) {
    var violations = binding.constantViolations.slice();
    violations.unshift(binding.path);
    return violations.filter(function (violation) {
      violation = violation.resolve();

      var status = violation._guessExecutionStatusRelativeTo(path);

      if (functions && status === "unknown") functions.push(violation);
      return status === "before";
    });
  }

  function inferAnnotationFromBinaryExpression(name, path) {
    var operator = path.node.operator;
    var right = path.get("right").resolve();
    var left = path.get("left").resolve();
    var target;

    if (left.isIdentifier({
      name: name
    })) {
      target = right;
    } else if (right.isIdentifier({
      name: name
    })) {
      target = left;
    }

    if (target) {
      if (operator === "===") {
        return target.getTypeAnnotation();
      }

      if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
        return numberTypeAnnotation();
      }

      return;
    }

    if (operator !== "===" && operator !== "==") return;
    var typeofPath;
    var typePath;

    if (left.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = left;
      typePath = right;
    } else if (right.isUnaryExpression({
      operator: "typeof"
    })) {
      typeofPath = right;
      typePath = left;
    }

    if (!typeofPath) return;
    if (!typeofPath.get("argument").isIdentifier({
      name: name
    })) return;
    typePath = typePath.resolve();
    if (!typePath.isLiteral()) return;
    var typeValue = typePath.node.value;
    if (typeof typeValue !== "string") return;
    return createTypeAnnotationBasedOnTypeof(typeValue);
  }

  function getParentConditionalPath(binding, path, name) {
    var parentPath;

    while (parentPath = path.parentPath) {
      if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
        if (path.key === "test") {
          return;
        }

        return parentPath;
      }

      if (parentPath.isFunction()) {
        if (parentPath.parentPath.scope.getBinding(name) !== binding) return;
      }

      path = parentPath;
    }
  }

  function getConditionalAnnotation(binding, path, name) {
    var ifStatement = getParentConditionalPath(binding, path, name);
    if (!ifStatement) return;
    var test = ifStatement.get("test");
    var paths = [test];
    var types = [];

    for (var i = 0; i < paths.length; i++) {
      var _path = paths[i];

      if (_path.isLogicalExpression()) {
        if (_path.node.operator === "&&") {
          paths.push(_path.get("left"));
          paths.push(_path.get("right"));
        }
      } else if (_path.isBinaryExpression()) {
        var type = inferAnnotationFromBinaryExpression(name, _path);
        if (type) types.push(type);
      }
    }

    if (types.length) {
      if (isTSTypeAnnotation(types[0]) && createTSUnionType) {
        return {
          typeAnnotation: createTSUnionType(types),
          ifStatement: ifStatement
        };
      }

      if (createFlowUnionType) {
        return {
          typeAnnotation: createFlowUnionType(types),
          ifStatement: ifStatement
        };
      }

      return {
        typeAnnotation: createFlowUnionType(types),
        ifStatement: ifStatement
      };
    }

    return getConditionalAnnotation(ifStatement, name);
  }

  function VariableDeclarator() {
    var _type;

    var id = this.get("id");
    if (!id.isIdentifier()) return;
    var init = this.get("init");
    var type = init.getTypeAnnotation();

    if (((_type = type) == null ? void 0 : _type.type) === "AnyTypeAnnotation") {
      if (init.isCallExpression() && init.get("callee").isIdentifier({
        name: "Array"
      }) && !init.scope.hasBinding("Array", true)) {
        type = ArrayExpression();
      }
    }

    return type;
  }
  function TypeCastExpression(node) {
    return node.typeAnnotation;
  }
  TypeCastExpression.validParent = true;
  function NewExpression(node) {
    if (this.get("callee").isIdentifier()) {
      return genericTypeAnnotation(node.callee);
    }
  }
  function TemplateLiteral() {
    return stringTypeAnnotation();
  }
  function UnaryExpression(node) {
    var operator = node.operator;

    if (operator === "void") {
      return voidTypeAnnotation();
    } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return stringTypeAnnotation();
    } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    }
  }
  function BinaryExpression(node) {
    var operator = node.operator;

    if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return numberTypeAnnotation();
    } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {
      return booleanTypeAnnotation();
    } else if (operator === "+") {
      var right = this.get("right");
      var left = this.get("left");

      if (left.isBaseType("number") && right.isBaseType("number")) {
        return numberTypeAnnotation();
      } else if (left.isBaseType("string") || right.isBaseType("string")) {
        return stringTypeAnnotation();
      }

      return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
    }
  }
  function LogicalExpression() {
    var argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];

    if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
      return createTSUnionType(argumentTypes);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(argumentTypes);
    }

    return createFlowUnionType(argumentTypes);
  }
  function ConditionalExpression() {
    var argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];

    if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {
      return createTSUnionType(argumentTypes);
    }

    if (createFlowUnionType) {
      return createFlowUnionType(argumentTypes);
    }

    return createFlowUnionType(argumentTypes);
  }
  function SequenceExpression() {
    return this.get("expressions").pop().getTypeAnnotation();
  }
  function ParenthesizedExpression() {
    return this.get("expression").getTypeAnnotation();
  }
  function AssignmentExpression() {
    return this.get("right").getTypeAnnotation();
  }
  function UpdateExpression(node) {
    var operator = node.operator;

    if (operator === "++" || operator === "--") {
      return numberTypeAnnotation();
    }
  }
  function StringLiteral$1() {
    return stringTypeAnnotation();
  }
  function NumericLiteral$1() {
    return numberTypeAnnotation();
  }
  function BooleanLiteral() {
    return booleanTypeAnnotation();
  }
  function NullLiteral() {
    return nullLiteralTypeAnnotation();
  }
  function RegExpLiteral() {
    return genericTypeAnnotation(identifier("RegExp"));
  }
  function ObjectExpression() {
    return genericTypeAnnotation(identifier("Object"));
  }
  function ArrayExpression() {
    return genericTypeAnnotation(identifier("Array"));
  }
  function RestElement() {
    return ArrayExpression();
  }
  RestElement.validParent = true;

  function Func() {
    return genericTypeAnnotation(identifier("Function"));
  }
  var isArrayFrom = buildMatchMemberExpression("Array.from");
  var isObjectKeys = buildMatchMemberExpression("Object.keys");
  var isObjectValues = buildMatchMemberExpression("Object.values");
  var isObjectEntries = buildMatchMemberExpression("Object.entries");
  function CallExpression() {
    var callee = this.node.callee;

    if (isObjectKeys(callee)) {
      return arrayTypeAnnotation(stringTypeAnnotation());
    } else if (isArrayFrom(callee) || isObjectValues(callee)) {
      return arrayTypeAnnotation(anyTypeAnnotation());
    } else if (isObjectEntries(callee)) {
      return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
    }

    return resolveCall(this.get("callee"));
  }
  function TaggedTemplateExpression() {
    return resolveCall(this.get("tag"));
  }

  function resolveCall(callee) {
    callee = callee.resolve();

    if (callee.isFunction()) {
      if (callee.is("async")) {
        if (callee.is("generator")) {
          return genericTypeAnnotation(identifier("AsyncIterator"));
        } else {
          return genericTypeAnnotation(identifier("Promise"));
        }
      } else {
        if (callee.node.returnType) {
          return callee.node.returnType;
        }
      }
    }
  }

  var inferers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VariableDeclarator: VariableDeclarator,
    TypeCastExpression: TypeCastExpression,
    NewExpression: NewExpression,
    TemplateLiteral: TemplateLiteral,
    UnaryExpression: UnaryExpression,
    BinaryExpression: BinaryExpression,
    LogicalExpression: LogicalExpression,
    ConditionalExpression: ConditionalExpression,
    SequenceExpression: SequenceExpression,
    ParenthesizedExpression: ParenthesizedExpression,
    AssignmentExpression: AssignmentExpression,
    UpdateExpression: UpdateExpression,
    StringLiteral: StringLiteral$1,
    NumericLiteral: NumericLiteral$1,
    BooleanLiteral: BooleanLiteral,
    NullLiteral: NullLiteral,
    RegExpLiteral: RegExpLiteral,
    ObjectExpression: ObjectExpression,
    ArrayExpression: ArrayExpression,
    RestElement: RestElement,
    FunctionExpression: Func,
    ArrowFunctionExpression: Func,
    FunctionDeclaration: Func,
    ClassExpression: Func,
    ClassDeclaration: Func,
    CallExpression: CallExpression,
    TaggedTemplateExpression: TaggedTemplateExpression,
    Identifier: infererReference
  });

  function getTypeAnnotation() {
    if (this.typeAnnotation) return this.typeAnnotation;
    var type = this._getTypeAnnotation() || anyTypeAnnotation();
    if (isTypeAnnotation(type)) type = type.typeAnnotation;
    return this.typeAnnotation = type;
  }
  var typeAnnotationInferringNodes = new WeakSet();
  function _getTypeAnnotation() {
    var node = this.node;

    if (!node) {
      if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
        var declar = this.parentPath.parentPath;
        var declarParent = declar.parentPath;

        if (declar.key === "left" && declarParent.isForInStatement()) {
          return stringTypeAnnotation();
        }

        if (declar.key === "left" && declarParent.isForOfStatement()) {
          return anyTypeAnnotation();
        }

        return voidTypeAnnotation();
      } else {
        return;
      }
    }

    if (node.typeAnnotation) {
      return node.typeAnnotation;
    }

    if (typeAnnotationInferringNodes.has(node)) {
      return;
    }

    typeAnnotationInferringNodes.add(node);

    try {
      var _inferer;

      var inferer = inferers[node.type];

      if (inferer) {
        return inferer.call(this, node);
      }

      inferer = inferers[this.parentPath.type];

      if ((_inferer = inferer) != null && _inferer.validParent) {
        return this.parentPath.getTypeAnnotation();
      }
    } finally {
      typeAnnotationInferringNodes["delete"](node);
    }
  }
  function isBaseType(baseName, soft) {
    return _isBaseType(baseName, this.getTypeAnnotation(), soft);
  }

  function _isBaseType(baseName, type, soft) {
    if (baseName === "string") {
      return isStringTypeAnnotation(type);
    } else if (baseName === "number") {
      return isNumberTypeAnnotation(type);
    } else if (baseName === "boolean") {
      return isBooleanTypeAnnotation(type);
    } else if (baseName === "any") {
      return isAnyTypeAnnotation(type);
    } else if (baseName === "mixed") {
      return isMixedTypeAnnotation(type);
    } else if (baseName === "empty") {
      return isEmptyTypeAnnotation(type);
    } else if (baseName === "void") {
      return isVoidTypeAnnotation(type);
    } else {
      if (soft) {
        return false;
      } else {
        throw new Error("Unknown base type " + baseName);
      }
    }
  }

  function couldBeBaseType(name) {
    var type = this.getTypeAnnotation();
    if (isAnyTypeAnnotation(type)) return true;

    if (isUnionTypeAnnotation(type)) {
      for (var _iterator = _createForOfIteratorHelperLoose(type.types), _step; !(_step = _iterator()).done;) {
        var type2 = _step.value;

        if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
          return true;
        }
      }

      return false;
    } else {
      return _isBaseType(name, type, true);
    }
  }
  function baseTypeStrictlyMatches(rightArg) {
    var left = this.getTypeAnnotation();
    var right = rightArg.getTypeAnnotation();

    if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
      return right.type === left.type;
    }

    return false;
  }
  function isGenericType(genericName) {
    var type = this.getTypeAnnotation();
    return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
      name: genericName
    });
  }

  var NodePath_inference = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getTypeAnnotation: getTypeAnnotation,
    _getTypeAnnotation: _getTypeAnnotation,
    isBaseType: isBaseType,
    couldBeBaseType: couldBeBaseType,
    baseTypeStrictlyMatches: baseTypeStrictlyMatches,
    isGenericType: isGenericType
  });

  var runtime_1 = createCommonjsModule(function (module) {
    var runtime = function (exports) {

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined$1;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }

      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap;

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      };

      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }

        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator;

      exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0) PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }

            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined$1) {
          context.delegate = null;

          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined$1;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined$1;
          }
        } else {
          return info;
        }

        context.delegate = null;
        return ContinueSentinel;
      }

      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator");

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse();
        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          }

          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined$1;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined$1,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined$1;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined$1;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined$1;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              context.method = "next";
              context.arg = undefined$1;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            this.arg = undefined$1;
          }

          return ContinueSentinel;
        }
      };
      return exports;
    }(module.exports );

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }, "/$$rollup_base$$/node_modules/regenerator-runtime");

  var regenerator = runtime_1;

  var IdentifierName, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace;
  RegularExpressionLiteral = new RegExp("\\/(?![\\*\\/])(?:\\[(?:(?![\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*\\]|(?![\\/\\\\\\]])(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])|\\\\(?:[\\0-\\t\\x0B\\f\\x0E-\\u2027\\u202A-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))*(\\/(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])*|\\\\)?", "y");
  Punctuator = new RegExp("--|\\+\\+|=>|\\.{3}|\\??\\.(?!\\d)|(?:&&|\\|\\||\\?\\?|[+\\-%&|^]|\\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\\/(?![\\/*]))=?|[?~,:;[\\](){}]", "y");
  IdentifierName = new RegExp("(?=(?:[\\$A-Z\\\\_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]))(?:(?:[\\$0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])|\\\\u[0-9A-Fa-f]{4}|\\\\u\\{[0-9A-Fa-f]+\\})+", "y");
  StringLiteral = new RegExp("(['\"])(?:(?!\\1)[^\\\\\\n\\r]|\\\\(?:\\r\\n|[^]))*(\\1)?", "y");
  NumericLiteral = new RegExp("(?:0[xX][\\da-fA-F](?:_?[\\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\\d)*n|(?:(?:0(?!\\d)|0\\d*[89]\\d*|[1-9](?:_?\\d)*)(?:\\.(?:\\d(?:_?\\d)*)?)?|\\.\\d(?:_?\\d)*)(?:[eE][+-]?\\d(?:_?\\d)*)?|0[0-7]+", "y");
  Template = new RegExp("[`}](?:[^`\\\\$]|\\\\[^]|\\$(?!\\{))*(`|\\$\\{)?", "y");
  WhiteSpace = new RegExp("[\\t\\x0B\\f \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000\\uFEFF]+", "y");
  LineTerminatorSequence = new RegExp("\\r?\\n|[\\r\\u2028\\u2029]", "y");
  MultiLineComment = new RegExp("\\/\\*(?:[^*]|\\*(?!\\/))*(\\*\\/)?", "y");
  SingleLineComment = new RegExp("\\/\\/.*", "y");
  JSXPunctuator = new RegExp("[<>.:={}]|\\/(?![\\/*])", "y");
  JSXIdentifier = new RegExp("(?:[\\$A-Z_a-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309B-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDEC0-\\uDEEB]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])(?:[\\$\\x2D0-9A-Z_a-z\\xAA\\xB5\\xB7\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u07FD\\u0800-\\u082D\\u0840-\\u085B\\u0860-\\u086A\\u08A0-\\u08B4\\u08B6-\\u08C7\\u08D3-\\u08E1\\u08E3-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u09FC\\u09FE\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0AF9-\\u0AFF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B55-\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58-\\u0C5A\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C80-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D00-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57\\u0D5F-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D81-\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1369-\\u1371\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1878\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19DA\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1ABF\\u1AC0\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CD0-\\u1CD2\\u1CD4-\\u1CFA\\u1D00-\\u1DF9\\u1DFB-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2118-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7BF\\uA7C2-\\uA7CA\\uA7F5-\\uA827\\uA82C\\uA840-\\uA873\\uA880-\\uA8C5\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA8FD-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDD40-\\uDD74\\uDDFD\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDEE0\\uDF00-\\uDF1F\\uDF2D-\\uDF4A\\uDF50-\\uDF7A\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF\\uDFD1-\\uDFD5]|\\uD801[\\uDC00-\\uDC9D\\uDCA0-\\uDCA9\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE38-\\uDE3A\\uDE3F\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE6\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD27\\uDD30-\\uDD39\\uDE80-\\uDEA9\\uDEAB\\uDEAC\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF50\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC00-\\uDC46\\uDC66-\\uDC6F\\uDC7F-\\uDCBA\\uDCD0-\\uDCE8\\uDCF0-\\uDCF9\\uDD00-\\uDD34\\uDD36-\\uDD3F\\uDD44-\\uDD47\\uDD50-\\uDD73\\uDD76\\uDD80-\\uDDC4\\uDDC9-\\uDDCC\\uDDCE-\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE37\\uDE3E\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEEA\\uDEF0-\\uDEF9\\uDF00-\\uDF03\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3B-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF50\\uDF57\\uDF5D-\\uDF63\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC00-\\uDC4A\\uDC50-\\uDC59\\uDC5E-\\uDC61\\uDC80-\\uDCC5\\uDCC7\\uDCD0-\\uDCD9\\uDD80-\\uDDB5\\uDDB8-\\uDDC0\\uDDD8-\\uDDDD\\uDE00-\\uDE40\\uDE44\\uDE50-\\uDE59\\uDE80-\\uDEB8\\uDEC0-\\uDEC9\\uDF00-\\uDF1A\\uDF1D-\\uDF2B\\uDF30-\\uDF39]|\\uD806[\\uDC00-\\uDC3A\\uDCA0-\\uDCE9\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD35\\uDD37\\uDD38\\uDD3B-\\uDD43\\uDD50-\\uDD59\\uDDA0-\\uDDA7\\uDDAA-\\uDDD7\\uDDDA-\\uDDE1\\uDDE3\\uDDE4\\uDE00-\\uDE3E\\uDE47\\uDE50-\\uDE99\\uDE9D\\uDEC0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC36\\uDC38-\\uDC40\\uDC50-\\uDC59\\uDC72-\\uDC8F\\uDC92-\\uDCA7\\uDCA9-\\uDCB6\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD47\\uDD50-\\uDD59\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD8E\\uDD90\\uDD91\\uDD93-\\uDD98\\uDDA0-\\uDDA9\\uDEE0-\\uDEF6\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC00-\\uDC6E\\uDC80-\\uDD43]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE60-\\uDE69\\uDED0-\\uDEED\\uDEF0-\\uDEF4\\uDF00-\\uDF36\\uDF40-\\uDF43\\uDF50-\\uDF59\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF4F-\\uDF87\\uDF8F-\\uDF9F\\uDFE0\\uDFE1\\uDFE3\\uDFE4\\uDFF0\\uDFF1]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82C[\\uDC00-\\uDD1E\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99\\uDC9D\\uDC9E]|\\uD834[\\uDD65-\\uDD69\\uDD6D-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB\\uDFCE-\\uDFFF]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD00-\\uDD2C\\uDD30-\\uDD3D\\uDD40-\\uDD49\\uDD4E\\uDEC0-\\uDEF9]|\\uD83A[\\uDC00-\\uDCC4\\uDCD0-\\uDCD6\\uDD00-\\uDD4B\\uDD50-\\uDD59]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD83E[\\uDFF0-\\uDFF9]|\\uD869[\\uDC00-\\uDEDD\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF34\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A]|\\uDB40[\\uDD00-\\uDDEF])*", "y");
  JSXString = new RegExp("(['\"])(?:(?!\\1)[^])*(\\1)?", "y");
  JSXText = new RegExp("[^<>{}]+", "y");
  TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
  TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
  KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
  KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
  Newline = RegExp(LineTerminatorSequence.source);

  regenerator.mark(function jsTokens(input, _temp) {
    var _ref, _ref$jsx, jsx, braces, firstCodePoint, isExpression, lastIndex, lastSignificantToken, length, match, mode, nextLastIndex, nextLastSignificantToken, parenNesting, postfixIncDec, punctuator, stack;

    return regenerator.wrap(function jsTokens$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _temp === void 0 ? {} : _temp, _ref$jsx = _ref.jsx, jsx = _ref$jsx === void 0 ? false : _ref$jsx;
            length = input.length;
            lastIndex = 0;
            lastSignificantToken = "";
            stack = [{
              tag: "JS"
            }];
            braces = [];
            parenNesting = 0;
            postfixIncDec = false;

          case 8:
            if (!(lastIndex < length)) {
              _context.next = 231;
              break;
            }

            mode = stack[stack.length - 1];
            _context.t0 = mode.tag;
            _context.next = _context.t0 === "JS" ? 13 : _context.t0 === "JSNonExpressionParen" ? 13 : _context.t0 === "InterpolationInTemplate" ? 13 : _context.t0 === "InterpolationInJSX" ? 13 : _context.t0 === "JSXTag" ? 136 : _context.t0 === "JSXTagEnd" ? 136 : _context.t0 === "JSXChildren" ? 172 : 195;
            break;

          case 13:
            if (!(input[lastIndex] === "/" && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 22;
              break;
            }

            RegularExpressionLiteral.lastIndex = lastIndex;

            if (!(match = RegularExpressionLiteral.exec(input))) {
              _context.next = 22;
              break;
            }

            lastIndex = RegularExpressionLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 21;
            return {
              type: "RegularExpressionLiteral",
              value: match[0],
              closed: match[1] !== void 0 && match[1] !== "\\"
            };

          case 21:
            return _context.abrupt("continue", 8);

          case 22:
            Punctuator.lastIndex = lastIndex;

            if (!(match = Punctuator.exec(input))) {
              _context.next = 93;
              break;
            }

            punctuator = match[0];
            nextLastIndex = Punctuator.lastIndex;
            nextLastSignificantToken = punctuator;
            _context.t1 = punctuator;
            _context.next = _context.t1 === "(" ? 30 : _context.t1 === ")" ? 34 : _context.t1 === "{" ? 38 : _context.t1 === "}" ? 43 : _context.t1 === "]" ? 74 : _context.t1 === "++" ? 76 : _context.t1 === "--" ? 76 : _context.t1 === "<" ? 78 : 87;
            break;

          case 30:
            if (lastSignificantToken === "?NonExpressionParenKeyword") {
              stack.push({
                tag: "JSNonExpressionParen",
                nesting: parenNesting
              });
            }

            parenNesting++;
            postfixIncDec = false;
            return _context.abrupt("break", 88);

          case 34:
            parenNesting--;
            postfixIncDec = true;

            if (mode.tag === "JSNonExpressionParen" && parenNesting === mode.nesting) {
              stack.pop();
              nextLastSignificantToken = "?NonExpressionParenEnd";
              postfixIncDec = false;
            }

            return _context.abrupt("break", 88);

          case 38:
            Punctuator.lastIndex = 0;
            isExpression = !TokensNotPrecedingObjectLiteral.test(lastSignificantToken) && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken));
            braces.push(isExpression);
            postfixIncDec = false;
            return _context.abrupt("break", 88);

          case 43:
            _context.t2 = mode.tag;
            _context.next = _context.t2 === "InterpolationInTemplate" ? 46 : _context.t2 === "InterpolationInJSX" ? 64 : 71;
            break;

          case 46:
            if (!(braces.length === mode.nesting)) {
              _context.next = 63;
              break;
            }

            Template.lastIndex = lastIndex;
            match = Template.exec(input);
            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];

            if (!(match[1] === "${")) {
              _context.next = 58;
              break;
            }

            lastSignificantToken = "?InterpolationInTemplate";
            postfixIncDec = false;
            _context.next = 56;
            return {
              type: "TemplateMiddle",
              value: match[0]
            };

          case 56:
            _context.next = 62;
            break;

          case 58:
            stack.pop();
            postfixIncDec = true;
            _context.next = 62;
            return {
              type: "TemplateTail",
              value: match[0],
              closed: match[1] === "`"
            };

          case 62:
            return _context.abrupt("continue", 8);

          case 63:
            return _context.abrupt("break", 71);

          case 64:
            if (!(braces.length === mode.nesting)) {
              _context.next = 71;
              break;
            }

            stack.pop();
            lastIndex += 1;
            lastSignificantToken = "}";
            _context.next = 70;
            return {
              type: "JSXPunctuator",
              value: "}"
            };

          case 70:
            return _context.abrupt("continue", 8);

          case 71:
            postfixIncDec = braces.pop();
            nextLastSignificantToken = postfixIncDec ? "?ExpressionBraceEnd" : "}";
            return _context.abrupt("break", 88);

          case 74:
            postfixIncDec = true;
            return _context.abrupt("break", 88);

          case 76:
            nextLastSignificantToken = postfixIncDec ? "?PostfixIncDec" : "?UnaryIncDec";
            return _context.abrupt("break", 88);

          case 78:
            if (!(jsx && (TokensPrecedingExpression.test(lastSignificantToken) || KeywordsWithExpressionAfter.test(lastSignificantToken)))) {
              _context.next = 85;
              break;
            }

            stack.push({
              tag: "JSXTag"
            });
            lastIndex += 1;
            lastSignificantToken = "<";
            _context.next = 84;
            return {
              type: "JSXPunctuator",
              value: punctuator
            };

          case 84:
            return _context.abrupt("continue", 8);

          case 85:
            postfixIncDec = false;
            return _context.abrupt("break", 88);

          case 87:
            postfixIncDec = false;

          case 88:
            lastIndex = nextLastIndex;
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 92;
            return {
              type: "Punctuator",
              value: punctuator
            };

          case 92:
            return _context.abrupt("continue", 8);

          case 93:
            IdentifierName.lastIndex = lastIndex;

            if (!(match = IdentifierName.exec(input))) {
              _context.next = 103;
              break;
            }

            lastIndex = IdentifierName.lastIndex;
            nextLastSignificantToken = match[0];

            switch (match[0]) {
              case "for":
              case "if":
              case "while":
              case "with":
                if (lastSignificantToken !== "." && lastSignificantToken !== "?.") {
                  nextLastSignificantToken = "?NonExpressionParenKeyword";
                }

            }

            lastSignificantToken = nextLastSignificantToken;
            postfixIncDec = !KeywordsWithExpressionAfter.test(match[0]);
            _context.next = 102;
            return {
              type: "IdentifierName",
              value: match[0]
            };

          case 102:
            return _context.abrupt("continue", 8);

          case 103:
            StringLiteral.lastIndex = lastIndex;

            if (!(match = StringLiteral.exec(input))) {
              _context.next = 111;
              break;
            }

            lastIndex = StringLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 110;
            return {
              type: "StringLiteral",
              value: match[0],
              closed: match[2] !== void 0
            };

          case 110:
            return _context.abrupt("continue", 8);

          case 111:
            NumericLiteral.lastIndex = lastIndex;

            if (!(match = NumericLiteral.exec(input))) {
              _context.next = 119;
              break;
            }

            lastIndex = NumericLiteral.lastIndex;
            lastSignificantToken = match[0];
            postfixIncDec = true;
            _context.next = 118;
            return {
              type: "NumericLiteral",
              value: match[0]
            };

          case 118:
            return _context.abrupt("continue", 8);

          case 119:
            Template.lastIndex = lastIndex;

            if (!(match = Template.exec(input))) {
              _context.next = 135;
              break;
            }

            lastIndex = Template.lastIndex;
            lastSignificantToken = match[0];

            if (!(match[1] === "${")) {
              _context.next = 131;
              break;
            }

            lastSignificantToken = "?InterpolationInTemplate";
            stack.push({
              tag: "InterpolationInTemplate",
              nesting: braces.length
            });
            postfixIncDec = false;
            _context.next = 129;
            return {
              type: "TemplateHead",
              value: match[0]
            };

          case 129:
            _context.next = 134;
            break;

          case 131:
            postfixIncDec = true;
            _context.next = 134;
            return {
              type: "NoSubstitutionTemplate",
              value: match[0],
              closed: match[1] === "`"
            };

          case 134:
            return _context.abrupt("continue", 8);

          case 135:
            return _context.abrupt("break", 195);

          case 136:
            JSXPunctuator.lastIndex = lastIndex;

            if (!(match = JSXPunctuator.exec(input))) {
              _context.next = 157;
              break;
            }

            lastIndex = JSXPunctuator.lastIndex;
            nextLastSignificantToken = match[0];
            _context.t3 = match[0];
            _context.next = _context.t3 === "<" ? 143 : _context.t3 === ">" ? 145 : _context.t3 === "{" ? 148 : _context.t3 === "/" ? 152 : 153;
            break;

          case 143:
            stack.push({
              tag: "JSXTag"
            });
            return _context.abrupt("break", 153);

          case 145:
            stack.pop();

            if (lastSignificantToken === "/" || mode.tag === "JSXTagEnd") {
              nextLastSignificantToken = "?JSX";
              postfixIncDec = true;
            } else {
              stack.push({
                tag: "JSXChildren"
              });
            }

            return _context.abrupt("break", 153);

          case 148:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            nextLastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            return _context.abrupt("break", 153);

          case 152:
            if (lastSignificantToken === "<") {
              stack.pop();

              if (stack[stack.length - 1].tag === "JSXChildren") {
                stack.pop();
              }

              stack.push({
                tag: "JSXTagEnd"
              });
            }

          case 153:
            lastSignificantToken = nextLastSignificantToken;
            _context.next = 156;
            return {
              type: "JSXPunctuator",
              value: match[0]
            };

          case 156:
            return _context.abrupt("continue", 8);

          case 157:
            JSXIdentifier.lastIndex = lastIndex;

            if (!(match = JSXIdentifier.exec(input))) {
              _context.next = 164;
              break;
            }

            lastIndex = JSXIdentifier.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 163;
            return {
              type: "JSXIdentifier",
              value: match[0]
            };

          case 163:
            return _context.abrupt("continue", 8);

          case 164:
            JSXString.lastIndex = lastIndex;

            if (!(match = JSXString.exec(input))) {
              _context.next = 171;
              break;
            }

            lastIndex = JSXString.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 170;
            return {
              type: "JSXString",
              value: match[0],
              closed: match[2] !== void 0
            };

          case 170:
            return _context.abrupt("continue", 8);

          case 171:
            return _context.abrupt("break", 195);

          case 172:
            JSXText.lastIndex = lastIndex;

            if (!(match = JSXText.exec(input))) {
              _context.next = 179;
              break;
            }

            lastIndex = JSXText.lastIndex;
            lastSignificantToken = match[0];
            _context.next = 178;
            return {
              type: "JSXText",
              value: match[0]
            };

          case 178:
            return _context.abrupt("continue", 8);

          case 179:
            _context.t4 = input[lastIndex];
            _context.next = _context.t4 === "<" ? 182 : _context.t4 === "{" ? 188 : 195;
            break;

          case 182:
            stack.push({
              tag: "JSXTag"
            });
            lastIndex++;
            lastSignificantToken = "<";
            _context.next = 187;
            return {
              type: "JSXPunctuator",
              value: "<"
            };

          case 187:
            return _context.abrupt("continue", 8);

          case 188:
            stack.push({
              tag: "InterpolationInJSX",
              nesting: braces.length
            });
            lastIndex++;
            lastSignificantToken = "?InterpolationInJSX";
            postfixIncDec = false;
            _context.next = 194;
            return {
              type: "JSXPunctuator",
              value: "{"
            };

          case 194:
            return _context.abrupt("continue", 8);

          case 195:
            WhiteSpace.lastIndex = lastIndex;

            if (!(match = WhiteSpace.exec(input))) {
              _context.next = 201;
              break;
            }

            lastIndex = WhiteSpace.lastIndex;
            _context.next = 200;
            return {
              type: "WhiteSpace",
              value: match[0]
            };

          case 200:
            return _context.abrupt("continue", 8);

          case 201:
            LineTerminatorSequence.lastIndex = lastIndex;

            if (!(match = LineTerminatorSequence.exec(input))) {
              _context.next = 209;
              break;
            }

            lastIndex = LineTerminatorSequence.lastIndex;
            postfixIncDec = false;

            if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
              lastSignificantToken = "?NoLineTerminatorHere";
            }

            _context.next = 208;
            return {
              type: "LineTerminatorSequence",
              value: match[0]
            };

          case 208:
            return _context.abrupt("continue", 8);

          case 209:
            MultiLineComment.lastIndex = lastIndex;

            if (!(match = MultiLineComment.exec(input))) {
              _context.next = 216;
              break;
            }

            lastIndex = MultiLineComment.lastIndex;

            if (Newline.test(match[0])) {
              postfixIncDec = false;

              if (KeywordsWithNoLineTerminatorAfter.test(lastSignificantToken)) {
                lastSignificantToken = "?NoLineTerminatorHere";
              }
            }

            _context.next = 215;
            return {
              type: "MultiLineComment",
              value: match[0],
              closed: match[1] !== void 0
            };

          case 215:
            return _context.abrupt("continue", 8);

          case 216:
            SingleLineComment.lastIndex = lastIndex;

            if (!(match = SingleLineComment.exec(input))) {
              _context.next = 223;
              break;
            }

            lastIndex = SingleLineComment.lastIndex;
            postfixIncDec = false;
            _context.next = 222;
            return {
              type: "SingleLineComment",
              value: match[0]
            };

          case 222:
            return _context.abrupt("continue", 8);

          case 223:
            firstCodePoint = String.fromCodePoint(input.codePointAt(lastIndex));
            lastIndex += firstCodePoint.length;
            lastSignificantToken = firstCodePoint;
            postfixIncDec = false;
            _context.next = 229;
            return {
              type: mode.tag.startsWith("JSX") ? "JSXInvalid" : "Invalid",
              value: firstCodePoint
            };

          case 229:
            _context.next = 8;
            break;

          case 231:
            return _context.abrupt("return", void 0);

          case 232:
          case "end":
            return _context.stop();
        }
      }
    }, jsTokens);
  });

  var _default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

  var matchToToken = function matchToToken(match) {
    var token = {
      type: "invalid",
      value: match[0],
      closed: undefined
    };
    if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
    return token;
  };

  var jsTokensBABEL_8_BREAKINGFalse = Object.defineProperty({
    "default": _default,
    matchToToken: matchToToken
  }, '__esModule', {
    value: true
  });

  var jsTokens = jsTokensBABEL_8_BREAKINGFalse;

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  var conversions = createCommonjsModule(function (module) {
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    };

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);

      var diffc = function diffc(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };

      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);

        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }

        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }

      return [h * 360, s * 100, v * 100];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };

    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }

    convert.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];

      if (reversed) {
        return reversed;
      }

      var currentClosestDistance = Infinity;
      var currentClosestKeyword;

      for (var keyword in colorName) {
        if (colorName.hasOwnProperty(keyword)) {
          var value = colorName[keyword];
          var distance = comparativeDistance(rgb, value);

          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }

      return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
      return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    };

    convert.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    };

    convert.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };

    convert.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh);
      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570;
      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };

    convert.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };

    convert.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value = Math.round(value / 50);

      if (value === 0) {
        return 30;
      }

      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

      if (value === 2) {
        ansi += 60;
      }

      return ansi;
    };

    convert.hsv.ansi16 = function (args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];

      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }

        if (r > 248) {
          return 231;
        }

        return Math.round((r - 8) / 247 * 24) + 232;
      }

      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };

    convert.ansi16.rgb = function (args) {
      var color = args % 10;

      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }

        color = color / 10.5 * 255;
        return [color, color, color];
      }

      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }

      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };

    convert.rgb.hex = function (args) {
      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

      if (!match) {
        return [0, 0, 0];
      }

      var colorString = match[0];

      if (match[0].length === 3) {
        colorString = colorString.split('').map(function (_char) {
          return _char + _char;
        }).join('');
      }

      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 0xFF;
      var g = integer >> 8 & 0xFF;
      var b = integer & 0xFF;
      return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;

      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }

      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }

      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;

      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }

      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }

      return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;

      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }

      return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;

      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }

      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;

      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;

        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;

        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;

        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;

        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;

        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }

      mg = (1.0 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };

    convert.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;

      if (v > 0.0) {
        f = c / v;
      }

      return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;

      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }

      return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;

      if (c < 1) {
        g = (v - c) / (1 - c);
      }

      return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };

    convert.rgb.apple = function (rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };

    convert.gray.rgb = function (args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
      var val = Math.round(gray[0] / 100 * 255) & 0xFF;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }, "/$$rollup_base$$/packages/babel-highlight/node_modules/chalk/node_modules/ansi-styles/node_modules/color-convert");

  function buildGraph() {
    var graph = {};
    var models = Object.keys(conversions);

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        distance: -1,
        parent: null
      };
    }

    return graph;
  }

  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel];
    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function route(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert = {};
  var models = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args);

      if (typeof result === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    };

    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;

  var ansiStyles = createCommonjsModule(function (module) {

    var wrapAnsi16 = function wrapAnsi16(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[" + (code + offset) + "m";
      };
    };

    var wrapAnsi256 = function wrapAnsi256(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[" + (38 + offset) + ";5;" + code + "m";
      };
    };

    var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
      return function () {
        var rgb = fn.apply(colorConvert, arguments);
        return "\x1B[" + (38 + offset) + ";2;" + rgb[0] + ";" + rgb[1] + ";" + rgb[2] + "m";
      };
    };

    function assembleStyles() {
      var codes = new Map();
      var styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.grey = styles.color.gray;

      for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
        var groupName = _Object$keys[_i];
        var group = styles[groupName];

        for (var _i2 = 0, _Object$keys2 = Object.keys(group); _i2 < _Object$keys2.length; _i2++) {
          var styleName = _Object$keys2[_i2];
          var style = group[styleName];
          styles[styleName] = {
            open: "\x1B[" + style[0] + "m",
            close: "\x1B[" + style[1] + "m"
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }

        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, 'codes', {
          value: codes,
          enumerable: false
        });
      }

      var ansi2ansi = function ansi2ansi(n) {
        return n;
      };

      var rgb2rgb = function rgb2rgb(r, g, b) {
        return [r, g, b];
      };

      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };

      for (var _i3 = 0, _Object$keys3 = Object.keys(colorConvert); _i3 < _Object$keys3.length; _i3++) {
        var key = _Object$keys3[_i3];

        if (typeof colorConvert[key] !== 'object') {
          continue;
        }

        var suite = colorConvert[key];

        if (key === 'ansi16') {
          key = 'ansi';
        }

        if ('ansi16' in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }

        if ('ansi256' in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }

        if ('rgb' in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }

      return styles;
    }

    Object.defineProperty(module, 'exports', {
      enumerable: true,
      get: assembleStyles
    });
  }, "/$$rollup_base$$/packages/babel-highlight/node_modules/chalk/node_modules/ansi-styles");

  var browser$3 = {
    stdout: false,
    stderr: false
  };

  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

  function unescape(c) {
    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
    var results = [];
    var chunks = args.trim().split(/\s*,\s*/g);
    var matches;

    for (var _iterator = _createForOfIteratorHelperLoose(chunks), _step; !(_step = _iterator()).done;) {
      var chunk = _step.value;

      if (!isNaN(chunk)) {
        results.push(Number(chunk));
      } else if (matches = chunk.match(STRING_REGEX)) {
        results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
          return escape ? unescape(escape) : chr;
        }));
      } else {
        throw new Error("Invalid Chalk template style argument: " + chunk + " (in style '" + name + "')");
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    var results = [];
    var matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      var name = matches[1];

      if (matches[2]) {
        var args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    var enabled = {};

    for (var _iterator2 = _createForOfIteratorHelperLoose(styles), _step2; !(_step2 = _iterator2()).done;) {
      var layer = _step2.value;

      for (var _iterator3 = _createForOfIteratorHelperLoose(layer.styles), _step3; !(_step3 = _iterator3()).done;) {
        var style = _step3.value;
        enabled[style[0]] = layer.inverse ? null : style.slice(1);
      }
    }

    var current = chalk;

    for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
      var styleName = _Object$keys[_i];

      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error("Unknown Chalk style: " + styleName);
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = function templates(chalk, tmp) {
    var styles = [];
    var chunks = [];
    var chunk = [];
    tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        var str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse: inverse,
          styles: parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      var errMsg = "Chalk template literal is missing " + styles.length + " closing bracket" + (styles.length === 1 ? '' : 's') + " (`}`)";
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {

    var stdoutColor = browser$3.stdout;
    var isSimpleWindowsTerm = browser$6.platform === 'win32' && !(browser$6.env.TERM || '').toLowerCase().startsWith('xterm');
    var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m'];
    var skipModels = new Set(['gray']);
    var styles = Object.create(null);

    function applyOptions(obj, options) {
      options = options || {};
      var scLevel = 0;
      obj.level = options.level === undefined ? scLevel : options.level;
      obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
    }

    function Chalk(options) {
      if (!this || !(this instanceof Chalk) || this.template) {
        var _chalk = {};
        applyOptions(_chalk, options);

        _chalk.template = function () {
          var args = [].slice.call(arguments);
          return chalkTag.apply(null, [_chalk.template].concat(args));
        };

        Object.setPrototypeOf(_chalk, Chalk.prototype);
        Object.setPrototypeOf(_chalk.template, _chalk);
        _chalk.template.constructor = Chalk;
        return _chalk.template;
      }

      applyOptions(this, options);
    }

    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }

    var _loop = function _loop() {
      var key = _Object$keys[_i];
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
      styles[key] = {
        get: function get() {
          var codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
      _loop();
    }

    styles.visible = {
      get: function get() {
        return build.call(this, this._styles || [], true, 'visible');
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

    var _loop2 = function _loop2() {
      var model = _Object$keys2[_i2];

      if (skipModels.has(model)) {
        return "continue";
      }

      styles[model] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
      var _ret = _loop2();

      if (_ret === "continue") continue;
    }

    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

    var _loop3 = function _loop3() {
      var model = _Object$keys3[_i3];

      if (skipModels.has(model)) {
        return "continue";
      }

      var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
      var _ret2 = _loop3();

      if (_ret2 === "continue") continue;
    }

    var proto = Object.defineProperties(function () {}, styles);

    function build(_styles, _empty, key) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };

      builder._styles = _styles;
      builder._empty = _empty;
      var self = this;
      Object.defineProperty(builder, 'level', {
        enumerable: true,
        get: function get() {
          return self.level;
        },
        set: function set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, 'enabled', {
        enumerable: true,
        get: function get() {
          return self.enabled;
        },
        set: function set(enabled) {
          self.enabled = enabled;
        }
      });
      builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey';
      builder.__proto__ = proto;
      return builder;
    }

    function applyStyle() {
      var args = arguments;
      var argsLen = args.length;
      var str = String(arguments[0]);

      if (argsLen === 0) {
        return '';
      }

      if (argsLen > 1) {
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }

      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? '' : str;
      }

      var originalDim = ansiStyles.dim.open;

      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = '';
      }

      for (var _iterator = _createForOfIteratorHelperLoose(this._styles.slice().reverse()), _step; !(_step = _iterator()).done;) {
        var code = _step.value;
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        str = str.replace(/\r?\n/g, code.close + "$&" + code.open);
      }

      ansiStyles.dim.open = originalDim;
      return str;
    }

    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        return [].slice.call(arguments, 1).join(' ');
      }

      var args = [].slice.call(arguments, 2);
      var parts = [strings.raw[0]];

      for (var i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
        parts.push(String(strings.raw[i]));
      }

      return templates(chalk, parts.join(''));
    }

    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk();
    module.exports.supportsColor = stdoutColor;
    module.exports["default"] = module.exports;
  }, "/$$rollup_base$$/packages/babel-highlight/node_modules/chalk");

  var sometimesKeywords = new Set(["as", "async", "from", "get", "of", "set"]);

  function getDefs$1(chalk) {
    return {
      keyword: chalk.cyan,
      capitalized: chalk.yellow,
      jsxIdentifier: chalk.yellow,
      punctuator: chalk.yellow,
      number: chalk.magenta,
      string: chalk.green,
      regex: chalk.magenta,
      comment: chalk.grey,
      invalid: chalk.white.bgRed.bold
    };
  }

  var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
  var BRACKET = /^[()[\]{}]$/;
  var tokenize;
  {
    var JSX_TAG = /^[a-z][\w-]*$/i;

    var getTokenType = function getTokenType(token, offset, text) {
      if (token.type === "name") {
        if (isKeyword(token.value) || isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsxIdentifier";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    };

    tokenize = regenerator.mark(function tokenize(text) {
      var match, token;
      return regenerator.wrap(function tokenize$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(match = jsTokens["default"].exec(text))) {
                _context.next = 6;
                break;
              }

              token = jsTokens.matchToToken(match);
              _context.next = 4;
              return {
                type: getTokenType(token, match.index, text),
                value: token.value
              };

            case 4:
              _context.next = 0;
              break;

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, tokenize);
    });
  }

  function highlightTokens(defs, text) {
    var highlighted = "";

    var _loop = function _loop() {
      var _step$value = _step.value,
          type = _step$value.type,
          value = _step$value.value;
      var colorize = defs[type];

      if (colorize) {
        highlighted += value.split(NEWLINE$1).map(function (str) {
          return colorize(str);
        }).join("\n");
      } else {
        highlighted += value;
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose(tokenize(text)), _step; !(_step = _iterator()).done;) {
      _loop();
    }

    return highlighted;
  }

  function shouldHighlight(options) {
    return !!chalk.supportsColor || options.forceColor;
  }
  function getChalk(options) {
    return options.forceColor ? new chalk.constructor({
      enabled: true,
      level: 1
    }) : chalk;
  }
  function highlight(code, options) {
    if (options === void 0) {
      options = {};
    }

    if (shouldHighlight(options)) {
      var chalk = getChalk(options);
      var defs = getDefs$1(chalk);
      return highlightTokens(defs, code);
    } else {
      return code;
    }
  }

  function getDefs(chalk) {
    return {
      gutter: chalk.grey,
      marker: chalk.red.bold,
      message: chalk.red.bold
    };
  }

  var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

  function getMarkerLines(loc, source, opts) {
    var startLoc = Object.assign({
      column: 0,
      line: -1
    }, loc.start);
    var endLoc = Object.assign({}, startLoc, loc.end);

    var _ref = opts || {},
        _ref$linesAbove = _ref.linesAbove,
        linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
        _ref$linesBelow = _ref.linesBelow,
        linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

    var startLine = startLoc.line;
    var startColumn = startLoc.column;
    var endLine = endLoc.line;
    var endColumn = endLoc.column;
    var start = Math.max(startLine - (linesAbove + 1), 0);
    var end = Math.min(source.length, endLine + linesBelow);

    if (startLine === -1) {
      start = 0;
    }

    if (endLine === -1) {
      end = source.length;
    }

    var lineDiff = endLine - startLine;
    var markerLines = {};

    if (lineDiff) {
      for (var i = 0; i <= lineDiff; i++) {
        var lineNumber = i + startLine;

        if (!startColumn) {
          markerLines[lineNumber] = true;
        } else if (i === 0) {
          var sourceLength = source[lineNumber - 1].length;
          markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
        } else if (i === lineDiff) {
          markerLines[lineNumber] = [0, endColumn];
        } else {
          var _sourceLength = source[lineNumber - i].length;
          markerLines[lineNumber] = [0, _sourceLength];
        }
      }
    } else {
      if (startColumn === endColumn) {
        if (startColumn) {
          markerLines[startLine] = [startColumn, 0];
        } else {
          markerLines[startLine] = true;
        }
      } else {
        markerLines[startLine] = [startColumn, endColumn - startColumn];
      }
    }

    return {
      start: start,
      end: end,
      markerLines: markerLines
    };
  }

  function codeFrameColumns(rawLines, loc, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var highlighted = (opts.highlightCode || opts.forceColor) && shouldHighlight(opts);
    var chalk = getChalk(opts);
    var defs = getDefs(chalk);

    var maybeHighlight = function maybeHighlight(chalkFn, string) {
      return highlighted ? chalkFn(string) : string;
    };

    var lines = rawLines.split(NEWLINE);

    var _getMarkerLines = getMarkerLines(loc, lines, opts),
        start = _getMarkerLines.start,
        end = _getMarkerLines.end,
        markerLines = _getMarkerLines.markerLines;

    var hasColumns = loc.start && typeof loc.start.column === "number";
    var numberMaxWidth = String(end).length;
    var highlightedLines = highlighted ? highlight(rawLines, opts) : rawLines;
    var frame = highlightedLines.split(NEWLINE).slice(start, end).map(function (line, index) {
      var number = start + 1 + index;
      var paddedNumber = (" " + number).slice(-numberMaxWidth);
      var gutter = " " + paddedNumber + " |";
      var hasMarker = markerLines[number];
      var lastMarkerLine = !markerLines[number + 1];

      if (hasMarker) {
        var markerLine = "";

        if (Array.isArray(hasMarker)) {
          var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
          var numberOfMarkers = hasMarker[1] || 1;
          markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), " ", markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

          if (lastMarkerLine && opts.message) {
            markerLine += " " + maybeHighlight(defs.message, opts.message);
          }
        }

        return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line.length > 0 ? " " + line : "", markerLine].join("");
      } else {
        return " " + maybeHighlight(defs.gutter, gutter) + (line.length > 0 ? " " + line : "");
      }
    }).join("\n");

    if (opts.message && !hasColumns) {
      frame = "" + " ".repeat(numberMaxWidth + 1) + opts.message + "\n" + frame;
    }

    if (highlighted) {
      return chalk.reset(frame);
    } else {
      return frame;
    }
  }

  var beforeExpr = true;
  var startsExpr = true;
  var isLoop = true;
  var isAssign = true;
  var prefix = true;
  var postfix = true;
  var TokenType = function TokenType(label, conf) {
    if (conf === void 0) {
      conf = {};
    }

    this.label = void 0;
    this.keyword = void 0;
    this.beforeExpr = void 0;
    this.startsExpr = void 0;
    this.rightAssociative = void 0;
    this.isLoop = void 0;
    this.isAssign = void 0;
    this.prefix = void 0;
    this.postfix = void 0;
    this.binop = void 0;
    this.updateContext = void 0;
    this.label = label;
    this.keyword = conf.keyword;
    this.beforeExpr = !!conf.beforeExpr;
    this.startsExpr = !!conf.startsExpr;
    this.rightAssociative = !!conf.rightAssociative;
    this.isLoop = !!conf.isLoop;
    this.isAssign = !!conf.isAssign;
    this.prefix = !!conf.prefix;
    this.postfix = !!conf.postfix;
    this.binop = conf.binop != null ? conf.binop : null;
    this.updateContext = null;
  };
  var keywords = new Map();

  function createKeyword(name, options) {
    if (options === void 0) {
      options = {};
    }

    options.keyword = name;
    var token = new TokenType(name, options);
    keywords.set(name, token);
    return token;
  }

  function createBinop(name, binop) {
    return new TokenType(name, {
      beforeExpr: beforeExpr,
      binop: binop
    });
  }

  var types$1 = {
    num: new TokenType("num", {
      startsExpr: startsExpr
    }),
    bigint: new TokenType("bigint", {
      startsExpr: startsExpr
    }),
    decimal: new TokenType("decimal", {
      startsExpr: startsExpr
    }),
    regexp: new TokenType("regexp", {
      startsExpr: startsExpr
    }),
    string: new TokenType("string", {
      startsExpr: startsExpr
    }),
    name: new TokenType("name", {
      startsExpr: startsExpr
    }),
    privateName: new TokenType("#name", {
      startsExpr: startsExpr
    }),
    eof: new TokenType("eof"),
    bracketL: new TokenType("[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketHashL: new TokenType("#[", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketBarL: new TokenType("[|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    bracketR: new TokenType("]"),
    bracketBarR: new TokenType("|]"),
    braceL: new TokenType("{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceBarL: new TokenType("{|", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceHashL: new TokenType("#{", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    braceR: new TokenType("}", {
      beforeExpr: beforeExpr
    }),
    braceBarR: new TokenType("|}"),
    parenL: new TokenType("(", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    parenR: new TokenType(")"),
    comma: new TokenType(",", {
      beforeExpr: beforeExpr
    }),
    semi: new TokenType(";", {
      beforeExpr: beforeExpr
    }),
    colon: new TokenType(":", {
      beforeExpr: beforeExpr
    }),
    doubleColon: new TokenType("::", {
      beforeExpr: beforeExpr
    }),
    dot: new TokenType("."),
    question: new TokenType("?", {
      beforeExpr: beforeExpr
    }),
    questionDot: new TokenType("?."),
    arrow: new TokenType("=>", {
      beforeExpr: beforeExpr
    }),
    template: new TokenType("template"),
    ellipsis: new TokenType("...", {
      beforeExpr: beforeExpr
    }),
    backQuote: new TokenType("`", {
      startsExpr: startsExpr
    }),
    dollarBraceL: new TokenType("${", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    at: new TokenType("@"),
    hash: new TokenType("#", {
      startsExpr: startsExpr
    }),
    interpreterDirective: new TokenType("#!..."),
    eq: new TokenType("=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    assign: new TokenType("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    slashAssign: new TokenType("_=", {
      beforeExpr: beforeExpr,
      isAssign: isAssign
    }),
    incDec: new TokenType("++/--", {
      prefix: prefix,
      postfix: postfix,
      startsExpr: startsExpr
    }),
    bang: new TokenType("!", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    tilde: new TokenType("~", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    pipeline: createBinop("|>", 0),
    nullishCoalescing: createBinop("??", 1),
    logicalOR: createBinop("||", 1),
    logicalAND: createBinop("&&", 2),
    bitwiseOR: createBinop("|", 3),
    bitwiseXOR: createBinop("^", 4),
    bitwiseAND: createBinop("&", 5),
    equality: createBinop("==/!=/===/!==", 6),
    relational: createBinop("</>/<=/>=", 7),
    bitShift: createBinop("<</>>/>>>", 8),
    plusMin: new TokenType("+/-", {
      beforeExpr: beforeExpr,
      binop: 9,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    modulo: new TokenType("%", {
      beforeExpr: beforeExpr,
      binop: 10,
      startsExpr: startsExpr
    }),
    star: new TokenType("*", {
      binop: 10
    }),
    slash: createBinop("/", 10),
    exponent: new TokenType("**", {
      beforeExpr: beforeExpr,
      binop: 11,
      rightAssociative: true
    }),
    _break: createKeyword("break"),
    _case: createKeyword("case", {
      beforeExpr: beforeExpr
    }),
    _catch: createKeyword("catch"),
    _continue: createKeyword("continue"),
    _debugger: createKeyword("debugger"),
    _default: createKeyword("default", {
      beforeExpr: beforeExpr
    }),
    _do: createKeyword("do", {
      isLoop: isLoop,
      beforeExpr: beforeExpr
    }),
    _else: createKeyword("else", {
      beforeExpr: beforeExpr
    }),
    _finally: createKeyword("finally"),
    _for: createKeyword("for", {
      isLoop: isLoop
    }),
    _function: createKeyword("function", {
      startsExpr: startsExpr
    }),
    _if: createKeyword("if"),
    _return: createKeyword("return", {
      beforeExpr: beforeExpr
    }),
    _switch: createKeyword("switch"),
    _throw: createKeyword("throw", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _try: createKeyword("try"),
    _var: createKeyword("var"),
    _const: createKeyword("const"),
    _while: createKeyword("while", {
      isLoop: isLoop
    }),
    _with: createKeyword("with"),
    _new: createKeyword("new", {
      beforeExpr: beforeExpr,
      startsExpr: startsExpr
    }),
    _this: createKeyword("this", {
      startsExpr: startsExpr
    }),
    _super: createKeyword("super", {
      startsExpr: startsExpr
    }),
    _class: createKeyword("class", {
      startsExpr: startsExpr
    }),
    _extends: createKeyword("extends", {
      beforeExpr: beforeExpr
    }),
    _export: createKeyword("export"),
    _import: createKeyword("import", {
      startsExpr: startsExpr
    }),
    _null: createKeyword("null", {
      startsExpr: startsExpr
    }),
    _true: createKeyword("true", {
      startsExpr: startsExpr
    }),
    _false: createKeyword("false", {
      startsExpr: startsExpr
    }),
    _in: createKeyword("in", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _instanceof: createKeyword("instanceof", {
      beforeExpr: beforeExpr,
      binop: 7
    }),
    _typeof: createKeyword("typeof", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _void: createKeyword("void", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    }),
    _delete: createKeyword("delete", {
      beforeExpr: beforeExpr,
      prefix: prefix,
      startsExpr: startsExpr
    })
  };

  var lineBreak = /\r\n?|[\n\u2028\u2029]/;
  var lineBreakG = new RegExp(lineBreak.source, "g");
  function isNewLine(code) {
    switch (code) {
      case 10:
      case 13:
      case 8232:
      case 8233:
        return true;

      default:
        return false;
    }
  }
  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  function isWhitespace(code) {
    switch (code) {
      case 0x0009:
      case 0x000b:
      case 0x000c:
      case 32:
      case 160:
      case 5760:
      case 0x2000:
      case 0x2001:
      case 0x2002:
      case 0x2003:
      case 0x2004:
      case 0x2005:
      case 0x2006:
      case 0x2007:
      case 0x2008:
      case 0x2009:
      case 0x200a:
      case 0x202f:
      case 0x205f:
      case 0x3000:
      case 0xfeff:
        return true;

      default:
        return false;
    }
  }

  var Position = function Position(line, col) {
    this.line = void 0;
    this.column = void 0;
    this.line = line;
    this.column = col;
  };
  var SourceLocation = function SourceLocation(start, end) {
    this.start = void 0;
    this.end = void 0;
    this.filename = void 0;
    this.identifierName = void 0;
    this.start = start;
    this.end = end;
  };
  function getLineInfo(input, offset) {
    var line = 1;
    var lineStart = 0;
    var match;
    lineBreakG.lastIndex = 0;

    while ((match = lineBreakG.exec(input)) && match.index < offset) {
      line++;
      lineStart = lineBreakG.lastIndex;
    }

    return new Position(line, offset - lineStart);
  }

  var BaseParser = function () {
    function BaseParser() {
      this.sawUnambiguousESM = false;
      this.ambiguousScriptDifferentAst = false;
    }

    var _proto = BaseParser.prototype;

    _proto.hasPlugin = function hasPlugin(name) {
      return this.plugins.has(name);
    };

    _proto.getPluginOption = function getPluginOption(plugin, name) {
      if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];
    };

    return BaseParser;
  }();

  function last(stack) {
    return stack[stack.length - 1];
  }

  var CommentsParser = function (_BaseParser) {
    _inherits(CommentsParser, _BaseParser);

    function CommentsParser() {
      return _BaseParser.apply(this, arguments) || this;
    }

    var _proto = CommentsParser.prototype;

    _proto.addComment = function addComment(comment) {
      if (this.filename) comment.loc.filename = this.filename;
      this.state.trailingComments.push(comment);
      this.state.leadingComments.push(comment);
    };

    _proto.adjustCommentsAfterTrailingComma = function adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {
      if (this.state.leadingComments.length === 0) {
        return;
      }

      var lastElement = null;
      var i = elements.length;

      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }

      if (lastElement === null) {
        return;
      }

      for (var j = 0; j < this.state.leadingComments.length; j++) {
        if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
          this.state.leadingComments.splice(j, 1);
          j--;
        }
      }

      var newTrailingComments = [];

      for (var _i = 0; _i < this.state.leadingComments.length; _i++) {
        var leadingComment = this.state.leadingComments[_i];

        if (leadingComment.end < node.end) {
          newTrailingComments.push(leadingComment);

          if (!takeAllComments) {
            this.state.leadingComments.splice(_i, 1);
            _i--;
          }
        } else {
          if (node.trailingComments === undefined) {
            node.trailingComments = [];
          }

          node.trailingComments.push(leadingComment);
        }
      }

      if (takeAllComments) this.state.leadingComments = [];

      if (newTrailingComments.length > 0) {
        lastElement.trailingComments = newTrailingComments;
      } else if (lastElement.trailingComments !== undefined) {
        lastElement.trailingComments = [];
      }
    };

    _proto.processComment = function processComment(node) {
      if (node.type === "Program" && node.body.length > 0) return;
      var stack = this.state.commentStack;
      var firstChild, lastChild, trailingComments, i, j;

      if (this.state.trailingComments.length > 0) {
        if (this.state.trailingComments[0].start >= node.end) {
          trailingComments = this.state.trailingComments;
          this.state.trailingComments = [];
        } else {
          this.state.trailingComments.length = 0;
        }
      } else if (stack.length > 0) {
        var lastInStack = last(stack);

        if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
          trailingComments = lastInStack.trailingComments;
          delete lastInStack.trailingComments;
        }
      }

      if (stack.length > 0 && last(stack).start >= node.start) {
        firstChild = stack.pop();
      }

      while (stack.length > 0 && last(stack).start >= node.start) {
        lastChild = stack.pop();
      }

      if (!lastChild && firstChild) lastChild = firstChild;

      if (firstChild) {
        switch (node.type) {
          case "ObjectExpression":
            this.adjustCommentsAfterTrailingComma(node, node.properties);
            break;

          case "ObjectPattern":
            this.adjustCommentsAfterTrailingComma(node, node.properties, true);
            break;

          case "CallExpression":
            this.adjustCommentsAfterTrailingComma(node, node.arguments);
            break;

          case "ArrayExpression":
            this.adjustCommentsAfterTrailingComma(node, node.elements);
            break;

          case "ArrayPattern":
            this.adjustCommentsAfterTrailingComma(node, node.elements, true);
            break;
        }
      } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === "ImportSpecifier" && node.type !== "ImportSpecifier" || this.state.commentPreviousNode.type === "ExportSpecifier" && node.type !== "ExportSpecifier")) {
        this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);
      }

      if (lastChild) {
        if (lastChild.leadingComments) {
          if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {
            node.leadingComments = lastChild.leadingComments;
            delete lastChild.leadingComments;
          } else {
            for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
              if (lastChild.leadingComments[i].end <= node.start) {
                node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
                break;
              }
            }
          }
        }
      } else if (this.state.leadingComments.length > 0) {
        if (last(this.state.leadingComments).end <= node.start) {
          if (this.state.commentPreviousNode) {
            for (j = 0; j < this.state.leadingComments.length; j++) {
              if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
                this.state.leadingComments.splice(j, 1);
                j--;
              }
            }
          }

          if (this.state.leadingComments.length > 0) {
            node.leadingComments = this.state.leadingComments;
            this.state.leadingComments = [];
          }
        } else {
          for (i = 0; i < this.state.leadingComments.length; i++) {
            if (this.state.leadingComments[i].end > node.start) {
              break;
            }
          }

          var leadingComments = this.state.leadingComments.slice(0, i);

          if (leadingComments.length) {
            node.leadingComments = leadingComments;
          }

          trailingComments = this.state.leadingComments.slice(i);

          if (trailingComments.length === 0) {
            trailingComments = null;
          }
        }
      }

      this.state.commentPreviousNode = node;

      if (trailingComments) {
        if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
          node.innerComments = trailingComments;
        } else {
          var firstTrailingCommentIndex = trailingComments.findIndex(function (comment) {
            return comment.end >= node.end;
          });

          if (firstTrailingCommentIndex > 0) {
            node.innerComments = trailingComments.slice(0, firstTrailingCommentIndex);
            node.trailingComments = trailingComments.slice(firstTrailingCommentIndex);
          } else {
            node.trailingComments = trailingComments;
          }
        }
      }

      stack.push(node);
    };

    return CommentsParser;
  }(BaseParser);

  var ErrorCodes = Object.freeze({
    SyntaxError: "BABEL_PARSER_SYNTAX_ERROR",
    SourceTypeModuleError: "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED"
  });

  var ErrorMessages = makeErrorTemplates({
    AccessorIsGenerator: "A %0ter cannot be a generator.",
    ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
    AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accesor must not have any formal parameters.",
    BadSetterArity: "A 'set' accesor must have exactly one formal parameter.",
    BadSetterRestParameter: "A 'set' accesor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: "'%0' require an initialization value.",
    DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax.",
    DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass: "Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: "`%0` has already been exported. Exported identifiers must be unique.",
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '%0' as '%1' } from 'some-module'`?",
    ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: "'%0' loop variable declaration may not have an initializer.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: "Unsyntactic %0.",
    IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportBindingIsString: 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "%0" as foo }`?',
    ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: "`import()` requires exactly %0.",
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: "Expected number in radix %0.",
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: "Escape sequence in keyword %0.",
    InvalidIdentifier: "Invalid identifier %0.",
    InvalidLhs: "Invalid left-hand side in %0.",
    InvalidLhsBinding: "Binding invalid left-hand side in %0.",
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: "Unexpected character '%0'.",
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: "Private name #%0 is not defined.",
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: "Label '%0' is already declared.",
    LetInLexicalBinding: "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: 'Duplicate key "%0" is not allowed in module attributes.',
    ModuleExportNameHasLoneSurrogate: "An export name cannot include a lone surrogate, found '\\u%0'.",
    ModuleExportUndefined: "Export '%0' is not defined.",
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline: "Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.",
    PrivateInExpectedIn: "Private names are only allowed in property accesses (`obj.#%0`) or in `in` expressions (`#%0 in obj`).",
    PrivateNameRedeclaration: "Duplicate private name #%0.",
    RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    StrictDelete: "Deleting local variable in strict mode.",
    StrictEvalArguments: "Assigning to '%0' in strict mode.",
    StrictEvalArgumentsBinding: "Binding '%0' in strict mode.",
    StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
    StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
    StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
    StrictWith: "'with' in strict mode.",
    SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: "Unexpected keyword '%0'.",
    UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\n or a property of member expression (i.e. this.#p).",
    UnexpectedReservedWord: "Unexpected reserved word '%0'.",
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: "Unexpected token '%0'.",
    UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
    UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: "The only valid meta property for %0 is %0.%1.",
    UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    VarRedeclaration: "Identifier '%0' has already been declared.",
    YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
  }, ErrorCodes.SyntaxError);
  var SourceTypeModuleErrorMessages = makeErrorTemplates({
    ImportMetaOutsideModule: "import.meta may appear only with 'sourceType: \"module\"'",
    ImportOutsideModule: "'import' and 'export' may appear only with 'sourceType: \"module\"'"
  }, ErrorCodes.SourceTypeModuleError);

  function makeErrorTemplates(messages, code) {
    var templates = {};
    Object.keys(messages).forEach(function (reasonCode) {
      templates[reasonCode] = Object.freeze({
        code: code,
        reasonCode: reasonCode,
        template: messages[reasonCode]
      });
    });
    return Object.freeze(templates);
  }

  var ParserError = function (_CommentsParser) {
    _inherits(ParserError, _CommentsParser);

    function ParserError() {
      return _CommentsParser.apply(this, arguments) || this;
    }

    var _proto = ParserError.prototype;

    _proto.getLocationForPosition = function getLocationForPosition(pos) {
      var loc;
      if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);
      return loc;
    };

    _proto.raise = function raise(pos, _ref) {
      var code = _ref.code,
          reasonCode = _ref.reasonCode,
          template = _ref.template;

      for (var _len = arguments.length, params = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        params[_key - 2] = arguments[_key];
      }

      return this.raiseWithData.apply(this, [pos, {
        code: code,
        reasonCode: reasonCode
      }, template].concat(params));
    };

    _proto.raiseOverwrite = function raiseOverwrite(pos, _ref2) {
      var code = _ref2.code,
          template = _ref2.template;

      for (var _len2 = arguments.length, params = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        params[_key2 - 2] = arguments[_key2];
      }

      var loc = this.getLocationForPosition(pos);
      var message = template.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + (" (" + loc.line + ":" + loc.column + ")");

      if (this.options.errorRecovery) {
        var errors = this.state.errors;

        for (var i = errors.length - 1; i >= 0; i--) {
          var error = errors[i];

          if (error.pos === pos) {
            return Object.assign(error, {
              message: message
            });
          } else if (error.pos < pos) {
            break;
          }
        }
      }

      return this._raise({
        code: code,
        loc: loc,
        pos: pos
      }, message);
    };

    _proto.raiseWithData = function raiseWithData(pos, data, errorTemplate) {
      for (var _len3 = arguments.length, params = new Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {
        params[_key3 - 3] = arguments[_key3];
      }

      var loc = this.getLocationForPosition(pos);
      var message = errorTemplate.replace(/%(\d+)/g, function (_, i) {
        return params[i];
      }) + (" (" + loc.line + ":" + loc.column + ")");
      return this._raise(Object.assign({
        loc: loc,
        pos: pos
      }, data), message);
    };

    _proto._raise = function _raise(errorContext, message) {
      var err = new SyntaxError(message);
      Object.assign(err, errorContext);

      if (this.options.errorRecovery) {
        if (!this.isLookahead) this.state.errors.push(err);
        return err;
      } else {
        throw err;
      }
    };

    return ParserError;
  }(CommentsParser);

  var estree = (function (superClass) {
    return function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parseRegExpLiteral = function parseRegExpLiteral(_ref) {
        var pattern = _ref.pattern,
            flags = _ref.flags;
        var regex = null;

        try {
          regex = new RegExp(pattern, flags);
        } catch (e) {}

        var node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern: pattern,
          flags: flags
        };
        return node;
      };

      _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
        var bigInt;

        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }

        var node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      };

      _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
        var decimal = null;
        var node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      };

      _proto.estreeParseLiteral = function estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      };

      _proto.parseStringLiteral = function parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      };

      _proto.parseNumericLiteral = function parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      };

      _proto.parseNullLiteral = function parseNullLiteral() {
        return this.estreeParseLiteral(null);
      };

      _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      };

      _proto.directiveToStmt = function directiveToStmt(directive) {
        var directiveLiteral = directive.value;
        var stmt = this.startNodeAt(directive.start, directive.loc.start);
        var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);
        expression.value = directiveLiteral.extra.expressionValue;
        expression.raw = directiveLiteral.extra.raw;
        stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
        stmt.directive = directiveLiteral.extra.raw.slice(1, -1);
        return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
      };

      _proto.initFunction = function initFunction(node, isAsync) {
        _superClass.prototype.initFunction.call(this, node, isAsync);

        node.expression = false;
      };

      _proto.checkDeclaration = function checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          _superClass.prototype.checkDeclaration.call(this, node);
        }
      };

      _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
        return method.value.params;
      };

      _proto.isValidDirective = function isValidDirective(stmt) {
        var _stmt$expression$extr;

        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      };

      _proto.stmtToDirective = function stmtToDirective(stmt) {
        var directive = _superClass.prototype.stmtToDirective.call(this, stmt);

        var value = stmt.expression.value;
        this.addExtra(directive.value, "expressionValue", value);
        return directive;
      };

      _proto.parseBlockBody = function parseBlockBody(node) {
        var _superClass$prototype,
            _this = this;

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        (_superClass$prototype = _superClass.prototype.parseBlockBody).call.apply(_superClass$prototype, [this, node].concat(args));

        var directiveStatements = node.directives.map(function (d) {
          return _this.directiveToStmt(d);
        });
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);

        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }

        classBody.body.push(method);
      };

      _proto.parseMaybePrivateName = function parseMaybePrivateName() {
        var _superClass$prototype2;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        var node = (_superClass$prototype2 = _superClass.prototype.parseMaybePrivateName).call.apply(_superClass$prototype2, [this].concat(args));

        if (node.type === "PrivateName" && this.getPluginOption("estree", "classFeatures")) {
          return this.convertPrivateNameToPrivateIdentifier(node);
        }

        return node;
      };

      _proto.convertPrivateNameToPrivateIdentifier = function convertPrivateNameToPrivateIdentifier(node) {
        var name = _superClass.prototype.getPrivateNameSV.call(this, node);

        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      };

      _proto.isPrivateName = function isPrivateName(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return _superClass.prototype.isPrivateName.call(this, node);
        }

        return node.type === "PrivateIdentifier";
      };

      _proto.getPrivateNameSV = function getPrivateNameSV(node) {
        if (!this.getPluginOption("estree", "classFeatures")) {
          return _superClass.prototype.getPrivateNameSV.call(this, node);
        }

        return node.name;
      };

      _proto.parseLiteral = function parseLiteral(value, type) {
        var node = _superClass.prototype.parseLiteral.call(this, value, type);

        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        _superClass.prototype.parseFunctionBody.call(this, node, allowExpression, isMethod);

        node.expression = node.body.type !== "BlockStatement";
      };

      _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        if (inClassScope === void 0) {
          inClassScope = false;
        }

        var funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = _superClass.prototype.parseMethod.call(this, funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;

        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }

        type = "MethodDefinition";
        return this.finishNode(node, type);
      };

      _proto.parseClassProperty = function parseClassProperty() {
        var _superClass$prototype3;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var propertyNode = (_superClass$prototype3 = _superClass.prototype.parseClassProperty).call.apply(_superClass$prototype3, [this].concat(args));

        if (this.getPluginOption("estree", "classFeatures")) {
          propertyNode.type = "PropertyDefinition";
        }

        return propertyNode;
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty() {
        var _superClass$prototype4;

        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }

        var propertyNode = (_superClass$prototype4 = _superClass.prototype.parseClassPrivateProperty).call.apply(_superClass$prototype4, [this].concat(args));

        if (this.getPluginOption("estree", "classFeatures")) {
          propertyNode.type = "PropertyDefinition";
          propertyNode.computed = false;
        }

        return propertyNode;
      };

      _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        var node = _superClass.prototype.parseObjectMethod.call(this, prop, isGenerator, isAsync, isPattern, isAccessor);

        if (node) {
          node.type = "Property";
          if (node.kind === "method") node.kind = "init";
          node.shorthand = false;
        }

        return node;
      };

      _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
        var node = _superClass.prototype.parseObjectProperty.call(this, prop, startPos, startLoc, isPattern, refExpressionErrors);

        if (node) {
          node.kind = "init";
          node.type = "Property";
        }

        return node;
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        if (node != null && this.isObjectProperty(node)) {
          this.toAssignable(node.value, isLHS);
          return node;
        }

        return _superClass.prototype.toAssignable.call(this, node, isLHS);
      };

      _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop) {
        if (prop.kind === "get" || prop.kind === "set") {
          this.raise(prop.key.start, ErrorMessages.PatternHasAccessor);
        } else if (prop.method) {
          this.raise(prop.key.start, ErrorMessages.PatternHasMethod);
        } else {
          var _superClass$prototype5;

          for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
            args[_key5 - 1] = arguments[_key5];
          }

          (_superClass$prototype5 = _superClass.prototype.toAssignableObjectExpressionProp).call.apply(_superClass$prototype5, [this, prop].concat(args));
        }
      };

      _proto.finishCallExpression = function finishCallExpression(node, optional) {
        _superClass.prototype.finishCallExpression.call(this, node, optional);

        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];

          if (this.hasPlugin("importAssertions")) {
            var _node$arguments$;

            node.attributes = (_node$arguments$ = node.arguments[1]) != null ? _node$arguments$ : null;
          }

          delete node.arguments;
          delete node.callee;
        }

        return node;
      };

      _proto.toReferencedArguments = function toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }

        _superClass.prototype.toReferencedArguments.call(this, node);
      };

      _proto.parseExport = function parseExport(node) {
        _superClass.prototype.parseExport.call(this, node);

        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;

          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }

            break;
        }

        return node;
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var node = _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);

        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }

          if (state.stop) {
            var chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }

        return node;
      };

      _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }

        return _superClass.prototype.hasPropertyAsPrivateName.call(this, node);
      };

      _proto.isOptionalChain = function isOptionalChain(node) {
        return node.type === "ChainExpression";
      };

      _proto.isObjectProperty = function isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      };

      _proto.isObjectMethod = function isObjectMethod(node) {
        return node.method || node.kind === "get" || node.kind === "set";
      };

      return _class;
    }(superClass);
  });

  var TokContext = function TokContext(token, preserveSpace) {
    this.token = void 0;
    this.preserveSpace = void 0;
    this.token = token;
    this.preserveSpace = !!preserveSpace;
  };
  var types = {
    brace: new TokContext("{"),
    template: new TokContext("`", true)
  };

  types$1.braceR.updateContext = function (context) {
    context.pop();
  };

  types$1.braceL.updateContext = types$1.braceHashL.updateContext = types$1.dollarBraceL.updateContext = function (context) {
    context.push(types.brace);
  };

  types$1.backQuote.updateContext = function (context) {
    if (context[context.length - 1] === types.template) {
      context.pop();
    } else {
      context.push(types.template);
    }
  };

  function isIteratorStart(current, next) {
    return current === 64 && next === 64;
  }
  var reservedWordLikeSet = new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
  function canBeReservedWord(word) {
    return reservedWordLikeSet.has(word);
  }

  var SCOPE_OTHER = 0,
      SCOPE_PROGRAM = 1,
      SCOPE_FUNCTION = 2,
      SCOPE_ARROW = 4,
      SCOPE_SIMPLE_CATCH = 8,
      SCOPE_SUPER = 16,
      SCOPE_DIRECT_SUPER = 32,
      SCOPE_CLASS = 64,
      SCOPE_STATIC_BLOCK = 128,
      SCOPE_TS_MODULE = 256,
      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;
  var BIND_KIND_VALUE = 1,
      BIND_KIND_TYPE = 2,
      BIND_SCOPE_VAR = 4,
      BIND_SCOPE_LEXICAL = 8,
      BIND_SCOPE_FUNCTION = 16,
      BIND_FLAGS_NONE = 64,
      BIND_FLAGS_CLASS = 128,
      BIND_FLAGS_TS_ENUM = 256,
      BIND_FLAGS_TS_CONST_ENUM = 512,
      BIND_FLAGS_TS_EXPORT_ONLY = 1024,
      BIND_FLAGS_FLOW_DECLARE_FN = 2048;
  var BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,
      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,
      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,
      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,
      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,
      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,
      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,
      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,
      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,
      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,
      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,
      BIND_FLOW_DECLARE_FN = BIND_FLAGS_FLOW_DECLARE_FN;
  var CLASS_ELEMENT_FLAG_STATIC = 4,
      CLASS_ELEMENT_KIND_GETTER = 2,
      CLASS_ELEMENT_KIND_SETTER = 1,
      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;
  var CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,
      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,
      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,
      CLASS_ELEMENT_OTHER = 0;

  var Scope = function Scope(flags) {
    this["var"] = new Set();
    this.lexical = new Set();
    this.functions = new Set();
    this.flags = flags;
  };

  var ScopeHandler = function () {
    function ScopeHandler(raise, inModule) {
      this.scopeStack = [];
      this.undefinedExports = new Map();
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
      this.inModule = inModule;
    }

    var _proto = ScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new Scope(flags);
    };

    _proto.enter = function enter(flags) {
      this.scopeStack.push(this.createScope(flags));
    };

    _proto.exit = function exit() {
      this.scopeStack.pop();
    };

    _proto.treatFunctionsAsVarInScope = function treatFunctionsAsVarInScope(scope) {
      return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);

        if (bindingType & BIND_SCOPE_FUNCTION) {
          scope.functions.add(name);
        } else {
          scope.lexical.add(name);
        }

        if (bindingType & BIND_SCOPE_LEXICAL) {
          this.maybeExportDefined(scope, name);
        }
      } else if (bindingType & BIND_SCOPE_VAR) {
        for (var i = this.scopeStack.length - 1; i >= 0; --i) {
          scope = this.scopeStack[i];
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          scope["var"].add(name);
          this.maybeExportDefined(scope, name);
          if (scope.flags & SCOPE_VAR) break;
        }
      }

      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.maybeExportDefined = function maybeExportDefined(scope, name) {
      if (this.inModule && scope.flags & SCOPE_PROGRAM) {
        this.undefinedExports["delete"](name);
      }
    };

    _proto.checkRedeclarationInScope = function checkRedeclarationInScope(scope, name, bindingType, pos) {
      if (this.isRedeclaredInScope(scope, name, bindingType)) {
        this.raise(pos, ErrorMessages.VarRedeclaration, name);
      }
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (!(bindingType & BIND_KIND_VALUE)) return false;

      if (bindingType & BIND_SCOPE_LEXICAL) {
        return scope.lexical.has(name) || scope.functions.has(name) || scope["var"].has(name);
      }

      if (bindingType & BIND_SCOPE_FUNCTION) {
        return scope.lexical.has(name) || !this.treatFunctionsAsVarInScope(scope) && scope["var"].has(name);
      }

      return scope.lexical.has(name) && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical.values().next().value === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.has(name);
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      var name = id.name;
      var topLevelScope = this.scopeStack[0];

      if (!topLevelScope.lexical.has(name) && !topLevelScope["var"].has(name) && !topLevelScope.functions.has(name)) {
        this.undefinedExports.set(name, id.start);
      }
    };

    _proto.currentScope = function currentScope() {
      return this.scopeStack[this.scopeStack.length - 1];
    };

    _proto.currentVarScopeFlags = function currentVarScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & SCOPE_VAR) {
          return flags;
        }
      }
    };

    _proto.currentThisScopeFlags = function currentThisScopeFlags() {
      for (var i = this.scopeStack.length - 1;; i--) {
        var flags = this.scopeStack[i].flags;

        if (flags & (SCOPE_VAR | SCOPE_CLASS) && !(flags & SCOPE_ARROW)) {
          return flags;
        }
      }
    };

    _createClass(ScopeHandler, [{
      key: "inFunction",
      get: function get() {
        return (this.currentVarScopeFlags() & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "allowSuper",
      get: function get() {
        return (this.currentThisScopeFlags() & SCOPE_SUPER) > 0;
      }
    }, {
      key: "allowDirectSuper",
      get: function get() {
        return (this.currentThisScopeFlags() & SCOPE_DIRECT_SUPER) > 0;
      }
    }, {
      key: "inClass",
      get: function get() {
        return (this.currentThisScopeFlags() & SCOPE_CLASS) > 0;
      }
    }, {
      key: "inClassAndNotInNonArrowFunction",
      get: function get() {
        var flags = this.currentThisScopeFlags();
        return (flags & SCOPE_CLASS) > 0 && (flags & SCOPE_FUNCTION) === 0;
      }
    }, {
      key: "inStaticBlock",
      get: function get() {
        return (this.currentThisScopeFlags() & SCOPE_STATIC_BLOCK) > 0;
      }
    }, {
      key: "inNonArrowFunction",
      get: function get() {
        return (this.currentThisScopeFlags() & SCOPE_FUNCTION) > 0;
      }
    }, {
      key: "treatFunctionsAsVar",
      get: function get() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
    }]);

    return ScopeHandler;
  }();

  var FlowScope = function (_Scope) {
    _inherits(FlowScope, _Scope);

    function FlowScope() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.declareFunctions = new Set();
      return _this;
    }

    return FlowScope;
  }(Scope);

  var FlowScopeHandler = function (_ScopeHandler) {
    _inherits(FlowScopeHandler, _ScopeHandler);

    function FlowScopeHandler() {
      return _ScopeHandler.apply(this, arguments) || this;
    }

    var _proto = FlowScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new FlowScope(flags);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        this.checkRedeclarationInScope(scope, name, bindingType, pos);
        this.maybeExportDefined(scope, name);
        scope.declareFunctions.add(name);
        return;
      }

      _ScopeHandler.prototype.declareName.apply(this, arguments);
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (_ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments)) return true;

      if (bindingType & BIND_FLAGS_FLOW_DECLARE_FN) {
        return !scope.declareFunctions.has(name) && (scope.lexical.has(name) || scope.functions.has(name));
      }

      return false;
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      if (!this.scopeStack[0].declareFunctions.has(id.name)) {
        _ScopeHandler.prototype.checkLocalExport.call(this, id);
      }
    };

    return FlowScopeHandler;
  }(ScopeHandler);

  var reservedTypes = new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
  var FlowErrors = makeErrorTemplates({
    AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: "Cannot overwrite reserved type %0.",
    DeclareClassElement: "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: "Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.",
    EnumDuplicateMemberName: "Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.",
    EnumInconsistentMemberValues: "Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.",
    EnumInvalidExplicitType: "Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidExplicitTypeUnknownSupplied: "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.",
    EnumInvalidMemberInitializerPrimaryType: "Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.",
    EnumInvalidMemberInitializerSymbolType: "Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.",
    EnumInvalidMemberInitializerUnknownType: "The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.",
    EnumInvalidMemberName: "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.",
    EnumNumberMemberNotInitialized: "Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.",
    EnumStringMemberInconsistentlyInitailized: "String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.",
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
    OptionalBindingPattern: "A binding pattern parameter cannot be optional in an implementation signature.",
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: "Unexpected reserved type %0.",
    UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: "`declare export %0` is not supported. Use `%1` instead.",
    UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment."
  }, ErrorCodes.SyntaxError);

  function isEsModuleType(bodyElement) {
    return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
  }

  function hasTypeImportKind(node) {
    return node.importKind === "type" || node.importKind === "typeof";
  }

  function isMaybeDefaultImport(state) {
    return (state.type === types$1.name || !!state.type.keyword) && state.value !== "from";
  }

  var exportSuggestions = {
    "const": "declare export var",
    "let": "declare export var",
    type: "export type",
    "interface": "export interface"
  };

  function partition(list, test) {
    var list1 = [];
    var list2 = [];

    for (var i = 0; i < list.length; i++) {
      (test(list[i], i, list) ? list1 : list2).push(list[i]);
    }

    return [list1, list2];
  }

  var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
  var flow = (function (superClass) {
    return function (_superClass) {
      _inherits(_class2, _superClass);

      function _class2() {
        var _this2;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        _this2 = _superClass.call.apply(_superClass, [this].concat(args)) || this;
        _this2.flowPragma = undefined;
        return _this2;
      }

      var _proto = _class2.prototype;

      _proto.getScopeHandler = function getScopeHandler() {
        return FlowScopeHandler;
      };

      _proto.shouldParseTypes = function shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      };

      _proto.shouldParseEnums = function shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      };

      _proto.finishToken = function finishToken(type, val) {
        if (type !== types$1.string && type !== types$1.semi && type !== types$1.interpreterDirective) {
          if (this.flowPragma === undefined) {
            this.flowPragma = null;
          }
        }

        return _superClass.prototype.finishToken.call(this, type, val);
      };

      _proto.addComment = function addComment(comment) {
        if (this.flowPragma === undefined) {
          var matches = FLOW_PRAGMA_REGEX.exec(comment.value);

          if (!matches) ; else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }

        return _superClass.prototype.addComment.call(this, comment);
      };

      _proto.flowParseTypeInitialiser = function flowParseTypeInitialiser(tok) {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || types$1.colon);
        var type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      };

      _proto.flowParsePredicate = function flowParsePredicate() {
        var node = this.startNode();
        var moduloPos = this.state.start;
        this.next();
        this.expectContextual("checks");

        if (this.state.lastTokStart > moduloPos + 1) {
          this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);
        }

        if (this.eat(types$1.parenL)) {
          node.value = this.parseExpression();
          this.expect(types$1.parenR);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      };

      _proto.flowParseTypeAndPredicateInitialiser = function flowParseTypeAndPredicateInitialiser() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(types$1.colon);
        var type = null;
        var predicate = null;

        if (this.match(types$1.modulo)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;

          if (this.match(types$1.modulo)) {
            predicate = this.flowParsePredicate();
          }
        }

        return [type, predicate];
      };

      _proto.flowParseDeclareClass = function flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      };

      _proto.flowParseDeclareFunction = function flowParseDeclareFunction(node) {
        this.next();
        var id = node.id = this.parseIdentifier();
        var typeNode = this.startNode();
        var typeContainer = this.startNode();

        if (this.isRelational("<")) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }

        this.expect(types$1.parenL);
        var tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode["this"] = tmp._this;
        this.expect(types$1.parenR);

        var _this$flowParseTypeAn = this.flowParseTypeAndPredicateInitialiser();

        typeNode.returnType = _this$flowParseTypeAn[0];
        node.predicate = _this$flowParseTypeAn[1];
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, BIND_FLOW_DECLARE_FN, node.id.start);
        return this.finishNode(node, "DeclareFunction");
      };

      _proto.flowParseDeclare = function flowParseDeclare(node, insideModule) {
        if (this.match(types$1._class)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(types$1._function)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(types$1._var)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual("module")) {
          if (this.match(types$1.dot)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);
            }

            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual("type")) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual("opaque")) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual("interface")) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(types$1._export)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          throw this.unexpected();
        }
      };

      _proto.flowParseDeclareVariable = function flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, BIND_VAR, node.id.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      };

      _proto.flowParseDeclareModule = function flowParseDeclareModule(node) {
        var _this3 = this;

        this.scope.enter(SCOPE_OTHER);

        if (this.match(types$1.string)) {
          node.id = this.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }

        var bodyNode = node.body = this.startNode();
        var body = bodyNode.body = [];
        this.expect(types$1.braceL);

        while (!this.match(types$1.braceR)) {
          var _bodyNode = this.startNode();

          if (this.match(types$1._import)) {
            this.next();

            if (!this.isContextual("type") && !this.match(types$1._typeof)) {
              this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);
            }

            this.parseImport(_bodyNode);
          } else {
            this.expectContextual("declare", FlowErrors.UnsupportedStatementInDeclareModule);
            _bodyNode = this.flowParseDeclare(_bodyNode, true);
          }

          body.push(_bodyNode);
        }

        this.scope.exit();
        this.expect(types$1.braceR);
        this.finishNode(bodyNode, "BlockStatement");
        var kind = null;
        var hasModuleExport = false;
        body.forEach(function (bodyElement) {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              _this3.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              _this3.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);
            }

            if (kind === "ES") {
              _this3.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);
            }

            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      };

      _proto.flowParseDeclareExportDeclaration = function flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(types$1._export);

        if (this.eat(types$1._default)) {
          if (this.match(types$1._function) || this.match(types$1._class)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }

          node["default"] = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(types$1._const) || this.isLet() || (this.isContextual("type") || this.isContextual("interface")) && !insideModule) {
            var label = this.state.value;
            var suggestion = exportSuggestions[label];
            throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);
          }

          if (this.match(types$1._var) || this.match(types$1._function) || this.match(types$1._class) || this.isContextual("opaque")) {
              node.declaration = this.flowParseDeclare(this.startNode());
              node["default"] = false;
              return this.finishNode(node, "DeclareExportDeclaration");
            } else if (this.match(types$1.star) || this.match(types$1.braceL) || this.isContextual("interface") || this.isContextual("type") || this.isContextual("opaque")) {
              node = this.parseExport(node);

              if (node.type === "ExportNamedDeclaration") {
                node.type = "ExportDeclaration";
                node["default"] = false;
                delete node.exportKind;
              }

              node.type = "Declare" + node.type;
              return node;
            }
        }

        throw this.unexpected();
      };

      _proto.flowParseDeclareModuleExports = function flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual("exports");
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      };

      _proto.flowParseDeclareTypeAlias = function flowParseDeclareTypeAlias(node) {
        this.next();
        this.flowParseTypeAlias(node);
        node.type = "DeclareTypeAlias";
        return node;
      };

      _proto.flowParseDeclareOpaqueType = function flowParseDeclareOpaqueType(node) {
        this.next();
        this.flowParseOpaqueType(node, true);
        node.type = "DeclareOpaqueType";
        return node;
      };

      _proto.flowParseDeclareInterface = function flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "DeclareInterface");
      };

      _proto.flowParseInterfaceish = function flowParseInterfaceish(node, isClass) {
        if (isClass === void 0) {
          isClass = false;
        }

        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node["extends"] = [];
        node["implements"] = [];
        node.mixins = [];

        if (this.eat(types$1._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(types$1.comma));
        }

        if (this.isContextual("mixins")) {
          this.next();

          do {
            node.mixins.push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }

        if (this.isContextual("implements")) {
          this.next();

          do {
            node["implements"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      };

      _proto.flowParseInterfaceExtends = function flowParseInterfaceExtends() {
        var node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }

        return this.finishNode(node, "InterfaceExtends");
      };

      _proto.flowParseInterface = function flowParseInterface(node) {
        this.flowParseInterfaceish(node);
        return this.finishNode(node, "InterfaceDeclaration");
      };

      _proto.checkNotUnderscore = function checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);
        }
      };

      _proto.checkReservedType = function checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);
      };

      _proto.flowParseRestrictedIdentifier = function flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.start, declaration);
        return this.parseIdentifier(liberal);
      };

      _proto.flowParseTypeAlias = function flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.right = this.flowParseTypeInitialiser(types$1.eq);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      };

      _proto.flowParseOpaqueType = function flowParseOpaqueType(node, declare) {
        this.expectContextual("type");
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }

        node.supertype = null;

        if (this.match(types$1.colon)) {
          node.supertype = this.flowParseTypeInitialiser(types$1.colon);
        }

        node.impltype = null;

        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(types$1.eq);
        }

        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      };

      _proto.flowParseTypeParameter = function flowParseTypeParameter(requireDefault) {
        if (requireDefault === void 0) {
          requireDefault = false;
        }

        var nodeStart = this.state.start;
        var node = this.startNode();
        var variance = this.flowParseVariance();
        var ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;

        if (this.match(types$1.eq)) {
          this.eat(types$1.eq);
          node["default"] = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);
          }
        }

        return this.finishNode(node, "TypeParameter");
      };

      _proto.flowParseTypeParameterDeclaration = function flowParseTypeParameterDeclaration() {
        var oldInType = this.state.inType;
        var node = this.startNode();
        node.params = [];
        this.state.inType = true;

        if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        var defaultRequired = false;

        do {
          var typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);

          if (typeParameter["default"]) {
            defaultRequired = true;
          }

          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        } while (!this.isRelational(">"));

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      };

      _proto.flowParseTypeParameterInstantiation = function flowParseTypeParameterInstantiation() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseType());

          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        }

        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseTypeParameterInstantiationCallOrNew = function flowParseTypeParameterInstantiationCallOrNew() {
        var node = this.startNode();
        var oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expectRelational("<");

        while (!this.isRelational(">")) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());

          if (!this.isRelational(">")) {
            this.expect(types$1.comma);
          }
        }

        this.expectRelational(">");
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      };

      _proto.flowParseInterfaceType = function flowParseInterfaceType() {
        var node = this.startNode();
        this.expectContextual("interface");
        node["extends"] = [];

        if (this.eat(types$1._extends)) {
          do {
            node["extends"].push(this.flowParseInterfaceExtends());
          } while (this.eat(types$1.comma));
        }

        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      };

      _proto.flowParseObjectPropertyKey = function flowParseObjectPropertyKey() {
        return this.match(types$1.num) || this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);
      };

      _proto.flowParseObjectTypeIndexer = function flowParseObjectTypeIndexer(node, isStatic, variance) {
        node["static"] = isStatic;

        if (this.lookahead().type === types$1.colon) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }

        this.expect(types$1.bracketR);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      };

      _proto.flowParseObjectTypeInternalSlot = function flowParseObjectTypeInternalSlot(node, isStatic) {
        node["static"] = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(types$1.bracketR);
        this.expect(types$1.bracketR);

        if (this.isRelational("<") || this.match(types$1.parenL)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));
        } else {
          node.method = false;

          if (this.eat(types$1.question)) {
            node.optional = true;
          }

          node.value = this.flowParseTypeInitialiser();
        }

        return this.finishNode(node, "ObjectTypeInternalSlot");
      };

      _proto.flowParseObjectTypeMethodish = function flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node["this"] = null;

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        this.expect(types$1.parenL);

        if (this.match(types$1._this)) {
          node["this"] = this.flowParseFunctionTypeParam(true);
          node["this"].name = null;

          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }

        while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
          node.params.push(this.flowParseFunctionTypeParam(false));

          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }

        if (this.eat(types$1.ellipsis)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }

        this.expect(types$1.parenR);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      };

      _proto.flowParseObjectTypeCallProperty = function flowParseObjectTypeCallProperty(node, isStatic) {
        var valueNode = this.startNode();
        node["static"] = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      };

      _proto.flowParseObjectType = function flowParseObjectType(_ref) {
        var allowStatic = _ref.allowStatic,
            allowExact = _ref.allowExact,
            allowSpread = _ref.allowSpread,
            allowProto = _ref.allowProto,
            allowInexact = _ref.allowInexact;
        var oldInType = this.state.inType;
        this.state.inType = true;
        var nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        var endDelim;
        var exact;
        var inexact = false;

        if (allowExact && this.match(types$1.braceBarL)) {
          this.expect(types$1.braceBarL);
          endDelim = types$1.braceBarR;
          exact = true;
        } else {
          this.expect(types$1.braceL);
          endDelim = types$1.braceR;
          exact = false;
        }

        nodeStart.exact = exact;

        while (!this.match(endDelim)) {
          var isStatic = false;
          var protoStart = null;
          var inexactStart = null;
          var node = this.startNode();

          if (allowProto && this.isContextual("proto")) {
            var lookahead = this.lookahead();

            if (lookahead.type !== types$1.colon && lookahead.type !== types$1.question) {
              this.next();
              protoStart = this.state.start;
              allowStatic = false;
            }
          }

          if (allowStatic && this.isContextual("static")) {
            var _lookahead = this.lookahead();

            if (_lookahead.type !== types$1.colon && _lookahead.type !== types$1.question) {
              this.next();
              isStatic = true;
            }
          }

          var variance = this.flowParseVariance();

          if (this.eat(types$1.bracketL)) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (this.eat(types$1.bracketL)) {
              if (variance) {
                this.unexpected(variance.start);
              }

              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(types$1.parenL) || this.isRelational("<")) {
            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            var kind = "init";

            if (this.isContextual("get") || this.isContextual("set")) {
              var _lookahead2 = this.lookahead();

              if (_lookahead2.type === types$1.name || _lookahead2.type === types$1.string || _lookahead2.type === types$1.num) {
                kind = this.state.value;
                this.next();
              }
            }

            var propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);

            if (propOrInexact === null) {
              inexact = true;
              inexactStart = this.state.lastTokStart;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }

          this.flowObjectTypeSemicolon();

          if (inexactStart && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
            this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);
          }
        }

        this.expect(endDelim);

        if (allowSpread) {
          nodeStart.inexact = inexact;
        }

        var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      };

      _proto.flowParseObjectTypeProperty = function flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {
        if (this.eat(types$1.ellipsis)) {
          var isInexactToken = this.match(types$1.comma) || this.match(types$1.semi) || this.match(types$1.braceR) || this.match(types$1.braceBarR);

          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);
            } else if (!allowInexact) {
              this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);
            }

            if (variance) {
              this.raise(variance.start, FlowErrors.InexactVariance);
            }

            return null;
          }

          if (!allowSpread) {
            this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);
          }

          if (protoStart != null) {
            this.unexpected(protoStart);
          }

          if (variance) {
            this.raise(variance.start, FlowErrors.SpreadVariance);
          }

          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node["static"] = isStatic;
          node.proto = protoStart != null;
          node.kind = kind;
          var optional = false;

          if (this.isRelational("<") || this.match(types$1.parenL)) {
            node.method = true;

            if (protoStart != null) {
              this.unexpected(protoStart);
            }

            if (variance) {
              this.unexpected(variance.start);
            }

            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));

            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }

            if (!allowSpread && node.key.name === "constructor" && node.value["this"]) {
              this.raise(node.value["this"].start, FlowErrors.ThisParamBannedInConstructor);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;

            if (this.eat(types$1.question)) {
              optional = true;
            }

            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }

          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      };

      _proto.flowCheckGetterSetterParams = function flowCheckGetterSetterParams(property) {
        var paramCount = property.kind === "get" ? 0 : 1;
        var start = property.start;
        var length = property.value.params.length + (property.value.rest ? 1 : 0);

        if (property.value["this"]) {
          this.raise(property.value["this"].start, property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam);
        }

        if (length !== paramCount) {
          if (property.kind === "get") {
            this.raise(start, ErrorMessages.BadGetterArity);
          } else {
            this.raise(start, ErrorMessages.BadSetterArity);
          }
        }

        if (property.kind === "set" && property.value.rest) {
          this.raise(start, ErrorMessages.BadSetterRestParameter);
        }
      };

      _proto.flowObjectTypeSemicolon = function flowObjectTypeSemicolon() {
        if (!this.eat(types$1.semi) && !this.eat(types$1.comma) && !this.match(types$1.braceR) && !this.match(types$1.braceBarR)) {
          this.unexpected();
        }
      };

      _proto.flowParseQualifiedTypeIdentifier = function flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {
        startPos = startPos || this.state.start;
        startLoc = startLoc || this.state.startLoc;
        var node = id || this.flowParseRestrictedIdentifier(true);

        while (this.eat(types$1.dot)) {
          var node2 = this.startNodeAt(startPos, startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }

        return node;
      };

      _proto.flowParseGenericType = function flowParseGenericType(startPos, startLoc, id) {
        var node = this.startNodeAt(startPos, startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }

        return this.finishNode(node, "GenericTypeAnnotation");
      };

      _proto.flowParseTypeofType = function flowParseTypeofType() {
        var node = this.startNode();
        this.expect(types$1._typeof);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      };

      _proto.flowParseTupleType = function flowParseTupleType() {
        var node = this.startNode();
        node.types = [];
        this.expect(types$1.bracketL);

        while (this.state.pos < this.length && !this.match(types$1.bracketR)) {
          node.types.push(this.flowParseType());
          if (this.match(types$1.bracketR)) break;
          this.expect(types$1.comma);
        }

        this.expect(types$1.bracketR);
        return this.finishNode(node, "TupleTypeAnnotation");
      };

      _proto.flowParseFunctionTypeParam = function flowParseFunctionTypeParam(first) {
        var name = null;
        var optional = false;
        var typeAnnotation = null;
        var node = this.startNode();
        var lh = this.lookahead();
        var isThis = this.state.type === types$1._this;

        if (lh.type === types$1.colon || lh.type === types$1.question) {
          if (isThis && !first) {
            this.raise(node.start, FlowErrors.ThisParamMustBeFirst);
          }

          name = this.parseIdentifier(isThis);

          if (this.eat(types$1.question)) {
            optional = true;

            if (isThis) {
              this.raise(node.start, FlowErrors.ThisParamMayNotBeOptional);
            }
          }

          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }

        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.reinterpretTypeAsFunctionTypeParam = function reinterpretTypeAsFunctionTypeParam(type) {
        var node = this.startNodeAt(type.start, type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      };

      _proto.flowParseFunctionTypeParams = function flowParseFunctionTypeParams(params) {
        if (params === void 0) {
          params = [];
        }

        var rest = null;
        var _this = null;

        if (this.match(types$1._this)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;

          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }

        while (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
          params.push(this.flowParseFunctionTypeParam(false));

          if (!this.match(types$1.parenR)) {
            this.expect(types$1.comma);
          }
        }

        if (this.eat(types$1.ellipsis)) {
          rest = this.flowParseFunctionTypeParam(false);
        }

        return {
          params: params,
          rest: rest,
          _this: _this
        };
      };

      _proto.flowIdentToTypeAnnotation = function flowIdentToTypeAnnotation(startPos, startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");

          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");

          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");

          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");

          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");

          case "string":
            return this.finishNode(node, "StringTypeAnnotation");

          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");

          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startPos, startLoc, id);
        }
      };

      _proto.flowParsePrimaryType = function flowParsePrimaryType() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.startNode();
        var tmp;
        var type;
        var isGroupedType = false;
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;

        switch (this.state.type) {
          case types$1.name:
            if (this.isContextual("interface")) {
              return this.flowParseInterfaceType();
            }

            return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

          case types$1.braceL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });

          case types$1.braceBarL:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });

          case types$1.bracketL:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;

          case types$1.relational:
            if (this.state.value === "<") {
              node.typeParameters = this.flowParseTypeParameterDeclaration();
              this.expect(types$1.parenL);
              tmp = this.flowParseFunctionTypeParams();
              node.params = tmp.params;
              node.rest = tmp.rest;
              node["this"] = tmp._this;
              this.expect(types$1.parenR);
              this.expect(types$1.arrow);
              node.returnType = this.flowParseType();
              return this.finishNode(node, "FunctionTypeAnnotation");
            }

            break;

          case types$1.parenL:
            this.next();

            if (!this.match(types$1.parenR) && !this.match(types$1.ellipsis)) {
              if (this.match(types$1.name) || this.match(types$1._this)) {
                var token = this.lookahead().type;
                isGroupedType = token !== types$1.question && token !== types$1.colon;
              } else {
                isGroupedType = true;
              }
            }

            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;

              if (this.state.noAnonFunctionType || !(this.match(types$1.comma) || this.match(types$1.parenR) && this.lookahead().type === types$1.arrow)) {
                this.expect(types$1.parenR);
                return type;
              } else {
                this.eat(types$1.comma);
              }
            }

            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }

            node.params = tmp.params;
            node.rest = tmp.rest;
            node["this"] = tmp._this;
            this.expect(types$1.parenR);
            this.expect(types$1.arrow);
            node.returnType = this.flowParseType();
            node.typeParameters = null;
            return this.finishNode(node, "FunctionTypeAnnotation");

          case types$1.string:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

          case types$1._true:
          case types$1._false:
            node.value = this.match(types$1._true);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");

          case types$1.plusMin:
            if (this.state.value === "-") {
              this.next();

              if (this.match(types$1.num)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }

              if (this.match(types$1.bigint)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }

              throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);
            }

            throw this.unexpected();

          case types$1.num:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

          case types$1.bigint:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");

          case types$1._void:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");

          case types$1._null:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");

          case types$1._this:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");

          case types$1.star:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");

          default:
            if (this.state.type.keyword === "typeof") {
              return this.flowParseTypeofType();
            } else if (this.state.type.keyword) {
              var label = this.state.type.label;
              this.next();
              return _superClass.prototype.createIdentifier.call(this, node, label);
            }

        }

        throw this.unexpected();
      };

      _proto.flowParsePostfixType = function flowParsePostfixType() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var type = this.flowParsePrimaryType();
        var seenOptionalIndexedAccess = false;

        while ((this.match(types$1.bracketL) || this.match(types$1.questionDot)) && !this.canInsertSemicolon()) {
          var node = this.startNodeAt(startPos, startLoc);
          var optional = this.eat(types$1.questionDot);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(types$1.bracketL);

          if (!optional && this.match(types$1.bracketR)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(types$1.bracketR);

            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }

        return type;
      };

      _proto.flowParsePrefixType = function flowParsePrefixType() {
        var node = this.startNode();

        if (this.eat(types$1.question)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      };

      _proto.flowParseAnonFunctionWithoutParens = function flowParseAnonFunctionWithoutParens() {
        var param = this.flowParsePrefixType();

        if (!this.state.noAnonFunctionType && this.eat(types$1.arrow)) {
          var node = this.startNodeAt(param.start, param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node["this"] = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }

        return param;
      };

      _proto.flowParseIntersectionType = function flowParseIntersectionType() {
        var node = this.startNode();
        this.eat(types$1.bitwiseAND);
        var type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];

        while (this.eat(types$1.bitwiseAND)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      };

      _proto.flowParseUnionType = function flowParseUnionType() {
        var node = this.startNode();
        this.eat(types$1.bitwiseOR);
        var type = this.flowParseIntersectionType();
        node.types = [type];

        while (this.eat(types$1.bitwiseOR)) {
          node.types.push(this.flowParseIntersectionType());
        }

        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      };

      _proto.flowParseType = function flowParseType() {
        var oldInType = this.state.inType;
        this.state.inType = true;
        var type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      };

      _proto.flowParseTypeOrImplicitInstantiation = function flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === types$1.name && this.state.value === "_") {
          var startPos = this.state.start;
          var startLoc = this.state.startLoc;
          var node = this.parseIdentifier();
          return this.flowParseGenericType(startPos, startLoc, node);
        } else {
          return this.flowParseType();
        }
      };

      _proto.flowParseTypeAnnotation = function flowParseTypeAnnotation() {
        var node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      };

      _proto.flowParseTypeAnnotatableIdentifier = function flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        var ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();

        if (this.match(types$1.colon)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }

        return ident;
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.flowParseVariance = function flowParseVariance() {
        var variance = null;

        if (this.match(types$1.plusMin)) {
          variance = this.startNode();

          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }

          this.next();
          this.finishNode(variance, "Variance");
        }

        return variance;
      };

      _proto.parseFunctionBody = function parseFunctionBody(node, allowExpressionBody, isMethod) {
        var _this4 = this;

        if (isMethod === void 0) {
          isMethod = false;
        }

        if (allowExpressionBody) {
          return this.forwardNoArrowParamsConversionAt(node, function () {
            return _superClass.prototype.parseFunctionBody.call(_this4, node, true, isMethod);
          });
        }

        return _superClass.prototype.parseFunctionBody.call(this, node, false, isMethod);
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types$1.colon)) {
          var typeNode = this.startNode();

          var _this$flowParseTypeAn2 = this.flowParseTypeAndPredicateInitialiser();

          typeNode.typeAnnotation = _this$flowParseTypeAn2[0];
          node.predicate = _this$flowParseTypeAn2[1];
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.parseStatement = function parseStatement(context, topLevel) {
        if (this.state.strict && this.match(types$1.name) && this.state.value === "interface") {
          var lookahead = this.lookahead();

          if (lookahead.type === types$1.name || isKeyword(lookahead.value)) {
            var node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          var _node = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_node);
        }

        var stmt = _superClass.prototype.parseStatement.call(this, context, topLevel);

        if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }

        return stmt;
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(types$1._class) || this.match(types$1.name) || this.match(types$1._function) || this.match(types$1._var) || this.match(types$1._export)) {
              return this.flowParseDeclare(node);
            }
          } else if (this.match(types$1.name)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }

        return _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        return this.isContextual("type") || this.isContextual("interface") || this.isContextual("opaque") || this.shouldParseEnums() && this.isContextual("enum") || _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types$1.name) && (this.state.value === "type" || this.state.value === "interface" || this.state.value === "opaque" || this.shouldParseEnums() && this.state.value === "enum")) {
          return false;
        }

        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual("enum")) {
          var node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        var _this5 = this;

        if (!this.match(types$1.question)) return expr;

        if (this.state.maybeInArrowParameters) {
          var result = this.tryParse(function () {
            return _superClass.prototype.parseConditional.call(_this5, expr, startPos, startLoc);
          });

          if (!result.node) {
            if (result.error) {
              _superClass.prototype.setOptionalParametersError.call(this, refExpressionErrors, result.error);
            }

            return expr;
          }

          if (result.error) this.state = result.failState;
          return result.node;
        }

        this.expect(types$1.question);
        var state = this.state.clone();
        var originalNoArrowAt = this.state.noArrowAt;
        var node = this.startNodeAt(startPos, startLoc);

        var _this$tryParseConditi = this.tryParseConditionalConsequent(),
            consequent = _this$tryParseConditi.consequent,
            failed = _this$tryParseConditi.failed;

        var _this$getArrowLikeExp = this.getArrowLikeExpressions(consequent),
            valid = _this$getArrowLikeExp[0],
            invalid = _this$getArrowLikeExp[1];

        if (failed || invalid.length > 0) {
          var noArrowAt = [].concat(originalNoArrowAt);

          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;

            for (var i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }

            var _this$tryParseConditi2 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi2.consequent;
            failed = _this$tryParseConditi2.failed;

            var _this$getArrowLikeExp2 = this.getArrowLikeExpressions(consequent);

            valid = _this$getArrowLikeExp2[0];
            invalid = _this$getArrowLikeExp2[1];
          }

          if (failed && valid.length > 1) {
            this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);
          }

          if (failed && valid.length === 1) {
            this.state = state;
            this.state.noArrowAt = noArrowAt.concat(valid[0].start);

            var _this$tryParseConditi3 = this.tryParseConditionalConsequent();

            consequent = _this$tryParseConditi3.consequent;
            failed = _this$tryParseConditi3.failed;
          }
        }

        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(types$1.colon);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, function () {
          return _this5.parseMaybeAssign(undefined, undefined);
        });
        return this.finishNode(node, "ConditionalExpression");
      };

      _proto.tryParseConditionalConsequent = function tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        var consequent = this.parseMaybeAssignAllowIn();
        var failed = !this.match(types$1.colon);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent: consequent,
          failed: failed
        };
      };

      _proto.getArrowLikeExpressions = function getArrowLikeExpressions(node, disallowInvalid) {
        var _this6 = this;

        var stack = [node];
        var arrows = [];

        while (stack.length !== 0) {
          var _node2 = stack.pop();

          if (_node2.type === "ArrowFunctionExpression") {
            if (_node2.typeParameters || !_node2.returnType) {
              this.finishArrowValidation(_node2);
            } else {
              arrows.push(_node2);
            }

            stack.push(_node2.body);
          } else if (_node2.type === "ConditionalExpression") {
            stack.push(_node2.consequent);
            stack.push(_node2.alternate);
          }
        }

        if (disallowInvalid) {
          arrows.forEach(function (node) {
            return _this6.finishArrowValidation(node);
          });
          return [arrows, []];
        }

        return partition(arrows, function (node) {
          return node.params.every(function (param) {
            return _this6.isAssignable(param, true);
          });
        });
      };

      _proto.finishArrowValidation = function finishArrowValidation(node) {
        var _node$extra;

        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma, false);
        this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);

        _superClass.prototype.checkParams.call(this, node, false, true);

        this.scope.exit();
      };

      _proto.forwardNoArrowParamsConversionAt = function forwardNoArrowParamsConversionAt(node, parse) {
        var result;

        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse();
        }

        return result;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types$1.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types$1.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }

        return node;
      };

      _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }

        _superClass.prototype.assertModuleNodeAllowed.call(this, node);
      };

      _proto.parseExport = function parseExport(node) {
        var decl = _superClass.prototype.parseExport.call(this, node);

        if (decl.type === "ExportNamedDeclaration" || decl.type === "ExportAllDeclaration") {
          decl.exportKind = decl.exportKind || "value";
        }

        return decl;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        if (this.isContextual("type")) {
          node.exportKind = "type";
          var declarationNode = this.startNode();
          this.next();

          if (this.match(types$1.braceL)) {
            node.specifiers = this.parseExportSpecifiers();
            this.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual("opaque")) {
          node.exportKind = "type";

          var _declarationNode = this.startNode();

          this.next();
          return this.flowParseOpaqueType(_declarationNode, false);
        } else if (this.isContextual("interface")) {
          node.exportKind = "type";

          var _declarationNode2 = this.startNode();

          this.next();
          return this.flowParseInterface(_declarationNode2);
        } else if (this.shouldParseEnums() && this.isContextual("enum")) {
          node.exportKind = "value";

          var _declarationNode3 = this.startNode();

          this.next();
          return this.flowParseEnumDeclaration(_declarationNode3);
        } else {
          return _superClass.prototype.parseExportDeclaration.call(this, node);
        }
      };

      _proto.eatExportStar = function eatExportStar(node) {
        if (_superClass.prototype.eatExportStar.apply(this, arguments)) return true;

        if (this.isContextual("type") && this.lookahead().type === types$1.star) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }

        return false;
      };

      _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
        var pos = this.state.start;

        var hasNamespace = _superClass.prototype.maybeParseExportNamespaceSpecifier.call(this, node);

        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(pos);
        }

        return hasNamespace;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId);

        if (this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var pos = this.state.start;

        if (this.isContextual("declare")) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }

          member.declare = true;
        }

        _superClass.prototype.parseClassMember.call(this, classBody, member, state);

        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
              this.raise(pos, FlowErrors.DeclareClassElement);
            } else if (member.value) {
            this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);
          }
        }
      };

      _proto.isIterator = function isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      };

      _proto.readIterator = function readIterator() {
        var word = _superClass.prototype.readWord1.call(this);

        var fullWord = "@@" + word;

        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(this.state.pos, ErrorMessages.InvalidIdentifier, fullWord);
        }

        this.finishToken(types$1.name, fullWord);
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 123 && next === 124) {
          return this.finishOp(types$1.braceBarL, 2);
        } else if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types$1.relational, 1);
        } else if (this.state.inType && code === 63) {
          if (next === 46) {
            return this.finishOp(types$1.questionDot, 2);
          }

          return this.finishOp(types$1.question, 1);
        } else if (isIteratorStart(code, next)) {
          this.state.pos += 2;
          return this.readIterator();
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.isAssignable = function isAssignable(node, isBinding) {
        var _this7 = this;

        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
            return true;

          case "ObjectExpression":
            {
              var last = node.properties.length - 1;
              return node.properties.every(function (prop, i) {
                return prop.type !== "ObjectMethod" && (i === last || prop.type === "SpreadElement") && _this7.isAssignable(prop);
              });
            }

          case "ObjectProperty":
            return this.isAssignable(node.value);

          case "SpreadElement":
            return this.isAssignable(node.argument);

          case "ArrayExpression":
            return node.elements.every(function (element) {
              return _this7.isAssignable(element);
            });

          case "AssignmentExpression":
            return node.operator === "=";

          case "ParenthesizedExpression":
          case "TypeCastExpression":
            return this.isAssignable(node.expression);

          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;

          default:
            return false;
        }
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        if (node.type === "TypeCastExpression") {
          return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);
        } else {
          return _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];

          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }

        return _superClass.prototype.toAssignableList.call(this, exprList, trailingCommaPos, isLHS);
      };

      _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
        for (var i = 0; i < exprList.length; i++) {
          var _expr$extra;

          var expr = exprList[i];

          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);
          }
        }

        return exprList;
      };

      _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        var node = _superClass.prototype.parseArrayLike.call(this, close, canBePattern, isTuple, refExpressionErrors);

        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }

        return node;
      };

      _proto.checkLVal = function checkLVal(expr) {
        if (expr.type !== "TypeCastExpression") {
          var _superClass$prototype;

          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }

          return (_superClass$prototype = _superClass.prototype.checkLVal).call.apply(_superClass$prototype, [this, expr].concat(args));
        }
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        if (this.match(types$1.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (this.match(types$1.colon)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }

        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types$1.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
        return !this.match(types$1.colon) && _superClass.prototype.isNonstaticConstructor.call(this, method);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);

        if (method.params && isConstructor) {
          var params = method.params;

          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          var _params = method.value.params;

          if (_params.length > 0 && this.isThisParam(_params[0])) {
            this.raise(method.start, FlowErrors.ThisParamBannedInConstructor);
          }
        }
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.start);
        }

        delete method.variance;

        if (this.isRelational("<")) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }

        if (this.isContextual("implements")) {
          this.next();
          var implemented = node["implements"] = [];

          do {
            var _node3 = this.startNode();

            _node3.id = this.flowParseRestrictedIdentifier(true);

            if (this.isRelational("<")) {
              _node3.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              _node3.typeParameters = null;
            }

            implemented.push(this.finishNode(_node3, "ClassImplements"));
          } while (this.eat(types$1.comma));
        }
      };

      _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
        _superClass.prototype.checkGetterSetterParams.call(this, method);

        var params = this.getObjectOrClassMethodParams(method);

        if (params.length > 0) {
          var param = params[0];

          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(param.start, FlowErrors.GetterMayNotHaveThisParam);
          } else if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.SetterMayNotHaveThisParam);
          }
        }
      };

      _proto.parsePropertyName = function parsePropertyName(node, isPrivateNameAllowed) {
        var variance = this.flowParseVariance();

        var key = _superClass.prototype.parsePropertyName.call(this, node, isPrivateNameAllowed);

        node.variance = variance;
        return key;
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.start);
        }

        delete prop.variance;
        var typeParameters;

        if (this.isRelational("<") && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(types$1.parenL)) this.unexpected();
        }

        _superClass.prototype.parseObjPropValue.call(this, prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);

        if (typeParameters) {
          (prop.value || prop).typeParameters = typeParameters;
        }
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types$1.question)) {
          if (param.type !== "Identifier") {
            this.raise(param.start, FlowErrors.OptionalBindingPattern);
          }

          if (this.isThisParam(param)) {
            this.raise(param.start, FlowErrors.ThisParamMayNotBeOptional);
          }

          param.optional = true;
        }

        if (this.match(types$1.colon)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamAnnotationRequired);
        }

        if (this.match(types$1.eq) && this.isThisParam(param)) {
          this.raise(param.start, FlowErrors.ThisParamNoDefault);
        }

        this.resetEndLocation(param);
        return param;
      };

      _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
        var node = _superClass.prototype.parseMaybeDefault.call(this, startPos, startLoc, left);

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);
        }

        return node;
      };

      _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
        if (!hasTypeImportKind(node)) {
          return _superClass.prototype.shouldParseDefaultImport.call(this, node);
        }

        return isMaybeDefaultImport(this.state);
      };

      _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, type));
      };

      _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
        node.importKind = "value";
        var kind = null;

        if (this.match(types$1._typeof)) {
          kind = "typeof";
        } else if (this.isContextual("type")) {
          kind = "type";
        }

        if (kind) {
          var lh = this.lookahead();

          if (kind === "type" && lh.type === types$1.star) {
            this.unexpected(lh.start);
          }

          if (isMaybeDefaultImport(lh) || lh.type === types$1.braceL || lh.type === types$1.star) {
            this.next();
            node.importKind = kind;
          }
        }

        return _superClass.prototype.maybeParseDefaultImportSpecifier.call(this, node);
      };

      _proto.parseImportSpecifier = function parseImportSpecifier(node) {
        var specifier = this.startNode();
        var firstIdentIsString = this.match(types$1.string);
        var firstIdent = this.parseModuleExportName();
        var specifierTypeKind = null;

        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }

        var isBinding = false;

        if (this.isContextual("as") && !this.isLookaheadContextual("as")) {
          var as_ident = this.parseIdentifier(true);

          if (specifierTypeKind !== null && !this.match(types$1.name) && !this.state.type.keyword) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = as_ident.__clone();
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else if (specifierTypeKind !== null && (this.match(types$1.name) || this.state.type.keyword)) {
          specifier.imported = this.parseIdentifier(true);
          specifier.importKind = specifierTypeKind;

          if (this.eatContextual("as")) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = specifier.imported.__clone();
          }
        } else {
          if (firstIdentIsString) {
            throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, firstIdent.value);
          }

          isBinding = true;
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = specifier.imported.__clone();
        }

        var nodeIsTypeImport = hasTypeImportKind(node);
        var specifierIsTypeImport = hasTypeImportKind(specifier);

        if (nodeIsTypeImport && specifierIsTypeImport) {
          this.raise(specifier.start, FlowErrors.ImportTypeShorthandOnlyInPureImport);
        }

        if (nodeIsTypeImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.start, true);
        }

        if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.start, true, true);
        }

        this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
        node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case types$1._this:
            return this.parseIdentifier(true);

          default:
            return _superClass.prototype.parseBindingAtom.call(this);
        }
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var kind = node.kind;

        if (kind !== "get" && kind !== "set" && this.isRelational("<")) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (this.match(types$1.colon)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types$1.colon)) {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types$1.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _this8 = this,
            _jsx;

        var state = null;
        var jsx;

        if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            return _superClass.prototype.parseMaybeAssign.call(_this8, refExpressionErrors, afterLeftParse);
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;
          var curContext = context[context.length - 1];

          if (curContext === types.j_oTag) {
            context.length -= 2;
          } else if (curContext === types.j_expr) {
            context.length -= 1;
          }
        }

        if ((_jsx = jsx) != null && _jsx.error || this.isRelational("<")) {
          var _jsx2, _jsx3;

          state = state || this.state.clone();
          var typeParameters;
          var arrow = this.tryParse(function (abort) {
            var _arrowExpression$extr;

            typeParameters = _this8.flowParseTypeParameterDeclaration();

            var arrowExpression = _this8.forwardNoArrowParamsConversionAt(typeParameters, function () {
              var result = _superClass.prototype.parseMaybeAssign.call(_this8, refExpressionErrors, afterLeftParse);

              _this8.resetStartLocationFromNode(result, typeParameters);

              return result;
            });

            if (arrowExpression.type !== "ArrowFunctionExpression" && (_arrowExpression$extr = arrowExpression.extra) != null && _arrowExpression$extr.parenthesized) {
              abort();
            }

            var expr = _this8.maybeUnwrapTypeCastExpression(arrowExpression);

            expr.typeParameters = typeParameters;

            _this8.resetStartLocationFromNode(expr, typeParameters);

            return arrowExpression;
          }, state);
          var arrowExpression = null;

          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(typeParameters.start, FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction);
              }

              return arrow.node;
            }

            arrowExpression = arrow.node;
          }

          if ((_jsx2 = jsx) != null && _jsx2.node) {
            this.state = jsx.failState;
            return jsx.node;
          }

          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }

          if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);
        }

        return _superClass.prototype.parseMaybeAssign.call(this, refExpressionErrors, afterLeftParse);
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this9 = this;

        if (this.match(types$1.colon)) {
          var result = this.tryParse(function () {
            var oldNoAnonFunctionType = _this9.state.noAnonFunctionType;
            _this9.state.noAnonFunctionType = true;

            var typeNode = _this9.startNode();

            var _this9$flowParseTypeA = _this9.flowParseTypeAndPredicateInitialiser();

            typeNode.typeAnnotation = _this9$flowParseTypeA[0];
            node.predicate = _this9$flowParseTypeA[1];
            _this9.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (_this9.canInsertSemicolon()) _this9.unexpected();
            if (!_this9.match(types$1.arrow)) _this9.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types$1.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          node.params = params;
        } else {
          _superClass.prototype.setArrowFunctionParameters.call(this, node, params);
        }
      };

      _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {
          return;
        }

        for (var i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(node.params[i].start, FlowErrors.ThisParamMustBeFirst);
          }
        }

        return _superClass.prototype.checkParams.apply(this, arguments);
      };

      _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
        return _superClass.prototype.parseParenAndDistinguishExpression.call(this, canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);
      };

      _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
        var _this10 = this;

        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.indexOf(startPos) !== -1) {
          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.isRelational("<")) {
          var state = this.state.clone();
          var arrow = this.tryParse(function (abort) {
            return _this10.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort();
          }, state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          var result = this.tryParse(function () {
            return _superClass.prototype.parseSubscripts.call(_this10, base, startPos, startLoc, noCalls);
          }, state);
          if (result.node && !result.error) return result.node;

          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }

          if (result.node) {
            this.state = result.failState;
            return result.node;
          }

          throw arrow.error || result.error;
        }

        return _superClass.prototype.parseSubscripts.call(this, base, startPos, startLoc, noCalls);
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {
        var _this11 = this;

        if (this.match(types$1.questionDot) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;

          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }

          this.next();
          var node = this.startNodeAt(startPos, startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(types$1.parenL);
          node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.isRelational("<")) {
          var _node4 = this.startNodeAt(startPos, startLoc);

          _node4.callee = base;
          var result = this.tryParse(function () {
            _node4.typeArguments = _this11.flowParseTypeParameterInstantiationCallOrNew();

            _this11.expect(types$1.parenL);

            _node4.arguments = _this11.parseCallExpressionArguments(types$1.parenR, false);
            if (subscriptState.optionalChainMember) _node4.optional = false;
            return _this11.finishCallExpression(_node4, subscriptState.optionalChainMember);
          });

          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, subscriptState);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this12 = this;

        var targs = null;

        if (this.shouldParseTypes() && this.isRelational("<")) {
          targs = this.tryParse(function () {
            return _this12.flowParseTypeParameterInstantiationCallOrNew();
          }).node;
        }

        node.typeArguments = targs;

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseAsyncArrowWithTypeParameters = function parseAsyncArrowWithTypeParameters(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        this.parseFunctionParams(node);
        if (!this.parseArrow(node)) return;
        return this.parseArrowExpression(node, undefined, true);
      };

      _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }

        _superClass.prototype.readToken_mult_modulo.call(this, code);
      };

      _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
        var next = this.input.charCodeAt(this.state.pos + 1);

        if (code === 124 && next === 125) {
          this.finishOp(types$1.braceBarR, 2);
          return;
        }

        _superClass.prototype.readToken_pipe_amp.call(this, code);
      };

      _proto.parseTopLevel = function parseTopLevel(file, program) {
        var fileNode = _superClass.prototype.parseTopLevel.call(this, file, program);

        if (this.state.hasFlowComment) {
          this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);
        }

        return fileNode;
      };

      _proto.skipBlockComment = function skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            this.unexpected(null, FlowErrors.NestedFlowComment);
          }

          this.hasFlowCommentCompletion();
          this.state.pos += this.skipFlowComment();
          this.state.hasFlowComment = true;
          return;
        }

        if (this.state.hasFlowComment) {
          var end = this.input.indexOf("*-/", this.state.pos += 2);

          if (end === -1) {
            throw this.raise(this.state.pos - 2, ErrorMessages.UnterminatedComment);
          }

          this.state.pos = end + 3;
          return;
        }

        _superClass.prototype.skipBlockComment.call(this);
      };

      _proto.skipFlowComment = function skipFlowComment() {
        var pos = this.state.pos;
        var shiftToFirstNonWhiteSpace = 2;

        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }

        var ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        var ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);

        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }

        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }

        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }

        return false;
      };

      _proto.hasFlowCommentCompletion = function hasFlowCommentCompletion() {
        var end = this.input.indexOf("*/", this.state.pos);

        if (end === -1) {
          throw this.raise(this.state.pos, ErrorMessages.UnterminatedComment);
        }
      };

      _proto.flowEnumErrorBooleanMemberNotInitialized = function flowEnumErrorBooleanMemberNotInitialized(pos, _ref2) {
        var enumName = _ref2.enumName,
            memberName = _ref2.memberName;
        this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);
      };

      _proto.flowEnumErrorInvalidMemberName = function flowEnumErrorInvalidMemberName(pos, _ref3) {
        var enumName = _ref3.enumName,
            memberName = _ref3.memberName;
        var suggestion = memberName[0].toUpperCase() + memberName.slice(1);
        this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);
      };

      _proto.flowEnumErrorDuplicateMemberName = function flowEnumErrorDuplicateMemberName(pos, _ref4) {
        var enumName = _ref4.enumName,
            memberName = _ref4.memberName;
        this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);
      };

      _proto.flowEnumErrorInconsistentMemberValues = function flowEnumErrorInconsistentMemberValues(pos, _ref5) {
        var enumName = _ref5.enumName;
        this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);
      };

      _proto.flowEnumErrorInvalidExplicitType = function flowEnumErrorInvalidExplicitType(pos, _ref6) {
        var enumName = _ref6.enumName,
            suppliedType = _ref6.suppliedType;
        return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);
      };

      _proto.flowEnumErrorInvalidMemberInitializer = function flowEnumErrorInvalidMemberInitializer(pos, _ref7) {
        var enumName = _ref7.enumName,
            explicitType = _ref7.explicitType,
            memberName = _ref7.memberName;
        var message = null;

        switch (explicitType) {
          case "boolean":
          case "number":
          case "string":
            message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;
            break;

          case "symbol":
            message = FlowErrors.EnumInvalidMemberInitializerSymbolType;
            break;

          default:
            message = FlowErrors.EnumInvalidMemberInitializerUnknownType;
        }

        return this.raise(pos, message, enumName, memberName, explicitType);
      };

      _proto.flowEnumErrorNumberMemberNotInitialized = function flowEnumErrorNumberMemberNotInitialized(pos, _ref8) {
        var enumName = _ref8.enumName,
            memberName = _ref8.memberName;
        this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);
      };

      _proto.flowEnumErrorStringMemberInconsistentlyInitailized = function flowEnumErrorStringMemberInconsistentlyInitailized(pos, _ref9) {
        var enumName = _ref9.enumName;
        this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);
      };

      _proto.flowEnumMemberInit = function flowEnumMemberInit() {
        var _this13 = this;

        var startPos = this.state.start;

        var endOfInit = function endOfInit() {
          return _this13.match(types$1.comma) || _this13.match(types$1.braceR);
        };

        switch (this.state.type) {
          case types$1.num:
            {
              var literal = this.parseNumericLiteral(this.state.value);

              if (endOfInit()) {
                return {
                  type: "number",
                  pos: literal.start,
                  value: literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types$1.string:
            {
              var _literal = this.parseStringLiteral(this.state.value);

              if (endOfInit()) {
                return {
                  type: "string",
                  pos: _literal.start,
                  value: _literal
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          case types$1._true:
          case types$1._false:
            {
              var _literal2 = this.parseBooleanLiteral(this.match(types$1._true));

              if (endOfInit()) {
                return {
                  type: "boolean",
                  pos: _literal2.start,
                  value: _literal2
                };
              }

              return {
                type: "invalid",
                pos: startPos
              };
            }

          default:
            return {
              type: "invalid",
              pos: startPos
            };
        }
      };

      _proto.flowEnumMemberRaw = function flowEnumMemberRaw() {
        var pos = this.state.start;
        var id = this.parseIdentifier(true);
        var init = this.eat(types$1.eq) ? this.flowEnumMemberInit() : {
          type: "none",
          pos: pos
        };
        return {
          id: id,
          init: init
        };
      };

      _proto.flowEnumCheckExplicitTypeMismatch = function flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {
        var explicitType = context.explicitType;

        if (explicitType === null) {
          return;
        }

        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(pos, context);
        }
      };

      _proto.flowEnumMembers = function flowEnumMembers(_ref10) {
        var enumName = _ref10.enumName,
            explicitType = _ref10.explicitType;
        var seenNames = new Set();
        var members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        var hasUnknownMembers = false;

        while (!this.match(types$1.braceR)) {
          if (this.eat(types$1.ellipsis)) {
            hasUnknownMembers = true;
            break;
          }

          var memberNode = this.startNode();

          var _this$flowEnumMemberR = this.flowEnumMemberRaw(),
              id = _this$flowEnumMemberR.id,
              init = _this$flowEnumMemberR.init;

          var memberName = id.name;

          if (memberName === "") {
            continue;
          }

          if (/^[a-z]/.test(memberName)) {
            this.flowEnumErrorInvalidMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          if (seenNames.has(memberName)) {
            this.flowEnumErrorDuplicateMemberName(id.start, {
              enumName: enumName,
              memberName: memberName
            });
          }

          seenNames.add(memberName);
          var context = {
            enumName: enumName,
            explicitType: explicitType,
            memberName: memberName
          };
          memberNode.id = id;

          switch (init.type) {
            case "boolean":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "boolean");
                memberNode.init = init.value;
                members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
                break;
              }

            case "number":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "number");
                memberNode.init = init.value;
                members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
                break;
              }

            case "string":
              {
                this.flowEnumCheckExplicitTypeMismatch(init.pos, context, "string");
                memberNode.init = init.value;
                members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
                break;
              }

            case "invalid":
              {
                throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);
              }

            case "none":
              {
                switch (explicitType) {
                  case "boolean":
                    this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);
                    break;

                  case "number":
                    this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);
                    break;

                  default:
                    members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
                }
              }
          }

          if (!this.match(types$1.braceR)) {
            this.expect(types$1.comma);
          }
        }

        return {
          members: members,
          hasUnknownMembers: hasUnknownMembers
        };
      };

      _proto.flowEnumStringMembers = function flowEnumStringMembers(initializedMembers, defaultedMembers, _ref11) {
        var enumName = _ref11.enumName;

        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (var _i2 = 0; _i2 < initializedMembers.length; _i2++) {
            var member = initializedMembers[_i2];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {
              enumName: enumName
            });
          }

          return defaultedMembers;
        } else {
          for (var _i4 = 0; _i4 < defaultedMembers.length; _i4++) {
            var _member = defaultedMembers[_i4];
            this.flowEnumErrorStringMemberInconsistentlyInitailized(_member.start, {
              enumName: enumName
            });
          }

          return initializedMembers;
        }
      };

      _proto.flowEnumParseExplicitType = function flowEnumParseExplicitType(_ref12) {
        var enumName = _ref12.enumName;

        if (this.eatContextual("of")) {
          if (!this.match(types$1.name)) {
            throw this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: null
            });
          }

          var value = this.state.value;
          this.next();

          if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
            this.flowEnumErrorInvalidExplicitType(this.state.start, {
              enumName: enumName,
              suppliedType: value
            });
          }

          return value;
        }

        return null;
      };

      _proto.flowEnumBody = function flowEnumBody(node, _ref13) {
        var _this14 = this;

        var enumName = _ref13.enumName,
            nameLoc = _ref13.nameLoc;
        var explicitType = this.flowEnumParseExplicitType({
          enumName: enumName
        });
        this.expect(types$1.braceL);

        var _this$flowEnumMembers = this.flowEnumMembers({
          enumName: enumName,
          explicitType: explicitType
        }),
            members = _this$flowEnumMembers.members,
            hasUnknownMembers = _this$flowEnumMembers.hasUnknownMembers;

        node.hasUnknownMembers = hasUnknownMembers;

        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumBooleanBody");

          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumNumberBody");

          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName: enumName
            });
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumStringBody");

          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(types$1.braceR);
            return this.finishNode(node, "EnumSymbolBody");

          default:
            {
              var empty = function empty() {
                node.members = [];

                _this14.expect(types$1.braceR);

                return _this14.finishNode(node, "EnumStringBody");
              };

              node.explicitType = false;
              var boolsLen = members.booleanMembers.length;
              var numsLen = members.numberMembers.length;
              var strsLen = members.stringMembers.length;
              var defaultedLen = members.defaultedMembers.length;

              if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
                return empty();
              } else if (!boolsLen && !numsLen) {
                node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                  enumName: enumName
                });
                this.expect(types$1.braceR);
                return this.finishNode(node, "EnumStringBody");
              } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
                for (var _i6 = 0, _members$defaultedMem2 = members.defaultedMembers; _i6 < _members$defaultedMem2.length; _i6++) {
                  var member = _members$defaultedMem2[_i6];
                  this.flowEnumErrorBooleanMemberNotInitialized(member.start, {
                    enumName: enumName,
                    memberName: member.id.name
                  });
                }

                node.members = members.booleanMembers;
                this.expect(types$1.braceR);
                return this.finishNode(node, "EnumBooleanBody");
              } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
                for (var _i8 = 0, _members$defaultedMem4 = members.defaultedMembers; _i8 < _members$defaultedMem4.length; _i8++) {
                  var _member2 = _members$defaultedMem4[_i8];
                  this.flowEnumErrorNumberMemberNotInitialized(_member2.start, {
                    enumName: enumName,
                    memberName: _member2.id.name
                  });
                }

                node.members = members.numberMembers;
                this.expect(types$1.braceR);
                return this.finishNode(node, "EnumNumberBody");
              } else {
                this.flowEnumErrorInconsistentMemberValues(nameLoc, {
                  enumName: enumName
                });
                return empty();
              }
            }
        }
      };

      _proto.flowParseEnumDeclaration = function flowParseEnumDeclaration(node) {
        var id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), {
          enumName: id.name,
          nameLoc: id.start
        });
        return this.finishNode(node, "EnumDeclaration");
      };

      _proto.isLookaheadToken_lt = function isLookaheadToken_lt() {
        var next = this.nextTokenStart();

        if (this.input.charCodeAt(next) === 60) {
          var afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }

        return false;
      };

      _proto.maybeUnwrapTypeCastExpression = function maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      };

      return _class2;
    }(superClass);
  });

  var entities = {
    quot: "\"",
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: "\xA0",
    iexcl: "\xA1",
    cent: "\xA2",
    pound: "\xA3",
    curren: "\xA4",
    yen: "\xA5",
    brvbar: "\xA6",
    sect: "\xA7",
    uml: "\xA8",
    copy: "\xA9",
    ordf: "\xAA",
    laquo: "\xAB",
    not: "\xAC",
    shy: "\xAD",
    reg: "\xAE",
    macr: "\xAF",
    deg: "\xB0",
    plusmn: "\xB1",
    sup2: "\xB2",
    sup3: "\xB3",
    acute: "\xB4",
    micro: "\xB5",
    para: "\xB6",
    middot: "\xB7",
    cedil: "\xB8",
    sup1: "\xB9",
    ordm: "\xBA",
    raquo: "\xBB",
    frac14: "\xBC",
    frac12: "\xBD",
    frac34: "\xBE",
    iquest: "\xBF",
    Agrave: "\xC0",
    Aacute: "\xC1",
    Acirc: "\xC2",
    Atilde: "\xC3",
    Auml: "\xC4",
    Aring: "\xC5",
    AElig: "\xC6",
    Ccedil: "\xC7",
    Egrave: "\xC8",
    Eacute: "\xC9",
    Ecirc: "\xCA",
    Euml: "\xCB",
    Igrave: "\xCC",
    Iacute: "\xCD",
    Icirc: "\xCE",
    Iuml: "\xCF",
    ETH: "\xD0",
    Ntilde: "\xD1",
    Ograve: "\xD2",
    Oacute: "\xD3",
    Ocirc: "\xD4",
    Otilde: "\xD5",
    Ouml: "\xD6",
    times: "\xD7",
    Oslash: "\xD8",
    Ugrave: "\xD9",
    Uacute: "\xDA",
    Ucirc: "\xDB",
    Uuml: "\xDC",
    Yacute: "\xDD",
    THORN: "\xDE",
    szlig: "\xDF",
    agrave: "\xE0",
    aacute: "\xE1",
    acirc: "\xE2",
    atilde: "\xE3",
    auml: "\xE4",
    aring: "\xE5",
    aelig: "\xE6",
    ccedil: "\xE7",
    egrave: "\xE8",
    eacute: "\xE9",
    ecirc: "\xEA",
    euml: "\xEB",
    igrave: "\xEC",
    iacute: "\xED",
    icirc: "\xEE",
    iuml: "\xEF",
    eth: "\xF0",
    ntilde: "\xF1",
    ograve: "\xF2",
    oacute: "\xF3",
    ocirc: "\xF4",
    otilde: "\xF5",
    ouml: "\xF6",
    divide: "\xF7",
    oslash: "\xF8",
    ugrave: "\xF9",
    uacute: "\xFA",
    ucirc: "\xFB",
    uuml: "\xFC",
    yacute: "\xFD",
    thorn: "\xFE",
    yuml: "\xFF",
    OElig: "\u0152",
    oelig: "\u0153",
    Scaron: "\u0160",
    scaron: "\u0161",
    Yuml: "\u0178",
    fnof: "\u0192",
    circ: "\u02C6",
    tilde: "\u02DC",
    Alpha: "\u0391",
    Beta: "\u0392",
    Gamma: "\u0393",
    Delta: "\u0394",
    Epsilon: "\u0395",
    Zeta: "\u0396",
    Eta: "\u0397",
    Theta: "\u0398",
    Iota: "\u0399",
    Kappa: "\u039A",
    Lambda: "\u039B",
    Mu: "\u039C",
    Nu: "\u039D",
    Xi: "\u039E",
    Omicron: "\u039F",
    Pi: "\u03A0",
    Rho: "\u03A1",
    Sigma: "\u03A3",
    Tau: "\u03A4",
    Upsilon: "\u03A5",
    Phi: "\u03A6",
    Chi: "\u03A7",
    Psi: "\u03A8",
    Omega: "\u03A9",
    alpha: "\u03B1",
    beta: "\u03B2",
    gamma: "\u03B3",
    delta: "\u03B4",
    epsilon: "\u03B5",
    zeta: "\u03B6",
    eta: "\u03B7",
    theta: "\u03B8",
    iota: "\u03B9",
    kappa: "\u03BA",
    lambda: "\u03BB",
    mu: "\u03BC",
    nu: "\u03BD",
    xi: "\u03BE",
    omicron: "\u03BF",
    pi: "\u03C0",
    rho: "\u03C1",
    sigmaf: "\u03C2",
    sigma: "\u03C3",
    tau: "\u03C4",
    upsilon: "\u03C5",
    phi: "\u03C6",
    chi: "\u03C7",
    psi: "\u03C8",
    omega: "\u03C9",
    thetasym: "\u03D1",
    upsih: "\u03D2",
    piv: "\u03D6",
    ensp: "\u2002",
    emsp: "\u2003",
    thinsp: "\u2009",
    zwnj: "\u200C",
    zwj: "\u200D",
    lrm: "\u200E",
    rlm: "\u200F",
    ndash: "\u2013",
    mdash: "\u2014",
    lsquo: "\u2018",
    rsquo: "\u2019",
    sbquo: "\u201A",
    ldquo: "\u201C",
    rdquo: "\u201D",
    bdquo: "\u201E",
    dagger: "\u2020",
    Dagger: "\u2021",
    bull: "\u2022",
    hellip: "\u2026",
    permil: "\u2030",
    prime: "\u2032",
    Prime: "\u2033",
    lsaquo: "\u2039",
    rsaquo: "\u203A",
    oline: "\u203E",
    frasl: "\u2044",
    euro: "\u20AC",
    image: "\u2111",
    weierp: "\u2118",
    real: "\u211C",
    trade: "\u2122",
    alefsym: "\u2135",
    larr: "\u2190",
    uarr: "\u2191",
    rarr: "\u2192",
    darr: "\u2193",
    harr: "\u2194",
    crarr: "\u21B5",
    lArr: "\u21D0",
    uArr: "\u21D1",
    rArr: "\u21D2",
    dArr: "\u21D3",
    hArr: "\u21D4",
    forall: "\u2200",
    part: "\u2202",
    exist: "\u2203",
    empty: "\u2205",
    nabla: "\u2207",
    isin: "\u2208",
    notin: "\u2209",
    ni: "\u220B",
    prod: "\u220F",
    sum: "\u2211",
    minus: "\u2212",
    lowast: "\u2217",
    radic: "\u221A",
    prop: "\u221D",
    infin: "\u221E",
    ang: "\u2220",
    and: "\u2227",
    or: "\u2228",
    cap: "\u2229",
    cup: "\u222A",
    "int": "\u222B",
    there4: "\u2234",
    sim: "\u223C",
    cong: "\u2245",
    asymp: "\u2248",
    ne: "\u2260",
    equiv: "\u2261",
    le: "\u2264",
    ge: "\u2265",
    sub: "\u2282",
    sup: "\u2283",
    nsub: "\u2284",
    sube: "\u2286",
    supe: "\u2287",
    oplus: "\u2295",
    otimes: "\u2297",
    perp: "\u22A5",
    sdot: "\u22C5",
    lceil: "\u2308",
    rceil: "\u2309",
    lfloor: "\u230A",
    rfloor: "\u230B",
    lang: "\u2329",
    rang: "\u232A",
    loz: "\u25CA",
    spades: "\u2660",
    clubs: "\u2663",
    hearts: "\u2665",
    diams: "\u2666"
  };

  var State = function () {
    function State() {
      this.strict = void 0;
      this.curLine = void 0;
      this.startLoc = void 0;
      this.endLoc = void 0;
      this.errors = [];
      this.potentialArrowAt = -1;
      this.noArrowAt = [];
      this.noArrowParamsConversionAt = [];
      this.maybeInArrowParameters = false;
      this.inPipeline = false;
      this.inType = false;
      this.noAnonFunctionType = false;
      this.inPropertyName = false;
      this.hasFlowComment = false;
      this.isAmbientContext = false;
      this.inAbstractClass = false;
      this.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };
      this.soloAwait = false;
      this.inFSharpPipelineDirectBody = false;
      this.labels = [];
      this.decoratorStack = [[]];
      this.comments = [];
      this.trailingComments = [];
      this.leadingComments = [];
      this.commentStack = [];
      this.commentPreviousNode = null;
      this.pos = 0;
      this.lineStart = 0;
      this.type = types$1.eof;
      this.value = null;
      this.start = 0;
      this.end = 0;
      this.lastTokEndLoc = null;
      this.lastTokStartLoc = null;
      this.lastTokStart = 0;
      this.lastTokEnd = 0;
      this.context = [types.brace];
      this.exprAllowed = true;
      this.containsEsc = false;
      this.strictErrors = new Map();
      this.tokensLength = 0;
    }

    var _proto = State.prototype;

    _proto.init = function init(options) {
      this.strict = options.strictMode === false ? false : options.sourceType === "module";
      this.curLine = options.startLine;
      this.startLoc = this.endLoc = this.curPosition();
    };

    _proto.curPosition = function curPosition() {
      return new Position(this.curLine, this.pos - this.lineStart);
    };

    _proto.clone = function clone(skipArrays) {
      var state = new State();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var key = keys[i];
        var val = this[key];

        if (!skipArrays && Array.isArray(val)) {
          val = val.slice();
        }

        state[key] = val;
      }

      return state;
    };

    return State;
  }();

  var HEX_NUMBER = /^[\da-fA-F]+$/;
  var DECIMAL_NUMBER = /^\d+$/;
  var JsxErrors = makeErrorTemplates({
    AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: "Expected corresponding JSX closing tag for <%0>.",
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
  }, ErrorCodes.SyntaxError);
  types.j_oTag = new TokContext("<tag");
  types.j_cTag = new TokContext("</tag");
  types.j_expr = new TokContext("<tag>...</tag>", true);
  types$1.jsxName = new TokenType("jsxName");
  types$1.jsxText = new TokenType("jsxText", {
    beforeExpr: true
  });
  types$1.jsxTagStart = new TokenType("jsxTagStart", {
    startsExpr: true
  });
  types$1.jsxTagEnd = new TokenType("jsxTagEnd");

  types$1.jsxTagStart.updateContext = function (context) {
    context.push(types.j_expr, types.j_oTag);
  };

  function isFragment(object) {
    return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
  }

  function getQualifiedJSXName(object) {
    if (object.type === "JSXIdentifier") {
      return object.name;
    }

    if (object.type === "JSXNamespacedName") {
      return object.namespace.name + ":" + object.name.name;
    }

    if (object.type === "JSXMemberExpression") {
      return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
    }

    throw new Error("Node had unexpected type: " + object.type);
  }

  var jsx$1 = (function (superClass) {
    return function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.jsxReadToken = function jsxReadToken() {
        var out = "";
        var chunkStart = this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);
          }

          var ch = this.input.charCodeAt(this.state.pos);

          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.exprAllowed) {
                  ++this.state.pos;
                  return this.finishToken(types$1.jsxTagStart);
                }

                return _superClass.prototype.getTokenFromCode.call(this, ch);
              }

              out += this.input.slice(chunkStart, this.state.pos);
              return this.finishToken(types$1.jsxText, out);

            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;

            case 62:
            case 125:

            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }

          }
        }
      };

      _proto.jsxReadNewLine = function jsxReadNewLine(normalizeCRLF) {
        var ch = this.input.charCodeAt(this.state.pos);
        var out;
        ++this.state.pos;

        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }

        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      };

      _proto.jsxReadString = function jsxReadString(quote) {
        var out = "";
        var chunkStart = ++this.state.pos;

        for (;;) {
          if (this.state.pos >= this.length) {
            throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
          }

          var ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;

          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }

        out += this.input.slice(chunkStart, this.state.pos++);
        return this.finishToken(types$1.string, out);
      };

      _proto.jsxReadEntity = function jsxReadEntity() {
        var str = "";
        var count = 0;
        var entity;
        var ch = this.input[this.state.pos];
        var startPos = ++this.state.pos;

        while (this.state.pos < this.length && count++ < 10) {
          ch = this.input[this.state.pos++];

          if (ch === ";") {
            if (str[0] === "#") {
              if (str[1] === "x") {
                str = str.substr(2);

                if (HEX_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 16));
                }
              } else {
                str = str.substr(1);

                if (DECIMAL_NUMBER.test(str)) {
                  entity = String.fromCodePoint(parseInt(str, 10));
                }
              }
            } else {
              entity = entities[str];
            }

            break;
          }

          str += ch;
        }

        if (!entity) {
          this.state.pos = startPos;
          return "&";
        }

        return entity;
      };

      _proto.jsxReadWord = function jsxReadWord() {
        var ch;
        var start = this.state.pos;

        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);

        return this.finishToken(types$1.jsxName, this.input.slice(start, this.state.pos));
      };

      _proto.jsxParseIdentifier = function jsxParseIdentifier() {
        var node = this.startNode();

        if (this.match(types$1.jsxName)) {
          node.name = this.state.value;
        } else if (this.state.type.keyword) {
          node.name = this.state.type.keyword;
        } else {
          this.unexpected();
        }

        this.next();
        return this.finishNode(node, "JSXIdentifier");
      };

      _proto.jsxParseNamespacedName = function jsxParseNamespacedName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var name = this.jsxParseIdentifier();
        if (!this.eat(types$1.colon)) return name;
        var node = this.startNodeAt(startPos, startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      };

      _proto.jsxParseElementName = function jsxParseElementName() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var node = this.jsxParseNamespacedName();

        if (node.type === "JSXNamespacedName") {
          return node;
        }

        while (this.eat(types$1.dot)) {
          var newNode = this.startNodeAt(startPos, startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }

        return node;
      };

      _proto.jsxParseAttributeValue = function jsxParseAttributeValue() {
        var node;

        switch (this.state.type) {
          case types$1.braceL:
            node = this.startNode();
            this.next();
            node = this.jsxParseExpressionContainer(node);

            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(node.start, JsxErrors.AttributeIsEmpty);
            }

            return node;

          case types$1.jsxTagStart:
          case types$1.string:
            return this.parseExprAtom();

          default:
            throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);
        }
      };

      _proto.jsxParseEmptyExpression = function jsxParseEmptyExpression() {
        var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
      };

      _proto.jsxParseSpreadChild = function jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXSpreadChild");
      };

      _proto.jsxParseExpressionContainer = function jsxParseExpressionContainer(node) {
        if (this.match(types$1.braceR)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          var expression = this.parseExpression();
          node.expression = expression;
        }

        this.expect(types$1.braceR);
        return this.finishNode(node, "JSXExpressionContainer");
      };

      _proto.jsxParseAttribute = function jsxParseAttribute() {
        var node = this.startNode();

        if (this.eat(types$1.braceL)) {
          this.expect(types$1.ellipsis);
          node.argument = this.parseMaybeAssignAllowIn();
          this.expect(types$1.braceR);
          return this.finishNode(node, "JSXSpreadAttribute");
        }

        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(types$1.eq) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      };

      _proto.jsxParseOpeningElementAt = function jsxParseOpeningElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types$1.jsxTagEnd)) {
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXOpeningFragment");
        }

        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var attributes = [];

        while (!this.match(types$1.slash) && !this.match(types$1.jsxTagEnd)) {
          attributes.push(this.jsxParseAttribute());
        }

        node.attributes = attributes;
        node.selfClosing = this.eat(types$1.slash);
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXOpeningElement");
      };

      _proto.jsxParseClosingElementAt = function jsxParseClosingElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);

        if (this.match(types$1.jsxTagEnd)) {
          this.expect(types$1.jsxTagEnd);
          return this.finishNode(node, "JSXClosingFragment");
        }

        node.name = this.jsxParseElementName();
        this.expect(types$1.jsxTagEnd);
        return this.finishNode(node, "JSXClosingElement");
      };

      _proto.jsxParseElementAt = function jsxParseElementAt(startPos, startLoc) {
        var node = this.startNodeAt(startPos, startLoc);
        var children = [];
        var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
        var closingElement = null;

        if (!openingElement.selfClosing) {
          contents: for (;;) {
            switch (this.state.type) {
              case types$1.jsxTagStart:
                startPos = this.state.start;
                startLoc = this.state.startLoc;
                this.next();

                if (this.eat(types$1.slash)) {
                  closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
                  break contents;
                }

                children.push(this.jsxParseElementAt(startPos, startLoc));
                break;

              case types$1.jsxText:
                children.push(this.parseExprAtom());
                break;

              case types$1.braceL:
                {
                  var _node = this.startNode();

                  this.next();

                  if (this.match(types$1.ellipsis)) {
                    children.push(this.jsxParseSpreadChild(_node));
                  } else {
                    children.push(this.jsxParseExpressionContainer(_node));
                  }

                  break;
                }

              default:
                throw this.unexpected();
            }
          }

          if (isFragment(openingElement) && !isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));
            }
          }
        }

        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }

        node.children = children;

        if (this.isRelational("<")) {
          throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);
        }

        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      };

      _proto.jsxParseElement = function jsxParseElement() {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startPos, startLoc);
      };

      _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
        if (this.match(types$1.jsxText)) {
          return this.parseLiteral(this.state.value, "JSXText");
        } else if (this.match(types$1.jsxTagStart)) {
          return this.jsxParseElement();
        } else if (this.isRelational("<") && this.input.charCodeAt(this.state.pos) !== 33) {
          this.finishToken(types$1.jsxTagStart);
          return this.jsxParseElement();
        } else {
          return _superClass.prototype.parseExprAtom.call(this, refExpressionErrors);
        }
      };

      _proto.createLookaheadState = function createLookaheadState(state) {
        var lookaheadState = _superClass.prototype.createLookaheadState.call(this, state);

        lookaheadState.inPropertyName = state.inPropertyName;
        return lookaheadState;
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inPropertyName) return _superClass.prototype.getTokenFromCode.call(this, code);
        var context = this.curContext();

        if (context === types.j_expr) {
          return this.jsxReadToken();
        }

        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code)) {
            return this.jsxReadWord();
          }

          if (code === 62) {
            ++this.state.pos;
            return this.finishToken(types$1.jsxTagEnd);
          }

          if ((code === 34 || code === 39) && context === types.j_oTag) {
            return this.jsxReadString(code);
          }
        }

        if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          return this.finishToken(types$1.jsxTagStart);
        }

        return _superClass.prototype.getTokenFromCode.call(this, code);
      };

      _proto.updateContext = function updateContext(prevType) {
        _superClass.prototype.updateContext.call(this, prevType);

        var _this$state = this.state,
            context = _this$state.context,
            type = _this$state.type;

        if (type === types$1.slash && prevType === types$1.jsxTagStart) {
          context.splice(-2, 2, types.j_cTag);
          this.state.exprAllowed = false;
        } else if (type === types$1.jsxTagEnd) {
          var out = context.pop();

          if (out === types.j_oTag && prevType === types$1.slash || out === types.j_cTag) {
            context.pop();
            this.state.exprAllowed = context[context.length - 1] === types.j_expr;
          } else {
            this.state.exprAllowed = true;
          }
        } else if (type.keyword && (prevType === types$1.dot || prevType === types$1.questionDot)) {
          this.state.exprAllowed = false;
        } else {
          this.state.exprAllowed = type.beforeExpr;
        }
      };

      return _class;
    }(superClass);
  });

  var TypeScriptScope = function (_Scope) {
    _inherits(TypeScriptScope, _Scope);

    function TypeScriptScope() {
      var _this;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _Scope.call.apply(_Scope, [this].concat(args)) || this;
      _this.types = new Set();
      _this.enums = new Set();
      _this.constEnums = new Set();
      _this.classes = new Set();
      _this.exportOnlyBindings = new Set();
      return _this;
    }

    return TypeScriptScope;
  }(Scope);

  var TypeScriptScopeHandler = function (_ScopeHandler) {
    _inherits(TypeScriptScopeHandler, _ScopeHandler);

    function TypeScriptScopeHandler() {
      return _ScopeHandler.apply(this, arguments) || this;
    }

    var _proto = TypeScriptScopeHandler.prototype;

    _proto.createScope = function createScope(flags) {
      return new TypeScriptScope(flags);
    };

    _proto.declareName = function declareName(name, bindingType, pos) {
      var scope = this.currentScope();

      if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {
        this.maybeExportDefined(scope, name);
        scope.exportOnlyBindings.add(name);
        return;
      }

      _ScopeHandler.prototype.declareName.apply(this, arguments);

      if (bindingType & BIND_KIND_TYPE) {
        if (!(bindingType & BIND_KIND_VALUE)) {
          this.checkRedeclarationInScope(scope, name, bindingType, pos);
          this.maybeExportDefined(scope, name);
        }

        scope.types.add(name);
      }

      if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.add(name);
      if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.add(name);
      if (bindingType & BIND_FLAGS_CLASS) scope.classes.add(name);
    };

    _proto.isRedeclaredInScope = function isRedeclaredInScope(scope, name, bindingType) {
      if (scope.enums.has(name)) {
        if (bindingType & BIND_FLAGS_TS_ENUM) {
          var isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);
          var wasConst = scope.constEnums.has(name);
          return isConst !== wasConst;
        }

        return true;
      }

      if (bindingType & BIND_FLAGS_CLASS && scope.classes.has(name)) {
        if (scope.lexical.has(name)) {
          return !!(bindingType & BIND_KIND_VALUE);
        } else {
          return false;
        }
      }

      if (bindingType & BIND_KIND_TYPE && scope.types.has(name)) {
        return true;
      }

      return _ScopeHandler.prototype.isRedeclaredInScope.apply(this, arguments);
    };

    _proto.checkLocalExport = function checkLocalExport(id) {
      var topLevelScope = this.scopeStack[0];
      var name = id.name;

      if (!topLevelScope.types.has(name) && !topLevelScope.exportOnlyBindings.has(name)) {
        _ScopeHandler.prototype.checkLocalExport.call(this, id);
      }
    };

    return TypeScriptScopeHandler;
  }(ScopeHandler);

  var PARAM = 0,
      PARAM_YIELD = 1,
      PARAM_AWAIT = 2,
      PARAM_RETURN = 4,
      PARAM_IN = 8;

  var ProductionParameterHandler = function () {
    function ProductionParameterHandler() {
      this.stacks = [];
    }

    var _proto = ProductionParameterHandler.prototype;

    _proto.enter = function enter(flags) {
      this.stacks.push(flags);
    };

    _proto.exit = function exit() {
      this.stacks.pop();
    };

    _proto.currentFlags = function currentFlags() {
      return this.stacks[this.stacks.length - 1];
    };

    _createClass(ProductionParameterHandler, [{
      key: "hasAwait",
      get: function get() {
        return (this.currentFlags() & PARAM_AWAIT) > 0;
      }
    }, {
      key: "hasYield",
      get: function get() {
        return (this.currentFlags() & PARAM_YIELD) > 0;
      }
    }, {
      key: "hasReturn",
      get: function get() {
        return (this.currentFlags() & PARAM_RETURN) > 0;
      }
    }, {
      key: "hasIn",
      get: function get() {
        return (this.currentFlags() & PARAM_IN) > 0;
      }
    }]);

    return ProductionParameterHandler;
  }();
  function functionFlags(isAsync, isGenerator) {
    return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);
  }

  function nonNull(x) {
    if (x == null) {
      throw new Error("Unexpected " + x + " value.");
    }

    return x;
  }

  function assert(x) {
    if (!x) {
      throw new Error("Assert fail");
    }
  }

  var TSErrors = makeErrorTemplates({
    AbstractMethodHasImplementation: "Method '%0' cannot have an implementation because it is marked abstract.",
    AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
    AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
    ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
    ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
    ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
    DeclareAccessor: "'declare' is not allowed in %0ters.",
    DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
    DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
    DuplicateAccessibilityModifier: "Accessibility modifier already seen.",
    DuplicateModifier: "Duplicate modifier: '%0'.",
    EmptyHeritageClauseType: "'%0' list cannot be empty.",
    EmptyTypeArguments: "Type argument list cannot be empty.",
    EmptyTypeParameters: "Type parameter list cannot be empty.",
    ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
    ImportAliasHasImportType: "An import alias can not use 'import type'.",
    IncompatibleModifiers: "'%0' modifier cannot be used with '%1' modifier.",
    IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
    IndexSignatureHasAccessibility: "Index signatures cannot have an accessibility modifier ('%0').",
    IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
    IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
    IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
    InvalidModifierOnTypeMember: "'%0' modifier cannot appear on a type member.",
    InvalidModifiersOrder: "'%0' modifier must precede '%1' modifier.",
    InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
    MixedLabeledAndUnlabeledElements: "Tuple members must all have names or all not have names.",
    NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
    NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
    OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
    OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
    PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
    PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
    PrivateElementHasAccessibility: "Private elements cannot have an accessibility modifier ('%0').",
    ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
    SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
    SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
    SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
    StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
    TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
    UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
    UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
    UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
    UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
    UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
    UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
    UnsupportedSignatureParameterKind: "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0."
  }, ErrorCodes.SyntaxError);

  function keywordTypeFromName(value) {
    switch (value) {
      case "any":
        return "TSAnyKeyword";

      case "boolean":
        return "TSBooleanKeyword";

      case "bigint":
        return "TSBigIntKeyword";

      case "never":
        return "TSNeverKeyword";

      case "number":
        return "TSNumberKeyword";

      case "object":
        return "TSObjectKeyword";

      case "string":
        return "TSStringKeyword";

      case "symbol":
        return "TSSymbolKeyword";

      case "undefined":
        return "TSUndefinedKeyword";

      case "unknown":
        return "TSUnknownKeyword";

      default:
        return undefined;
    }
  }

  function tsIsAccessModifier(modifier) {
    return modifier === "private" || modifier === "public" || modifier === "protected";
  }

  var typescript = (function (superClass) {
    return function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.getScopeHandler = function getScopeHandler() {
        return TypeScriptScopeHandler;
      };

      _proto.tsIsIdentifier = function tsIsIdentifier() {
        return this.match(types$1.name);
      };

      _proto.tsTokenCanFollowModifier = function tsTokenCanFollowModifier() {
        return (this.match(types$1.bracketL) || this.match(types$1.braceL) || this.match(types$1.star) || this.match(types$1.ellipsis) || this.match(types$1.privateName) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      };

      _proto.tsNextTokenCanFollowModifier = function tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      };

      _proto.tsParseModifier = function tsParseModifier(allowedModifiers) {
        if (!this.match(types$1.name)) {
          return undefined;
        }

        var modifier = this.state.value;

        if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
          return modifier;
        }

        return undefined;
      };

      _proto.tsParseModifiers = function tsParseModifiers(modified, allowedModifiers, disallowedModifiers, errorTemplate) {
        var _this = this;

        var enforceOrder = function enforceOrder(pos, modifier, before, after) {
          if (modifier === before && modified[after]) {
            _this.raise(pos, TSErrors.InvalidModifiersOrder, before, after);
          }
        };

        var incompatible = function incompatible(pos, modifier, mod1, mod2) {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            _this.raise(pos, TSErrors.IncompatibleModifiers, mod1, mod2);
          }
        };

        for (;;) {
          var startPos = this.state.start;
          var modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []));
          if (!modifier) break;

          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(startPos, TSErrors.DuplicateAccessibilityModifier);
            } else {
              enforceOrder(startPos, modifier, modifier, "override");
              enforceOrder(startPos, modifier, modifier, "static");
              enforceOrder(startPos, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else {
            if (Object.hasOwnProperty.call(modified, modifier)) {
              this.raise(startPos, TSErrors.DuplicateModifier, modifier);
            } else {
              enforceOrder(startPos, modifier, "static", "readonly");
              enforceOrder(startPos, modifier, "static", "override");
              enforceOrder(startPos, modifier, "override", "readonly");
              enforceOrder(startPos, modifier, "abstract", "override");
              incompatible(startPos, modifier, "declare", "override");
              incompatible(startPos, modifier, "static", "abstract");
            }

            modified[modifier] = true;
          }

          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(startPos, errorTemplate, modifier);
          }
        }
      };

      _proto.tsIsListTerminator = function tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(types$1.braceR);

          case "HeritageClauseElement":
            return this.match(types$1.braceL);

          case "TupleElementTypes":
            return this.match(types$1.bracketR);

          case "TypeParametersOrArguments":
            return this.isRelational(">");
        }

        throw new Error("Unreachable");
      };

      _proto.tsParseList = function tsParseList(kind, parseElement) {
        var result = [];

        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }

        return result;
      };

      _proto.tsParseDelimitedList = function tsParseDelimitedList(kind, parseElement) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));
      };

      _proto.tsParseDelimitedListWorker = function tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {
        var result = [];

        for (;;) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }

          var element = parseElement();

          if (element == null) {
            return undefined;
          }

          result.push(element);

          if (this.eat(types$1.comma)) {
            continue;
          }

          if (this.tsIsListTerminator(kind)) {
            break;
          }

          if (expectSuccess) {
            this.expect(types$1.comma);
          }

          return undefined;
        }

        return result;
      };

      _proto.tsParseBracketedList = function tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(types$1.bracketL);
          } else {
            this.expectRelational("<");
          }
        }

        var result = this.tsParseDelimitedList(kind, parseElement);

        if (bracket) {
          this.expect(types$1.bracketR);
        } else {
          this.expectRelational(">");
        }

        return result;
      };

      _proto.tsParseImportType = function tsParseImportType() {
        var node = this.startNode();
        this.expect(types$1._import);
        this.expect(types$1.parenL);

        if (!this.match(types$1.string)) {
          this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);
        }

        node.argument = this.parseExprAtom();
        this.expect(types$1.parenR);

        if (this.eat(types$1.dot)) {
          node.qualifier = this.tsParseEntityName(true);
        }

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSImportType");
      };

      _proto.tsParseEntityName = function tsParseEntityName(allowReservedWords) {
        var entity = this.parseIdentifier();

        while (this.eat(types$1.dot)) {
          var node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }

        return entity;
      };

      _proto.tsParseTypeReference = function tsParseTypeReference() {
        var node = this.startNode();
        node.typeName = this.tsParseEntityName(false);

        if (!this.hasPrecedingLineBreak() && this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSTypeReference");
      };

      _proto.tsParseThisTypePredicate = function tsParseThisTypePredicate(lhs) {
        this.next();
        var node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      };

      _proto.tsParseThisTypeNode = function tsParseThisTypeNode() {
        var node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      };

      _proto.tsParseTypeQuery = function tsParseTypeQuery() {
        var node = this.startNode();
        this.expect(types$1._typeof);

        if (this.match(types$1._import)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName(true);
        }

        return this.finishNode(node, "TSTypeQuery");
      };

      _proto.tsParseTypeParameter = function tsParseTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsEatThenParseType(types$1._extends);
        node["default"] = this.tsEatThenParseType(types$1.eq);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsTryParseTypeParameters = function tsTryParseTypeParameters() {
        if (this.isRelational("<")) {
          return this.tsParseTypeParameters();
        }
      };

      _proto.tsParseTypeParameters = function tsParseTypeParameters() {
        var node = this.startNode();

        if (this.isRelational("<") || this.match(types$1.jsxTagStart)) {
          this.next();
        } else {
          this.unexpected();
        }

        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this), false, true);

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeParameters);
        }

        return this.finishNode(node, "TSTypeParameterDeclaration");
      };

      _proto.tsTryNextParseConstantContext = function tsTryNextParseConstantContext() {
        if (this.lookahead().type === types$1._const) {
          this.next();
          return this.tsParseTypeReference();
        }

        return null;
      };

      _proto.tsFillSignature = function tsFillSignature(returnToken, signature) {
        var returnTokenRequired = returnToken === types$1.arrow;
        signature.typeParameters = this.tsTryParseTypeParameters();
        this.expect(types$1.parenL);
        signature.parameters = this.tsParseBindingListForSignature();

        if (returnTokenRequired) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      };

      _proto.tsParseBindingListForSignature = function tsParseBindingListForSignature() {
        var _this2 = this;

        return this.parseBindingList(types$1.parenR, 41).map(function (pattern) {
          if (pattern.type !== "Identifier" && pattern.type !== "RestElement" && pattern.type !== "ObjectPattern" && pattern.type !== "ArrayPattern") {
            _this2.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);
          }

          return pattern;
        });
      };

      _proto.tsParseTypeMemberSemicolon = function tsParseTypeMemberSemicolon() {
        if (!this.eat(types$1.comma) && !this.isLineTerminator()) {
          this.expect(types$1.semi);
        }
      };

      _proto.tsParseSignatureMember = function tsParseSignatureMember(kind, node) {
        this.tsFillSignature(types$1.colon, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      };

      _proto.tsIsUnambiguouslyIndexSignature = function tsIsUnambiguouslyIndexSignature() {
        this.next();
        return this.eat(types$1.name) && this.match(types$1.colon);
      };

      _proto.tsTryParseIndexSignature = function tsTryParseIndexSignature(node) {
        if (!(this.match(types$1.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return undefined;
        }

        this.expect(types$1.bracketL);
        var id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(types$1.bracketR);
        node.parameters = [id];
        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      };

      _proto.tsParsePropertyOrMethodSignature = function tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(types$1.question)) node.optional = true;
        var nodeAny = node;

        if (this.match(types$1.parenL) || this.isRelational("<")) {
          if (readonly) {
            this.raise(node.start, TSErrors.ReadonlyForMethodSignature);
          }

          var method = nodeAny;

          if (method.kind && this.isRelational("<")) {
            this.raise(this.state.pos, TSErrors.AccesorCannotHaveTypeParameters);
          }

          this.tsFillSignature(types$1.colon, method);
          this.tsParseTypeMemberSemicolon();

          if (method.kind === "get") {
            if (method.parameters.length > 0) {
              this.raise(this.state.pos, ErrorMessages.BadGetterArity);

              if (this.isThisParam(method.parameters[0])) {
                this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
              }
            }
          } else if (method.kind === "set") {
            if (method.parameters.length !== 1) {
              this.raise(this.state.pos, ErrorMessages.BadSetterArity);
            } else {
              var firstParameter = method.parameters[0];

              if (this.isThisParam(firstParameter)) {
                this.raise(this.state.pos, TSErrors.AccesorCannotDeclareThisParameter);
              }

              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveOptionalParameter);
              }

              if (firstParameter.type === "RestElement") {
                this.raise(this.state.pos, TSErrors.SetAccesorCannotHaveRestParameter);
              }
            }

            if (method.typeAnnotation) {
              this.raise(method.typeAnnotation.start, TSErrors.SetAccesorCannotHaveReturnType);
            }
          } else {
            method.kind = "method";
          }

          return this.finishNode(method, "TSMethodSignature");
        } else {
          var property = nodeAny;
          if (readonly) property.readonly = true;
          var type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      };

      _proto.tsParseTypeMember = function tsParseTypeMember() {
        var node = this.startNode();

        if (this.match(types$1.parenL) || this.isRelational("<")) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }

        if (this.match(types$1._new)) {
          var id = this.startNode();
          this.next();

          if (this.match(types$1.parenL) || this.isRelational("<")) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }

        this.tsParseModifiers(node, ["readonly"], ["declare", "abstract", "private", "protected", "public", "static", "override"], TSErrors.InvalidModifierOnTypeMember);
        var idx = this.tsTryParseIndexSignature(node);

        if (idx) {
          return idx;
        }

        this.parsePropertyName(node, false);

        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          this.parsePropertyName(node, false);
        }

        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      };

      _proto.tsParseTypeLiteral = function tsParseTypeLiteral() {
        var node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      };

      _proto.tsParseObjectTypeMembers = function tsParseObjectTypeMembers() {
        this.expect(types$1.braceL);
        var members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(types$1.braceR);
        return members;
      };

      _proto.tsIsStartOfMappedType = function tsIsStartOfMappedType() {
        this.next();

        if (this.eat(types$1.plusMin)) {
          return this.isContextual("readonly");
        }

        if (this.isContextual("readonly")) {
          this.next();
        }

        if (!this.match(types$1.bracketL)) {
          return false;
        }

        this.next();

        if (!this.tsIsIdentifier()) {
          return false;
        }

        this.next();
        return this.match(types$1._in);
      };

      _proto.tsParseMappedTypeParameter = function tsParseMappedTypeParameter() {
        var node = this.startNode();
        node.name = this.parseIdentifierName(node.start);
        node.constraint = this.tsExpectThenParseType(types$1._in);
        return this.finishNode(node, "TSTypeParameter");
      };

      _proto.tsParseMappedType = function tsParseMappedType() {
        var node = this.startNode();
        this.expect(types$1.braceL);

        if (this.match(types$1.plusMin)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual("readonly");
        } else if (this.eatContextual("readonly")) {
          node.readonly = true;
        }

        this.expect(types$1.bracketL);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual("as") ? this.tsParseType() : null;
        this.expect(types$1.bracketR);

        if (this.match(types$1.plusMin)) {
          node.optional = this.state.value;
          this.next();
          this.expect(types$1.question);
        } else if (this.eat(types$1.question)) {
          node.optional = true;
        }

        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(types$1.braceR);
        return this.finishNode(node, "TSMappedType");
      };

      _proto.tsParseTupleType = function tsParseTupleType() {
        var _this3 = this;

        var node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        var seenOptionalElement = false;
        var labeledElements = null;
        node.elementTypes.forEach(function (elementNode) {
          var _labeledElements;

          var _elementNode = elementNode,
              type = _elementNode.type;

          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            _this3.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);
          }

          seenOptionalElement = seenOptionalElement || type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType";

          if (type === "TSRestType") {
            elementNode = elementNode.typeAnnotation;
            type = elementNode.type;
          }

          var isLabeled = type === "TSNamedTupleMember";
          labeledElements = (_labeledElements = labeledElements) != null ? _labeledElements : isLabeled;

          if (labeledElements !== isLabeled) {
            _this3.raise(elementNode.start, TSErrors.MixedLabeledAndUnlabeledElements);
          }
        });
        return this.finishNode(node, "TSTupleType");
      };

      _proto.tsParseTupleElementType = function tsParseTupleElementType() {
        var _this$state = this.state,
            startPos = _this$state.start,
            startLoc = _this$state.startLoc;
        var rest = this.eat(types$1.ellipsis);
        var type = this.tsParseType();
        var optional = this.eat(types$1.question);
        var labeled = this.eat(types$1.colon);

        if (labeled) {
          var labeledNode = this.startNodeAtNode(type);
          labeledNode.optional = optional;

          if (type.type === "TSTypeReference" && !type.typeParameters && type.typeName.type === "Identifier") {
            labeledNode.label = type.typeName;
          } else {
            this.raise(type.start, TSErrors.InvalidTupleMemberLabel);
            labeledNode.label = type;
          }

          labeledNode.elementType = this.tsParseType();
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          var optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }

        if (rest) {
          var restNode = this.startNodeAt(startPos, startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }

        return type;
      };

      _proto.tsParseParenthesizedType = function tsParseParenthesizedType() {
        var node = this.startNode();
        this.expect(types$1.parenL);
        node.typeAnnotation = this.tsParseType();
        this.expect(types$1.parenR);
        return this.finishNode(node, "TSParenthesizedType");
      };

      _proto.tsParseFunctionOrConstructorType = function tsParseFunctionOrConstructorType(type, _abstract) {
        var node = this.startNode();

        if (type === "TSConstructorType") {
          node["abstract"] = !!_abstract;
          if (_abstract) this.next();
          this.next();
        }

        this.tsFillSignature(types$1.arrow, node);
        return this.finishNode(node, type);
      };

      _proto.tsParseLiteralTypeNode = function tsParseLiteralTypeNode() {
        var _this4 = this;

        var node = this.startNode();

        node.literal = function () {
          switch (_this4.state.type) {
            case types$1.num:
            case types$1.bigint:
            case types$1.string:
            case types$1._true:
            case types$1._false:
              return _this4.parseExprAtom();

            default:
              throw _this4.unexpected();
          }
        }();

        return this.finishNode(node, "TSLiteralType");
      };

      _proto.tsParseTemplateLiteralType = function tsParseTemplateLiteralType() {
        var node = this.startNode();
        node.literal = this.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      };

      _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return _superClass.prototype.parseTemplateSubstitution.call(this);
      };

      _proto.tsParseThisTypeOrThisTypePredicate = function tsParseThisTypeOrThisTypePredicate() {
        var thisKeyword = this.tsParseThisTypeNode();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      };

      _proto.tsParseNonArrayType = function tsParseNonArrayType() {
        switch (this.state.type) {
          case types$1.name:
          case types$1._void:
          case types$1._null:
            {
              var type = this.match(types$1._void) ? "TSVoidKeyword" : this.match(types$1._null) ? "TSNullKeyword" : keywordTypeFromName(this.state.value);

              if (type !== undefined && this.lookaheadCharCode() !== 46) {
                var node = this.startNode();
                this.next();
                return this.finishNode(node, type);
              }

              return this.tsParseTypeReference();
            }

          case types$1.string:
          case types$1.num:
          case types$1.bigint:
          case types$1._true:
          case types$1._false:
            return this.tsParseLiteralTypeNode();

          case types$1.plusMin:
            if (this.state.value === "-") {
              var _node = this.startNode();

              var nextToken = this.lookahead();

              if (nextToken.type !== types$1.num && nextToken.type !== types$1.bigint) {
                throw this.unexpected();
              }

              _node.literal = this.parseMaybeUnary();
              return this.finishNode(_node, "TSLiteralType");
            }

            break;

          case types$1._this:
            return this.tsParseThisTypeOrThisTypePredicate();

          case types$1._typeof:
            return this.tsParseTypeQuery();

          case types$1._import:
            return this.tsParseImportType();

          case types$1.braceL:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();

          case types$1.bracketL:
            return this.tsParseTupleType();

          case types$1.parenL:
            return this.tsParseParenthesizedType();

          case types$1.backQuote:
            return this.tsParseTemplateLiteralType();
        }

        throw this.unexpected();
      };

      _proto.tsParseArrayTypeOrHigher = function tsParseArrayTypeOrHigher() {
        var type = this.tsParseNonArrayType();

        while (!this.hasPrecedingLineBreak() && this.eat(types$1.bracketL)) {
          if (this.match(types$1.bracketR)) {
            var node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(types$1.bracketR);
            type = this.finishNode(node, "TSArrayType");
          } else {
            var _node2 = this.startNodeAtNode(type);

            _node2.objectType = type;
            _node2.indexType = this.tsParseType();
            this.expect(types$1.bracketR);
            type = this.finishNode(_node2, "TSIndexedAccessType");
          }
        }

        return type;
      };

      _proto.tsParseTypeOperator = function tsParseTypeOperator(operator) {
        var node = this.startNode();
        this.expectContextual(operator);
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();

        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }

        return this.finishNode(node, "TSTypeOperator");
      };

      _proto.tsCheckTypeAnnotationForReadOnly = function tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;

          default:
            this.raise(node.start, TSErrors.UnexpectedReadonly);
        }
      };

      _proto.tsParseInferType = function tsParseInferType() {
        var node = this.startNode();
        this.expectContextual("infer");
        var typeParameter = this.startNode();
        typeParameter.name = this.parseIdentifierName(typeParameter.start);
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      };

      _proto.tsParseTypeOperatorOrHigher = function tsParseTypeOperatorOrHigher() {
        var _this5 = this;

        var operator = ["keyof", "unique", "readonly"].find(function (kw) {
          return _this5.isContextual(kw);
        });
        return operator ? this.tsParseTypeOperator(operator) : this.isContextual("infer") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();
      };

      _proto.tsParseUnionOrIntersectionType = function tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        var node = this.startNode();
        var hasLeadingOperator = this.eat(operator);
        var types = [];

        do {
          types.push(parseConstituentType());
        } while (this.eat(operator));

        if (types.length === 1 && !hasLeadingOperator) {
          return types[0];
        }

        node.types = types;
        return this.finishNode(node, kind);
      };

      _proto.tsParseIntersectionTypeOrHigher = function tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), types$1.bitwiseAND);
      };

      _proto.tsParseUnionTypeOrHigher = function tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), types$1.bitwiseOR);
      };

      _proto.tsIsStartOfFunctionType = function tsIsStartOfFunctionType() {
        if (this.isRelational("<")) {
          return true;
        }

        return this.match(types$1.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      };

      _proto.tsSkipParameterStart = function tsSkipParameterStart() {
        if (this.match(types$1.name) || this.match(types$1._this)) {
          this.next();
          return true;
        }

        if (this.match(types$1.braceL)) {
          var braceStackCounter = 1;
          this.next();

          while (braceStackCounter > 0) {
            if (this.match(types$1.braceL)) {
              ++braceStackCounter;
            } else if (this.match(types$1.braceR)) {
              --braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        if (this.match(types$1.bracketL)) {
          var _braceStackCounter = 1;
          this.next();

          while (_braceStackCounter > 0) {
            if (this.match(types$1.bracketL)) {
              ++_braceStackCounter;
            } else if (this.match(types$1.bracketR)) {
              --_braceStackCounter;
            }

            this.next();
          }

          return true;
        }

        return false;
      };

      _proto.tsIsUnambiguouslyStartOfFunctionType = function tsIsUnambiguouslyStartOfFunctionType() {
        this.next();

        if (this.match(types$1.parenR) || this.match(types$1.ellipsis)) {
          return true;
        }

        if (this.tsSkipParameterStart()) {
          if (this.match(types$1.colon) || this.match(types$1.comma) || this.match(types$1.question) || this.match(types$1.eq)) {
            return true;
          }

          if (this.match(types$1.parenR)) {
            this.next();

            if (this.match(types$1.arrow)) {
              return true;
            }
          }
        }

        return false;
      };

      _proto.tsParseTypeOrTypePredicateAnnotation = function tsParseTypeOrTypePredicateAnnotation(returnToken) {
        var _this6 = this;

        return this.tsInType(function () {
          var t = _this6.startNode();

          _this6.expect(returnToken);

          var node = _this6.startNode();

          var asserts = !!_this6.tsTryParse(_this6.tsParseTypePredicateAsserts.bind(_this6));

          if (asserts && _this6.match(types$1._this)) {
            var thisTypePredicate = _this6.tsParseThisTypeOrThisTypePredicate();

            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = _this6.finishNode(node, "TSTypePredicate");
            } else {
              _this6.resetStartLocationFromNode(thisTypePredicate, node);

              thisTypePredicate.asserts = true;
            }

            t.typeAnnotation = thisTypePredicate;
            return _this6.finishNode(t, "TSTypeAnnotation");
          }

          var typePredicateVariable = _this6.tsIsIdentifier() && _this6.tsTryParse(_this6.tsParseTypePredicatePrefix.bind(_this6));

          if (!typePredicateVariable) {
            if (!asserts) {
              return _this6.tsParseTypeAnnotation(false, t);
            }

            node.parameterName = _this6.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = _this6.finishNode(node, "TSTypePredicate");
            return _this6.finishNode(t, "TSTypeAnnotation");
          }

          var type = _this6.tsParseTypeAnnotation(false);

          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = _this6.finishNode(node, "TSTypePredicate");
          return _this6.finishNode(t, "TSTypeAnnotation");
        });
      };

      _proto.tsTryParseTypeOrTypePredicateAnnotation = function tsTryParseTypeOrTypePredicateAnnotation() {
        return this.match(types$1.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types$1.colon) : undefined;
      };

      _proto.tsTryParseTypeAnnotation = function tsTryParseTypeAnnotation() {
        return this.match(types$1.colon) ? this.tsParseTypeAnnotation() : undefined;
      };

      _proto.tsTryParseType = function tsTryParseType() {
        return this.tsEatThenParseType(types$1.colon);
      };

      _proto.tsParseTypePredicatePrefix = function tsParseTypePredicatePrefix() {
        var id = this.parseIdentifier();

        if (this.isContextual("is") && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      };

      _proto.tsParseTypePredicateAsserts = function tsParseTypePredicateAsserts() {
        if (!this.match(types$1.name) || this.state.value !== "asserts" || this.hasPrecedingLineBreak()) {
          return false;
        }

        var containsEsc = this.state.containsEsc;
        this.next();

        if (!this.match(types$1.name) && !this.match(types$1._this)) {
          return false;
        }

        if (containsEsc) {
          this.raise(this.state.lastTokStart, ErrorMessages.InvalidEscapedReservedWord, "asserts");
        }

        return true;
      };

      _proto.tsParseTypeAnnotation = function tsParseTypeAnnotation(eatColon, t) {
        var _this7 = this;

        if (eatColon === void 0) {
          eatColon = true;
        }

        if (t === void 0) {
          t = this.startNode();
        }

        this.tsInType(function () {
          if (eatColon) _this7.expect(types$1.colon);
          t.typeAnnotation = _this7.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      };

      _proto.tsParseType = function tsParseType() {
        assert(this.state.inType);
        var type = this.tsParseNonConditionalType();

        if (this.hasPrecedingLineBreak() || !this.eat(types$1._extends)) {
          return type;
        }

        var node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsParseNonConditionalType();
        this.expect(types$1.question);
        node.trueType = this.tsParseType();
        this.expect(types$1.colon);
        node.falseType = this.tsParseType();
        return this.finishNode(node, "TSConditionalType");
      };

      _proto.isAbstractConstructorSignature = function isAbstractConstructorSignature() {
        return this.isContextual("abstract") && this.lookahead().type === types$1._new;
      };

      _proto.tsParseNonConditionalType = function tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }

        if (this.match(types$1._new)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }

        return this.tsParseUnionTypeOrHigher();
      };

      _proto.tsParseTypeAssertion = function tsParseTypeAssertion() {
        var node = this.startNode();

        var _const = this.tsTryNextParseConstantContext();

        node.typeAnnotation = _const || this.tsNextThenParseType();
        this.expectRelational(">");
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      };

      _proto.tsParseHeritageClause = function tsParseHeritageClause(descriptor) {
        var originalStart = this.state.start;
        var delimitedList = this.tsParseDelimitedList("HeritageClauseElement", this.tsParseExpressionWithTypeArguments.bind(this));

        if (!delimitedList.length) {
          this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);
        }

        return delimitedList;
      };

      _proto.tsParseExpressionWithTypeArguments = function tsParseExpressionWithTypeArguments() {
        var node = this.startNode();
        node.expression = this.tsParseEntityName(false);

        if (this.isRelational("<")) {
          node.typeParameters = this.tsParseTypeArguments();
        }

        return this.finishNode(node, "TSExpressionWithTypeArguments");
      };

      _proto.tsParseInterfaceDeclaration = function tsParseInterfaceDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript interface declaration", BIND_TS_INTERFACE);
        node.typeParameters = this.tsTryParseTypeParameters();

        if (this.eat(types$1._extends)) {
          node["extends"] = this.tsParseHeritageClause("extends");
        }

        var body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      };

      _proto.tsParseTypeAliasDeclaration = function tsParseTypeAliasDeclaration(node) {
        var _this8 = this;

        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript type alias", BIND_TS_TYPE);
        node.typeParameters = this.tsTryParseTypeParameters();
        node.typeAnnotation = this.tsInType(function () {
          _this8.expect(types$1.eq);

          if (_this8.isContextual("intrinsic") && _this8.lookahead().type !== types$1.dot) {
            var _node3 = _this8.startNode();

            _this8.next();

            return _this8.finishNode(_node3, "TSIntrinsicKeyword");
          }

          return _this8.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      };

      _proto.tsInNoContext = function tsInNoContext(cb) {
        var oldContext = this.state.context;
        this.state.context = [oldContext[0]];

        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      };

      _proto.tsInType = function tsInType(cb) {
        var oldInType = this.state.inType;
        this.state.inType = true;

        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      };

      _proto.tsEatThenParseType = function tsEatThenParseType(token) {
        return !this.match(token) ? undefined : this.tsNextThenParseType();
      };

      _proto.tsExpectThenParseType = function tsExpectThenParseType(token) {
        var _this9 = this;

        return this.tsDoThenParseType(function () {
          return _this9.expect(token);
        });
      };

      _proto.tsNextThenParseType = function tsNextThenParseType() {
        var _this10 = this;

        return this.tsDoThenParseType(function () {
          return _this10.next();
        });
      };

      _proto.tsDoThenParseType = function tsDoThenParseType(cb) {
        var _this11 = this;

        return this.tsInType(function () {
          cb();
          return _this11.tsParseType();
        });
      };

      _proto.tsParseEnumMember = function tsParseEnumMember() {
        var node = this.startNode();
        node.id = this.match(types$1.string) ? this.parseExprAtom() : this.parseIdentifier(true);

        if (this.eat(types$1.eq)) {
          node.initializer = this.parseMaybeAssignAllowIn();
        }

        return this.finishNode(node, "TSEnumMember");
      };

      _proto.tsParseEnumDeclaration = function tsParseEnumDeclaration(node, isConst) {
        if (isConst) node["const"] = true;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "typescript enum declaration", isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM);
        this.expect(types$1.braceL);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(types$1.braceR);
        return this.finishNode(node, "TSEnumDeclaration");
      };

      _proto.tsParseModuleBlock = function tsParseModuleBlock() {
        var node = this.startNode();
        this.scope.enter(SCOPE_OTHER);
        this.expect(types$1.braceL);
        this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types$1.braceR);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      };

      _proto.tsParseModuleOrNamespaceDeclaration = function tsParseModuleOrNamespaceDeclaration(node, nested) {
        if (nested === void 0) {
          nested = false;
        }

        node.id = this.parseIdentifier();

        if (!nested) {
          this.checkLVal(node.id, "module or namespace declaration", BIND_TS_NAMESPACE);
        }

        if (this.eat(types$1.dot)) {
          var inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseAmbientExternalModuleDeclaration = function tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual("global")) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(types$1.string)) {
          node.id = this.parseExprAtom();
        } else {
          this.unexpected();
        }

        if (this.match(types$1.braceL)) {
          this.scope.enter(SCOPE_TS_MODULE);
          this.prodParam.enter(PARAM);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }

        return this.finishNode(node, "TSModuleDeclaration");
      };

      _proto.tsParseImportEqualsDeclaration = function tsParseImportEqualsDeclaration(node, isExport) {
        node.isExport = isExport || false;
        node.id = this.parseIdentifier();
        this.checkLVal(node.id, "import equals declaration", BIND_LEXICAL);
        this.expect(types$1.eq);
        var moduleReference = this.tsParseModuleReference();

        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(moduleReference.start, TSErrors.ImportAliasHasImportType);
        }

        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      };

      _proto.tsIsExternalModuleReference = function tsIsExternalModuleReference() {
        return this.isContextual("require") && this.lookaheadCharCode() === 40;
      };

      _proto.tsParseModuleReference = function tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      };

      _proto.tsParseExternalModuleReference = function tsParseExternalModuleReference() {
        var node = this.startNode();
        this.expectContextual("require");
        this.expect(types$1.parenL);

        if (!this.match(types$1.string)) {
          throw this.unexpected();
        }

        node.expression = this.parseExprAtom();
        this.expect(types$1.parenR);
        return this.finishNode(node, "TSExternalModuleReference");
      };

      _proto.tsLookAhead = function tsLookAhead(f) {
        var state = this.state.clone();
        var res = f();
        this.state = state;
        return res;
      };

      _proto.tsTryParseAndCatch = function tsTryParseAndCatch(f) {
        var result = this.tryParse(function (abort) {
          return f() || abort();
        });
        if (result.aborted || !result.node) return undefined;
        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.tsTryParse = function tsTryParse(f) {
        var state = this.state.clone();
        var result = f();

        if (result !== undefined && result !== false) {
          return result;
        } else {
          this.state = state;
          return undefined;
        }
      };

      _proto.tsTryParseDeclare = function tsTryParseDeclare(nany) {
        var _this12 = this;

        if (this.isLineTerminator()) {
          return;
        }

        var starttype = this.state.type;
        var kind;

        if (this.isContextual("let")) {
          starttype = types$1._var;
          kind = "let";
        }

        return this.tsInAmbientContext(function () {
          switch (starttype) {
            case types$1._function:
              nany.declare = true;
              return _this12.parseFunctionStatement(nany, false, true);

            case types$1._class:
              nany.declare = true;
              return _this12.parseClass(nany, true, false);

            case types$1._const:
              if (_this12.match(types$1._const) && _this12.isLookaheadContextual("enum")) {
                _this12.expect(types$1._const);

                _this12.expectContextual("enum");

                return _this12.tsParseEnumDeclaration(nany, true);
              }

            case types$1._var:
              kind = kind || _this12.state.value;
              return _this12.parseVarStatement(nany, kind);

            case types$1.name:
              {
                var value = _this12.state.value;

                if (value === "global") {
                  return _this12.tsParseAmbientExternalModuleDeclaration(nany);
                } else {
                  return _this12.tsParseDeclaration(nany, value, true);
                }
              }
          }
        });
      };

      _proto.tsTryParseExportDeclaration = function tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true);
      };

      _proto.tsParseExpressionStatement = function tsParseExpressionStatement(node, expr) {
        switch (expr.name) {
          case "declare":
            {
              var declaration = this.tsTryParseDeclare(node);

              if (declaration) {
                declaration.declare = true;
                return declaration;
              }

              break;
            }

          case "global":
            if (this.match(types$1.braceL)) {
              this.scope.enter(SCOPE_TS_MODULE);
              this.prodParam.enter(PARAM);
              var mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }

            break;

          default:
            return this.tsParseDeclaration(node, expr.name, false);
        }
      };

      _proto.tsParseDeclaration = function tsParseDeclaration(node, value, next) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(types$1._class) || this.match(types$1.name))) {
              return this.tsParseAbstractDeclaration(node);
            }

            break;

          case "enum":
            if (next || this.match(types$1.name)) {
              if (next) this.next();
              return this.tsParseEnumDeclaration(node, false);
            }

            break;

          case "interface":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseInterfaceDeclaration(node);
            }

            break;

          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(types$1.string)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (this.match(types$1.name)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }

            break;

          case "namespace":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }

            break;

          case "type":
            if (this.tsCheckLineTerminator(next) && this.match(types$1.name)) {
              return this.tsParseTypeAliasDeclaration(node);
            }

            break;
        }
      };

      _proto.tsCheckLineTerminator = function tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }

        return !this.isLineTerminator();
      };

      _proto.tsTryParseGenericAsyncArrowFunction = function tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {
        var _this13 = this;

        if (!this.isRelational("<")) {
          return undefined;
        }

        var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        var res = this.tsTryParseAndCatch(function () {
          var node = _this13.startNodeAt(startPos, startLoc);

          node.typeParameters = _this13.tsParseTypeParameters();

          _superClass.prototype.parseFunctionParams.call(_this13, node);

          node.returnType = _this13.tsTryParseTypeOrTypePredicateAnnotation();

          _this13.expect(types$1.arrow);

          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;

        if (!res) {
          return undefined;
        }

        return this.parseArrowExpression(res, null, true);
      };

      _proto.tsParseTypeArguments = function tsParseTypeArguments() {
        var _this14 = this;

        var node = this.startNode();
        node.params = this.tsInType(function () {
          return _this14.tsInNoContext(function () {
            _this14.expectRelational("<");

            return _this14.tsParseDelimitedList("TypeParametersOrArguments", _this14.tsParseType.bind(_this14));
          });
        });

        if (node.params.length === 0) {
          this.raise(node.start, TSErrors.EmptyTypeArguments);
        }

        this.expectRelational(">");
        return this.finishNode(node, "TSTypeParameterInstantiation");
      };

      _proto.tsIsDeclarationStart = function tsIsDeclarationStart() {
        if (this.match(types$1.name)) {
          switch (this.state.value) {
            case "abstract":
            case "declare":
            case "enum":
            case "interface":
            case "module":
            case "namespace":
            case "type":
              return true;
          }
        }

        return false;
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var accessibility;
        var readonly = false;
        var override = false;

        if (allowModifiers !== undefined) {
          var modified = {};
          this.tsParseModifiers(modified, ["public", "private", "protected", "override", "readonly"]);
          accessibility = modified.accessibility;
          override = modified.override;
          readonly = modified.readonly;

          if (allowModifiers === false && (accessibility || readonly || override)) {
            this.raise(startPos, TSErrors.UnexpectedParameterModifier);
          }
        }

        var left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left);
        var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

        if (accessibility || readonly || override) {
          var pp = this.startNodeAt(startPos, startLoc);

          if (decorators.length) {
            pp.decorators = decorators;
          }

          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;

          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);
          }

          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }

        if (decorators.length) {
          left.decorators = decorators;
        }

        return elt;
      };

      _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
        if (isMethod === void 0) {
          isMethod = false;
        }

        if (this.match(types$1.colon)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types$1.colon);
        }

        var bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" ? "TSDeclareMethod" : undefined;

        if (bodilessType && !this.match(types$1.braceL) && this.isLineTerminator()) {
          this.finishNode(node, bodilessType);
          return;
        }

        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(node.start, TSErrors.DeclareFunctionHasImplementation);

          if (node.declare) {
            _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, bodilessType, isMethod);

            return;
          }
        }

        _superClass.prototype.parseFunctionBodyAndFinish.call(this, node, type, isMethod);
      };

      _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkLVal(node.id, "function name", BIND_TS_AMBIENT);
        } else {
          _superClass.prototype.registerFunctionStatementId.apply(this, arguments);
        }
      };

      _proto.tsCheckForInvalidTypeCasts = function tsCheckForInvalidTypeCasts(items) {
        var _this15 = this;

        items.forEach(function (node) {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            _this15.raise(node.typeAnnotation.start, TSErrors.UnexpectedTypeAnnotation);
          }
        });
      };

      _proto.toReferencedList = function toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      };

      _proto.parseArrayLike = function parseArrayLike() {
        var _superClass$prototype;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var node = (_superClass$prototype = _superClass.prototype.parseArrayLike).call.apply(_superClass$prototype, [this].concat(args));

        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }

        return node;
      };

      _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
        var _this16 = this;

        if (!this.hasPrecedingLineBreak() && this.match(types$1.bang)) {
          this.state.exprAllowed = false;
          this.next();
          var nonNullExpression = this.startNodeAt(startPos, startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }

        if (this.isRelational("<")) {
          var result = this.tsTryParseAndCatch(function () {
            if (!noCalls && _this16.atPossibleAsyncArrow(base)) {
              var asyncArrowFn = _this16.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);

              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }

            var node = _this16.startNodeAt(startPos, startLoc);

            node.callee = base;

            var typeArguments = _this16.tsParseTypeArguments();

            if (typeArguments) {
              if (!noCalls && _this16.eat(types$1.parenL)) {
                node.arguments = _this16.parseCallExpressionArguments(types$1.parenR, false);

                _this16.tsCheckForInvalidTypeCasts(node.arguments);

                node.typeParameters = typeArguments;

                if (state.optionalChainMember) {
                  node.optional = false;
                }

                return _this16.finishCallExpression(node, state.optionalChainMember);
              } else if (_this16.match(types$1.backQuote)) {
                var _result = _this16.parseTaggedTemplateExpression(base, startPos, startLoc, state);

                _result.typeParameters = typeArguments;
                return _result;
              }
            }

            _this16.unexpected();
          });
          if (result) return result;
        }

        return _superClass.prototype.parseSubscript.call(this, base, startPos, startLoc, noCalls, state);
      };

      _proto.parseNewArguments = function parseNewArguments(node) {
        var _this17 = this;

        if (this.isRelational("<")) {
          var typeParameters = this.tsTryParseAndCatch(function () {
            var args = _this17.tsParseTypeArguments();

            if (!_this17.match(types$1.parenL)) _this17.unexpected();
            return args;
          });

          if (typeParameters) {
            node.typeParameters = typeParameters;
          }
        }

        _superClass.prototype.parseNewArguments.call(this, node);
      };

      _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
        if (nonNull(types$1._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual("as")) {
          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.expression = left;

          var _const = this.tsTryNextParseConstantContext();

          if (_const) {
            node.typeAnnotation = _const;
          } else {
            node.typeAnnotation = this.tsNextThenParseType();
          }

          this.finishNode(node, "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }

        return _superClass.prototype.parseExprOp.call(this, left, leftStartPos, leftStartLoc, minPrec);
      };

      _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {};

      _proto.checkDuplicateExports = function checkDuplicateExports() {};

      _proto.parseImport = function parseImport(node) {
        node.importKind = "value";

        if (this.match(types$1.name) || this.match(types$1.star) || this.match(types$1.braceL)) {
          var ahead = this.lookahead();

          if (this.isContextual("type") && ahead.type !== types$1.comma && !(ahead.type === types$1.name && ahead.value === "from") && ahead.type !== types$1.eq) {
            node.importKind = "type";
            this.next();
            ahead = this.lookahead();
          }

          if (this.match(types$1.name) && ahead.type === types$1.eq) {
            return this.tsParseImportEqualsDeclaration(node);
          }
        }

        var importNode = _superClass.prototype.parseImport.call(this, node);

        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(importNode.start, TSErrors.TypeImportCannotSpecifyDefaultAndNamed);
        }

        return importNode;
      };

      _proto.parseExport = function parseExport(node) {
        if (this.match(types$1._import)) {
          this.next();

          if (this.isContextual("type") && this.lookaheadCharCode() !== 61) {
            node.importKind = "type";
            this.next();
          } else {
            node.importKind = "value";
          }

          return this.tsParseImportEqualsDeclaration(node, true);
        } else if (this.eat(types$1.eq)) {
          var assign = node;
          assign.expression = this.parseExpression();
          this.semicolon();
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual("as")) {
          var decl = node;
          this.expectContextual("namespace");
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          if (this.isContextual("type") && this.lookahead().type === types$1.braceL) {
            this.next();
            node.exportKind = "type";
          } else {
            node.exportKind = "value";
          }

          return _superClass.prototype.parseExport.call(this, node);
        }
      };

      _proto.isAbstractClass = function isAbstractClass() {
        return this.isContextual("abstract") && this.lookahead().type === types$1._class;
      };

      _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          var cls = this.startNode();
          this.next();
          cls["abstract"] = true;
          this.parseClass(cls, true, true);
          return cls;
        }

        if (this.state.value === "interface") {
          var result = this.tsParseDeclaration(this.startNode(), this.state.value, true);
          if (result) return result;
        }

        return _superClass.prototype.parseExportDefaultExpression.call(this);
      };

      _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
        if (this.state.type === types$1._const) {
          var ahead = this.lookahead();

          if (ahead.type === types$1.name && ahead.value === "enum") {
            var node = this.startNode();
            this.expect(types$1._const);
            this.expectContextual("enum");
            return this.tsParseEnumDeclaration(node, true);
          }
        }

        return _superClass.prototype.parseStatementContent.call(this, context, topLevel);
      };

      _proto.parseAccessModifier = function parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      };

      _proto.tsHasSomeModifiers = function tsHasSomeModifiers(member, modifiers) {
        return modifiers.some(function (modifier) {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }

          return !!member[modifier];
        });
      };

      _proto.parseClassMember = function parseClassMember(classBody, member, state) {
        var _this18 = this;

        var invalidModifersForStaticBlocks = ["declare", "private", "public", "protected", "override", "abstract", "readonly"];
        this.tsParseModifiers(member, invalidModifersForStaticBlocks.concat(["static"]));

        var callParseClassMemberWithIsStatic = function callParseClassMemberWithIsStatic() {
          var isStatic = !!member["static"];

          if (isStatic && _this18.eat(types$1.braceL)) {
            if (_this18.tsHasSomeModifiers(member, invalidModifersForStaticBlocks)) {
              _this18.raise(_this18.state.pos, TSErrors.StaticBlockCannotHaveModifier);
            }

            _this18.parseClassStaticBlock(classBody, member);
          } else {
            _this18.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
          }
        };

        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      };

      _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        var idx = this.tsTryParseIndexSignature(member);

        if (idx) {
          classBody.body.push(idx);

          if (member["abstract"]) {
            this.raise(member.start, TSErrors.IndexSignatureHasAbstract);
          }

          if (member.accessibility) {
            this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);
          }

          if (member.declare) {
            this.raise(member.start, TSErrors.IndexSignatureHasDeclare);
          }

          if (member.override) {
            this.raise(member.start, TSErrors.IndexSignatureHasOverride);
          }

          return;
        }

        if (!this.state.inAbstractClass && member["abstract"]) {
          this.raise(member.start, TSErrors.NonAbstractClassHasAbstractMethod);
        }

        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(member.start, TSErrors.OverrideNotInSubClass);
          }
        }

        _superClass.prototype.parseClassMemberWithIsStatic.call(this, classBody, member, state, isStatic);
      };

      _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {
        var optional = this.eat(types$1.question);
        if (optional) methodOrProp.optional = true;

        if (methodOrProp.readonly && this.match(types$1.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);
        }

        if (methodOrProp.declare && this.match(types$1.parenL)) {
          this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);
        }
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        var decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr) : undefined;
        return decl || _superClass.prototype.parseExpressionStatement.call(this, node, expr);
      };

      _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return _superClass.prototype.shouldParseExportDeclaration.call(this);
      };

      _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
        var _this19 = this;

        if (!this.state.maybeInArrowParameters || !this.match(types$1.question)) {
          return _superClass.prototype.parseConditional.call(this, expr, startPos, startLoc, refExpressionErrors);
        }

        var result = this.tryParse(function () {
          return _superClass.prototype.parseConditional.call(_this19, expr, startPos, startLoc);
        });

        if (!result.node) {
          if (result.error) {
            _superClass.prototype.setOptionalParametersError.call(this, refExpressionErrors, result.error);
          }

          return expr;
        }

        if (result.error) this.state = result.failState;
        return result.node;
      };

      _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
        node = _superClass.prototype.parseParenItem.call(this, node, startPos, startLoc);

        if (this.eat(types$1.question)) {
          node.optional = true;
          this.resetEndLocation(node);
        }

        if (this.match(types$1.colon)) {
          var typeCastNode = this.startNodeAt(startPos, startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }

        return node;
      };

      _proto.parseExportDeclaration = function parseExportDeclaration(node) {
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var isDeclare = this.eatContextual("declare");

        if (isDeclare && (this.isContextual("declare") || !this.shouldParseExportDeclaration())) {
          throw this.raise(this.state.start, TSErrors.ExpectedAmbientAfterExportDeclare);
        }

        var declaration;

        if (this.match(types$1.name)) {
          declaration = this.tsTryParseExportDeclaration();
        }

        if (!declaration) {
          declaration = _superClass.prototype.parseExportDeclaration.call(this, node);
        }

        if (declaration && (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare)) {
          node.exportKind = "type";
        }

        if (declaration && isDeclare) {
          this.resetStartLocation(declaration, startPos, startLoc);
          declaration.declare = true;
        }

        return declaration;
      };

      _proto.parseClassId = function parseClassId(node, isStatement, optionalId) {
        if ((!isStatement || optionalId) && this.isContextual("implements")) {
          return;
        }

        _superClass.prototype.parseClassId.call(this, node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;
      };

      _proto.parseClassPropertyAnnotation = function parseClassPropertyAnnotation(node) {
        if (!node.optional && this.eat(types$1.bang)) {
          node.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      };

      _proto.parseClassProperty = function parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);

        if (this.state.isAmbientContext && this.match(types$1.eq)) {
          this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);
        }

        return _superClass.prototype.parseClassProperty.call(this, node);
      };

      _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
        if (node["abstract"]) {
          this.raise(node.start, TSErrors.PrivateElementHasAbstract);
        }

        if (node.accessibility) {
          this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);
        }

        this.parseClassPropertyAnnotation(node);
        return _superClass.prototype.parseClassPrivateProperty.call(this, node);
      };

      _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        var typeParameters = this.tsTryParseTypeParameters();

        if (typeParameters && isConstructor) {
          this.raise(typeParameters.start, TSErrors.ConstructorHasTypeParameters);
        }

        if (method.declare && (method.kind === "get" || method.kind === "set")) {
          this.raise(method.start, TSErrors.DeclareAccessor, method.kind);
        }

        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassMethod.call(this, classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      };

      _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) method.typeParameters = typeParameters;

        _superClass.prototype.pushClassPrivateMethod.call(this, classBody, method, isGenerator, isAsync);
      };

      _proto.parseClassSuper = function parseClassSuper(node) {
        _superClass.prototype.parseClassSuper.call(this, node);

        if (node.superClass && this.isRelational("<")) {
          node.superTypeParameters = this.tsParseTypeArguments();
        }

        if (this.eatContextual("implements")) {
          node["implements"] = this.tsParseHeritageClause("implements");
        }
      };

      _proto.parseObjPropValue = function parseObjPropValue(prop) {
        var _superClass$prototype2;

        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) prop.typeParameters = typeParameters;

        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        (_superClass$prototype2 = _superClass.prototype.parseObjPropValue).call.apply(_superClass$prototype2, [this, prop].concat(args));
      };

      _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
        var typeParameters = this.tsTryParseTypeParameters();
        if (typeParameters) node.typeParameters = typeParameters;

        _superClass.prototype.parseFunctionParams.call(this, node, allowModifiers);
      };

      _proto.parseVarId = function parseVarId(decl, kind) {
        _superClass.prototype.parseVarId.call(this, decl, kind);

        if (decl.id.type === "Identifier" && this.eat(types$1.bang)) {
          decl.definite = true;
        }

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      };

      _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(types$1.colon)) {
          node.returnType = this.tsParseTypeAnnotation();
        }

        return _superClass.prototype.parseAsyncArrowFromCallExpression.call(this, node, call);
      };

      _proto.parseMaybeAssign = function parseMaybeAssign() {
        var _this20 = this,
            _jsx,
            _jsx2,
            _typeCast,
            _jsx3,
            _typeCast2,
            _jsx4,
            _typeCast3;

        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var state;
        var jsx;
        var typeCast;

        if (this.hasPlugin("jsx") && (this.match(types$1.jsxTagStart) || this.isRelational("<"))) {
          state = this.state.clone();
          jsx = this.tryParse(function () {
            var _superClass$prototype3;

            return (_superClass$prototype3 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype3, [_this20].concat(args));
          }, state);
          if (!jsx.error) return jsx.node;
          var context = this.state.context;

          if (context[context.length - 1] === types.j_oTag) {
            context.length -= 2;
          } else if (context[context.length - 1] === types.j_expr) {
            context.length -= 1;
          }
        }

        if (!((_jsx = jsx) != null && _jsx.error) && !this.isRelational("<")) {
          var _superClass$prototype4;

          return (_superClass$prototype4 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype4, [this].concat(args));
        }

        var typeParameters;
        state = state || this.state.clone();
        var arrow = this.tryParse(function (abort) {
          var _superClass$prototype5, _expr$extra, _typeParameters;

          typeParameters = _this20.tsParseTypeParameters();

          var expr = (_superClass$prototype5 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype5, [_this20].concat(args));

          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }

          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            _this20.resetStartLocationFromNode(expr, typeParameters);
          }

          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) return arrow.node;

        if (!jsx) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(function () {
            var _superClass$prototype6;

            return (_superClass$prototype6 = _superClass.prototype.parseMaybeAssign).call.apply(_superClass$prototype6, [_this20].concat(args));
          }, state);
          if (!typeCast.error) return typeCast.node;
        }

        if ((_jsx2 = jsx) != null && _jsx2.node) {
          this.state = jsx.failState;
          return jsx.node;
        }

        if (arrow.node) {
          this.state = arrow.failState;
          return arrow.node;
        }

        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }

        if ((_jsx3 = jsx) != null && _jsx3.thrown) throw jsx.error;
        if (arrow.thrown) throw arrow.error;
        if ((_typeCast2 = typeCast) != null && _typeCast2.thrown) throw typeCast.error;
        throw ((_jsx4 = jsx) == null ? void 0 : _jsx4.error) || arrow.error || ((_typeCast3 = typeCast) == null ? void 0 : _typeCast3.error);
      };

      _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors) {
        if (!this.hasPlugin("jsx") && this.isRelational("<")) {
          return this.tsParseTypeAssertion();
        } else {
          return _superClass.prototype.parseMaybeUnary.call(this, refExpressionErrors);
        }
      };

      _proto.parseArrow = function parseArrow(node) {
        var _this21 = this;

        if (this.match(types$1.colon)) {
          var result = this.tryParse(function (abort) {
            var returnType = _this21.tsParseTypeOrTypePredicateAnnotation(types$1.colon);

            if (_this21.canInsertSemicolon() || !_this21.match(types$1.arrow)) abort();
            return returnType;
          });
          if (result.aborted) return;

          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }

        return _superClass.prototype.parseArrow.call(this, node);
      };

      _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
        if (this.eat(types$1.question)) {
          if (param.type !== "Identifier" && !this.state.isAmbientContext && !this.state.inType) {
            this.raise(param.start, TSErrors.PatternIsOptional);
          }

          param.optional = true;
        }

        var type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      };

      _proto.toAssignable = function toAssignable(node, isLHS) {
        if (isLHS === void 0) {
          isLHS = false;
        }

        switch (node.type) {
          case "TSTypeCastExpression":
            return _superClass.prototype.toAssignable.call(this, this.typeCastToParameter(node), isLHS);

          case "TSParameterProperty":
            return _superClass.prototype.toAssignable.call(this, node, isLHS);

          case "ParenthesizedExpression":
            return this.toAssignableParenthesizedExpression(node, isLHS);

          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;

          default:
            return _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };

      _proto.toAssignableParenthesizedExpression = function toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            node.expression = this.toAssignable(node.expression, isLHS);
            return node;

          default:
            return _superClass.prototype.toAssignable.call(this, node, isLHS);
        }
      };

      _proto.checkLVal = function checkLVal(expr, contextDescription) {
        var _expr$extra2, _superClass$prototype7;

        for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
          args[_key4 - 2] = arguments[_key4];
        }

        switch (expr.type) {
          case "TSTypeCastExpression":
            return;

          case "TSParameterProperty":
            this.checkLVal.apply(this, [expr.parameter, "parameter property"].concat(args));
            return;

          case "TSAsExpression":
          case "TSTypeAssertion":
            if (!args[0] && contextDescription !== "parenthesized expression" && !((_expr$extra2 = expr.extra) != null && _expr$extra2.parenthesized)) {
              this.raise(expr.start, ErrorMessages.InvalidLhs, contextDescription);
              break;
            }

            this.checkLVal.apply(this, [expr.expression, "parenthesized expression"].concat(args));
            return;

          case "TSNonNullExpression":
            this.checkLVal.apply(this, [expr.expression, contextDescription].concat(args));
            return;

          default:
            (_superClass$prototype7 = _superClass.prototype.checkLVal).call.apply(_superClass$prototype7, [this, expr, contextDescription].concat(args));

            return;
        }
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        switch (this.state.type) {
          case types$1._this:
            return this.parseIdentifier(true);

          default:
            return _superClass.prototype.parseBindingAtom.call(this);
        }
      };

      _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
        if (this.isRelational("<")) {
          var typeArguments = this.tsParseTypeArguments();

          if (this.match(types$1.parenL)) {
            var call = _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);

            call.typeParameters = typeArguments;
            return call;
          }

          this.unexpected(this.state.start, types$1.parenL);
        }

        return _superClass.prototype.parseMaybeDecoratorArguments.call(this, expr);
      };

      _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(types$1.comma) && this.lookaheadCharCode() === close) {
          this.next();
        } else {
          _superClass.prototype.checkCommaAfterRest.call(this, close);
        }
      };

      _proto.isClassMethod = function isClassMethod() {
        return this.isRelational("<") || _superClass.prototype.isClassMethod.call(this);
      };

      _proto.isClassProperty = function isClassProperty() {
        return this.match(types$1.bang) || this.match(types$1.colon) || _superClass.prototype.isClassProperty.call(this);
      };

      _proto.parseMaybeDefault = function parseMaybeDefault() {
        var _superClass$prototype8;

        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }

        var node = (_superClass$prototype8 = _superClass.prototype.parseMaybeDefault).call.apply(_superClass$prototype8, [this].concat(args));

        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);
        }

        return node;
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (this.state.inType && (code === 62 || code === 60)) {
          return this.finishOp(types$1.relational, 1);
        } else {
          return _superClass.prototype.getTokenFromCode.call(this, code);
        }
      };

      _proto.reScan_lt_gt = function reScan_lt_gt() {
        if (this.match(types$1.relational)) {
          var code = this.input.charCodeAt(this.state.start);

          if (code === 60 || code === 62) {
            this.state.pos -= 1;
            this.readToken_lt_gt(code);
          }
        }
      };

      _proto.toAssignableList = function toAssignableList(exprList) {
        for (var i = 0; i < exprList.length; i++) {
          var expr = exprList[i];
          if (!expr) continue;

          switch (expr.type) {
            case "TSTypeCastExpression":
              exprList[i] = this.typeCastToParameter(expr);
              break;

            case "TSAsExpression":
            case "TSTypeAssertion":
              if (!this.state.maybeInArrowParameters) {
                exprList[i] = this.typeCastToParameter(expr);
              } else {
                this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);
              }

              break;
          }
        }

        return _superClass.prototype.toAssignableList.apply(this, arguments);
      };

      _proto.typeCastToParameter = function typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);
        return node.expression;
      };

      _proto.shouldParseArrow = function shouldParseArrow() {
        return this.match(types$1.colon) || _superClass.prototype.shouldParseArrow.call(this);
      };

      _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
        return this.match(types$1.colon) || _superClass.prototype.shouldParseAsyncArrow.call(this);
      };

      _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
        return _superClass.prototype.canHaveLeadingDecorator.call(this) || this.isAbstractClass();
      };

      _proto.jsxParseOpeningElementAfterName = function jsxParseOpeningElementAfterName(node) {
        var _this22 = this;

        if (this.isRelational("<")) {
          var typeArguments = this.tsTryParseAndCatch(function () {
            return _this22.tsParseTypeArguments();
          });
          if (typeArguments) node.typeParameters = typeArguments;
        }

        return _superClass.prototype.jsxParseOpeningElementAfterName.call(this, node);
      };

      _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
        var baseCount = _superClass.prototype.getGetterSetterExpectedParamCount.call(this, method);

        var params = this.getObjectOrClassMethodParams(method);
        var firstParam = params[0];
        var hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      };

      _proto.parseCatchClauseParam = function parseCatchClauseParam() {
        var param = _superClass.prototype.parseCatchClauseParam.call(this);

        var type = this.tsTryParseTypeAnnotation();

        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }

        return param;
      };

      _proto.tsInAmbientContext = function tsInAmbientContext(cb) {
        var oldIsAmbientContext = this.state.isAmbientContext;
        this.state.isAmbientContext = true;

        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
        }
      };

      _proto.parseClass = function parseClass(node) {
        var oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node["abstract"];

        try {
          var _superClass$prototype9;

          for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
            args[_key6 - 1] = arguments[_key6];
          }

          return (_superClass$prototype9 = _superClass.prototype.parseClass).call.apply(_superClass$prototype9, [this, node].concat(args));
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      };

      _proto.tsParseAbstractDeclaration = function tsParseAbstractDeclaration(node) {
        if (this.match(types$1._class)) {
          node["abstract"] = true;
          return this.parseClass(node, true, false);
        } else if (this.isContextual("interface")) {
          if (!this.hasFollowingLineBreak()) {
            node["abstract"] = true;
            this.raise(node.start, TSErrors.NonClassMethodPropertyHasAbstractModifer);
            this.next();
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, types$1._class);
        }
      };

      _proto.parseMethod = function parseMethod() {
        var _superClass$prototype10;

        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        var method = (_superClass$prototype10 = _superClass.prototype.parseMethod).call.apply(_superClass$prototype10, [this].concat(args));

        if (method["abstract"]) {
          var hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;

          if (hasBody) {
            var _key8 = method.key;
            this.raise(method.start, TSErrors.AbstractMethodHasImplementation, _key8.type === "Identifier" ? _key8.name : "[" + this.input.slice(_key8.start, _key8.end) + "]");
          }
        }

        return method;
      };

      _proto.shouldParseAsAmbientContext = function shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      };

      _proto.parse = function parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }

        return _superClass.prototype.parse.call(this);
      };

      _proto.getExpression = function getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }

        return _superClass.prototype.getExpression.call(this);
      };

      return _class;
    }(superClass);
  });

  types$1.placeholder = new TokenType("%%", {
    startsExpr: true
  });
  var PlaceHolderErrors = makeErrorTemplates({
    ClassNameIsRequired: "A class name is required."
  }, ErrorCodes.SyntaxError);
  var placeholders = (function (superClass) {
    return function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parsePlaceholder = function parsePlaceholder(expectedNode) {
        if (this.match(types$1.placeholder)) {
          var node = this.startNode();
          this.next();
          this.assertNoSpace("Unexpected space in placeholder.");
          node.name = _superClass.prototype.parseIdentifier.call(this, true);
          this.assertNoSpace("Unexpected space in placeholder.");
          this.expect(types$1.placeholder);
          return this.finishPlaceholder(node, expectedNode);
        }
      };

      _proto.finishPlaceholder = function finishPlaceholder(node, expectedNode) {
        var isFinished = !!(node.expectedNode && node.type === "Placeholder");
        node.expectedNode = expectedNode;
        return isFinished ? node : this.finishNode(node, "Placeholder");
      };

      _proto.getTokenFromCode = function getTokenFromCode(code) {
        if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          return this.finishOp(types$1.placeholder, 2);
        }

        return _superClass.prototype.getTokenFromCode.apply(this, arguments);
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parsePlaceholder("Expression") || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      _proto.parseIdentifier = function parseIdentifier() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseIdentifier.apply(this, arguments);
      };

      _proto.checkReservedWord = function checkReservedWord(word) {
        if (word !== undefined) _superClass.prototype.checkReservedWord.apply(this, arguments);
      };

      _proto.parseBindingAtom = function parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || _superClass.prototype.parseBindingAtom.apply(this, arguments);
      };

      _proto.checkLVal = function checkLVal(expr) {
        if (expr.type !== "Placeholder") _superClass.prototype.checkLVal.apply(this, arguments);
      };

      _proto.toAssignable = function toAssignable(node) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
          return node;
        }

        return _superClass.prototype.toAssignable.apply(this, arguments);
      };

      _proto.isLet = function isLet(context) {
        if (_superClass.prototype.isLet.call(this, context)) {
          return true;
        }

        if (!this.isContextual("let")) {
          return false;
        }

        if (context) return false;
        var nextToken = this.lookahead();

        if (nextToken.type === types$1.placeholder) {
          return true;
        }

        return false;
      };

      _proto.verifyBreakContinue = function verifyBreakContinue(node) {
        if (node.label && node.label.type === "Placeholder") return;

        _superClass.prototype.verifyBreakContinue.apply(this, arguments);
      };

      _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
        if (expr.type !== "Placeholder" || expr.extra && expr.extra.parenthesized) {
          return _superClass.prototype.parseExpressionStatement.apply(this, arguments);
        }

        if (this.match(types$1.colon)) {
          var stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = this.parseStatement("label");
          return this.finishNode(stmt, "LabeledStatement");
        }

        this.semicolon();
        node.name = expr.name;
        return this.finishPlaceholder(node, "Statement");
      };

      _proto.parseBlock = function parseBlock() {
        return this.parsePlaceholder("BlockStatement") || _superClass.prototype.parseBlock.apply(this, arguments);
      };

      _proto.parseFunctionId = function parseFunctionId() {
        return this.parsePlaceholder("Identifier") || _superClass.prototype.parseFunctionId.apply(this, arguments);
      };

      _proto.parseClass = function parseClass(node, isStatement, optionalId) {
        var type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        this.takeDecorators(node);
        var oldStrict = this.state.strict;
        var placeholder = this.parsePlaceholder("Identifier");

        if (placeholder) {
          if (this.match(types$1._extends) || this.match(types$1.placeholder) || this.match(types$1.braceL)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            this.unexpected(null, PlaceHolderErrors.ClassNameIsRequired);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }

        this.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      };

      _proto.parseExport = function parseExport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseExport.apply(this, arguments);

        if (!this.isContextual("from") && !this.match(types$1.comma)) {
          node.specifiers = [];
          node.source = null;
          node.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node, "ExportNamedDeclaration");
        }

        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = placeholder;
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return _superClass.prototype.parseExport.call(this, node);
      };

      _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
        if (this.match(types$1._default)) {
          var next = this.nextTokenStart();

          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(types$1.placeholder.label, this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }

        return _superClass.prototype.isExportDefaultSpecifier.call(this);
      };

      _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
        if (node.specifiers && node.specifiers.length > 0) {
          return true;
        }

        return _superClass.prototype.maybeParseExportDefaultSpecifier.apply(this, arguments);
      };

      _proto.checkExport = function checkExport(node) {
        var specifiers = node.specifiers;

        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter(function (node) {
            return node.exported.type === "Placeholder";
          });
        }

        _superClass.prototype.checkExport.call(this, node);

        node.specifiers = specifiers;
      };

      _proto.parseImport = function parseImport(node) {
        var placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return _superClass.prototype.parseImport.apply(this, arguments);
        node.specifiers = [];

        if (!this.isContextual("from") && !this.match(types$1.comma)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }

        var specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        this.finishNode(specifier, "ImportDefaultSpecifier");
        node.specifiers.push(specifier);

        if (this.eat(types$1.comma)) {
          var hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }

        this.expectContextual("from");
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      };

      _proto.parseImportSource = function parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || _superClass.prototype.parseImportSource.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  var v8intrinsic = (function (superClass) {
    return function (_superClass) {
      _inherits(_class, _superClass);

      function _class() {
        return _superClass.apply(this, arguments) || this;
      }

      var _proto = _class.prototype;

      _proto.parseV8Intrinsic = function parseV8Intrinsic() {
        if (this.match(types$1.modulo)) {
          var v8IntrinsicStart = this.state.start;
          var node = this.startNode();
          this.eat(types$1.modulo);

          if (this.match(types$1.name)) {
            var name = this.parseIdentifierName(this.state.start);
            var identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";

            if (this.match(types$1.parenL)) {
              return identifier;
            }
          }

          this.unexpected(v8IntrinsicStart);
        }
      };

      _proto.parseExprAtom = function parseExprAtom() {
        return this.parseV8Intrinsic() || _superClass.prototype.parseExprAtom.apply(this, arguments);
      };

      return _class;
    }(superClass);
  });

  function hasPlugin(plugins, name) {
    return plugins.some(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });
  }
  function getPluginOption(plugins, name, option) {
    var plugin = plugins.find(function (plugin) {
      if (Array.isArray(plugin)) {
        return plugin[0] === name;
      } else {
        return plugin === name;
      }
    });

    if (plugin && Array.isArray(plugin)) {
      return plugin[1][option];
    }

    return null;
  }
  var PIPELINE_PROPOSALS = ["minimal", "smart", "fsharp"];
  var RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
  function validatePlugins(plugins) {
    if (hasPlugin(plugins, "decorators")) {
      if (hasPlugin(plugins, "decorators-legacy")) {
        throw new Error("Cannot use the decorators and decorators-legacy plugin together");
      }

      var decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");

      if (decoratorsBeforeExport == null) {
        throw new Error("The 'decorators' plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you are migrating from" + " Babylon/Babel 6 or want to use the old decorators proposal, you" + " should use the 'decorators-legacy' plugin instead of 'decorators'.");
      } else if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
      throw new Error("Cannot combine flow and typescript plugins.");
    }

    if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
      throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
    }

    if (hasPlugin(plugins, "pipelineOperator") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, "pipelineOperator", "proposal"))) {
      throw new Error("'pipelineOperator' requires 'proposal' option whose value should be one of: " + PIPELINE_PROPOSALS.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }

    if (hasPlugin(plugins, "moduleAttributes")) {
      {
        if (hasPlugin(plugins, "importAssertions")) {
          throw new Error("Cannot combine importAssertions and moduleAttributes plugins.");
        }

        var moduleAttributesVerionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");

        if (moduleAttributesVerionPluginOption !== "may-2020") {
          throw new Error("The 'moduleAttributes' plugin requires a 'version' option," + " representing the last proposal update. Currently, the" + " only supported value is 'may-2020'.");
        }
      }
    }

    if (hasPlugin(plugins, "recordAndTuple") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, "recordAndTuple", "syntaxType"))) {
      throw new Error("'recordAndTuple' requires 'syntaxType' option whose value should be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map(function (p) {
        return "'" + p + "'";
      }).join(", "));
    }

    if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
      var error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
      error.missingPlugins = "doExpressions";
      throw error;
    }
  }
  var mixinPlugins = {
    estree: estree,
    jsx: jsx$1,
    flow: flow,
    typescript: typescript,
    v8intrinsic: v8intrinsic,
    placeholders: placeholders
  };
  var mixinPluginNames = Object.keys(mixinPlugins);

  var defaultOptions = {
    sourceType: "script",
    sourceFilename: undefined,
    startLine: 1,
    allowAwaitOutsideFunction: false,
    allowReturnOutsideFunction: false,
    allowImportExportEverywhere: false,
    allowSuperOutsideMethod: false,
    allowUndeclaredExports: false,
    plugins: [],
    strictMode: null,
    ranges: false,
    tokens: false,
    createParenthesizedExpressions: false,
    errorRecovery: false
  };
  function getOptions(opts) {
    var options = {};

    for (var _i2 = 0, _Object$keys2 = Object.keys(defaultOptions); _i2 < _Object$keys2.length; _i2++) {
      var key = _Object$keys2[_i2];
      options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];
    }

    return options;
  }

  var _isDigit = function isDigit(code) {
    return code >= 48 && code <= 57;
  };
  var VALID_REGEX_FLAGS = new Set([103, 109, 115, 105, 121, 117, 100]);
  var forbiddenNumericSeparatorSiblings = {
    decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],
    hex: [46, 88, 95, 120]
  };
  var allowedNumericSeparatorSiblings = {};
  allowedNumericSeparatorSiblings.bin = [48, 49];
  allowedNumericSeparatorSiblings.oct = [].concat(allowedNumericSeparatorSiblings.bin, [50, 51, 52, 53, 54, 55]);
  allowedNumericSeparatorSiblings.dec = [].concat(allowedNumericSeparatorSiblings.oct, [56, 57]);
  allowedNumericSeparatorSiblings.hex = [].concat(allowedNumericSeparatorSiblings.dec, [65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102]);
  var Token = function Token(state) {
    this.type = state.type;
    this.value = state.value;
    this.start = state.start;
    this.end = state.end;
    this.loc = new SourceLocation(state.startLoc, state.endLoc);
  };

  var Tokenizer = function (_ParserErrors) {
    _inherits(Tokenizer, _ParserErrors);

    function Tokenizer(options, input) {
      var _this;

      _this = _ParserErrors.call(this) || this;
      _this.isLookahead = void 0;
      _this.tokens = [];
      _this.state = new State();

      _this.state.init(options);

      _this.input = input;
      _this.length = input.length;
      _this.isLookahead = false;
      return _this;
    }

    var _proto = Tokenizer.prototype;

    _proto.pushToken = function pushToken(token) {
      this.tokens.length = this.state.tokensLength;
      this.tokens.push(token);
      ++this.state.tokensLength;
    };

    _proto.next = function next() {
      this.checkKeywordEscapes();

      if (this.options.tokens) {
        this.pushToken(new Token(this.state));
      }

      this.state.lastTokEnd = this.state.end;
      this.state.lastTokStart = this.state.start;
      this.state.lastTokEndLoc = this.state.endLoc;
      this.state.lastTokStartLoc = this.state.startLoc;
      this.nextToken();
    };

    _proto.eat = function eat(type) {
      if (this.match(type)) {
        this.next();
        return true;
      } else {
        return false;
      }
    };

    _proto.match = function match(type) {
      return this.state.type === type;
    };

    _proto.createLookaheadState = function createLookaheadState(state) {
      return {
        pos: state.pos,
        value: null,
        type: state.type,
        start: state.start,
        end: state.end,
        lastTokEnd: state.end,
        context: [this.curContext()],
        inType: state.inType
      };
    };

    _proto.lookahead = function lookahead() {
      var old = this.state;
      this.state = this.createLookaheadState(old);
      this.isLookahead = true;
      this.nextToken();
      this.isLookahead = false;
      var curr = this.state;
      this.state = old;
      return curr;
    };

    _proto.nextTokenStart = function nextTokenStart() {
      return this.nextTokenStartSince(this.state.pos);
    };

    _proto.nextTokenStartSince = function nextTokenStartSince(pos) {
      skipWhiteSpace.lastIndex = pos;
      var skip = skipWhiteSpace.exec(this.input);
      return pos + skip[0].length;
    };

    _proto.lookaheadCharCode = function lookaheadCharCode() {
      return this.input.charCodeAt(this.nextTokenStart());
    };

    _proto.codePointAtPos = function codePointAtPos(pos) {
      var cp = this.input.charCodeAt(pos);

      if ((cp & 0xfc00) === 0xd800 && ++pos < this.input.length) {
        var trail = this.input.charCodeAt(pos);

        if ((trail & 0xfc00) === 0xdc00) {
          cp = 0x10000 + ((cp & 0x3ff) << 10) + (trail & 0x3ff);
        }
      }

      return cp;
    };

    _proto.setStrict = function setStrict(strict) {
      var _this2 = this;

      this.state.strict = strict;

      if (strict) {
        this.state.strictErrors.forEach(function (message, pos) {
          return _this2.raise(pos, message);
        });
        this.state.strictErrors.clear();
      }
    };

    _proto.curContext = function curContext() {
      return this.state.context[this.state.context.length - 1];
    };

    _proto.nextToken = function nextToken() {
      var curContext = this.curContext();
      if (!curContext.preserveSpace) this.skipSpace();
      this.state.start = this.state.pos;
      if (!this.isLookahead) this.state.startLoc = this.state.curPosition();

      if (this.state.pos >= this.length) {
        this.finishToken(types$1.eof);
        return;
      }

      if (curContext === types.template) {
        this.readTmplToken();
      } else {
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
    };

    _proto.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
      var comment = {
        type: block ? "CommentBlock" : "CommentLine",
        value: text,
        start: start,
        end: end,
        loc: new SourceLocation(startLoc, endLoc)
      };
      if (this.options.tokens) this.pushToken(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    };

    _proto.skipBlockComment = function skipBlockComment() {
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var start = this.state.pos;
      var end = this.input.indexOf("*/", this.state.pos + 2);
      if (end === -1) throw this.raise(start, ErrorMessages.UnterminatedComment);
      this.state.pos = end + 2;
      lineBreakG.lastIndex = start;
      var match;

      while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
        ++this.state.curLine;
        this.state.lineStart = match.index + match[0].length;
      }

      if (this.isLookahead) return;
      this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipLineComment = function skipLineComment(startSkip) {
      var start = this.state.pos;
      var startLoc;
      if (!this.isLookahead) startLoc = this.state.curPosition();
      var ch = this.input.charCodeAt(this.state.pos += startSkip);

      if (this.state.pos < this.length) {
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
      }

      if (this.isLookahead) return;
      this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
    };

    _proto.skipSpace = function skipSpace() {
      loop: while (this.state.pos < this.length) {
        var ch = this.input.charCodeAt(this.state.pos);

        switch (ch) {
          case 32:
          case 160:
          case 9:
            ++this.state.pos;
            break;

          case 13:
            if (this.input.charCodeAt(this.state.pos + 1) === 10) {
              ++this.state.pos;
            }

          case 10:
          case 8232:
          case 8233:
            ++this.state.pos;
            ++this.state.curLine;
            this.state.lineStart = this.state.pos;
            break;

          case 47:
            switch (this.input.charCodeAt(this.state.pos + 1)) {
              case 42:
                this.skipBlockComment();
                break;

              case 47:
                this.skipLineComment(2);
                break;

              default:
                break loop;
            }

            break;

          default:
            if (isWhitespace(ch)) {
              ++this.state.pos;
            } else {
              break loop;
            }

        }
      }
    };

    _proto.finishToken = function finishToken(type, val) {
      this.state.end = this.state.pos;
      var prevType = this.state.type;
      this.state.type = type;
      this.state.value = val;

      if (!this.isLookahead) {
        this.state.endLoc = this.state.curPosition();
        this.updateContext(prevType);
      }
    };

    _proto.readToken_numberSign = function readToken_numberSign() {
      if (this.state.pos === 0 && this.readToken_interpreter()) {
        return;
      }

      var nextPos = this.state.pos + 1;
      var next = this.codePointAtPos(nextPos);

      if (next >= 48 && next <= 57) {
        throw this.raise(this.state.pos, ErrorMessages.UnexpectedDigitAfterHash);
      }

      if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
        this.expectPlugin("recordAndTuple");

        if (this.getPluginOption("recordAndTuple", "syntaxType") !== "hash") {
          throw this.raise(this.state.pos, next === 123 ? ErrorMessages.RecordExpressionHashIncorrectStartSyntaxType : ErrorMessages.TupleExpressionHashIncorrectStartSyntaxType);
        }

        this.state.pos += 2;

        if (next === 123) {
          this.finishToken(types$1.braceHashL);
        } else {
          this.finishToken(types$1.bracketHashL);
        }
      } else if (isIdentifierStart(next)) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1(next));
      } else if (next === 92) {
        ++this.state.pos;
        this.finishToken(types$1.privateName, this.readWord1());
      } else {
        this.finishOp(types$1.hash, 1);
      }
    };

    _proto.readToken_dot = function readToken_dot() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next >= 48 && next <= 57) {
        this.readNumber(true);
        return;
      }

      if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
        this.state.pos += 3;
        this.finishToken(types$1.ellipsis);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.dot);
      }
    };

    _proto.readToken_slash = function readToken_slash() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.slashAssign, 2);
      } else {
        this.finishOp(types$1.slash, 1);
      }
    };

    _proto.readToken_interpreter = function readToken_interpreter() {
      if (this.state.pos !== 0 || this.length < 2) return false;
      var ch = this.input.charCodeAt(this.state.pos + 1);
      if (ch !== 33) return false;
      var start = this.state.pos;
      this.state.pos += 1;

      while (!isNewLine(ch) && ++this.state.pos < this.length) {
        ch = this.input.charCodeAt(this.state.pos);
      }

      var value = this.input.slice(start + 2, this.state.pos);
      this.finishToken(types$1.interpreterDirective, value);
      return true;
    };

    _proto.readToken_mult_modulo = function readToken_mult_modulo(code) {
      var type = code === 42 ? types$1.star : types$1.modulo;
      var width = 1;
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (code === 42 && next === 42) {
        width++;
        next = this.input.charCodeAt(this.state.pos + 2);
        type = types$1.exponent;
      }

      if (next === 61 && !this.state.inType) {
        width++;
        type = types$1.assign;
      }

      this.finishOp(type, width);
    };

    _proto.readToken_pipe_amp = function readToken_pipe_amp(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (this.input.charCodeAt(this.state.pos + 2) === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
        }

        return;
      }

      if (code === 124) {
        if (next === 62) {
          this.finishOp(types$1.pipeline, 2);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 125) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.braceBarR);
          return;
        }

        if (this.hasPlugin("recordAndTuple") && next === 93) {
          if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
            throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectEndSyntaxType);
          }

          this.state.pos += 2;
          this.finishToken(types$1.bracketBarR);
          return;
        }
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
        return;
      }

      this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
    };

    _proto.readToken_caret = function readToken_caret() {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.bitwiseXOR, 1);
      }
    };

    _proto.readToken_plus_min = function readToken_plus_min(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === code) {
        if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || this.hasPrecedingLineBreak())) {
          this.skipLineComment(3);
          this.skipSpace();
          this.nextToken();
          return;
        }

        this.finishOp(types$1.incDec, 2);
        return;
      }

      if (next === 61) {
        this.finishOp(types$1.assign, 2);
      } else {
        this.finishOp(types$1.plusMin, 1);
      }
    };

    _proto.readToken_lt_gt = function readToken_lt_gt(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var size = 1;

      if (next === code) {
        size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;

        if (this.input.charCodeAt(this.state.pos + size) === 61) {
          this.finishOp(types$1.assign, size + 1);
          return;
        }

        this.finishOp(types$1.bitShift, size);
        return;
      }

      if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
        this.skipLineComment(4);
        this.skipSpace();
        this.nextToken();
        return;
      }

      if (next === 61) {
        size = 2;
      }

      this.finishOp(types$1.relational, size);
    };

    _proto.readToken_eq_excl = function readToken_eq_excl(code) {
      var next = this.input.charCodeAt(this.state.pos + 1);

      if (next === 61) {
        this.finishOp(types$1.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
        return;
      }

      if (code === 61 && next === 62) {
        this.state.pos += 2;
        this.finishToken(types$1.arrow);
        return;
      }

      this.finishOp(code === 61 ? types$1.eq : types$1.bang, 1);
    };

    _proto.readToken_question = function readToken_question() {
      var next = this.input.charCodeAt(this.state.pos + 1);
      var next2 = this.input.charCodeAt(this.state.pos + 2);

      if (next === 63) {
        if (next2 === 61) {
          this.finishOp(types$1.assign, 3);
        } else {
          this.finishOp(types$1.nullishCoalescing, 2);
        }
      } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
        this.state.pos += 2;
        this.finishToken(types$1.questionDot);
      } else {
        ++this.state.pos;
        this.finishToken(types$1.question);
      }
    };

    _proto.getTokenFromCode = function getTokenFromCode(code) {
      switch (code) {
        case 46:
          this.readToken_dot();
          return;

        case 40:
          ++this.state.pos;
          this.finishToken(types$1.parenL);
          return;

        case 41:
          ++this.state.pos;
          this.finishToken(types$1.parenR);
          return;

        case 59:
          ++this.state.pos;
          this.finishToken(types$1.semi);
          return;

        case 44:
          ++this.state.pos;
          this.finishToken(types$1.comma);
          return;

        case 91:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.TupleExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.bracketBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.bracketL);
          }

          return;

        case 93:
          ++this.state.pos;
          this.finishToken(types$1.bracketR);
          return;

        case 123:
          if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(this.state.pos, ErrorMessages.RecordExpressionBarIncorrectStartSyntaxType);
            }

            this.state.pos += 2;
            this.finishToken(types$1.braceBarL);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.braceL);
          }

          return;

        case 125:
          ++this.state.pos;
          this.finishToken(types$1.braceR);
          return;

        case 58:
          if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
            this.finishOp(types$1.doubleColon, 2);
          } else {
            ++this.state.pos;
            this.finishToken(types$1.colon);
          }

          return;

        case 63:
          this.readToken_question();
          return;

        case 96:
          ++this.state.pos;
          this.finishToken(types$1.backQuote);
          return;

        case 48:
          {
            var next = this.input.charCodeAt(this.state.pos + 1);

            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }

            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }

            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }

        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          this.readNumber(false);
          return;

        case 34:
        case 39:
          this.readString(code);
          return;

        case 47:
          this.readToken_slash();
          return;

        case 37:
        case 42:
          this.readToken_mult_modulo(code);
          return;

        case 124:
        case 38:
          this.readToken_pipe_amp(code);
          return;

        case 94:
          this.readToken_caret();
          return;

        case 43:
        case 45:
          this.readToken_plus_min(code);
          return;

        case 60:
        case 62:
          this.readToken_lt_gt(code);
          return;

        case 61:
        case 33:
          this.readToken_eq_excl(code);
          return;

        case 126:
          this.finishOp(types$1.tilde, 1);
          return;

        case 64:
          ++this.state.pos;
          this.finishToken(types$1.at);
          return;

        case 35:
          this.readToken_numberSign();
          return;

        case 92:
          this.readWord();
          return;

        default:
          if (isIdentifierStart(code)) {
            this.readWord(code);
            return;
          }

      }

      throw this.raise(this.state.pos, ErrorMessages.InvalidOrUnexpectedToken, String.fromCodePoint(code));
    };

    _proto.finishOp = function finishOp(type, size) {
      var str = this.input.slice(this.state.pos, this.state.pos + size);
      this.state.pos += size;
      this.finishToken(type, str);
    };

    _proto.readRegexp = function readRegexp() {
      var start = this.state.start + 1;
      var escaped, inClass;
      var pos = this.state.pos;

      for (;; ++pos) {
        if (pos >= this.length) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        var ch = this.input.charCodeAt(pos);

        if (isNewLine(ch)) {
          throw this.raise(start, ErrorMessages.UnterminatedRegExp);
        }

        if (escaped) {
          escaped = false;
        } else {
          if (ch === 91) {
            inClass = true;
          } else if (ch === 93 && inClass) {
            inClass = false;
          } else if (ch === 47 && !inClass) {
            break;
          }

          escaped = ch === 92;
        }
      }

      var content = this.input.slice(start, pos);
      ++pos;
      var mods = "";

      while (pos < this.length) {
        var cp = this.codePointAtPos(pos);

        var _char = String.fromCharCode(cp);

        if (VALID_REGEX_FLAGS.has(cp)) {
          if (mods.includes(_char)) {
            this.raise(pos + 1, ErrorMessages.DuplicateRegExpFlags);
          }
        } else if (isIdentifierChar(cp) || cp === 92) {
          this.raise(pos + 1, ErrorMessages.MalformedRegExpFlags);
        } else {
          break;
        }

        ++pos;
        mods += _char;
      }

      this.state.pos = pos;
      this.finishToken(types$1.regexp, {
        pattern: content,
        flags: mods
      });
    };

    _proto.readInt = function readInt(radix, len, forceLen, allowNumSeparator) {
      if (allowNumSeparator === void 0) {
        allowNumSeparator = true;
      }

      var start = this.state.pos;
      var forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      var allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;
      var invalid = false;
      var total = 0;

      for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        var code = this.input.charCodeAt(this.state.pos);
        var val = void 0;

        if (code === 95) {
          var prev = this.input.charCodeAt(this.state.pos - 1);
          var next = this.input.charCodeAt(this.state.pos + 1);

          if (allowedSiblings.indexOf(next) === -1) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {
            this.raise(this.state.pos, ErrorMessages.UnexpectedNumericSeparator);
          }

          if (!allowNumSeparator) {
            this.raise(this.state.pos, ErrorMessages.NumericSeparatorInEscapeSequence);
          }

          ++this.state.pos;
          continue;
        }

        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }

        if (val >= radix) {
          if (this.options.errorRecovery && val <= 9) {
            val = 0;
            this.raise(this.state.start + i + 2, ErrorMessages.InvalidDigit, radix);
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }

        ++this.state.pos;
        total = total * radix + val;
      }

      if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {
        return null;
      }

      return total;
    };

    _proto.readRadixNumber = function readRadixNumber(radix) {
      var start = this.state.pos;
      var isBigInt = false;
      this.state.pos += 2;
      var val = this.readInt(radix);

      if (val == null) {
        this.raise(this.state.start + 2, ErrorMessages.InvalidDigit, radix);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 110) {
        ++this.state.pos;
        isBigInt = true;
      } else if (next === 109) {
        throw this.raise(start, ErrorMessages.InvalidDecimal);
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      if (isBigInt) {
        var str = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
        this.finishToken(types$1.bigint, str);
        return;
      }

      this.finishToken(types$1.num, val);
    };

    _proto.readNumber = function readNumber(startsWithDot) {
      var start = this.state.pos;
      var isFloat = false;
      var isBigInt = false;
      var isDecimal = false;
      var hasExponent = false;
      var isOctal = false;

      if (!startsWithDot && this.readInt(10) === null) {
        this.raise(start, ErrorMessages.InvalidNumber);
      }

      var hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;

      if (hasLeadingZero) {
        var integer = this.input.slice(start, this.state.pos);
        this.recordStrictModeErrors(start, ErrorMessages.StrictOctalLiteral);

        if (!this.state.strict) {
          var underscorePos = integer.indexOf("_");

          if (underscorePos > 0) {
            this.raise(underscorePos + start, ErrorMessages.ZeroDigitNumericSeparator);
          }
        }

        isOctal = hasLeadingZero && !/[89]/.test(integer);
      }

      var next = this.input.charCodeAt(this.state.pos);

      if (next === 46 && !isOctal) {
        ++this.state.pos;
        this.readInt(10);
        isFloat = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if ((next === 69 || next === 101) && !isOctal) {
        next = this.input.charCodeAt(++this.state.pos);

        if (next === 43 || next === 45) {
          ++this.state.pos;
        }

        if (this.readInt(10) === null) {
          this.raise(start, ErrorMessages.InvalidOrMissingExponent);
        }

        isFloat = true;
        hasExponent = true;
        next = this.input.charCodeAt(this.state.pos);
      }

      if (next === 110) {
        if (isFloat || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidBigIntLiteral);
        }

        ++this.state.pos;
        isBigInt = true;
      }

      if (next === 109) {
        this.expectPlugin("decimal", this.state.pos);

        if (hasExponent || hasLeadingZero) {
          this.raise(start, ErrorMessages.InvalidDecimal);
        }

        ++this.state.pos;
        isDecimal = true;
      }

      if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
        throw this.raise(this.state.pos, ErrorMessages.NumberIdentifier);
      }

      var str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");

      if (isBigInt) {
        this.finishToken(types$1.bigint, str);
        return;
      }

      if (isDecimal) {
        this.finishToken(types$1.decimal, str);
        return;
      }

      var val = isOctal ? parseInt(str, 8) : parseFloat(str);
      this.finishToken(types$1.num, val);
    };

    _proto.readCodePoint = function readCodePoint(throwOnInvalid) {
      var ch = this.input.charCodeAt(this.state.pos);
      var code;

      if (ch === 123) {
        var codePos = ++this.state.pos;
        code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, true, throwOnInvalid);
        ++this.state.pos;

        if (code !== null && code > 0x10ffff) {
          if (throwOnInvalid) {
            this.raise(codePos, ErrorMessages.InvalidCodePoint);
          } else {
            return null;
          }
        }
      } else {
        code = this.readHexChar(4, false, throwOnInvalid);
      }

      return code;
    };

    _proto.readString = function readString(quote) {
      var out = "",
          chunkStart = ++this.state.pos;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        }

        var ch = this.input.charCodeAt(this.state.pos);
        if (ch === quote) break;

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.readEscapedChar(false);
          chunkStart = this.state.pos;
        } else if (ch === 8232 || ch === 8233) {
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
        } else if (isNewLine(ch)) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedString);
        } else {
          ++this.state.pos;
        }
      }

      out += this.input.slice(chunkStart, this.state.pos++);
      this.finishToken(types$1.string, out);
    };

    _proto.readTmplToken = function readTmplToken() {
      var out = "",
          chunkStart = this.state.pos,
          containsInvalid = false;

      for (;;) {
        if (this.state.pos >= this.length) {
          throw this.raise(this.state.start, ErrorMessages.UnterminatedTemplate);
        }

        var ch = this.input.charCodeAt(this.state.pos);

        if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
          if (this.state.pos === this.state.start && this.match(types$1.template)) {
            if (ch === 36) {
              this.state.pos += 2;
              this.finishToken(types$1.dollarBraceL);
              return;
            } else {
              ++this.state.pos;
              this.finishToken(types$1.backQuote);
              return;
            }
          }

          out += this.input.slice(chunkStart, this.state.pos);
          this.finishToken(types$1.template, containsInvalid ? null : out);
          return;
        }

        if (ch === 92) {
          out += this.input.slice(chunkStart, this.state.pos);
          var escaped = this.readEscapedChar(true);

          if (escaped === null) {
            containsInvalid = true;
          } else {
            out += escaped;
          }

          chunkStart = this.state.pos;
        } else if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          ++this.state.pos;

          switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.state.pos) === 10) {
                ++this.state.pos;
              }

            case 10:
              out += "\n";
              break;

            default:
              out += String.fromCharCode(ch);
              break;
          }

          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
      }
    };

    _proto.recordStrictModeErrors = function recordStrictModeErrors(pos, message) {
      if (this.state.strict && !this.state.strictErrors.has(pos)) {
        this.raise(pos, message);
      } else {
        this.state.strictErrors.set(pos, message);
      }
    };

    _proto.readEscapedChar = function readEscapedChar(inTemplate) {
      var throwOnInvalid = !inTemplate;
      var ch = this.input.charCodeAt(++this.state.pos);
      ++this.state.pos;

      switch (ch) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 120:
          {
            var code = this.readHexChar(2, false, throwOnInvalid);
            return code === null ? null : String.fromCharCode(code);
          }

        case 117:
          {
            var _code = this.readCodePoint(throwOnInvalid);

            return _code === null ? null : String.fromCodePoint(_code);
          }

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\x0B";

        case 102:
          return "\f";

        case 13:
          if (this.input.charCodeAt(this.state.pos) === 10) {
            ++this.state.pos;
          }

        case 10:
          this.state.lineStart = this.state.pos;
          ++this.state.curLine;

        case 8232:
        case 8233:
          return "";

        case 56:
        case 57:
          if (inTemplate) {
            return null;
          } else {
            this.recordStrictModeErrors(this.state.pos - 1, ErrorMessages.StrictNumericEscape);
          }

        default:
          if (ch >= 48 && ch <= 55) {
            var codePos = this.state.pos - 1;
            var match = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/);
            var octalStr = match[0];
            var octal = parseInt(octalStr, 8);

            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }

            this.state.pos += octalStr.length - 1;
            var next = this.input.charCodeAt(this.state.pos);

            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return null;
              } else {
                this.recordStrictModeErrors(codePos, ErrorMessages.StrictNumericEscape);
              }
            }

            return String.fromCharCode(octal);
          }

          return String.fromCharCode(ch);
      }
    };

    _proto.readHexChar = function readHexChar(len, forceLen, throwOnInvalid) {
      var codePos = this.state.pos;
      var n = this.readInt(16, len, forceLen, false);

      if (n === null) {
        if (throwOnInvalid) {
          this.raise(codePos, ErrorMessages.InvalidEscapeSequence);
        } else {
          this.state.pos = codePos - 1;
        }
      }

      return n;
    };

    _proto.readWord1 = function readWord1(firstCode) {
      this.state.containsEsc = false;
      var word = "";
      var start = this.state.pos;
      var chunkStart = this.state.pos;

      if (firstCode !== undefined) {
        this.state.pos += firstCode <= 0xffff ? 1 : 2;
      }

      while (this.state.pos < this.length) {
        var ch = this.codePointAtPos(this.state.pos);

        if (isIdentifierChar(ch)) {
          this.state.pos += ch <= 0xffff ? 1 : 2;
        } else if (ch === 92) {
          this.state.containsEsc = true;
          word += this.input.slice(chunkStart, this.state.pos);
          var escStart = this.state.pos;
          var identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;

          if (this.input.charCodeAt(++this.state.pos) !== 117) {
            this.raise(this.state.pos, ErrorMessages.MissingUnicodeEscape);
            chunkStart = this.state.pos - 1;
            continue;
          }

          ++this.state.pos;
          var esc = this.readCodePoint(true);

          if (esc !== null) {
            if (!identifierCheck(esc)) {
              this.raise(escStart, ErrorMessages.EscapedCharNotAnIdentifier);
            }

            word += String.fromCodePoint(esc);
          }

          chunkStart = this.state.pos;
        } else {
          break;
        }
      }

      return word + this.input.slice(chunkStart, this.state.pos);
    };

    _proto.readWord = function readWord(firstCode) {
      var word = this.readWord1(firstCode);
      var type = keywords.get(word) || types$1.name;
      this.finishToken(type, word);
    };

    _proto.checkKeywordEscapes = function checkKeywordEscapes() {
      var kw = this.state.type.keyword;

      if (kw && this.state.containsEsc) {
        this.raise(this.state.start, ErrorMessages.InvalidEscapedReservedWord, kw);
      }
    };

    _proto.updateContext = function updateContext(prevType) {
      var _this$state$type$upda, _this$state$type;

      (_this$state$type$upda = (_this$state$type = this.state.type).updateContext) == null ? void 0 : _this$state$type$upda.call(_this$state$type, this.state.context);
    };

    return Tokenizer;
  }(ParserError);

  var ClassScope = function ClassScope() {
    this.privateNames = new Set();
    this.loneAccessors = new Map();
    this.undefinedPrivateNames = new Map();
  };

  var ClassScopeHandler = function () {
    function ClassScopeHandler(raise) {
      this.stack = [];
      this.undefinedPrivateNames = new Map();
      this.raise = raise;
    }

    var _proto = ClassScopeHandler.prototype;

    _proto.current = function current() {
      return this.stack[this.stack.length - 1];
    };

    _proto.enter = function enter() {
      this.stack.push(new ClassScope());
    };

    _proto.exit = function exit() {
      var oldClassScope = this.stack.pop();
      var current = this.current();

      for (var _i2 = 0, _Array$from2 = Array.from(oldClassScope.undefinedPrivateNames); _i2 < _Array$from2.length; _i2++) {
        var _Array$from2$_i = _Array$from2[_i2],
            name = _Array$from2$_i[0],
            pos = _Array$from2$_i[1];

        if (current) {
          if (!current.undefinedPrivateNames.has(name)) {
            current.undefinedPrivateNames.set(name, pos);
          }
        } else {
          this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
        }
      }
    };

    _proto.declarePrivateName = function declarePrivateName(name, elementType, pos) {
      var classScope = this.current();
      var redefined = classScope.privateNames.has(name);

      if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {
        var accessor = redefined && classScope.loneAccessors.get(name);

        if (accessor) {
          var oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;
          var newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;
          var oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;
          var newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;
          redefined = oldKind === newKind || oldStatic !== newStatic;
          if (!redefined) classScope.loneAccessors["delete"](name);
        } else if (!redefined) {
          classScope.loneAccessors.set(name, elementType);
        }
      }

      if (redefined) {
        this.raise(pos, ErrorMessages.PrivateNameRedeclaration, name);
      }

      classScope.privateNames.add(name);
      classScope.undefinedPrivateNames["delete"](name);
    };

    _proto.usePrivateName = function usePrivateName(name, pos) {
      var classScope;

      for (var _i4 = 0, _this$stack2 = this.stack; _i4 < _this$stack2.length; _i4++) {
        classScope = _this$stack2[_i4];
        if (classScope.privateNames.has(name)) return;
      }

      if (classScope) {
        classScope.undefinedPrivateNames.set(name, pos);
      } else {
        this.raise(pos, ErrorMessages.InvalidPrivateFieldResolution, name);
      }
    };

    return ClassScopeHandler;
  }();

  var kExpression = 0,
      kMaybeArrowParameterDeclaration = 1,
      kMaybeAsyncArrowParameterDeclaration = 2,
      kParameterDeclaration = 3;

  var ExpressionScope = function () {
    function ExpressionScope(type) {
      if (type === void 0) {
        type = kExpression;
      }

      this.type = void 0;
      this.type = type;
    }

    var _proto = ExpressionScope.prototype;

    _proto.canBeArrowParameterDeclaration = function canBeArrowParameterDeclaration() {
      return this.type === kMaybeAsyncArrowParameterDeclaration || this.type === kMaybeArrowParameterDeclaration;
    };

    _proto.isCertainlyParameterDeclaration = function isCertainlyParameterDeclaration() {
      return this.type === kParameterDeclaration;
    };

    return ExpressionScope;
  }();

  var ArrowHeadParsingScope = function (_ExpressionScope) {
    _inherits(ArrowHeadParsingScope, _ExpressionScope);

    function ArrowHeadParsingScope(type) {
      var _this;

      _this = _ExpressionScope.call(this, type) || this;
      _this.errors = new Map();
      return _this;
    }

    var _proto2 = ArrowHeadParsingScope.prototype;

    _proto2.recordDeclarationError = function recordDeclarationError(pos, template) {
      this.errors.set(pos, template);
    };

    _proto2.clearDeclarationError = function clearDeclarationError(pos) {
      this.errors["delete"](pos);
    };

    _proto2.iterateErrors = function iterateErrors(iterator) {
      this.errors.forEach(iterator);
    };

    return ArrowHeadParsingScope;
  }(ExpressionScope);

  var ExpressionScopeHandler = function () {
    function ExpressionScopeHandler(raise) {
      this.stack = [new ExpressionScope()];
      this.raise = raise;
    }

    var _proto3 = ExpressionScopeHandler.prototype;

    _proto3.enter = function enter(scope) {
      this.stack.push(scope);
    };

    _proto3.exit = function exit() {
      this.stack.pop();
    };

    _proto3.recordParameterInitializerError = function recordParameterInitializerError(pos, template) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (!scope.isCertainlyParameterDeclaration()) {
        if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(pos, template);
        } else {
          return;
        }

        scope = stack[--i];
      }

      this.raise(pos, template);
    };

    _proto3.recordParenthesizedIdentifierError = function recordParenthesizedIdentifierError(pos, template) {
      var stack = this.stack;
      var scope = stack[stack.length - 1];

      if (scope.isCertainlyParameterDeclaration()) {
        this.raise(pos, template);
      } else if (scope.canBeArrowParameterDeclaration()) {
        scope.recordDeclarationError(pos, template);
      } else {
        return;
      }
    };

    _proto3.recordAsyncArrowParametersError = function recordAsyncArrowParametersError(pos, template) {
      var stack = this.stack;
      var i = stack.length - 1;
      var scope = stack[i];

      while (scope.canBeArrowParameterDeclaration()) {
        if (scope.type === kMaybeAsyncArrowParameterDeclaration) {
          scope.recordDeclarationError(pos, template);
        }

        scope = stack[--i];
      }
    };

    _proto3.validateAsPattern = function validateAsPattern() {
      var _this2 = this;

      var stack = this.stack;
      var currentScope = stack[stack.length - 1];
      if (!currentScope.canBeArrowParameterDeclaration()) return;
      currentScope.iterateErrors(function (template, pos) {
        _this2.raise(pos, template);

        var i = stack.length - 2;
        var scope = stack[i];

        while (scope.canBeArrowParameterDeclaration()) {
          scope.clearDeclarationError(pos);
          scope = stack[--i];
        }
      });
    };

    return ExpressionScopeHandler;
  }();
  function newParameterDeclarationScope() {
    return new ExpressionScope(kParameterDeclaration);
  }
  function newArrowHeadScope() {
    return new ArrowHeadParsingScope(kMaybeArrowParameterDeclaration);
  }
  function newAsyncArrowScope() {
    return new ArrowHeadParsingScope(kMaybeAsyncArrowParameterDeclaration);
  }
  function newExpressionScope() {
    return new ExpressionScope();
  }

  var UtilParser = function (_Tokenizer) {
    _inherits(UtilParser, _Tokenizer);

    function UtilParser() {
      return _Tokenizer.apply(this, arguments) || this;
    }

    var _proto = UtilParser.prototype;

    _proto.addExtra = function addExtra(node, key, val) {
      if (!node) return;
      var extra = node.extra = node.extra || {};
      extra[key] = val;
    };

    _proto.isRelational = function isRelational(op) {
      return this.match(types$1.relational) && this.state.value === op;
    };

    _proto.expectRelational = function expectRelational(op) {
      if (this.isRelational(op)) {
        this.next();
      } else {
        this.unexpected(null, types$1.relational);
      }
    };

    _proto.isContextual = function isContextual(name) {
      return this.match(types$1.name) && this.state.value === name && !this.state.containsEsc;
    };

    _proto.isUnparsedContextual = function isUnparsedContextual(nameStart, name) {
      var nameEnd = nameStart + name.length;

      if (this.input.slice(nameStart, nameEnd) === name) {
        var nextCh = this.input.charCodeAt(nameEnd);
        return !(isIdentifierChar(nextCh) || (nextCh & 0xfc00) === 0xd800);
      }

      return false;
    };

    _proto.isLookaheadContextual = function isLookaheadContextual(name) {
      var next = this.nextTokenStart();
      return this.isUnparsedContextual(next, name);
    };

    _proto.eatContextual = function eatContextual(name) {
      return this.isContextual(name) && this.eat(types$1.name);
    };

    _proto.expectContextual = function expectContextual(name, template) {
      if (!this.eatContextual(name)) this.unexpected(null, template);
    };

    _proto.canInsertSemicolon = function canInsertSemicolon() {
      return this.match(types$1.eof) || this.match(types$1.braceR) || this.hasPrecedingLineBreak();
    };

    _proto.hasPrecedingLineBreak = function hasPrecedingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    };

    _proto.hasFollowingLineBreak = function hasFollowingLineBreak() {
      return lineBreak.test(this.input.slice(this.state.end, this.nextTokenStart()));
    };

    _proto.isLineTerminator = function isLineTerminator() {
      return this.eat(types$1.semi) || this.canInsertSemicolon();
    };

    _proto.semicolon = function semicolon(allowAsi) {
      if (allowAsi === void 0) {
        allowAsi = true;
      }

      if (allowAsi ? this.isLineTerminator() : this.eat(types$1.semi)) return;
      this.raise(this.state.lastTokEnd, ErrorMessages.MissingSemicolon);
    };

    _proto.expect = function expect(type, pos) {
      this.eat(type) || this.unexpected(pos, type);
    };

    _proto.assertNoSpace = function assertNoSpace(message) {
      if (message === void 0) {
        message = "Unexpected space.";
      }

      if (this.state.start > this.state.lastTokEnd) {
        this.raise(this.state.lastTokEnd, {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedSpace",
          template: message
        });
      }
    };

    _proto.unexpected = function unexpected(pos, messageOrType) {
      if (messageOrType === void 0) {
        messageOrType = {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: "Unexpected token"
        };
      }

      if (messageOrType instanceof TokenType) {
        messageOrType = {
          code: ErrorCodes.SyntaxError,
          reasonCode: "UnexpectedToken",
          template: "Unexpected token, expected \"" + messageOrType.label + "\""
        };
      }

      throw this.raise(pos != null ? pos : this.state.start, messageOrType);
    };

    _proto.expectPlugin = function expectPlugin(name, pos) {
      if (!this.hasPlugin(name)) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: [name]
        }, "This experimental syntax requires enabling the parser plugin: '" + name + "'");
      }

      return true;
    };

    _proto.expectOnePlugin = function expectOnePlugin(names, pos) {
      var _this = this;

      if (!names.some(function (n) {
        return _this.hasPlugin(n);
      })) {
        throw this.raiseWithData(pos != null ? pos : this.state.start, {
          missingPlugin: names
        }, "This experimental syntax requires enabling one of the following parser plugin(s): '" + names.join(", ") + "'");
      }
    };

    _proto.tryParse = function tryParse(fn, oldState) {
      if (oldState === void 0) {
        oldState = this.state.clone();
      }

      var abortSignal = {
        node: null
      };

      try {
        var _node = fn(function (node) {
          if (node === void 0) {
            node = null;
          }

          abortSignal.node = node;
          throw abortSignal;
        });

        if (this.state.errors.length > oldState.errors.length) {
          var failState = this.state;
          this.state = oldState;
          this.state.tokensLength = failState.tokensLength;
          return {
            node: _node,
            error: failState.errors[oldState.errors.length],
            thrown: false,
            aborted: false,
            failState: failState
          };
        }

        return {
          node: _node,
          error: null,
          thrown: false,
          aborted: false,
          failState: null
        };
      } catch (error) {
        var _failState = this.state;
        this.state = oldState;

        if (error instanceof SyntaxError) {
          return {
            node: null,
            error: error,
            thrown: true,
            aborted: false,
            failState: _failState
          };
        }

        if (error === abortSignal) {
          return {
            node: abortSignal.node,
            error: null,
            thrown: false,
            aborted: true,
            failState: _failState
          };
        }

        throw error;
      }
    };

    _proto.checkExpressionErrors = function checkExpressionErrors(refExpressionErrors, andThrow) {
      if (!refExpressionErrors) return false;
      var shorthandAssign = refExpressionErrors.shorthandAssign,
          doubleProto = refExpressionErrors.doubleProto,
          optionalParameters = refExpressionErrors.optionalParameters;

      if (!andThrow) {
        return shorthandAssign >= 0 || doubleProto >= 0 || optionalParameters >= 0;
      }

      if (shorthandAssign >= 0) {
        this.unexpected(shorthandAssign);
      }

      if (doubleProto >= 0) {
        this.raise(doubleProto, ErrorMessages.DuplicateProto);
      }

      if (optionalParameters >= 0) {
        this.unexpected(optionalParameters);
      }
    };

    _proto.isLiteralPropertyName = function isLiteralPropertyName() {
      return this.match(types$1.name) || !!this.state.type.keyword || this.match(types$1.string) || this.match(types$1.num) || this.match(types$1.bigint) || this.match(types$1.decimal);
    };

    _proto.isPrivateName = function isPrivateName(node) {
      return node.type === "PrivateName";
    };

    _proto.getPrivateNameSV = function getPrivateNameSV(node) {
      return node.id.name;
    };

    _proto.hasPropertyAsPrivateName = function hasPropertyAsPrivateName(node) {
      return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
    };

    _proto.isOptionalChain = function isOptionalChain(node) {
      return node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression";
    };

    _proto.isObjectProperty = function isObjectProperty(node) {
      return node.type === "ObjectProperty";
    };

    _proto.isObjectMethod = function isObjectMethod(node) {
      return node.type === "ObjectMethod";
    };

    _proto.initializeScopes = function initializeScopes(inModule) {
      var _this2 = this;

      if (inModule === void 0) {
        inModule = this.options.sourceType === "module";
      }

      var oldLabels = this.state.labels;
      this.state.labels = [];
      var oldExportedIdentifiers = this.exportedIdentifiers;
      this.exportedIdentifiers = new Set();
      var oldInModule = this.inModule;
      this.inModule = inModule;
      var oldScope = this.scope;
      var ScopeHandler = this.getScopeHandler();
      this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);
      var oldProdParam = this.prodParam;
      this.prodParam = new ProductionParameterHandler();
      var oldClassScope = this.classScope;
      this.classScope = new ClassScopeHandler(this.raise.bind(this));
      var oldExpressionScope = this.expressionScope;
      this.expressionScope = new ExpressionScopeHandler(this.raise.bind(this));
      return function () {
        _this2.state.labels = oldLabels;
        _this2.exportedIdentifiers = oldExportedIdentifiers;
        _this2.inModule = oldInModule;
        _this2.scope = oldScope;
        _this2.prodParam = oldProdParam;
        _this2.classScope = oldClassScope;
        _this2.expressionScope = oldExpressionScope;
      };
    };

    _proto.enterInitialScopes = function enterInitialScopes() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
    };

    return UtilParser;
  }(Tokenizer);
  var ExpressionErrors = function ExpressionErrors() {
    this.shorthandAssign = -1;
    this.doubleProto = -1;
    this.optionalParameters = -1;
  };

  var Node$3 = function () {
    function Node(parser, pos, loc) {
      this.type = void 0;
      this.start = void 0;
      this.end = void 0;
      this.loc = void 0;
      this.range = void 0;
      this.leadingComments = void 0;
      this.trailingComments = void 0;
      this.innerComments = void 0;
      this.extra = void 0;
      this.type = "";
      this.start = pos;
      this.end = 0;
      this.loc = new SourceLocation(loc);
      if (parser != null && parser.options.ranges) this.range = [pos, 0];
      if (parser != null && parser.filename) this.loc.filename = parser.filename;
    }

    var _proto = Node.prototype;

    _proto.__clone = function __clone() {
      var newNode = new Node();
      var keys = Object.keys(this);

      for (var i = 0, length = keys.length; i < length; i++) {
        var _key = keys[i];

        if (_key !== "leadingComments" && _key !== "trailingComments" && _key !== "innerComments") {
          newNode[_key] = this[_key];
        }
      }

      return newNode;
    };

    return Node;
  }();

  var NodeUtils = function (_UtilParser) {
    _inherits(NodeUtils, _UtilParser);

    function NodeUtils() {
      return _UtilParser.apply(this, arguments) || this;
    }

    var _proto2 = NodeUtils.prototype;

    _proto2.startNode = function startNode() {
      return new Node$3(this, this.state.start, this.state.startLoc);
    };

    _proto2.startNodeAt = function startNodeAt(pos, loc) {
      return new Node$3(this, pos, loc);
    };

    _proto2.startNodeAtNode = function startNodeAtNode(type) {
      return this.startNodeAt(type.start, type.loc.start);
    };

    _proto2.finishNode = function finishNode(node, type) {
      return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
    };

    _proto2.finishNodeAt = function finishNodeAt(node, type, pos, loc) {
      if (node.end > 0) {
        throw new Error("Do not call finishNode*() twice on the same node." + " Instead use resetEndLocation() or change type directly.");
      }

      node.type = type;
      node.end = pos;
      node.loc.end = loc;
      if (this.options.ranges) node.range[1] = pos;
      this.processComment(node);
      return node;
    };

    _proto2.resetStartLocation = function resetStartLocation(node, start, startLoc) {
      node.start = start;
      node.loc.start = startLoc;
      if (this.options.ranges) node.range[0] = start;
    };

    _proto2.resetEndLocation = function resetEndLocation(node, end, endLoc) {
      if (end === void 0) {
        end = this.state.lastTokEnd;
      }

      if (endLoc === void 0) {
        endLoc = this.state.lastTokEndLoc;
      }

      node.end = end;
      node.loc.end = endLoc;
      if (this.options.ranges) node.range[1] = end;
    };

    _proto2.resetStartLocationFromNode = function resetStartLocationFromNode(node, locationNode) {
      this.resetStartLocation(node, locationNode.start, locationNode.loc.start);
    };

    return NodeUtils;
  }(UtilParser);

  var unwrapParenthesizedExpression = function unwrapParenthesizedExpression(node) {
    return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
  };

  var LValParser = function (_NodeUtils) {
    _inherits(LValParser, _NodeUtils);

    function LValParser() {
      return _NodeUtils.apply(this, arguments) || this;
    }

    var _proto = LValParser.prototype;

    _proto.toAssignable = function toAssignable(node, isLHS) {
      var _node$extra, _node$extra3;

      if (isLHS === void 0) {
        isLHS = false;
      }

      var parenthesized = undefined;

      if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
        parenthesized = unwrapParenthesizedExpression(node);

        if (isLHS) {
          if (parenthesized.type === "Identifier") {
            this.expressionScope.recordParenthesizedIdentifierError(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          } else if (parenthesized.type !== "MemberExpression") {
            this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
          }
        } else {
          this.raise(node.start, ErrorMessages.InvalidParenthesizedAssignment);
        }
      }

      switch (node.type) {
        case "Identifier":
        case "ObjectPattern":
        case "ArrayPattern":
        case "AssignmentPattern":
          break;

        case "ObjectExpression":
          node.type = "ObjectPattern";

          for (var i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
            var _node$extra2;

            var prop = node.properties[i];
            var isLast = i === last;
            this.toAssignableObjectExpressionProp(prop, isLast, isLHS);

            if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingComma) {
              this.raiseRestNotLast(node.extra.trailingComma);
            }
          }

          break;

        case "ObjectProperty":
          this.toAssignable(node.value, isLHS);
          break;

        case "SpreadElement":
          {
            this.checkToRestConversion(node);
            node.type = "RestElement";
            var arg = node.argument;
            this.toAssignable(arg, isLHS);
            break;
          }

        case "ArrayExpression":
          node.type = "ArrayPattern";
          this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma, isLHS);
          break;

        case "AssignmentExpression":
          if (node.operator !== "=") {
            this.raise(node.left.end, ErrorMessages.MissingEqInAssignment);
          }

          node.type = "AssignmentPattern";
          delete node.operator;
          this.toAssignable(node.left, isLHS);
          break;

        case "ParenthesizedExpression":
          this.toAssignable(parenthesized, isLHS);
          break;
      }

      return node;
    };

    _proto.toAssignableObjectExpressionProp = function toAssignableObjectExpressionProp(prop, isLast, isLHS) {
      if (prop.type === "ObjectMethod") {
        var error = prop.kind === "get" || prop.kind === "set" ? ErrorMessages.PatternHasAccessor : ErrorMessages.PatternHasMethod;
        this.raise(prop.key.start, error);
      } else if (prop.type === "SpreadElement" && !isLast) {
        this.raiseRestNotLast(prop.start);
      } else {
        this.toAssignable(prop, isLHS);
      }
    };

    _proto.toAssignableList = function toAssignableList(exprList, trailingCommaPos, isLHS) {
      var end = exprList.length;

      if (end) {
        var last = exprList[end - 1];

        if ((last == null ? void 0 : last.type) === "RestElement") {
          --end;
        } else if ((last == null ? void 0 : last.type) === "SpreadElement") {
          last.type = "RestElement";
          var arg = last.argument;
          this.toAssignable(arg, isLHS);
          arg = unwrapParenthesizedExpression(arg);

          if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern" && arg.type !== "ObjectPattern") {
            this.unexpected(arg.start);
          }

          if (trailingCommaPos) {
            this.raiseTrailingCommaAfterRest(trailingCommaPos);
          }

          --end;
        }
      }

      for (var i = 0; i < end; i++) {
        var elt = exprList[i];

        if (elt) {
          this.toAssignable(elt, isLHS);

          if (elt.type === "RestElement") {
            this.raiseRestNotLast(elt.start);
          }
        }
      }

      return exprList;
    };

    _proto.toReferencedList = function toReferencedList(exprList, isParenthesizedExpr) {
      return exprList;
    };

    _proto.toReferencedListDeep = function toReferencedListDeep(exprList, isParenthesizedExpr) {
      this.toReferencedList(exprList, isParenthesizedExpr);

      for (var _i2 = 0; _i2 < exprList.length; _i2++) {
        var expr = exprList[_i2];

        if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
          this.toReferencedListDeep(expr.elements);
        }
      }
    };

    _proto.parseSpread = function parseSpread(refExpressionErrors, refNeedsArrowPos) {
      var node = this.startNode();
      this.next();
      node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, undefined, refNeedsArrowPos);
      return this.finishNode(node, "SpreadElement");
    };

    _proto.parseRestBinding = function parseRestBinding() {
      var node = this.startNode();
      this.next();
      node.argument = this.parseBindingAtom();
      return this.finishNode(node, "RestElement");
    };

    _proto.parseBindingAtom = function parseBindingAtom() {
      switch (this.state.type) {
        case types$1.bracketL:
          {
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types$1.bracketR, 93, true);
            return this.finishNode(node, "ArrayPattern");
          }

        case types$1.braceL:
          return this.parseObjectLike(types$1.braceR, true);
      }

      return this.parseIdentifier();
    };

    _proto.parseBindingList = function parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
        }

        if (allowEmpty && this.match(types$1.comma)) {
          elts.push(null);
        } else if (this.eat(close)) {
          break;
        } else if (this.match(types$1.ellipsis)) {
          elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));
          this.checkCommaAfterRest(closeCharCode);
          this.expect(close);
          break;
        } else {
          var decorators = [];

          if (this.match(types$1.at) && this.hasPlugin("decorators")) {
            this.raise(this.state.start, ErrorMessages.UnsupportedParameterDecorator);
          }

          while (this.match(types$1.at)) {
            decorators.push(this.parseDecorator());
          }

          elts.push(this.parseAssignableListItem(allowModifiers, decorators));
        }
      }

      return elts;
    };

    _proto.parseAssignableListItem = function parseAssignableListItem(allowModifiers, decorators) {
      var left = this.parseMaybeDefault();
      this.parseAssignableListItemTypes(left);
      var elt = this.parseMaybeDefault(left.start, left.loc.start, left);

      if (decorators.length) {
        left.decorators = decorators;
      }

      return elt;
    };

    _proto.parseAssignableListItemTypes = function parseAssignableListItemTypes(param) {
      return param;
    };

    _proto.parseMaybeDefault = function parseMaybeDefault(startPos, startLoc, left) {
      var _startLoc, _startPos, _left;

      startLoc = (_startLoc = startLoc) != null ? _startLoc : this.state.startLoc;
      startPos = (_startPos = startPos) != null ? _startPos : this.state.start;
      left = (_left = left) != null ? _left : this.parseBindingAtom();
      if (!this.eat(types$1.eq)) return left;
      var node = this.startNodeAt(startPos, startLoc);
      node.left = left;
      node.right = this.parseMaybeAssignAllowIn();
      return this.finishNode(node, "AssignmentPattern");
    };

    _proto.checkLVal = function checkLVal(expr, contextDescription, bindingType, checkClashes, disallowLetBinding, strictModeChanged) {
      if (bindingType === void 0) {
        bindingType = BIND_NONE;
      }

      if (strictModeChanged === void 0) {
        strictModeChanged = false;
      }

      switch (expr.type) {
        case "Identifier":
          {
            var name = expr.name;

            if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(name, this.inModule) : isStrictBindOnlyReservedWord(name))) {
              this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.StrictEvalArguments : ErrorMessages.StrictEvalArgumentsBinding, name);
            }

            if (checkClashes) {
              if (checkClashes.has(name)) {
                this.raise(expr.start, ErrorMessages.ParamDupe);
              } else {
                checkClashes.add(name);
              }
            }

            if (disallowLetBinding && name === "let") {
              this.raise(expr.start, ErrorMessages.LetInLexicalBinding);
            }

            if (!(bindingType & BIND_NONE)) {
              this.scope.declareName(name, bindingType, expr.start);
            }

            break;
          }

        case "MemberExpression":
          if (bindingType !== BIND_NONE) {
            this.raise(expr.start, ErrorMessages.InvalidPropertyBindingPattern);
          }

          break;

        case "ObjectPattern":
          for (var _i4 = 0, _expr$properties2 = expr.properties; _i4 < _expr$properties2.length; _i4++) {
            var prop = _expr$properties2[_i4];
            if (this.isObjectProperty(prop)) prop = prop.value;else if (this.isObjectMethod(prop)) continue;
            this.checkLVal(prop, "object destructuring pattern", bindingType, checkClashes, disallowLetBinding);
          }

          break;

        case "ArrayPattern":
          for (var _i6 = 0, _expr$elements2 = expr.elements; _i6 < _expr$elements2.length; _i6++) {
            var elem = _expr$elements2[_i6];

            if (elem) {
              this.checkLVal(elem, "array destructuring pattern", bindingType, checkClashes, disallowLetBinding);
            }
          }

          break;

        case "AssignmentPattern":
          this.checkLVal(expr.left, "assignment pattern", bindingType, checkClashes);
          break;

        case "RestElement":
          this.checkLVal(expr.argument, "rest element", bindingType, checkClashes);
          break;

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, "parenthesized expression", bindingType, checkClashes);
          break;

        default:
          {
            this.raise(expr.start, bindingType === BIND_NONE ? ErrorMessages.InvalidLhs : ErrorMessages.InvalidLhsBinding, contextDescription);
          }
      }
    };

    _proto.checkToRestConversion = function checkToRestConversion(node) {
      if (node.argument.type !== "Identifier" && node.argument.type !== "MemberExpression") {
        this.raise(node.argument.start, ErrorMessages.InvalidRestAssignmentPattern);
      }
    };

    _proto.checkCommaAfterRest = function checkCommaAfterRest(close) {
      if (this.match(types$1.comma)) {
        if (this.lookaheadCharCode() === close) {
          this.raiseTrailingCommaAfterRest(this.state.start);
        } else {
          this.raiseRestNotLast(this.state.start);
        }
      }
    };

    _proto.raiseRestNotLast = function raiseRestNotLast(pos) {
      throw this.raise(pos, ErrorMessages.ElementAfterRest);
    };

    _proto.raiseTrailingCommaAfterRest = function raiseTrailingCommaAfterRest(pos) {
      this.raise(pos, ErrorMessages.RestTrailingComma);
    };

    return LValParser;
  }(NodeUtils);

  var ExpressionParser = function (_LValParser) {
    _inherits(ExpressionParser, _LValParser);

    function ExpressionParser() {
      return _LValParser.apply(this, arguments) || this;
    }

    var _proto = ExpressionParser.prototype;

    _proto.checkProto = function checkProto(prop, isRecord, protoRef, refExpressionErrors) {
      if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
        return;
      }

      var key = prop.key;
      var name = key.type === "Identifier" ? key.name : key.value;

      if (name === "__proto__") {
        if (isRecord) {
          this.raise(key.start, ErrorMessages.RecordNoProto);
          return;
        }

        if (protoRef.used) {
          if (refExpressionErrors) {
            if (refExpressionErrors.doubleProto === -1) {
              refExpressionErrors.doubleProto = key.start;
            }
          } else {
            this.raise(key.start, ErrorMessages.DuplicateProto);
          }
        }

        protoRef.used = true;
      }
    };

    _proto.shouldExitDescending = function shouldExitDescending(expr, potentialArrowAt) {
      return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
    };

    _proto.getExpression = function getExpression() {
      var paramFlags = PARAM;

      if (this.hasPlugin("topLevelAwait") && this.inModule) {
        paramFlags |= PARAM_AWAIT;
      }

      this.scope.enter(SCOPE_PROGRAM);
      this.prodParam.enter(paramFlags);
      this.nextToken();
      var expr = this.parseExpression();

      if (!this.match(types$1.eof)) {
        this.unexpected();
      }

      expr.comments = this.state.comments;
      expr.errors = this.state.errors;

      if (this.options.tokens) {
        expr.tokens = this.tokens;
      }

      return expr;
    };

    _proto.parseExpression = function parseExpression(disallowIn, refExpressionErrors) {
      var _this = this;

      if (disallowIn) {
        return this.disallowInAnd(function () {
          return _this.parseExpressionBase(refExpressionErrors);
        });
      }

      return this.allowInAnd(function () {
        return _this.parseExpressionBase(refExpressionErrors);
      });
    };

    _proto.parseExpressionBase = function parseExpressionBase(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseMaybeAssign(refExpressionErrors);

      if (this.match(types$1.comma)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.expressions = [expr];

        while (this.eat(types$1.comma)) {
          node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
        }

        this.toReferencedList(node.expressions);
        return this.finishNode(node, "SequenceExpression");
      }

      return expr;
    };

    _proto.parseMaybeAssignDisallowIn = function parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
      var _this2 = this;

      return this.disallowInAnd(function () {
        return _this2.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    };

    _proto.parseMaybeAssignAllowIn = function parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
      var _this3 = this;

      return this.allowInAnd(function () {
        return _this3.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      });
    };

    _proto.setOptionalParametersError = function setOptionalParametersError(refExpressionErrors, resultError) {
      var _resultError$pos;

      refExpressionErrors.optionalParameters = (_resultError$pos = resultError == null ? void 0 : resultError.pos) != null ? _resultError$pos : this.state.start;
    };

    _proto.parseMaybeAssign = function parseMaybeAssign(refExpressionErrors, afterLeftParse) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      if (this.isContextual("yield")) {
        if (this.prodParam.hasYield) {
          var _left = this.parseYield();

          if (afterLeftParse) {
            _left = afterLeftParse.call(this, _left, startPos, startLoc);
          }

          return _left;
        }
      }

      var ownExpressionErrors;

      if (refExpressionErrors) {
        ownExpressionErrors = false;
      } else {
        refExpressionErrors = new ExpressionErrors();
        ownExpressionErrors = true;
      }

      if (this.match(types$1.parenL) || this.match(types$1.name)) {
        this.state.potentialArrowAt = this.state.start;
      }

      var left = this.parseMaybeConditional(refExpressionErrors);

      if (afterLeftParse) {
        left = afterLeftParse.call(this, left, startPos, startLoc);
      }

      if (this.state.type.isAssign) {
        var node = this.startNodeAt(startPos, startLoc);
        var operator = this.state.value;
        node.operator = operator;

        if (this.match(types$1.eq)) {
          node.left = this.toAssignable(left, true);
          refExpressionErrors.doubleProto = -1;
        } else {
          node.left = left;
        }

        if (refExpressionErrors.shorthandAssign >= node.left.start) {
          refExpressionErrors.shorthandAssign = -1;
        }

        this.checkLVal(left, "assignment expression");
        this.next();
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentExpression");
      } else if (ownExpressionErrors) {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      return left;
    };

    _proto.parseMaybeConditional = function parseMaybeConditional(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprOps(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseConditional(expr, startPos, startLoc, refExpressionErrors);
    };

    _proto.parseConditional = function parseConditional(expr, startPos, startLoc, refExpressionErrors) {
      if (this.eat(types$1.question)) {
        var node = this.startNodeAt(startPos, startLoc);
        node.test = expr;
        node.consequent = this.parseMaybeAssignAllowIn();
        this.expect(types$1.colon);
        node.alternate = this.parseMaybeAssign();
        return this.finishNode(node, "ConditionalExpression");
      }

      return expr;
    };

    _proto.parseExprOps = function parseExprOps(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseMaybeUnary(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseExprOp(expr, startPos, startLoc, -1);
    };

    _proto.parseExprOp = function parseExprOp(left, leftStartPos, leftStartLoc, minPrec) {
      var prec = this.state.type.binop;

      if (prec != null && (this.prodParam.hasIn || !this.match(types$1._in))) {
        if (prec > minPrec) {
          var op = this.state.type;

          if (op === types$1.pipeline) {
            this.expectPlugin("pipelineOperator");

            if (this.state.inFSharpPipelineDirectBody) {
              return left;
            }

            this.state.inPipeline = true;
            this.checkPipelineAtInfixOperator(left, leftStartPos);
          }

          var node = this.startNodeAt(leftStartPos, leftStartLoc);
          node.left = left;
          node.operator = this.state.value;
          var logical = op === types$1.logicalOR || op === types$1.logicalAND;
          var coalesce = op === types$1.nullishCoalescing;

          if (coalesce) {
            prec = types$1.logicalAND.binop;
          }

          this.next();

          if (op === types$1.pipeline && this.getPluginOption("pipelineOperator", "proposal") === "minimal") {
            if (this.match(types$1.name) && this.state.value === "await" && this.prodParam.hasAwait) {
              throw this.raise(this.state.start, ErrorMessages.UnexpectedAwaitAfterPipelineBody);
            }
          }

          node.right = this.parseExprOpRightExpr(op, prec);
          this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
          var nextOp = this.state.type;

          if (coalesce && (nextOp === types$1.logicalOR || nextOp === types$1.logicalAND) || logical && nextOp === types$1.nullishCoalescing) {
            throw this.raise(this.state.start, ErrorMessages.MixingCoalesceWithLogical);
          }

          return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec);
        }
      }

      return left;
    };

    _proto.parseExprOpRightExpr = function parseExprOpRightExpr(op, prec) {
      var _this4 = this;

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;

      switch (op) {
        case types$1.pipeline:
          switch (this.getPluginOption("pipelineOperator", "proposal")) {
            case "smart":
              return this.withTopicPermittingContext(function () {
                return _this4.parseSmartPipelineBody(_this4.parseExprOpBaseRightExpr(op, prec), startPos, startLoc);
              });

            case "fsharp":
              return this.withSoloAwaitPermittingContext(function () {
                return _this4.parseFSharpPipelineBody(prec);
              });
          }

        default:
          return this.parseExprOpBaseRightExpr(op, prec);
      }
    };

    _proto.parseExprOpBaseRightExpr = function parseExprOpBaseRightExpr(op, prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec);
    };

    _proto.checkExponentialAfterUnary = function checkExponentialAfterUnary(node) {
      if (this.match(types$1.exponent)) {
        this.raise(node.argument.start, ErrorMessages.UnexpectedTokenUnaryExponentiation);
      }
    };

    _proto.parseMaybeUnary = function parseMaybeUnary(refExpressionErrors, sawUnary) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var isAwait = this.isContextual("await");

      if (isAwait && this.isAwaitAllowed()) {
        this.next();

        var _expr = this.parseAwait(startPos, startLoc);

        if (!sawUnary) this.checkExponentialAfterUnary(_expr);
        return _expr;
      }

      if (this.isContextual("module") && this.lookaheadCharCode() === 123 && !this.hasFollowingLineBreak()) {
        return this.parseModuleExpression();
      }

      var update = this.match(types$1.incDec);
      var node = this.startNode();

      if (this.state.type.prefix) {
        node.operator = this.state.value;
        node.prefix = true;

        if (this.match(types$1._throw)) {
          this.expectPlugin("throwExpressions");
        }

        var isDelete = this.match(types$1._delete);
        this.next();
        node.argument = this.parseMaybeUnary(null, true);
        this.checkExpressionErrors(refExpressionErrors, true);

        if (this.state.strict && isDelete) {
          var arg = node.argument;

          if (arg.type === "Identifier") {
            this.raise(node.start, ErrorMessages.StrictDelete);
          } else if (this.hasPropertyAsPrivateName(arg)) {
            this.raise(node.start, ErrorMessages.DeletePrivateField);
          }
        }

        if (!update) {
          if (!sawUnary) this.checkExponentialAfterUnary(node);
          return this.finishNode(node, "UnaryExpression");
        }
      }

      var expr = this.parseUpdate(node, update, refExpressionErrors);

      if (isAwait) {
        var startsExpr = this.hasPlugin("v8intrinsic") ? this.state.type.startsExpr : this.state.type.startsExpr && !this.match(types$1.modulo);

        if (startsExpr && !this.isAmbiguousAwait()) {
          this.raiseOverwrite(startPos, this.hasPlugin("topLevelAwait") ? ErrorMessages.AwaitNotInAsyncContext : ErrorMessages.AwaitNotInAsyncFunction);
          return this.parseAwait(startPos, startLoc);
        }
      }

      return expr;
    };

    _proto.parseUpdate = function parseUpdate(node, update, refExpressionErrors) {
      if (update) {
        this.checkLVal(node.argument, "prefix operation");
        return this.finishNode(node, "UpdateExpression");
      }

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var expr = this.parseExprSubscripts(refExpressionErrors);
      if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;

      while (this.state.type.postfix && !this.canInsertSemicolon()) {
        var _node = this.startNodeAt(startPos, startLoc);

        _node.operator = this.state.value;
        _node.prefix = false;
        _node.argument = expr;
        this.checkLVal(expr, "postfix operation");
        this.next();
        expr = this.finishNode(_node, "UpdateExpression");
      }

      return expr;
    };

    _proto.parseExprSubscripts = function parseExprSubscripts(refExpressionErrors) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var potentialArrowAt = this.state.potentialArrowAt;
      var expr = this.parseExprAtom(refExpressionErrors);

      if (this.shouldExitDescending(expr, potentialArrowAt)) {
        return expr;
      }

      return this.parseSubscripts(expr, startPos, startLoc);
    };

    _proto.parseSubscripts = function parseSubscripts(base, startPos, startLoc, noCalls) {
      var state = {
        optionalChainMember: false,
        maybeAsyncArrow: this.atPossibleAsyncArrow(base),
        stop: false
      };

      do {
        base = this.parseSubscript(base, startPos, startLoc, noCalls, state);
        state.maybeAsyncArrow = false;
      } while (!state.stop);

      return base;
    };

    _proto.parseSubscript = function parseSubscript(base, startPos, startLoc, noCalls, state) {
      if (!noCalls && this.eat(types$1.doubleColon)) {
        return this.parseBind(base, startPos, startLoc, noCalls, state);
      } else if (this.match(types$1.backQuote)) {
        return this.parseTaggedTemplateExpression(base, startPos, startLoc, state);
      }

      var optional = false;

      if (this.match(types$1.questionDot)) {
        if (noCalls && this.lookaheadCharCode() === 40) {
          state.stop = true;
          return base;
        }

        state.optionalChainMember = optional = true;
        this.next();
      }

      if (!noCalls && this.match(types$1.parenL)) {
        return this.parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional);
      } else if (optional || this.match(types$1.bracketL) || this.eat(types$1.dot)) {
        return this.parseMember(base, startPos, startLoc, state, optional);
      } else {
        state.stop = true;
        return base;
      }
    };

    _proto.parseMember = function parseMember(base, startPos, startLoc, state, optional) {
      var node = this.startNodeAt(startPos, startLoc);
      var computed = this.eat(types$1.bracketL);
      node.object = base;
      node.computed = computed;
      var privateName = !computed && this.match(types$1.privateName) && this.state.value;
      var property = computed ? this.parseExpression() : privateName ? this.parsePrivateName() : this.parseIdentifier(true);

      if (privateName !== false) {
        if (node.object.type === "Super") {
          this.raise(startPos, ErrorMessages.SuperPrivateField);
        }

        this.classScope.usePrivateName(privateName, property.start);
      }

      node.property = property;

      if (computed) {
        this.expect(types$1.bracketR);
      }

      if (state.optionalChainMember) {
        node.optional = optional;
        return this.finishNode(node, "OptionalMemberExpression");
      } else {
        return this.finishNode(node, "MemberExpression");
      }
    };

    _proto.parseBind = function parseBind(base, startPos, startLoc, noCalls, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      state.stop = true;
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    };

    _proto.parseCoverCallAndAsyncArrowHead = function parseCoverCallAndAsyncArrowHead(base, startPos, startLoc, state, optional) {
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var refExpressionErrors = null;
      this.state.maybeInArrowParameters = true;
      this.next();
      var node = this.startNodeAt(startPos, startLoc);
      node.callee = base;

      if (state.maybeAsyncArrow) {
        this.expressionScope.enter(newAsyncArrowScope());
        refExpressionErrors = new ExpressionErrors();
      }

      if (state.optionalChainMember) {
        node.optional = optional;
      }

      if (optional) {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR);
      } else {
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
      }

      this.finishCallExpression(node, state.optionalChainMember);

      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
        state.stop = true;
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);
      } else {
        if (state.maybeAsyncArrow) {
          this.checkExpressionErrors(refExpressionErrors, true);
          this.expressionScope.exit();
        }

        this.toReferencedArguments(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    };

    _proto.toReferencedArguments = function toReferencedArguments(node, isParenthesizedExpr) {
      this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
    };

    _proto.parseTaggedTemplateExpression = function parseTaggedTemplateExpression(base, startPos, startLoc, state) {
      var node = this.startNodeAt(startPos, startLoc);
      node.tag = base;
      node.quasi = this.parseTemplate(true);

      if (state.optionalChainMember) {
        this.raise(startPos, ErrorMessages.OptionalChainingNoTemplate);
      }

      return this.finishNode(node, "TaggedTemplateExpression");
    };

    _proto.atPossibleAsyncArrow = function atPossibleAsyncArrow(base) {
      return base.type === "Identifier" && base.name === "async" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
    };

    _proto.finishCallExpression = function finishCallExpression(node, optional) {
      if (node.callee.type === "Import") {
        if (node.arguments.length === 2) {
          {
            if (!this.hasPlugin("moduleAttributes")) {
              this.expectPlugin("importAssertions");
            }
          }
        }

        if (node.arguments.length === 0 || node.arguments.length > 2) {
          this.raise(node.start, ErrorMessages.ImportCallArity, this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? "one or two arguments" : "one argument");
        } else {
          for (var _i2 = 0, _node$arguments2 = node.arguments; _i2 < _node$arguments2.length; _i2++) {
            var arg = _node$arguments2[_i2];

            if (arg.type === "SpreadElement") {
              this.raise(arg.start, ErrorMessages.ImportCallSpreadArgument);
            }
          }
        }
      }

      return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
    };

    _proto.parseCallExpressionArguments = function parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
      var elts = [];
      var first = true;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (dynamicImport && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
              this.raise(this.state.lastTokStart, ErrorMessages.ImportCallArgumentTrailingComma);
            }

            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
      }

      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return elts;
    };

    _proto.shouldParseAsyncArrow = function shouldParseAsyncArrow() {
      return this.match(types$1.arrow) && !this.canInsertSemicolon();
    };

    _proto.parseAsyncArrowFromCallExpression = function parseAsyncArrowFromCallExpression(node, call) {
      var _call$extra;

      this.expect(types$1.arrow);
      this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);
      return node;
    };

    _proto.parseNoCallExpr = function parseNoCallExpr() {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
    };

    _proto.parseExprAtom = function parseExprAtom(refExpressionErrors) {
      var node;

      switch (this.state.type) {
        case types$1._super:
          return this.parseSuper();

        case types$1._import:
          node = this.startNode();
          this.next();

          if (this.match(types$1.dot)) {
            return this.parseImportMetaProperty(node);
          }

          if (!this.match(types$1.parenL)) {
            this.raise(this.state.lastTokStart, ErrorMessages.UnsupportedImport);
          }

          return this.finishNode(node, "Import");

        case types$1._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression");

        case types$1.name:
          {
            var canBeArrow = this.state.potentialArrowAt === this.state.start;
            var containsEsc = this.state.containsEsc;
            var id = this.parseIdentifier();

            if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
              if (this.match(types$1._function)) {
                this.next();
                return this.parseFunction(this.startNodeAtNode(id), undefined, true);
              } else if (this.match(types$1.name)) {
                if (this.lookaheadCharCode() === 61) {
                  return this.parseAsyncArrowUnaryFunction(id);
                } else {
                  return id;
                }
              } else if (this.match(types$1._do)) {
                return this.parseDo(true);
              }
            }

            if (canBeArrow && this.match(types$1.arrow) && !this.canInsertSemicolon()) {
              this.next();
              return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
            }

            return id;
          }

        case types$1._do:
          {
            return this.parseDo(false);
          }

        case types$1.slash:
        case types$1.slashAssign:
          {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }

        case types$1.num:
          return this.parseNumericLiteral(this.state.value);

        case types$1.bigint:
          return this.parseBigIntLiteral(this.state.value);

        case types$1.decimal:
          return this.parseDecimalLiteral(this.state.value);

        case types$1.string:
          return this.parseStringLiteral(this.state.value);

        case types$1._null:
          return this.parseNullLiteral();

        case types$1._true:
          return this.parseBooleanLiteral(true);

        case types$1._false:
          return this.parseBooleanLiteral(false);

        case types$1.parenL:
          {
            var _canBeArrow = this.state.potentialArrowAt === this.state.start;

            return this.parseParenAndDistinguishExpression(_canBeArrow);
          }

        case types$1.bracketBarL:
        case types$1.bracketHashL:
          {
            return this.parseArrayLike(this.state.type === types$1.bracketBarL ? types$1.bracketBarR : types$1.bracketR, false, true, refExpressionErrors);
          }

        case types$1.bracketL:
          {
            return this.parseArrayLike(types$1.bracketR, true, false, refExpressionErrors);
          }

        case types$1.braceBarL:
        case types$1.braceHashL:
          {
            return this.parseObjectLike(this.state.type === types$1.braceBarL ? types$1.braceBarR : types$1.braceR, false, true, refExpressionErrors);
          }

        case types$1.braceL:
          {
            return this.parseObjectLike(types$1.braceR, false, false, refExpressionErrors);
          }

        case types$1._function:
          return this.parseFunctionOrFunctionSent();

        case types$1.at:
          this.parseDecorators();

        case types$1._class:
          node = this.startNode();
          this.takeDecorators(node);
          return this.parseClass(node, false);

        case types$1._new:
          return this.parseNewOrNewTarget();

        case types$1.backQuote:
          return this.parseTemplate(false);

        case types$1.doubleColon:
          {
            node = this.startNode();
            this.next();
            node.object = null;
            var callee = node.callee = this.parseNoCallExpr();

            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(callee.start, ErrorMessages.UnsupportedBind);
            }
          }

        case types$1.privateName:
          {
            var start = this.state.start;
            var value = this.state.value;
            node = this.parsePrivateName();

            if (this.match(types$1._in)) {
              this.expectPlugin("privateIn");
              this.classScope.usePrivateName(value, node.start);
            } else if (this.hasPlugin("privateIn")) {
              this.raise(this.state.start, ErrorMessages.PrivateInExpectedIn, value);
            } else {
              throw this.unexpected(start);
            }

            return node;
          }

        case types$1.hash:
          {
            if (this.state.inPipeline) {
              node = this.startNode();

              if (this.getPluginOption("pipelineOperator", "proposal") !== "smart") {
                this.raise(node.start, ErrorMessages.PrimaryTopicRequiresSmartPipeline);
              }

              this.next();

              if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {
                this.raise(node.start, ErrorMessages.PrimaryTopicNotAllowed);
              }

              this.registerTopicReference();
              return this.finishNode(node, "PipelinePrimaryTopicReference");
            }
          }

        case types$1.relational:
          {
            if (this.state.value === "<") {
              var lookaheadCh = this.input.codePointAt(this.nextTokenStart());

              if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
                  this.expectOnePlugin(["jsx", "flow", "typescript"]);
                }
            }
          }

        default:
          throw this.unexpected();
      }
    };

    _proto.parseAsyncArrowUnaryFunction = function parseAsyncArrowUnaryFunction(id) {
      var node = this.startNodeAtNode(id);
      this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
      var params = [this.parseIdentifier()];
      this.prodParam.exit();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.pos, ErrorMessages.LineTerminatorBeforeArrow);
      }

      this.expect(types$1.arrow);
      this.parseArrowExpression(node, params, true);
      return node;
    };

    _proto.parseDo = function parseDo(isAsync) {
      this.expectPlugin("doExpressions");

      if (isAsync) {
        this.expectPlugin("asyncDoExpressions");
      }

      var node = this.startNode();
      node.async = isAsync;
      this.next();
      var oldLabels = this.state.labels;
      this.state.labels = [];

      if (isAsync) {
        this.prodParam.enter(PARAM_AWAIT);
        node.body = this.parseBlock();
        this.prodParam.exit();
      } else {
        node.body = this.parseBlock();
      }

      this.state.labels = oldLabels;
      return this.finishNode(node, "DoExpression");
    };

    _proto.parseSuper = function parseSuper() {
      var node = this.startNode();
      this.next();

      if (this.match(types$1.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.SuperNotAllowed);
      } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, ErrorMessages.UnexpectedSuper);
      }

      if (!this.match(types$1.parenL) && !this.match(types$1.bracketL) && !this.match(types$1.dot)) {
        this.raise(node.start, ErrorMessages.UnsupportedSuper);
      }

      return this.finishNode(node, "Super");
    };

    _proto.parseMaybePrivateName = function parseMaybePrivateName(isPrivateNameAllowed) {
      var isPrivate = this.match(types$1.privateName);

      if (isPrivate) {
        if (!isPrivateNameAllowed) {
          this.raise(this.state.start + 1, ErrorMessages.UnexpectedPrivateField);
        }

        return this.parsePrivateName();
      } else {
        return this.parseIdentifier(true);
      }
    };

    _proto.parsePrivateName = function parsePrivateName() {
      var node = this.startNode();
      var id = this.startNodeAt(this.state.start + 1, new Position(this.state.curLine, this.state.start + 1 - this.state.lineStart));
      var name = this.state.value;
      this.next();
      node.id = this.createIdentifier(id, name);
      return this.finishNode(node, "PrivateName");
    };

    _proto.parseFunctionOrFunctionSent = function parseFunctionOrFunctionSent() {
      var node = this.startNode();
      this.next();

      if (this.prodParam.hasYield && this.match(types$1.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "function");
        this.next();
        return this.parseMetaProperty(node, meta, "sent");
      }

      return this.parseFunction(node);
    };

    _proto.parseMetaProperty = function parseMetaProperty(node, meta, propertyName) {
      node.meta = meta;

      if (meta.name === "function" && propertyName === "sent") {
        if (this.isContextual(propertyName)) {
          this.expectPlugin("functionSent");
        } else if (!this.hasPlugin("functionSent")) {
          this.unexpected();
        }
      }

      var containsEsc = this.state.containsEsc;
      node.property = this.parseIdentifier(true);

      if (node.property.name !== propertyName || containsEsc) {
        this.raise(node.property.start, ErrorMessages.UnsupportedMetaProperty, meta.name, propertyName);
      }

      return this.finishNode(node, "MetaProperty");
    };

    _proto.parseImportMetaProperty = function parseImportMetaProperty(node) {
      var id = this.createIdentifier(this.startNodeAtNode(node), "import");
      this.next();

      if (this.isContextual("meta")) {
        if (!this.inModule) {
          this.raise(id.start, SourceTypeModuleErrorMessages.ImportMetaOutsideModule);
        }

        this.sawUnambiguousESM = true;
      }

      return this.parseMetaProperty(node, id, "meta");
    };

    _proto.parseLiteralAtNode = function parseLiteralAtNode(value, type, node) {
      this.addExtra(node, "rawValue", value);
      this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
      node.value = value;
      this.next();
      return this.finishNode(node, type);
    };

    _proto.parseLiteral = function parseLiteral(value, type) {
      var node = this.startNode();
      return this.parseLiteralAtNode(value, type, node);
    };

    _proto.parseStringLiteral = function parseStringLiteral(value) {
      return this.parseLiteral(value, "StringLiteral");
    };

    _proto.parseNumericLiteral = function parseNumericLiteral(value) {
      return this.parseLiteral(value, "NumericLiteral");
    };

    _proto.parseBigIntLiteral = function parseBigIntLiteral(value) {
      return this.parseLiteral(value, "BigIntLiteral");
    };

    _proto.parseDecimalLiteral = function parseDecimalLiteral(value) {
      return this.parseLiteral(value, "DecimalLiteral");
    };

    _proto.parseRegExpLiteral = function parseRegExpLiteral(value) {
      var node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;
    };

    _proto.parseBooleanLiteral = function parseBooleanLiteral(value) {
      var node = this.startNode();
      node.value = value;
      this.next();
      return this.finishNode(node, "BooleanLiteral");
    };

    _proto.parseNullLiteral = function parseNullLiteral() {
      var node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");
    };

    _proto.parseParenAndDistinguishExpression = function parseParenAndDistinguishExpression(canBeArrow) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      var val;
      this.next();
      this.expressionScope.enter(newArrowHeadScope());
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.maybeInArrowParameters = true;
      this.state.inFSharpPipelineDirectBody = false;
      var innerStartPos = this.state.start;
      var innerStartLoc = this.state.startLoc;
      var exprList = [];
      var refExpressionErrors = new ExpressionErrors();
      var first = true;
      var spreadStart;
      var optionalCommaStart;

      while (!this.match(types$1.parenR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma, refExpressionErrors.optionalParameters === -1 ? null : refExpressionErrors.optionalParameters);

          if (this.match(types$1.parenR)) {
            optionalCommaStart = this.state.start;
            break;
          }
        }

        if (this.match(types$1.ellipsis)) {
          var spreadNodeStartPos = this.state.start;
          var spreadNodeStartLoc = this.state.startLoc;
          spreadStart = this.state.start;
          exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));
          this.checkCommaAfterRest(41);
          break;
        } else {
          exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
        }
      }

      var innerEndPos = this.state.lastTokEnd;
      var innerEndLoc = this.state.lastTokEndLoc;
      this.expect(types$1.parenR);
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var arrowNode = this.startNodeAt(startPos, startLoc);

      if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
        this.expressionScope.validateAsPattern();
        this.expressionScope.exit();
        this.parseArrowExpression(arrowNode, exprList, false);
        return arrowNode;
      }

      this.expressionScope.exit();

      if (!exprList.length) {
        this.unexpected(this.state.lastTokStart);
      }

      if (optionalCommaStart) this.unexpected(optionalCommaStart);
      if (spreadStart) this.unexpected(spreadStart);
      this.checkExpressionErrors(refExpressionErrors, true);
      this.toReferencedListDeep(exprList, true);

      if (exprList.length > 1) {
        val = this.startNodeAt(innerStartPos, innerStartLoc);
        val.expressions = exprList;
        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
      } else {
        val = exprList[0];
      }

      if (!this.options.createParenthesizedExpressions) {
        this.addExtra(val, "parenthesized", true);
        this.addExtra(val, "parenStart", startPos);
        return val;
      }

      var parenExpression = this.startNodeAt(startPos, startLoc);
      parenExpression.expression = val;
      this.finishNode(parenExpression, "ParenthesizedExpression");
      return parenExpression;
    };

    _proto.shouldParseArrow = function shouldParseArrow() {
      return !this.canInsertSemicolon();
    };

    _proto.parseArrow = function parseArrow(node) {
      if (this.eat(types$1.arrow)) {
        return node;
      }
    };

    _proto.parseParenItem = function parseParenItem(node, startPos, startLoc) {
      return node;
    };

    _proto.parseNewOrNewTarget = function parseNewOrNewTarget() {
      var node = this.startNode();
      this.next();

      if (this.match(types$1.dot)) {
        var meta = this.createIdentifier(this.startNodeAtNode(node), "new");
        this.next();
        var metaProp = this.parseMetaProperty(node, meta, "target");

        if (!this.scope.inNonArrowFunction && !this.scope.inClass) {
          this.raise(metaProp.start, ErrorMessages.UnexpectedNewTarget);
        }

        return metaProp;
      }

      return this.parseNew(node);
    };

    _proto.parseNew = function parseNew(node) {
      node.callee = this.parseNoCallExpr();

      if (node.callee.type === "Import") {
        this.raise(node.callee.start, ErrorMessages.ImportCallNotNewExpression);
      } else if (this.isOptionalChain(node.callee)) {
        this.raise(this.state.lastTokEnd, ErrorMessages.OptionalChainingNoNew);
      } else if (this.eat(types$1.questionDot)) {
        this.raise(this.state.start, ErrorMessages.OptionalChainingNoNew);
      }

      this.parseNewArguments(node);
      return this.finishNode(node, "NewExpression");
    };

    _proto.parseNewArguments = function parseNewArguments(node) {
      if (this.eat(types$1.parenL)) {
        var args = this.parseExprList(types$1.parenR);
        this.toReferencedList(args);
        node.arguments = args;
      } else {
        node.arguments = [];
      }
    };

    _proto.parseTemplateElement = function parseTemplateElement(isTagged) {
      var elem = this.startNode();

      if (this.state.value === null) {
        if (!isTagged) {
          this.raise(this.state.start + 1, ErrorMessages.InvalidEscapeSequenceTemplate);
        }
      }

      elem.value = {
        raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
        cooked: this.state.value
      };
      this.next();
      elem.tail = this.match(types$1.backQuote);
      return this.finishNode(elem, "TemplateElement");
    };

    _proto.parseTemplate = function parseTemplate(isTagged) {
      var node = this.startNode();
      this.next();
      node.expressions = [];
      var curElt = this.parseTemplateElement(isTagged);
      node.quasis = [curElt];

      while (!curElt.tail) {
        this.expect(types$1.dollarBraceL);
        node.expressions.push(this.parseTemplateSubstitution());
        this.expect(types$1.braceR);
        node.quasis.push(curElt = this.parseTemplateElement(isTagged));
      }

      this.next();
      return this.finishNode(node, "TemplateLiteral");
    };

    _proto.parseTemplateSubstitution = function parseTemplateSubstitution() {
      return this.parseExpression();
    };

    _proto.parseObjectLike = function parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
      if (isRecord) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var propHash = Object.create(null);
      var first = true;
      var node = this.startNode();
      node.properties = [];
      this.next();

      while (!this.match(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            this.addExtra(node, "trailingComma", this.state.lastTokStart);
            break;
          }
        }

        var prop = this.parsePropertyDefinition(isPattern, refExpressionErrors);

        if (!isPattern) {
          this.checkProto(prop, isRecord, propHash, refExpressionErrors);
        }

        if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
          this.raise(prop.start, ErrorMessages.InvalidRecordProperty);
        }

        if (prop.shorthand) {
          this.addExtra(prop, "shorthand", true);
        }

        node.properties.push(prop);
      }

      this.next();
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      var type = "ObjectExpression";

      if (isPattern) {
        type = "ObjectPattern";
      } else if (isRecord) {
        type = "RecordExpression";
      }

      return this.finishNode(node, type);
    };

    _proto.maybeAsyncOrAccessorProp = function maybeAsyncOrAccessorProp(prop) {
      return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(types$1.bracketL) || this.match(types$1.star));
    };

    _proto.parsePropertyDefinition = function parsePropertyDefinition(isPattern, refExpressionErrors) {
      var decorators = [];

      if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators")) {
          this.raise(this.state.start, ErrorMessages.UnsupportedPropertyDecorator);
        }

        while (this.match(types$1.at)) {
          decorators.push(this.parseDecorator());
        }
      }

      var prop = this.startNode();
      var isGenerator = false;
      var isAsync = false;
      var isAccessor = false;
      var startPos;
      var startLoc;

      if (this.match(types$1.ellipsis)) {
        if (decorators.length) this.unexpected();

        if (isPattern) {
          this.next();
          prop.argument = this.parseIdentifier();
          this.checkCommaAfterRest(125);
          return this.finishNode(prop, "RestElement");
        }

        return this.parseSpread();
      }

      if (decorators.length) {
        prop.decorators = decorators;
        decorators = [];
      }

      prop.method = false;

      if (isPattern || refExpressionErrors) {
        startPos = this.state.start;
        startLoc = this.state.startLoc;
      }

      if (!isPattern) {
        isGenerator = this.eat(types$1.star);
      }

      var containsEsc = this.state.containsEsc;
      var key = this.parsePropertyName(prop, false);

      if (!isPattern && !isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
        var keyName = key.name;

        if (keyName === "async" && !this.hasPrecedingLineBreak()) {
          isAsync = true;
          isGenerator = this.eat(types$1.star);
          this.parsePropertyName(prop, false);
        }

        if (keyName === "get" || keyName === "set") {
          isAccessor = true;
          prop.kind = keyName;

          if (this.match(types$1.star)) {
            isGenerator = true;
            this.raise(this.state.pos, ErrorMessages.AccessorIsGenerator, keyName);
            this.next();
          }

          this.parsePropertyName(prop, false);
        }
      }

      this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      return prop;
    };

    _proto.getGetterSetterExpectedParamCount = function getGetterSetterExpectedParamCount(method) {
      return method.kind === "get" ? 0 : 1;
    };

    _proto.getObjectOrClassMethodParams = function getObjectOrClassMethodParams(method) {
      return method.params;
    };

    _proto.checkGetterSetterParams = function checkGetterSetterParams(method) {
      var _params;

      var paramCount = this.getGetterSetterExpectedParamCount(method);
      var params = this.getObjectOrClassMethodParams(method);
      var start = method.start;

      if (params.length !== paramCount) {
        if (method.kind === "get") {
          this.raise(start, ErrorMessages.BadGetterArity);
        } else {
          this.raise(start, ErrorMessages.BadSetterArity);
        }
      }

      if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
        this.raise(start, ErrorMessages.BadSetterRestParameter);
      }
    };

    _proto.parseObjectMethod = function parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
      if (isAccessor) {
        this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
        this.checkGetterSetterParams(prop);
        return prop;
      }

      if (isAsync || isGenerator || this.match(types$1.parenL)) {
        if (isPattern) this.unexpected();
        prop.kind = "method";
        prop.method = true;
        return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
      }
    };

    _proto.parseObjectProperty = function parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {
      prop.shorthand = false;

      if (this.eat(types$1.colon)) {
        prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
        return this.finishNode(prop, "ObjectProperty");
      }

      if (!prop.computed && prop.key.type === "Identifier") {
        this.checkReservedWord(prop.key.name, prop.key.start, true, false);

        if (isPattern) {
          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else if (this.match(types$1.eq) && refExpressionErrors) {
          if (refExpressionErrors.shorthandAssign === -1) {
            refExpressionErrors.shorthandAssign = this.state.start;
          }

          prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
        } else {
          prop.value = prop.key.__clone();
        }

        prop.shorthand = true;
        return this.finishNode(prop, "ObjectProperty");
      }
    };

    _proto.parseObjPropValue = function parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
      var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);
      if (!node) this.unexpected();
      return node;
    };

    _proto.parsePropertyName = function parsePropertyName(prop, isPrivateNameAllowed) {
      if (this.eat(types$1.bracketL)) {
        prop.computed = true;
        prop.key = this.parseMaybeAssignAllowIn();
        this.expect(types$1.bracketR);
      } else {
        var oldInPropertyName = this.state.inPropertyName;
        this.state.inPropertyName = true;
        var type = this.state.type;
        prop.key = type === types$1.num || type === types$1.string || type === types$1.bigint || type === types$1.decimal ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);

        if (type !== types$1.privateName) {
          prop.computed = false;
        }

        this.state.inPropertyName = oldInPropertyName;
      }

      return prop.key;
    };

    _proto.initFunction = function initFunction(node, isAsync) {
      node.id = null;
      node.generator = false;
      node.async = !!isAsync;
    };

    _proto.parseMethod = function parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
      if (inClassScope === void 0) {
        inClassScope = false;
      }

      this.initFunction(node, isAsync);
      node.generator = !!isGenerator;
      var allowModifiers = isConstructor;
      this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
      this.prodParam.enter(functionFlags(isAsync, node.generator));
      this.parseFunctionParams(node, allowModifiers);
      this.parseFunctionBodyAndFinish(node, type, true);
      this.prodParam.exit();
      this.scope.exit();
      return node;
    };

    _proto.parseArrayLike = function parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
      if (isTuple) {
        this.expectPlugin("recordAndTuple");
      }

      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = false;
      var node = this.startNode();
      this.next();
      node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
    };

    _proto.parseArrowExpression = function parseArrowExpression(node, params, isAsync, trailingCommaPos) {
      this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);
      var flags = functionFlags(isAsync, false);

      if (!this.match(types$1.bracketL) && this.prodParam.hasIn) {
        flags |= PARAM_IN;
      }

      this.prodParam.enter(flags);
      this.initFunction(node, isAsync);
      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;

      if (params) {
        this.state.maybeInArrowParameters = true;
        this.setArrowFunctionParameters(node, params, trailingCommaPos);
      }

      this.state.maybeInArrowParameters = false;
      this.parseFunctionBody(node, true);
      this.prodParam.exit();
      this.scope.exit();
      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return this.finishNode(node, "ArrowFunctionExpression");
    };

    _proto.setArrowFunctionParameters = function setArrowFunctionParameters(node, params, trailingCommaPos) {
      node.params = this.toAssignableList(params, trailingCommaPos, false);
    };

    _proto.parseFunctionBodyAndFinish = function parseFunctionBodyAndFinish(node, type, isMethod) {
      if (isMethod === void 0) {
        isMethod = false;
      }

      this.parseFunctionBody(node, false, isMethod);
      this.finishNode(node, type);
    };

    _proto.parseFunctionBody = function parseFunctionBody(node, allowExpression, isMethod) {
      var _this5 = this;

      if (isMethod === void 0) {
        isMethod = false;
      }

      var isExpression = allowExpression && !this.match(types$1.braceL);
      this.expressionScope.enter(newExpressionScope());

      if (isExpression) {
        node.body = this.parseMaybeAssign();
        this.checkParams(node, false, allowExpression, false);
      } else {
        var oldStrict = this.state.strict;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);
        node.body = this.parseBlock(true, false, function (hasStrictModeDirective) {
          var nonSimple = !_this5.isSimpleParamList(node.params);

          if (hasStrictModeDirective && nonSimple) {
            var errorPos = (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.end : node.start;

            _this5.raise(errorPos, ErrorMessages.IllegalLanguageModeDirective);
          }

          var strictModeChanged = !oldStrict && _this5.state.strict;

          _this5.checkParams(node, !_this5.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);

          if (_this5.state.strict && node.id) {
            _this5.checkLVal(node.id, "function name", BIND_OUTSIDE, undefined, undefined, strictModeChanged);
          }
        });
        this.prodParam.exit();
        this.expressionScope.exit();
        this.state.labels = oldLabels;
      }
    };

    _proto.isSimpleParamList = function isSimpleParamList(params) {
      for (var i = 0, len = params.length; i < len; i++) {
        if (params[i].type !== "Identifier") return false;
      }

      return true;
    };

    _proto.checkParams = function checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged) {
      if (strictModeChanged === void 0) {
        strictModeChanged = true;
      }

      var checkClashes = new Set();

      for (var _i4 = 0, _node$params2 = node.params; _i4 < _node$params2.length; _i4++) {
        var param = _node$params2[_i4];
        this.checkLVal(param, "function parameter list", BIND_VAR, allowDuplicates ? null : checkClashes, undefined, strictModeChanged);
      }
    };

    _proto.parseExprList = function parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
      var elts = [];
      var first = true;

      while (!this.eat(close)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);

          if (this.match(close)) {
            if (nodeForExtra) {
              this.addExtra(nodeForExtra, "trailingComma", this.state.lastTokStart);
            }

            this.next();
            break;
          }
        }

        elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
      }

      return elts;
    };

    _proto.parseExprListItem = function parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
      var elt;

      if (this.match(types$1.comma)) {
        if (!allowEmpty) {
          this.raise(this.state.pos, ErrorMessages.UnexpectedToken, ",");
        }

        elt = null;
      } else if (this.match(types$1.ellipsis)) {
        var spreadNodeStartPos = this.state.start;
        var spreadNodeStartLoc = this.state.startLoc;
        elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartPos, spreadNodeStartLoc);
      } else if (this.match(types$1.question)) {
        this.expectPlugin("partialApplication");

        if (!allowPlaceholder) {
          this.raise(this.state.start, ErrorMessages.UnexpectedArgumentPlaceholder);
        }

        var node = this.startNode();
        this.next();
        elt = this.finishNode(node, "ArgumentPlaceholder");
      } else {
        elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
      }

      return elt;
    };

    _proto.parseIdentifier = function parseIdentifier(liberal) {
      var node = this.startNode();
      var name = this.parseIdentifierName(node.start, liberal);
      return this.createIdentifier(node, name);
    };

    _proto.createIdentifier = function createIdentifier(node, name) {
      node.name = name;
      node.loc.identifierName = name;
      return this.finishNode(node, "Identifier");
    };

    _proto.parseIdentifierName = function parseIdentifierName(pos, liberal) {
      var name;
      var _this$state = this.state,
          start = _this$state.start,
          type = _this$state.type;

      if (type === types$1.name) {
        name = this.state.value;
      } else if (type.keyword) {
        name = type.keyword;
      } else {
        throw this.unexpected();
      }

      if (liberal) {
        this.state.type = types$1.name;
      } else {
        this.checkReservedWord(name, start, !!type.keyword, false);
      }

      this.next();
      return name;
    };

    _proto.checkReservedWord = function checkReservedWord(word, startLoc, checkKeywords, isBinding) {
      if (word.length > 10) {
        return;
      }

      if (!canBeReservedWord(word)) {
        return;
      }

      if (word === "yield") {
        if (this.prodParam.hasYield) {
          this.raise(startLoc, ErrorMessages.YieldBindingIdentifier);
          return;
        }
      } else if (word === "await") {
        if (this.prodParam.hasAwait) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifier);
          return;
        } else if (this.scope.inStaticBlock && !this.scope.inNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.AwaitBindingIdentifierInStaticBlock);
          return;
        } else {
          this.expressionScope.recordAsyncArrowParametersError(startLoc, ErrorMessages.AwaitBindingIdentifier);
        }
      } else if (word === "arguments") {
        if (this.scope.inClassAndNotInNonArrowFunction) {
          this.raise(startLoc, ErrorMessages.ArgumentsInClass);
          return;
        }
      }

      if (checkKeywords && isKeyword(word)) {
        this.raise(startLoc, ErrorMessages.UnexpectedKeyword, word);
        return;
      }

      var reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;

      if (reservedTest(word, this.inModule)) {
        this.raise(startLoc, ErrorMessages.UnexpectedReservedWord, word);
      }
    };

    _proto.isAwaitAllowed = function isAwaitAllowed() {
      if (this.prodParam.hasAwait) return true;

      if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
        return true;
      }

      return false;
    };

    _proto.parseAwait = function parseAwait(startPos, startLoc) {
      var node = this.startNodeAt(startPos, startLoc);
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.AwaitExpressionFormalParameter);

      if (this.eat(types$1.star)) {
        this.raise(node.start, ErrorMessages.ObsoleteAwaitStar);
      }

      if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
        if (this.isAmbiguousAwait()) {
          this.ambiguousScriptDifferentAst = true;
        } else {
          this.sawUnambiguousESM = true;
        }
      }

      if (!this.state.soloAwait) {
        node.argument = this.parseMaybeUnary(null, true);
      }

      return this.finishNode(node, "AwaitExpression");
    };

    _proto.isAmbiguousAwait = function isAmbiguousAwait() {
      return this.hasPrecedingLineBreak() || this.match(types$1.plusMin) || this.match(types$1.parenL) || this.match(types$1.bracketL) || this.match(types$1.backQuote) || this.match(types$1.regexp) || this.match(types$1.slash) || this.hasPlugin("v8intrinsic") && this.match(types$1.modulo);
    };

    _proto.parseYield = function parseYield() {
      var node = this.startNode();
      this.expressionScope.recordParameterInitializerError(node.start, ErrorMessages.YieldInParameter);
      this.next();
      var delegating = false;
      var argument = null;

      if (!this.hasPrecedingLineBreak()) {
        delegating = this.eat(types$1.star);

        switch (this.state.type) {
          case types$1.semi:
          case types$1.eof:
          case types$1.braceR:
          case types$1.parenR:
          case types$1.bracketR:
          case types$1.braceBarR:
          case types$1.colon:
          case types$1.comma:
            if (!delegating) break;

          default:
            argument = this.parseMaybeAssign();
        }
      }

      node.delegate = delegating;
      node.argument = argument;
      return this.finishNode(node, "YieldExpression");
    };

    _proto.checkPipelineAtInfixOperator = function checkPipelineAtInfixOperator(left, leftStartPos) {
      if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
        if (left.type === "SequenceExpression") {
          this.raise(leftStartPos, ErrorMessages.PipelineHeadSequenceExpression);
        }
      }
    };

    _proto.parseSmartPipelineBody = function parseSmartPipelineBody(childExpression, startPos, startLoc) {
      this.checkSmartPipelineBodyEarlyErrors(childExpression, startPos);
      return this.parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc);
    };

    _proto.checkSmartPipelineBodyEarlyErrors = function checkSmartPipelineBodyEarlyErrors(childExpression, startPos) {
      if (this.match(types$1.arrow)) {
        throw this.raise(this.state.start, ErrorMessages.PipelineBodyNoArrow);
      } else if (childExpression.type === "SequenceExpression") {
        this.raise(startPos, ErrorMessages.PipelineBodySequenceExpression);
      }
    };

    _proto.parseSmartPipelineBodyInStyle = function parseSmartPipelineBodyInStyle(childExpression, startPos, startLoc) {
      var bodyNode = this.startNodeAt(startPos, startLoc);
      var isSimpleReference = this.isSimpleReference(childExpression);

      if (isSimpleReference) {
        bodyNode.callee = childExpression;
      } else {
        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {
          this.raise(startPos, ErrorMessages.PipelineTopicUnused);
        }

        bodyNode.expression = childExpression;
      }

      return this.finishNode(bodyNode, isSimpleReference ? "PipelineBareFunction" : "PipelineTopicExpression");
    };

    _proto.isSimpleReference = function isSimpleReference(expression) {
      switch (expression.type) {
        case "MemberExpression":
          return !expression.computed && this.isSimpleReference(expression.object);

        case "Identifier":
          return true;

        default:
          return false;
      }
    };

    _proto.withTopicPermittingContext = function withTopicPermittingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 1,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withTopicForbiddingContext = function withTopicForbiddingContext(callback) {
      var outerContextTopicState = this.state.topicContext;
      this.state.topicContext = {
        maxNumOfResolvableTopics: 0,
        maxTopicIndex: null
      };

      try {
        return callback();
      } finally {
        this.state.topicContext = outerContextTopicState;
      }
    };

    _proto.withSoloAwaitPermittingContext = function withSoloAwaitPermittingContext(callback) {
      var outerContextSoloAwaitState = this.state.soloAwait;
      this.state.soloAwait = true;

      try {
        return callback();
      } finally {
        this.state.soloAwait = outerContextSoloAwaitState;
      }
    };

    _proto.allowInAnd = function allowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToSet = PARAM_IN & ~flags;

      if (prodParamToSet) {
        this.prodParam.enter(flags | PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    };

    _proto.disallowInAnd = function disallowInAnd(callback) {
      var flags = this.prodParam.currentFlags();
      var prodParamToClear = PARAM_IN & flags;

      if (prodParamToClear) {
        this.prodParam.enter(flags & ~PARAM_IN);

        try {
          return callback();
        } finally {
          this.prodParam.exit();
        }
      }

      return callback();
    };

    _proto.registerTopicReference = function registerTopicReference() {
      this.state.topicContext.maxTopicIndex = 0;
    };

    _proto.primaryTopicReferenceIsAllowedInCurrentTopicContext = function primaryTopicReferenceIsAllowedInCurrentTopicContext() {
      return this.state.topicContext.maxNumOfResolvableTopics >= 1;
    };

    _proto.topicReferenceWasUsedInCurrentTopicContext = function topicReferenceWasUsedInCurrentTopicContext() {
      return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
    };

    _proto.parseFSharpPipelineBody = function parseFSharpPipelineBody(prec) {
      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      this.state.potentialArrowAt = this.state.start;
      var oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
      this.state.inFSharpPipelineDirectBody = true;
      var ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec);
      this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
      return ret;
    };

    _proto.parseModuleExpression = function parseModuleExpression() {
      this.expectPlugin("moduleBlocks");
      var node = this.startNode();
      this.next();
      this.eat(types$1.braceL);
      var revertScopes = this.initializeScopes(true);
      this.enterInitialScopes();
      var program = this.startNode();

      try {
        node.body = this.parseProgram(program, types$1.braceR, "module");
      } finally {
        revertScopes();
      }

      this.eat(types$1.braceR);
      return this.finishNode(node, "ModuleExpression");
    };

    return ExpressionParser;
  }(LValParser);

  var loopLabel = {
    kind: "loop"
  },
      switchLabel = {
    kind: "switch"
  };
  var FUNC_NO_FLAGS = 0,
      FUNC_STATEMENT = 1,
      FUNC_HANGING_STATEMENT = 2,
      FUNC_NULLABLE_ID = 4;
  var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
  var keywordRelationalOperator = new RegExp("in(?:stanceof)?", "y");

  function babel7CompatTokens(tokens) {
    {
      for (var i = 0; i < tokens.length; i++) {
        var token = tokens[i];

        if (token.type === types$1.privateName) {
          var loc = token.loc,
              start = token.start,
              value = token.value,
              end = token.end;
          var hashEndPos = start + 1;
          var hashEndLoc = new Position(loc.start.line, loc.start.column + 1);
          tokens.splice(i, 1, new Token({
            type: types$1.hash,
            value: "#",
            start: start,
            end: hashEndPos,
            startLoc: loc.start,
            endLoc: hashEndLoc
          }), new Token({
            type: types$1.name,
            value: value,
            start: hashEndPos,
            end: end,
            startLoc: hashEndLoc,
            endLoc: loc.end
          }));
        }
      }
    }
    return tokens;
  }

  var StatementParser = function (_ExpressionParser) {
    _inherits(StatementParser, _ExpressionParser);

    function StatementParser() {
      return _ExpressionParser.apply(this, arguments) || this;
    }

    var _proto = StatementParser.prototype;

    _proto.parseTopLevel = function parseTopLevel(file, program) {
      file.program = this.parseProgram(program);
      file.comments = this.state.comments;
      if (this.options.tokens) file.tokens = babel7CompatTokens(this.tokens);
      return this.finishNode(file, "File");
    };

    _proto.parseProgram = function parseProgram(program, end, sourceType) {
      if (end === void 0) {
        end = types$1.eof;
      }

      if (sourceType === void 0) {
        sourceType = this.options.sourceType;
      }

      program.sourceType = sourceType;
      program.interpreter = this.parseInterpreterDirective();
      this.parseBlockBody(program, true, true, end);

      if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
        for (var _i2 = 0, _Array$from2 = Array.from(this.scope.undefinedExports); _i2 < _Array$from2.length; _i2++) {
          var _Array$from2$_i = _Array$from2[_i2],
              name = _Array$from2$_i[0];
          var pos = this.scope.undefinedExports.get(name);
          this.raise(pos, ErrorMessages.ModuleExportUndefined, name);
        }
      }

      return this.finishNode(program, "Program");
    };

    _proto.stmtToDirective = function stmtToDirective(stmt) {
      var expr = stmt.expression;
      var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
      var directive = this.startNodeAt(stmt.start, stmt.loc.start);
      var raw = this.input.slice(expr.start, expr.end);
      var val = directiveLiteral.value = raw.slice(1, -1);
      this.addExtra(directiveLiteral, "raw", raw);
      this.addExtra(directiveLiteral, "rawValue", val);
      directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);
      return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
    };

    _proto.parseInterpreterDirective = function parseInterpreterDirective() {
      if (!this.match(types$1.interpreterDirective)) {
        return null;
      }

      var node = this.startNode();
      node.value = this.state.value;
      this.next();
      return this.finishNode(node, "InterpreterDirective");
    };

    _proto.isLet = function isLet(context) {
      if (!this.isContextual("let")) {
        return false;
      }

      return this.isLetKeyword(context);
    };

    _proto.isLetKeyword = function isLetKeyword(context) {
      var next = this.nextTokenStart();
      var nextCh = this.codePointAtPos(next);

      if (nextCh === 92 || nextCh === 91) {
        return true;
      }

      if (context) return false;
      if (nextCh === 123) return true;

      if (isIdentifierStart(nextCh)) {
        keywordRelationalOperator.lastIndex = next;
        var matched = keywordRelationalOperator.exec(this.input);

        if (matched !== null) {
          var endCh = this.codePointAtPos(next + matched[0].length);

          if (!isIdentifierChar(endCh) && endCh !== 92) {
            return false;
          }
        }

        return true;
      }

      return false;
    };

    _proto.parseStatement = function parseStatement(context, topLevel) {
      if (this.match(types$1.at)) {
        this.parseDecorators(true);
      }

      return this.parseStatementContent(context, topLevel);
    };

    _proto.parseStatementContent = function parseStatementContent(context, topLevel) {
      var starttype = this.state.type;
      var node = this.startNode();
      var kind;

      if (this.isLet(context)) {
        starttype = types$1._var;
        kind = "let";
      }

      switch (starttype) {
        case types$1._break:
        case types$1._continue:
          return this.parseBreakContinueStatement(node, starttype.keyword);

        case types$1._debugger:
          return this.parseDebuggerStatement(node);

        case types$1._do:
          return this.parseDoStatement(node);

        case types$1._for:
          return this.parseForStatement(node);

        case types$1._function:
          if (this.lookaheadCharCode() === 46) break;

          if (context) {
            if (this.state.strict) {
              this.raise(this.state.start, ErrorMessages.StrictFunction);
            } else if (context !== "if" && context !== "label") {
              this.raise(this.state.start, ErrorMessages.SloppyFunction);
            }
          }

          return this.parseFunctionStatement(node, false, !context);

        case types$1._class:
          if (context) this.unexpected();
          return this.parseClass(node, true);

        case types$1._if:
          return this.parseIfStatement(node);

        case types$1._return:
          return this.parseReturnStatement(node);

        case types$1._switch:
          return this.parseSwitchStatement(node);

        case types$1._throw:
          return this.parseThrowStatement(node);

        case types$1._try:
          return this.parseTryStatement(node);

        case types$1._const:
        case types$1._var:
          kind = kind || this.state.value;

          if (context && kind !== "var") {
            this.raise(this.state.start, ErrorMessages.UnexpectedLexicalDeclaration);
          }

          return this.parseVarStatement(node, kind);

        case types$1._while:
          return this.parseWhileStatement(node);

        case types$1._with:
          return this.parseWithStatement(node);

        case types$1.braceL:
          return this.parseBlock();

        case types$1.semi:
          return this.parseEmptyStatement(node);

        case types$1._import:
          {
            var nextTokenCharCode = this.lookaheadCharCode();

            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
                break;
              }
          }

        case types$1._export:
          {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(this.state.start, ErrorMessages.UnexpectedImportExport);
            }

            this.next();
            var result;

            if (starttype === types$1._import) {
              result = this.parseImport(node);

              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node);

              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }

            this.assertModuleNodeAllowed(node);
            return result;
          }

        default:
          {
            if (this.isAsyncFunction()) {
              if (context) {
                this.raise(this.state.start, ErrorMessages.AsyncFunctionInSingleStatementContext);
              }

              this.next();
              return this.parseFunctionStatement(node, true, !context);
            }
          }
      }

      var maybeName = this.state.value;
      var expr = this.parseExpression();

      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
    };

    _proto.assertModuleNodeAllowed = function assertModuleNodeAllowed(node) {
      if (!this.options.allowImportExportEverywhere && !this.inModule) {
        this.raise(node.start, SourceTypeModuleErrorMessages.ImportOutsideModule);
      }
    };

    _proto.takeDecorators = function takeDecorators(node) {
      var decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (decorators.length) {
        node.decorators = decorators;
        this.resetStartLocationFromNode(node, decorators[0]);
        this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];
      }
    };

    _proto.canHaveLeadingDecorator = function canHaveLeadingDecorator() {
      return this.match(types$1._class);
    };

    _proto.parseDecorators = function parseDecorators(allowExport) {
      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      while (this.match(types$1.at)) {
        var decorator = this.parseDecorator();
        currentContextDecorators.push(decorator);
      }

      if (this.match(types$1._export)) {
        if (!allowExport) {
          this.unexpected();
        }

        if (this.hasPlugin("decorators") && !this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorExportClass);
        }
      } else if (!this.canHaveLeadingDecorator()) {
        throw this.raise(this.state.start, ErrorMessages.UnexpectedLeadingDecorator);
      }
    };

    _proto.parseDecorator = function parseDecorator() {
      this.expectOnePlugin(["decorators-legacy", "decorators"]);
      var node = this.startNode();
      this.next();

      if (this.hasPlugin("decorators")) {
        this.state.decoratorStack.push([]);
        var startPos = this.state.start;
        var startLoc = this.state.startLoc;
        var expr;

        if (this.eat(types$1.parenL)) {
          expr = this.parseExpression();
          this.expect(types$1.parenR);
        } else {
          expr = this.parseIdentifier(false);

          while (this.eat(types$1.dot)) {
            var _node = this.startNodeAt(startPos, startLoc);

            _node.object = expr;
            _node.property = this.parseIdentifier(true);
            _node.computed = false;
            expr = this.finishNode(_node, "MemberExpression");
          }
        }

        node.expression = this.parseMaybeDecoratorArguments(expr);
        this.state.decoratorStack.pop();
      } else {
        node.expression = this.parseExprSubscripts();
      }

      return this.finishNode(node, "Decorator");
    };

    _proto.parseMaybeDecoratorArguments = function parseMaybeDecoratorArguments(expr) {
      if (this.eat(types$1.parenL)) {
        var node = this.startNodeAtNode(expr);
        node.callee = expr;
        node.arguments = this.parseCallExpressionArguments(types$1.parenR, false);
        this.toReferencedList(node.arguments);
        return this.finishNode(node, "CallExpression");
      }

      return expr;
    };

    _proto.parseBreakContinueStatement = function parseBreakContinueStatement(node, keyword) {
      var isBreak = keyword === "break";
      this.next();

      if (this.isLineTerminator()) {
        node.label = null;
      } else {
        node.label = this.parseIdentifier();
        this.semicolon();
      }

      this.verifyBreakContinue(node, keyword);
      return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
    };

    _proto.verifyBreakContinue = function verifyBreakContinue(node, keyword) {
      var isBreak = keyword === "break";
      var i;

      for (i = 0; i < this.state.labels.length; ++i) {
        var lab = this.state.labels[i];

        if (node.label == null || lab.name === node.label.name) {
          if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
          if (node.label && isBreak) break;
        }
      }

      if (i === this.state.labels.length) {
        this.raise(node.start, ErrorMessages.IllegalBreakContinue, keyword);
      }
    };

    _proto.parseDebuggerStatement = function parseDebuggerStatement(node) {
      this.next();
      this.semicolon();
      return this.finishNode(node, "DebuggerStatement");
    };

    _proto.parseHeaderExpression = function parseHeaderExpression() {
      this.expect(types$1.parenL);
      var val = this.parseExpression();
      this.expect(types$1.parenR);
      return val;
    };

    _proto.parseDoStatement = function parseDoStatement(node) {
      var _this = this;

      this.next();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this.parseStatement("do");
      });
      this.state.labels.pop();
      this.expect(types$1._while);
      node.test = this.parseHeaderExpression();
      this.eat(types$1.semi);
      return this.finishNode(node, "DoWhileStatement");
    };

    _proto.parseForStatement = function parseForStatement(node) {
      this.next();
      this.state.labels.push(loopLabel);
      var awaitAt = -1;

      if (this.isAwaitAllowed() && this.eatContextual("await")) {
        awaitAt = this.state.lastTokStart;
      }

      this.scope.enter(SCOPE_OTHER);
      this.expect(types$1.parenL);

      if (this.match(types$1.semi)) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, null);
      }

      var startsWithLet = this.isContextual("let");
      var isLet = startsWithLet && this.isLetKeyword();

      if (this.match(types$1._var) || this.match(types$1._const) || isLet) {
        var _init = this.startNode();

        var kind = isLet ? "let" : this.state.value;
        this.next();
        this.parseVar(_init, true, kind);
        this.finishNode(_init, "VariableDeclaration");

        if ((this.match(types$1._in) || this.isContextual("of")) && _init.declarations.length === 1) {
          return this.parseForIn(node, _init, awaitAt);
        }

        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }

        return this.parseFor(node, _init);
      }

      var startsWithUnescapedName = this.match(types$1.name) && !this.state.containsEsc;
      var refExpressionErrors = new ExpressionErrors();
      var init = this.parseExpression(true, refExpressionErrors);
      var isForOf = this.isContextual("of");

      if (isForOf) {
        if (startsWithLet) {
          this.raise(init.start, ErrorMessages.ForOfLet);
        } else if (awaitAt === -1 && startsWithUnescapedName && init.type === "Identifier" && init.name === "async") {
          this.raise(init.start, ErrorMessages.ForOfAsync);
        }
      }

      if (isForOf || this.match(types$1._in)) {
        this.toAssignable(init, true);
        var description = isForOf ? "for-of statement" : "for-in statement";
        this.checkLVal(init, description);
        return this.parseForIn(node, init, awaitAt);
      } else {
        this.checkExpressionErrors(refExpressionErrors, true);
      }

      if (awaitAt > -1) {
        this.unexpected(awaitAt);
      }

      return this.parseFor(node, init);
    };

    _proto.parseFunctionStatement = function parseFunctionStatement(node, isAsync, declarationPosition) {
      this.next();
      return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);
    };

    _proto.parseIfStatement = function parseIfStatement(node) {
      this.next();
      node.test = this.parseHeaderExpression();
      node.consequent = this.parseStatement("if");
      node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
      return this.finishNode(node, "IfStatement");
    };

    _proto.parseReturnStatement = function parseReturnStatement(node) {
      if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
        this.raise(this.state.start, ErrorMessages.IllegalReturn);
      }

      this.next();

      if (this.isLineTerminator()) {
        node.argument = null;
      } else {
        node.argument = this.parseExpression();
        this.semicolon();
      }

      return this.finishNode(node, "ReturnStatement");
    };

    _proto.parseSwitchStatement = function parseSwitchStatement(node) {
      this.next();
      node.discriminant = this.parseHeaderExpression();
      var cases = node.cases = [];
      this.expect(types$1.braceL);
      this.state.labels.push(switchLabel);
      this.scope.enter(SCOPE_OTHER);
      var cur;

      for (var sawDefault; !this.match(types$1.braceR);) {
        if (this.match(types$1._case) || this.match(types$1._default)) {
          var isCase = this.match(types$1._case);
          if (cur) this.finishNode(cur, "SwitchCase");
          cases.push(cur = this.startNode());
          cur.consequent = [];
          this.next();

          if (isCase) {
            cur.test = this.parseExpression();
          } else {
            if (sawDefault) {
              this.raise(this.state.lastTokStart, ErrorMessages.MultipleDefaultsInSwitch);
            }

            sawDefault = true;
            cur.test = null;
          }

          this.expect(types$1.colon);
        } else {
          if (cur) {
            cur.consequent.push(this.parseStatement(null));
          } else {
            this.unexpected();
          }
        }
      }

      this.scope.exit();
      if (cur) this.finishNode(cur, "SwitchCase");
      this.next();
      this.state.labels.pop();
      return this.finishNode(node, "SwitchStatement");
    };

    _proto.parseThrowStatement = function parseThrowStatement(node) {
      this.next();

      if (this.hasPrecedingLineBreak()) {
        this.raise(this.state.lastTokEnd, ErrorMessages.NewlineAfterThrow);
      }

      node.argument = this.parseExpression();
      this.semicolon();
      return this.finishNode(node, "ThrowStatement");
    };

    _proto.parseCatchClauseParam = function parseCatchClauseParam() {
      var param = this.parseBindingAtom();
      var simple = param.type === "Identifier";
      this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);
      this.checkLVal(param, "catch clause", BIND_LEXICAL);
      return param;
    };

    _proto.parseTryStatement = function parseTryStatement(node) {
      var _this2 = this;

      this.next();
      node.block = this.parseBlock();
      node.handler = null;

      if (this.match(types$1._catch)) {
        var clause = this.startNode();
        this.next();

        if (this.match(types$1.parenL)) {
          this.expect(types$1.parenL);
          clause.param = this.parseCatchClauseParam();
          this.expect(types$1.parenR);
        } else {
          clause.param = null;
          this.scope.enter(SCOPE_OTHER);
        }

        clause.body = this.withTopicForbiddingContext(function () {
          return _this2.parseBlock(false, false);
        });
        this.scope.exit();
        node.handler = this.finishNode(clause, "CatchClause");
      }

      node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;

      if (!node.handler && !node.finalizer) {
        this.raise(node.start, ErrorMessages.NoCatchOrFinally);
      }

      return this.finishNode(node, "TryStatement");
    };

    _proto.parseVarStatement = function parseVarStatement(node, kind) {
      this.next();
      this.parseVar(node, false, kind);
      this.semicolon();
      return this.finishNode(node, "VariableDeclaration");
    };

    _proto.parseWhileStatement = function parseWhileStatement(node) {
      var _this3 = this;

      this.next();
      node.test = this.parseHeaderExpression();
      this.state.labels.push(loopLabel);
      node.body = this.withTopicForbiddingContext(function () {
        return _this3.parseStatement("while");
      });
      this.state.labels.pop();
      return this.finishNode(node, "WhileStatement");
    };

    _proto.parseWithStatement = function parseWithStatement(node) {
      var _this4 = this;

      if (this.state.strict) {
        this.raise(this.state.start, ErrorMessages.StrictWith);
      }

      this.next();
      node.object = this.parseHeaderExpression();
      node.body = this.withTopicForbiddingContext(function () {
        return _this4.parseStatement("with");
      });
      return this.finishNode(node, "WithStatement");
    };

    _proto.parseEmptyStatement = function parseEmptyStatement(node) {
      this.next();
      return this.finishNode(node, "EmptyStatement");
    };

    _proto.parseLabeledStatement = function parseLabeledStatement(node, maybeName, expr, context) {
      for (var _i4 = 0, _this$state$labels2 = this.state.labels; _i4 < _this$state$labels2.length; _i4++) {
        var label = _this$state$labels2[_i4];

        if (label.name === maybeName) {
          this.raise(expr.start, ErrorMessages.LabelRedeclaration, maybeName);
        }
      }

      var kind = this.state.type.isLoop ? "loop" : this.match(types$1._switch) ? "switch" : null;

      for (var i = this.state.labels.length - 1; i >= 0; i--) {
        var _label = this.state.labels[i];

        if (_label.statementStart === node.start) {
          _label.statementStart = this.state.start;
          _label.kind = kind;
        } else {
          break;
        }
      }

      this.state.labels.push({
        name: maybeName,
        kind: kind,
        statementStart: this.state.start
      });
      node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
      this.state.labels.pop();
      node.label = expr;
      return this.finishNode(node, "LabeledStatement");
    };

    _proto.parseExpressionStatement = function parseExpressionStatement(node, expr) {
      node.expression = expr;
      this.semicolon();
      return this.finishNode(node, "ExpressionStatement");
    };

    _proto.parseBlock = function parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
      if (allowDirectives === void 0) {
        allowDirectives = false;
      }

      if (createNewLexicalScope === void 0) {
        createNewLexicalScope = true;
      }

      var node = this.startNode();

      if (allowDirectives) {
        this.state.strictErrors.clear();
      }

      this.expect(types$1.braceL);

      if (createNewLexicalScope) {
        this.scope.enter(SCOPE_OTHER);
      }

      this.parseBlockBody(node, allowDirectives, false, types$1.braceR, afterBlockParse);

      if (createNewLexicalScope) {
        this.scope.exit();
      }

      return this.finishNode(node, "BlockStatement");
    };

    _proto.isValidDirective = function isValidDirective(stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
    };

    _proto.parseBlockBody = function parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
      var body = node.body = [];
      var directives = node.directives = [];
      this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);
    };

    _proto.parseBlockOrModuleBlockBody = function parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
      var oldStrict = this.state.strict;
      var hasStrictModeDirective = false;
      var parsedNonDirective = false;

      while (!this.match(end)) {
        var stmt = this.parseStatement(null, topLevel);

        if (directives && !parsedNonDirective) {
          if (this.isValidDirective(stmt)) {
            var directive = this.stmtToDirective(stmt);
            directives.push(directive);

            if (!hasStrictModeDirective && directive.value.value === "use strict") {
              hasStrictModeDirective = true;
              this.setStrict(true);
            }

            continue;
          }

          parsedNonDirective = true;
          this.state.strictErrors.clear();
        }

        body.push(stmt);
      }

      if (afterBlockParse) {
        afterBlockParse.call(this, hasStrictModeDirective);
      }

      if (!oldStrict) {
        this.setStrict(false);
      }

      this.next();
    };

    _proto.parseFor = function parseFor(node, init) {
      var _this5 = this;

      node.init = init;
      this.semicolon(false);
      node.test = this.match(types$1.semi) ? null : this.parseExpression();
      this.semicolon(false);
      node.update = this.match(types$1.parenR) ? null : this.parseExpression();
      this.expect(types$1.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this5.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, "ForStatement");
    };

    _proto.parseForIn = function parseForIn(node, init, awaitAt) {
      var _this6 = this;

      var isForIn = this.match(types$1._in);
      this.next();

      if (isForIn) {
        if (awaitAt > -1) this.unexpected(awaitAt);
      } else {
        node["await"] = awaitAt > -1;
      }

      if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
        this.raise(init.start, ErrorMessages.ForInOfLoopInitializer, isForIn ? "for-in" : "for-of");
      } else if (init.type === "AssignmentPattern") {
        this.raise(init.start, ErrorMessages.InvalidLhs, "for-loop");
      }

      node.left = init;
      node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
      this.expect(types$1.parenR);
      node.body = this.withTopicForbiddingContext(function () {
        return _this6.parseStatement("for");
      });
      this.scope.exit();
      this.state.labels.pop();
      return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
    };

    _proto.parseVar = function parseVar(node, isFor, kind) {
      var declarations = node.declarations = [];
      var isTypescript = this.hasPlugin("typescript");
      node.kind = kind;

      for (;;) {
        var decl = this.startNode();
        this.parseVarId(decl, kind);

        if (this.eat(types$1.eq)) {
          decl.init = isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
        } else {
          if (kind === "const" && !(this.match(types$1._in) || this.isContextual("of"))) {
            if (!isTypescript) {
              this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Const declarations");
            }
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types$1._in) || this.isContextual("of")))) {
            this.raise(this.state.lastTokEnd, ErrorMessages.DeclarationMissingInitializer, "Complex binding patterns");
          }

          decl.init = null;
        }

        declarations.push(this.finishNode(decl, "VariableDeclarator"));
        if (!this.eat(types$1.comma)) break;
      }

      return node;
    };

    _proto.parseVarId = function parseVarId(decl, kind) {
      decl.id = this.parseBindingAtom();
      this.checkLVal(decl.id, "variable declaration", kind === "var" ? BIND_VAR : BIND_LEXICAL, undefined, kind !== "var");
    };

    _proto.parseFunction = function parseFunction(node, statement, isAsync) {
      var _this7 = this;

      if (statement === void 0) {
        statement = FUNC_NO_FLAGS;
      }

      if (isAsync === void 0) {
        isAsync = false;
      }

      var isStatement = statement & FUNC_STATEMENT;
      var isHangingStatement = statement & FUNC_HANGING_STATEMENT;
      var requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);
      this.initFunction(node, isAsync);

      if (this.match(types$1.star) && isHangingStatement) {
        this.raise(this.state.start, ErrorMessages.GeneratorInSingleStatementContext);
      }

      node.generator = this.eat(types$1.star);

      if (isStatement) {
        node.id = this.parseFunctionId(requireId);
      }

      var oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
      this.state.maybeInArrowParameters = false;
      this.scope.enter(SCOPE_FUNCTION);
      this.prodParam.enter(functionFlags(isAsync, node.generator));

      if (!isStatement) {
        node.id = this.parseFunctionId();
      }

      this.parseFunctionParams(node, false);
      this.withTopicForbiddingContext(function () {
        _this7.parseFunctionBodyAndFinish(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
      });
      this.prodParam.exit();
      this.scope.exit();

      if (isStatement && !isHangingStatement) {
        this.registerFunctionStatementId(node);
      }

      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
      return node;
    };

    _proto.parseFunctionId = function parseFunctionId(requireId) {
      return requireId || this.match(types$1.name) ? this.parseIdentifier() : null;
    };

    _proto.parseFunctionParams = function parseFunctionParams(node, allowModifiers) {
      this.expect(types$1.parenL);
      this.expressionScope.enter(newParameterDeclarationScope());
      node.params = this.parseBindingList(types$1.parenR, 41, false, allowModifiers);
      this.expressionScope.exit();
    };

    _proto.registerFunctionStatementId = function registerFunctionStatementId(node) {
      if (!node.id) return;
      this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);
    };

    _proto.parseClass = function parseClass(node, isStatement, optionalId) {
      this.next();
      this.takeDecorators(node);
      var oldStrict = this.state.strict;
      this.state.strict = true;
      this.parseClassId(node, isStatement, optionalId);
      this.parseClassSuper(node);
      node.body = this.parseClassBody(!!node.superClass, oldStrict);
      return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
    };

    _proto.isClassProperty = function isClassProperty() {
      return this.match(types$1.eq) || this.match(types$1.semi) || this.match(types$1.braceR);
    };

    _proto.isClassMethod = function isClassMethod() {
      return this.match(types$1.parenL);
    };

    _proto.isNonstaticConstructor = function isNonstaticConstructor(method) {
      return !method.computed && !method["static"] && (method.key.name === "constructor" || method.key.value === "constructor");
    };

    _proto.parseClassBody = function parseClassBody(hadSuperClass, oldStrict) {
      var _this8 = this;

      this.classScope.enter();
      var state = {
        hadConstructor: false,
        hadSuperClass: hadSuperClass
      };
      var decorators = [];
      var classBody = this.startNode();
      classBody.body = [];
      this.expect(types$1.braceL);
      this.withTopicForbiddingContext(function () {
        while (!_this8.match(types$1.braceR)) {
          if (_this8.eat(types$1.semi)) {
            if (decorators.length > 0) {
              throw _this8.raise(_this8.state.lastTokEnd, ErrorMessages.DecoratorSemicolon);
            }

            continue;
          }

          if (_this8.match(types$1.at)) {
            decorators.push(_this8.parseDecorator());
            continue;
          }

          var member = _this8.startNode();

          if (decorators.length) {
            member.decorators = decorators;

            _this8.resetStartLocationFromNode(member, decorators[0]);

            decorators = [];
          }

          _this8.parseClassMember(classBody, member, state);

          if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
            _this8.raise(member.start, ErrorMessages.DecoratorConstructor);
          }
        }
      });
      this.state.strict = oldStrict;
      this.next();

      if (decorators.length) {
        throw this.raise(this.state.start, ErrorMessages.TrailingDecorator);
      }

      this.classScope.exit();
      return this.finishNode(classBody, "ClassBody");
    };

    _proto.parseClassMemberFromModifier = function parseClassMemberFromModifier(classBody, member) {
      var key = this.parseIdentifier(true);

      if (this.isClassMethod()) {
        var method = member;
        method.kind = "method";
        method.computed = false;
        method.key = key;
        method["static"] = false;
        this.pushClassMethod(classBody, method, false, false, false, false);
        return true;
      } else if (this.isClassProperty()) {
        var prop = member;
        prop.computed = false;
        prop.key = key;
        prop["static"] = false;
        classBody.body.push(this.parseClassProperty(prop));
        return true;
      }

      return false;
    };

    _proto.parseClassMember = function parseClassMember(classBody, member, state) {
      var isStatic = this.isContextual("static");

      if (isStatic) {
        if (this.parseClassMemberFromModifier(classBody, member)) {
          return;
        }

        if (this.eat(types$1.braceL)) {
          this.parseClassStaticBlock(classBody, member);
          return;
        }
      }

      this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
    };

    _proto.parseClassMemberWithIsStatic = function parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
      var publicMethod = member;
      var privateMethod = member;
      var publicProp = member;
      var privateProp = member;
      var method = publicMethod;
      var publicMember = publicMethod;
      member["static"] = isStatic;

      if (this.eat(types$1.star)) {
        method.kind = "method";
        var isPrivateName = this.match(types$1.privateName);
        this.parseClassElementName(method);

        if (isPrivateName) {
          this.pushClassPrivateMethod(classBody, privateMethod, true, false);
          return;
        }

        if (this.isNonstaticConstructor(publicMethod)) {
          this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsGenerator);
        }

        this.pushClassMethod(classBody, publicMethod, true, false, false, false);
        return;
      }

      var containsEsc = this.state.containsEsc;
      var isPrivate = this.match(types$1.privateName);
      var key = this.parseClassElementName(member);
      var isSimple = key.type === "Identifier";
      var maybeQuestionTokenStart = this.state.start;
      this.parsePostMemberNameModifiers(publicMember);

      if (this.isClassMethod()) {
        method.kind = "method";

        if (isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          return;
        }

        var isConstructor = this.isNonstaticConstructor(publicMethod);
        var allowsDirectSuper = false;

        if (isConstructor) {
          publicMethod.kind = "constructor";

          if (state.hadConstructor && !this.hasPlugin("typescript")) {
            this.raise(key.start, ErrorMessages.DuplicateConstructor);
          }

          if (isConstructor && this.hasPlugin("typescript") && member.override) {
            this.raise(key.start, ErrorMessages.OverrideOnConstructor);
          }

          state.hadConstructor = true;
          allowsDirectSuper = state.hadSuperClass;
        }

        this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
      } else if (this.isClassProperty()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else if (isSimple && key.name === "async" && !containsEsc && !this.isLineTerminator()) {
        var isGenerator = this.eat(types$1.star);

        if (publicMember.optional) {
          this.unexpected(maybeQuestionTokenStart);
        }

        method.kind = "method";

        var _isPrivate = this.match(types$1.privateName);

        this.parseClassElementName(method);
        this.parsePostMemberNameModifiers(publicMember);

        if (_isPrivate) {
          this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAsync);
          }

          this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
        }
      } else if (isSimple && (key.name === "get" || key.name === "set") && !containsEsc && !(this.match(types$1.star) && this.isLineTerminator())) {
        method.kind = key.name;

        var _isPrivate2 = this.match(types$1.privateName);

        this.parseClassElementName(publicMethod);

        if (_isPrivate2) {
          this.pushClassPrivateMethod(classBody, privateMethod, false, false);
        } else {
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(publicMethod.key.start, ErrorMessages.ConstructorIsAccessor);
          }

          this.pushClassMethod(classBody, publicMethod, false, false, false, false);
        }

        this.checkGetterSetterParams(publicMethod);
      } else if (this.isLineTerminator()) {
        if (isPrivate) {
          this.pushClassPrivateProperty(classBody, privateProp);
        } else {
          this.pushClassProperty(classBody, publicProp);
        }
      } else {
        this.unexpected();
      }
    };

    _proto.parseClassElementName = function parseClassElementName(member) {
      var _this$state = this.state,
          type = _this$state.type,
          value = _this$state.value,
          start = _this$state.start;

      if ((type === types$1.name || type === types$1.string) && member["static"] && value === "prototype") {
        this.raise(start, ErrorMessages.StaticPrototype);
      }

      if (type === types$1.privateName && value === "constructor") {
        this.raise(start, ErrorMessages.ConstructorClassPrivateField);
      }

      return this.parsePropertyName(member, true);
    };

    _proto.parseClassStaticBlock = function parseClassStaticBlock(classBody, member) {
      var _member$decorators;

      this.expectPlugin("classStaticBlock", member.start);
      this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);
      var oldLabels = this.state.labels;
      this.state.labels = [];
      this.prodParam.enter(PARAM);
      var body = member.body = [];
      this.parseBlockOrModuleBlockBody(body, undefined, false, types$1.braceR);
      this.prodParam.exit();
      this.scope.exit();
      this.state.labels = oldLabels;
      classBody.body.push(this.finishNode(member, "StaticBlock"));

      if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
        this.raise(member.start, ErrorMessages.DecoratorStaticBlock);
      }
    };

    _proto.pushClassProperty = function pushClassProperty(classBody, prop) {
      if (!prop.computed && (prop.key.name === "constructor" || prop.key.value === "constructor")) {
        this.raise(prop.key.start, ErrorMessages.ConstructorClassField);
      }

      classBody.body.push(this.parseClassProperty(prop));
    };

    _proto.pushClassPrivateProperty = function pushClassPrivateProperty(classBody, prop) {
      var node = this.parseClassPrivateProperty(prop);
      classBody.body.push(node);
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), CLASS_ELEMENT_OTHER, node.key.start);
    };

    _proto.pushClassMethod = function pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
      classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
    };

    _proto.pushClassPrivateMethod = function pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
      var node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
      classBody.body.push(node);
      var kind = node.kind === "get" ? node["static"] ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === "set" ? node["static"] ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;
      this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.start);
    };

    _proto.parsePostMemberNameModifiers = function parsePostMemberNameModifiers(methodOrProp) {};

    _proto.parseClassPrivateProperty = function parseClassPrivateProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassPrivateProperty");
    };

    _proto.parseClassProperty = function parseClassProperty(node) {
      this.parseInitializer(node);
      this.semicolon();
      return this.finishNode(node, "ClassProperty");
    };

    _proto.parseInitializer = function parseInitializer(node) {
      this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);
      this.expressionScope.enter(newExpressionScope());
      this.prodParam.enter(PARAM);
      node.value = this.eat(types$1.eq) ? this.parseMaybeAssignAllowIn() : null;
      this.expressionScope.exit();
      this.prodParam.exit();
      this.scope.exit();
    };

    _proto.parseClassId = function parseClassId(node, isStatement, optionalId, bindingType) {
      if (bindingType === void 0) {
        bindingType = BIND_CLASS;
      }

      if (this.match(types$1.name)) {
        node.id = this.parseIdentifier();

        if (isStatement) {
          this.checkLVal(node.id, "class name", bindingType);
        }
      } else {
        if (optionalId || !isStatement) {
          node.id = null;
        } else {
          this.unexpected(null, ErrorMessages.MissingClassName);
        }
      }
    };

    _proto.parseClassSuper = function parseClassSuper(node) {
      node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts() : null;
    };

    _proto.parseExport = function parseExport(node) {
      var hasDefault = this.maybeParseExportDefaultSpecifier(node);
      var parseAfterDefault = !hasDefault || this.eat(types$1.comma);
      var hasStar = parseAfterDefault && this.eatExportStar(node);
      var hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
      var parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types$1.comma));
      var isFromRequired = hasDefault || hasStar;

      if (hasStar && !hasNamespace) {
        if (hasDefault) this.unexpected();
        this.parseExportFrom(node, true);
        return this.finishNode(node, "ExportAllDeclaration");
      }

      var hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);

      if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {
        throw this.unexpected(null, types$1.braceL);
      }

      var hasDeclaration;

      if (isFromRequired || hasSpecifiers) {
        hasDeclaration = false;
        this.parseExportFrom(node, isFromRequired);
      } else {
        hasDeclaration = this.maybeParseExportDeclaration(node);
      }

      if (isFromRequired || hasSpecifiers || hasDeclaration) {
        this.checkExport(node, true, false, !!node.source);
        return this.finishNode(node, "ExportNamedDeclaration");
      }

      if (this.eat(types$1._default)) {
        node.declaration = this.parseExportDefaultExpression();
        this.checkExport(node, true, true);
        return this.finishNode(node, "ExportDefaultDeclaration");
      }

      throw this.unexpected(null, types$1.braceL);
    };

    _proto.eatExportStar = function eatExportStar(node) {
      return this.eat(types$1.star);
    };

    _proto.maybeParseExportDefaultSpecifier = function maybeParseExportDefaultSpecifier(node) {
      if (this.isExportDefaultSpecifier()) {
        this.expectPlugin("exportDefaultFrom");
        var specifier = this.startNode();
        specifier.exported = this.parseIdentifier(true);
        node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamespaceSpecifier = function maybeParseExportNamespaceSpecifier(node) {
      if (this.isContextual("as")) {
        if (!node.specifiers) node.specifiers = [];
        var specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);
        this.next();
        specifier.exported = this.parseModuleExportName();
        node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
        return true;
      }

      return false;
    };

    _proto.maybeParseExportNamedSpecifiers = function maybeParseExportNamedSpecifiers(node) {
      if (this.match(types$1.braceL)) {
        var _node$specifiers;

        if (!node.specifiers) node.specifiers = [];

        (_node$specifiers = node.specifiers).push.apply(_node$specifiers, this.parseExportSpecifiers());

        node.source = null;
        node.declaration = null;
        return true;
      }

      return false;
    };

    _proto.maybeParseExportDeclaration = function maybeParseExportDeclaration(node) {
      if (this.shouldParseExportDeclaration()) {
        node.specifiers = [];
        node.source = null;
        node.declaration = this.parseExportDeclaration(node);
        return true;
      }

      return false;
    };

    _proto.isAsyncFunction = function isAsyncFunction() {
      if (!this.isContextual("async")) return false;
      var next = this.nextTokenStart();
      return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, "function");
    };

    _proto.parseExportDefaultExpression = function parseExportDefaultExpression() {
      var expr = this.startNode();
      var isAsync = this.isAsyncFunction();

      if (this.match(types$1._function) || isAsync) {
        this.next();

        if (isAsync) {
          this.next();
        }

        return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);
      } else if (this.match(types$1._class)) {
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1.at)) {
        if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport")) {
          this.raise(this.state.start, ErrorMessages.DecoratorBeforeExport);
        }

        this.parseDecorators(false);
        return this.parseClass(expr, true, true);
      } else if (this.match(types$1._const) || this.match(types$1._var) || this.isLet()) {
        throw this.raise(this.state.start, ErrorMessages.UnsupportedDefaultExport);
      } else {
        var res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
    };

    _proto.parseExportDeclaration = function parseExportDeclaration(node) {
      return this.parseStatement(null);
    };

    _proto.isExportDefaultSpecifier = function isExportDefaultSpecifier() {
      if (this.match(types$1.name)) {
        var value = this.state.value;

        if (value === "async" && !this.state.containsEsc || value === "let") {
          return false;
        }

        if ((value === "type" || value === "interface") && !this.state.containsEsc) {
          var l = this.lookahead();

          if (l.type === types$1.name && l.value !== "from" || l.type === types$1.braceL) {
            this.expectOnePlugin(["flow", "typescript"]);
            return false;
          }
        }
      } else if (!this.match(types$1._default)) {
        return false;
      }

      var next = this.nextTokenStart();
      var hasFrom = this.isUnparsedContextual(next, "from");

      if (this.input.charCodeAt(next) === 44 || this.match(types$1.name) && hasFrom) {
        return true;
      }

      if (this.match(types$1._default) && hasFrom) {
        var nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
        return nextAfterFrom === 34 || nextAfterFrom === 39;
      }

      return false;
    };

    _proto.parseExportFrom = function parseExportFrom(node, expect) {
      if (this.eatContextual("from")) {
        node.source = this.parseImportSource();
        this.checkExport(node);
        var assertions = this.maybeParseImportAssertions();

        if (assertions) {
          node.assertions = assertions;
        }
      } else {
        if (expect) {
          this.unexpected();
        } else {
          node.source = null;
        }
      }

      this.semicolon();
    };

    _proto.shouldParseExportDeclaration = function shouldParseExportDeclaration() {
      if (this.match(types$1.at)) {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);

        if (this.hasPlugin("decorators")) {
          if (this.getPluginOption("decorators", "decoratorsBeforeExport")) {
            this.unexpected(this.state.start, ErrorMessages.DecoratorBeforeExport);
          } else {
            return true;
          }
        }
      }

      return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isLet() || this.isAsyncFunction();
    };

    _proto.checkExport = function checkExport(node, checkNames, isDefault, isFrom) {
      if (checkNames) {
        if (isDefault) {
          this.checkDuplicateExports(node, "default");

          if (this.hasPlugin("exportDefaultFrom")) {
            var _declaration$extra;

            var declaration = node.declaration;

            if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
              this.raise(declaration.start, ErrorMessages.ExportDefaultFromAsIdentifier);
            }
          }
        } else if (node.specifiers && node.specifiers.length) {
          for (var _i6 = 0, _node$specifiers3 = node.specifiers; _i6 < _node$specifiers3.length; _i6++) {
            var specifier = _node$specifiers3[_i6];
            var exported = specifier.exported;
            var exportedName = exported.type === "Identifier" ? exported.name : exported.value;
            this.checkDuplicateExports(specifier, exportedName);

            if (!isFrom && specifier.local) {
              var local = specifier.local;

              if (local.type !== "Identifier") {
                this.raise(specifier.start, ErrorMessages.ExportBindingIsString, local.value, exportedName);
              } else {
                this.checkReservedWord(local.name, local.start, true, false);
                this.scope.checkLocalExport(local);
              }
            }
          }
        } else if (node.declaration) {
          if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
            var id = node.declaration.id;
            if (!id) throw new Error("Assertion failure");
            this.checkDuplicateExports(node, id.name);
          } else if (node.declaration.type === "VariableDeclaration") {
            for (var _i8 = 0, _node$declaration$dec2 = node.declaration.declarations; _i8 < _node$declaration$dec2.length; _i8++) {
              var _declaration = _node$declaration$dec2[_i8];
              this.checkDeclaration(_declaration.id);
            }
          }
        }
      }

      var currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];

      if (currentContextDecorators.length) {
        throw this.raise(node.start, ErrorMessages.UnsupportedDecoratorExport);
      }
    };

    _proto.checkDeclaration = function checkDeclaration(node) {
      if (node.type === "Identifier") {
        this.checkDuplicateExports(node, node.name);
      } else if (node.type === "ObjectPattern") {
        for (var _i10 = 0, _node$properties2 = node.properties; _i10 < _node$properties2.length; _i10++) {
          var prop = _node$properties2[_i10];
          this.checkDeclaration(prop);
        }
      } else if (node.type === "ArrayPattern") {
        for (var _i12 = 0, _node$elements2 = node.elements; _i12 < _node$elements2.length; _i12++) {
          var elem = _node$elements2[_i12];

          if (elem) {
            this.checkDeclaration(elem);
          }
        }
      } else if (node.type === "ObjectProperty") {
        this.checkDeclaration(node.value);
      } else if (node.type === "RestElement") {
        this.checkDeclaration(node.argument);
      } else if (node.type === "AssignmentPattern") {
        this.checkDeclaration(node.left);
      }
    };

    _proto.checkDuplicateExports = function checkDuplicateExports(node, name) {
      if (this.exportedIdentifiers.has(name)) {
        this.raise(node.start, name === "default" ? ErrorMessages.DuplicateDefaultExport : ErrorMessages.DuplicateExport, name);
      }

      this.exportedIdentifiers.add(name);
    };

    _proto.parseExportSpecifiers = function parseExportSpecifiers() {
      var nodes = [];
      var first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        var node = this.startNode();
        node.local = this.parseModuleExportName();
        node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local.__clone();
        nodes.push(this.finishNode(node, "ExportSpecifier"));
      }

      return nodes;
    };

    _proto.parseModuleExportName = function parseModuleExportName() {
      if (this.match(types$1.string)) {
        var result = this.parseStringLiteral(this.state.value);
        var surrogate = result.value.match(loneSurrogate);

        if (surrogate) {
          this.raise(result.start, ErrorMessages.ModuleExportNameHasLoneSurrogate, surrogate[0].charCodeAt(0).toString(16));
        }

        return result;
      }

      return this.parseIdentifier(true);
    };

    _proto.parseImport = function parseImport(node) {
      node.specifiers = [];

      if (!this.match(types$1.string)) {
        var hasDefault = this.maybeParseDefaultImportSpecifier(node);
        var parseNext = !hasDefault || this.eat(types$1.comma);
        var hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual("from");
      }

      node.source = this.parseImportSource();
      var assertions = this.maybeParseImportAssertions();

      if (assertions) {
        node.assertions = assertions;
      } else {
        var attributes = this.maybeParseModuleAttributes();

        if (attributes) {
          node.attributes = attributes;
        }
      }

      this.semicolon();
      return this.finishNode(node, "ImportDeclaration");
    };

    _proto.parseImportSource = function parseImportSource() {
      if (!this.match(types$1.string)) this.unexpected();
      return this.parseExprAtom();
    };

    _proto.shouldParseDefaultImport = function shouldParseDefaultImport(node) {
      return this.match(types$1.name);
    };

    _proto.parseImportSpecifierLocal = function parseImportSpecifierLocal(node, specifier, type, contextDescription) {
      specifier.local = this.parseIdentifier();
      this.checkLVal(specifier.local, contextDescription, BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, type));
    };

    _proto.parseAssertEntries = function parseAssertEntries() {
      var attrs = [];
      var attrNames = new Set();

      do {
        if (this.match(types$1.braceR)) {
          break;
        }

        var node = this.startNode();
        var keyName = this.state.value;

        if (attrNames.has(keyName)) {
          this.raise(this.state.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, keyName);
        }

        attrNames.add(keyName);

        if (this.match(types$1.string)) {
          node.key = this.parseStringLiteral(keyName);
        } else {
          node.key = this.parseIdentifier(true);
        }

        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    };

    _proto.maybeParseModuleAttributes = function maybeParseModuleAttributes() {
      if (this.match(types$1._with) && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("moduleAttributes");
        this.next();
      } else {
        if (this.hasPlugin("moduleAttributes")) return [];
        return null;
      }

      var attrs = [];
      var attributes = new Set();

      do {
        var node = this.startNode();
        node.key = this.parseIdentifier(true);

        if (node.key.name !== "type") {
          this.raise(node.key.start, ErrorMessages.ModuleAttributeDifferentFromType, node.key.name);
        }

        if (attributes.has(node.key.name)) {
          this.raise(node.key.start, ErrorMessages.ModuleAttributesWithDuplicateKeys, node.key.name);
        }

        attributes.add(node.key.name);
        this.expect(types$1.colon);

        if (!this.match(types$1.string)) {
          throw this.unexpected(this.state.start, ErrorMessages.ModuleAttributeInvalidValue);
        }

        node.value = this.parseStringLiteral(this.state.value);
        this.finishNode(node, "ImportAttribute");
        attrs.push(node);
      } while (this.eat(types$1.comma));

      return attrs;
    };

    _proto.maybeParseImportAssertions = function maybeParseImportAssertions() {
      if (this.isContextual("assert") && !this.hasPrecedingLineBreak()) {
        this.expectPlugin("importAssertions");
        this.next();
      } else {
        if (this.hasPlugin("importAssertions")) return [];
        return null;
      }

      this.eat(types$1.braceL);
      var attrs = this.parseAssertEntries();
      this.eat(types$1.braceR);
      return attrs;
    };

    _proto.maybeParseDefaultImportSpecifier = function maybeParseDefaultImportSpecifier(node) {
      if (this.shouldParseDefaultImport(node)) {
        this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier", "default import specifier");
        return true;
      }

      return false;
    };

    _proto.maybeParseStarImportSpecifier = function maybeParseStarImportSpecifier(node) {
      if (this.match(types$1.star)) {
        var specifier = this.startNode();
        this.next();
        this.expectContextual("as");
        this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier", "import namespace specifier");
        return true;
      }

      return false;
    };

    _proto.parseNamedImportSpecifiers = function parseNamedImportSpecifiers(node) {
      var first = true;
      this.expect(types$1.braceL);

      while (!this.eat(types$1.braceR)) {
        if (first) {
          first = false;
        } else {
          if (this.eat(types$1.colon)) {
            throw this.raise(this.state.start, ErrorMessages.DestructureNamedImport);
          }

          this.expect(types$1.comma);
          if (this.eat(types$1.braceR)) break;
        }

        this.parseImportSpecifier(node);
      }
    };

    _proto.parseImportSpecifier = function parseImportSpecifier(node) {
      var specifier = this.startNode();
      var importedIsString = this.match(types$1.string);
      specifier.imported = this.parseModuleExportName();

      if (this.eatContextual("as")) {
        specifier.local = this.parseIdentifier();
      } else {
        var imported = specifier.imported;

        if (importedIsString) {
          throw this.raise(specifier.start, ErrorMessages.ImportBindingIsString, imported.value);
        }

        this.checkReservedWord(imported.name, specifier.start, true, true);
        specifier.local = imported.__clone();
      }

      this.checkLVal(specifier.local, "import specifier", BIND_LEXICAL);
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };

    _proto.isThisParam = function isThisParam(param) {
      return param.type === "Identifier" && param.name === "this";
    };

    return StatementParser;
  }(ExpressionParser);

  var Parser = function (_StatementParser) {
    _inherits(Parser, _StatementParser);

    function Parser(options, input) {
      var _this;

      options = getOptions(options);
      _this = _StatementParser.call(this, options, input) || this;
      _this.options = options;

      _this.initializeScopes();

      _this.plugins = pluginsMap(_this.options.plugins);
      _this.filename = options.sourceFilename;
      return _this;
    }

    var _proto = Parser.prototype;

    _proto.getScopeHandler = function getScopeHandler() {
      return ScopeHandler;
    };

    _proto.parse = function parse() {
      this.enterInitialScopes();
      var file = this.startNode();
      var program = this.startNode();
      this.nextToken();
      file.errors = null;
      this.parseTopLevel(file, program);
      file.errors = this.state.errors;
      return file;
    };

    return Parser;
  }(StatementParser);

  function pluginsMap(plugins) {
    var pluginMap = new Map();

    for (var _i2 = 0; _i2 < plugins.length; _i2++) {
      var plugin = plugins[_i2];

      var _ref = Array.isArray(plugin) ? plugin : [plugin, {}],
          name = _ref[0],
          options = _ref[1];

      if (!pluginMap.has(name)) pluginMap.set(name, options || {});
    }

    return pluginMap;
  }

  function parse$8(input, options) {
    var _options;

    if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
      options = Object.assign({}, options);

      try {
        options.sourceType = "module";
        var parser = getParser(options, input);
        var ast = parser.parse();

        if (parser.sawUnambiguousESM) {
          return ast;
        }

        if (parser.ambiguousScriptDifferentAst) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused) {}
        } else {
          ast.program.sourceType = "script";
        }

        return ast;
      } catch (moduleError) {
        try {
          options.sourceType = "script";
          return getParser(options, input).parse();
        } catch (_unused2) {}

        throw moduleError;
      }
    } else {
      return getParser(options, input).parse();
    }
  }

  function getParser(options, input) {
    var cls = Parser;

    if (options != null && options.plugins) {
      validatePlugins(options.plugins);
      cls = getParserClass(options.plugins);
    }

    return new cls(options, input);
  }

  var parserClassCache = {};

  function getParserClass(pluginsFromOptions) {
    var pluginList = mixinPluginNames.filter(function (name) {
      return hasPlugin(pluginsFromOptions, name);
    });
    var key = pluginList.join("/");
    var cls = parserClassCache[key];

    if (!cls) {
      cls = Parser;

      for (var _i2 = 0; _i2 < pluginList.length; _i2++) {
        var plugin = pluginList[_i2];
        cls = mixinPlugins[plugin](cls);
      }

      parserClassCache[key] = cls;
    }

    return cls;
  }

  var visitor$3 = {
    Scope: function Scope(path, state) {
      if (state.kind === "let") path.skip();
    },
    FunctionParent: function FunctionParent(path) {
      path.skip();
    },
    VariableDeclaration: function (_VariableDeclaration) {
      function VariableDeclaration(_x, _x2) {
        return _VariableDeclaration.apply(this, arguments);
      }

      VariableDeclaration.toString = function () {
        return _VariableDeclaration.toString();
      };

      return VariableDeclaration;
    }(function (path, state) {
      if (state.kind && path.node.kind !== state.kind) return;
      var nodes = [];
      var declarations = path.get("declarations");
      var firstId;

      for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
        var declar = _step.value;
        firstId = declar.node.id;

        if (declar.node.init) {
          nodes.push(expressionStatement(assignmentExpression("=", declar.node.id, declar.node.init)));
        }

        for (var _i = 0, _Object$keys = Object.keys(declar.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          state.emit(identifier(name), name, declar.node.init !== null);
        }
      }

      if (path.parentPath.isFor({
        left: path.node
      })) {
        path.replaceWith(firstId);
      } else {
        path.replaceWithMultiple(nodes);
      }
    })
  };
  function hoistVariables(path, emit, kind) {
    if (kind === void 0) {
      kind = "var";
    }

    path.traverse(visitor$3, {
      kind: kind,
      emit: emit
    });
  }

  function replaceWithMultiple(nodes) {
    var _pathCache$get;

    this.resync();
    nodes = this._verifyNodeList(nodes);
    inheritLeadingComments(nodes[0], this.node);
    inheritTrailingComments(nodes[nodes.length - 1], this.node);
    (_pathCache$get = path$3.get(this.parent)) == null ? void 0 : _pathCache$get["delete"](this.node);
    this.node = this.container[this.key] = null;
    var paths = this.insertAfter(nodes);

    if (this.node) {
      this.requeue();
    } else {
      this.remove();
    }

    return paths;
  }
  function replaceWithSourceString(replacement) {
    this.resync();

    try {
      replacement = "(" + replacement + ")";
      replacement = parse$8(replacement);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += " - make sure this is an expression.\n" + codeFrameColumns(replacement, {
          start: {
            line: loc.line,
            column: loc.column + 1
          }
        });
        err.code = "BABEL_REPLACE_SOURCE_ERROR";
      }

      throw err;
    }

    replacement = replacement.program.body[0].expression;
    traverse.removeProperties(replacement);
    return this.replaceWith(replacement);
  }
  function replaceWith(replacement) {
    this.resync();

    if (this.removed) {
      throw new Error("You can't replace this node, we've already removed it");
    }

    if (replacement instanceof NodePath) {
      replacement = replacement.node;
    }

    if (!replacement) {
      throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
    }

    if (this.node === replacement) {
      return [this];
    }

    if (this.isProgram() && !isProgram(replacement)) {
      throw new Error("You can only replace a Program root node with another Program node");
    }

    if (Array.isArray(replacement)) {
      throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
    }

    if (typeof replacement === "string") {
      throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
    }

    var nodePath = "";

    if (this.isNodeType("Statement") && isExpression(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
        replacement = expressionStatement(replacement);
        nodePath = "expression";
      }
    }

    if (this.isNodeType("Expression") && isStatement(replacement)) {
      if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
        return this.replaceExpressionWithStatements([replacement]);
      }
    }

    var oldNode = this.node;

    if (oldNode) {
      inheritsComments(replacement, oldNode);
      removeComments(oldNode);
    }

    this._replaceWith(replacement);

    this.type = replacement.type;
    this.setScope();
    this.requeue();
    return [nodePath ? this.get(nodePath) : this];
  }
  function _replaceWith(node) {
    var _pathCache$get2;

    if (!this.container) {
      throw new ReferenceError("Container is falsy");
    }

    if (this.inList) {
      validate$3(this.parent, this.key, [node]);
    } else {
      validate$3(this.parent, this.key, node);
    }

    this.debug("Replace with " + (node == null ? void 0 : node.type));
    (_pathCache$get2 = path$3.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this)["delete"](this.node);
    this.node = this.container[this.key] = node;
  }
  function replaceExpressionWithStatements(nodes) {
    var _this = this;

    this.resync();
    var toSequenceExpression$1 = toSequenceExpression(nodes, this.scope);

    if (toSequenceExpression$1) {
      return this.replaceWith(toSequenceExpression$1)[0].get("expressions");
    }

    var functionParent = this.getFunctionParent();
    var isParentAsync = functionParent == null ? void 0 : functionParent.is("async");
    var isParentGenerator = functionParent == null ? void 0 : functionParent.is("generator");
    var container = arrowFunctionExpression([], blockStatement(nodes));
    this.replaceWith(callExpression(container, []));
    var callee = this.get("callee");
    hoistVariables(callee.get("body"), function (id) {
      _this.scope.push({
        id: id
      });
    }, "var");
    var completionRecords = this.get("callee").getCompletionRecords();

    for (var _iterator = _createForOfIteratorHelperLoose(completionRecords), _step; !(_step = _iterator()).done;) {
      var path = _step.value;
      if (!path.isExpressionStatement()) continue;
      var loop = path.findParent(function (path) {
        return path.isLoop();
      });

      if (loop) {
        var uid = loop.getData("expressionReplacementReturnUid");

        if (!uid) {
          uid = callee.scope.generateDeclaredUidIdentifier("ret");
          callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
          loop.setData("expressionReplacementReturnUid", uid);
        } else {
          uid = identifier(uid.name);
        }

        path.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path.node.expression));
      } else {
        path.replaceWith(returnStatement(path.node.expression));
      }
    }

    callee.arrowFunctionToExpression();
    var newCallee = callee;
    var needToAwaitFunction = isParentAsync && traverse.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
    var needToYieldFunction = isParentGenerator && traverse.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);

    if (needToAwaitFunction) {
      newCallee.set("async", true);

      if (!needToYieldFunction) {
        this.replaceWith(awaitExpression(this.node));
      }
    }

    if (needToYieldFunction) {
      newCallee.set("generator", true);
      this.replaceWith(yieldExpression(this.node, true));
    }

    return newCallee.get("body.body");
  }
  function replaceInline(nodes) {
    this.resync();

    if (Array.isArray(nodes)) {
      if (Array.isArray(this.container)) {
        nodes = this._verifyNodeList(nodes);

        var paths = this._containerInsertAfter(nodes);

        this.remove();
        return paths;
      } else {
        return this.replaceWithMultiple(nodes);
      }
    } else {
      return this.replaceWith(nodes);
    }
  }

  var NodePath_replacement = /*#__PURE__*/Object.freeze({
    __proto__: null,
    replaceWithMultiple: replaceWithMultiple,
    replaceWithSourceString: replaceWithSourceString,
    replaceWith: replaceWith,
    _replaceWith: _replaceWith,
    replaceExpressionWithStatements: replaceExpressionWithStatements,
    replaceInline: replaceInline
  });

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  var VALID_CALLEES = ["String", "Number", "Math"];
  var INVALID_METHODS = ["random"];
  function evaluateTruthy() {
    var res = this.evaluate();
    if (res.confident) return !!res.value;
  }

  function deopt(path, state) {
    if (!state.confident) return;
    state.deoptPath = path;
    state.confident = false;
  }

  function evaluateCached(path, state) {
    var node = path.node;
    var seen = state.seen;

    if (seen.has(node)) {
      var existing = seen.get(node);

      if (existing.resolved) {
        return existing.value;
      } else {
        deopt(path, state);
        return;
      }
    } else {
      var item = {
        resolved: false
      };
      seen.set(node, item);

      var val = _evaluate(path, state);

      if (state.confident) {
        item.resolved = true;
        item.value = val;
      }

      return val;
    }
  }

  function _evaluate(path, state) {
    if (!state.confident) return;

    if (path.isSequenceExpression()) {
      var exprs = path.get("expressions");
      return evaluateCached(exprs[exprs.length - 1], state);
    }

    if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {
      return path.node.value;
    }

    if (path.isNullLiteral()) {
      return null;
    }

    if (path.isTemplateLiteral()) {
      return evaluateQuasis(path, path.node.quasis, state);
    }

    if (path.isTaggedTemplateExpression() && path.get("tag").isMemberExpression()) {
      var object = path.get("tag.object");
      var name = object.node.name;
      var property = path.get("tag.property");

      if (object.isIdentifier() && name === "String" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === "raw") {
        return evaluateQuasis(path, path.node.quasi.quasis, state, true);
      }
    }

    if (path.isConditionalExpression()) {
      var testResult = evaluateCached(path.get("test"), state);
      if (!state.confident) return;

      if (testResult) {
        return evaluateCached(path.get("consequent"), state);
      } else {
        return evaluateCached(path.get("alternate"), state);
      }
    }

    if (path.isExpressionWrapper()) {
      return evaluateCached(path.get("expression"), state);
    }

    if (path.isMemberExpression() && !path.parentPath.isCallExpression({
      callee: path.node
    })) {
      var _property = path.get("property");

      var _object = path.get("object");

      if (_object.isLiteral() && _property.isIdentifier()) {
        var value = _object.node.value;
        var type = typeof value;

        if (type === "number" || type === "string") {
          return value[_property.node.name];
        }
      }
    }

    if (path.isReferencedIdentifier()) {
      var binding = path.scope.getBinding(path.node.name);

      if (binding && binding.constantViolations.length > 0) {
        return deopt(binding.path, state);
      }

      if (binding && path.node.start < binding.path.node.end) {
        return deopt(binding.path, state);
      }

      if (binding != null && binding.hasValue) {
        return binding.value;
      } else {
        if (path.node.name === "undefined") {
          return binding ? deopt(binding.path, state) : undefined;
        } else if (path.node.name === "Infinity") {
          return binding ? deopt(binding.path, state) : Infinity;
        } else if (path.node.name === "NaN") {
          return binding ? deopt(binding.path, state) : NaN;
        }

        var resolved = path.resolve();

        if (resolved === path) {
          return deopt(path, state);
        } else {
          return evaluateCached(resolved, state);
        }
      }
    }

    if (path.isUnaryExpression({
      prefix: true
    })) {
      if (path.node.operator === "void") {
        return undefined;
      }

      var argument = path.get("argument");

      if (path.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
        return "function";
      }

      var arg = evaluateCached(argument, state);
      if (!state.confident) return;

      switch (path.node.operator) {
        case "!":
          return !arg;

        case "+":
          return +arg;

        case "-":
          return -arg;

        case "~":
          return ~arg;

        case "typeof":
          return typeof arg;
      }
    }

    if (path.isArrayExpression()) {
      var arr = [];
      var elems = path.get("elements");

      for (var _iterator = _createForOfIteratorHelperLoose(elems), _step; !(_step = _iterator()).done;) {
        var elem = _step.value;
        var elemValue = elem.evaluate();

        if (elemValue.confident) {
          arr.push(elemValue.value);
        } else {
          return deopt(elemValue.deopt, state);
        }
      }

      return arr;
    }

    if (path.isObjectExpression()) {
      var obj = {};
      var props = path.get("properties");

      for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;

        if (prop.isObjectMethod() || prop.isSpreadElement()) {
          return deopt(prop, state);
        }

        var keyPath = prop.get("key");
        var key = keyPath;

        if (prop.node.computed) {
          key = key.evaluate();

          if (!key.confident) {
            return deopt(key.deopt, state);
          }

          key = key.value;
        } else if (key.isIdentifier()) {
          key = key.node.name;
        } else {
          key = key.node.value;
        }

        var valuePath = prop.get("value");

        var _value = valuePath.evaluate();

        if (!_value.confident) {
          return deopt(_value.deopt, state);
        }

        _value = _value.value;
        obj[key] = _value;
      }

      return obj;
    }

    if (path.isLogicalExpression()) {
      var wasConfident = state.confident;
      var left = evaluateCached(path.get("left"), state);
      var leftConfident = state.confident;
      state.confident = wasConfident;
      var right = evaluateCached(path.get("right"), state);
      var rightConfident = state.confident;

      switch (path.node.operator) {
        case "||":
          state.confident = leftConfident && (!!left || rightConfident);
          if (!state.confident) return;
          return left || right;

        case "&&":
          state.confident = leftConfident && (!left || rightConfident);
          if (!state.confident) return;
          return left && right;
      }
    }

    if (path.isBinaryExpression()) {
      var _left = evaluateCached(path.get("left"), state);

      if (!state.confident) return;

      var _right = evaluateCached(path.get("right"), state);

      if (!state.confident) return;

      switch (path.node.operator) {
        case "-":
          return _left - _right;

        case "+":
          return _left + _right;

        case "/":
          return _left / _right;

        case "*":
          return _left * _right;

        case "%":
          return _left % _right;

        case "**":
          return Math.pow(_left, _right);

        case "<":
          return _left < _right;

        case ">":
          return _left > _right;

        case "<=":
          return _left <= _right;

        case ">=":
          return _left >= _right;

        case "==":
          return _left == _right;

        case "!=":
          return _left != _right;

        case "===":
          return _left === _right;

        case "!==":
          return _left !== _right;

        case "|":
          return _left | _right;

        case "&":
          return _left & _right;

        case "^":
          return _left ^ _right;

        case "<<":
          return _left << _right;

        case ">>":
          return _left >> _right;

        case ">>>":
          return _left >>> _right;
      }
    }

    if (path.isCallExpression()) {
      var callee = path.get("callee");
      var context;
      var func;

      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {
        func = global$1[callee.node.name];
      }

      if (callee.isMemberExpression()) {
        var _object2 = callee.get("object");

        var _property2 = callee.get("property");

        if (_object2.isIdentifier() && _property2.isIdentifier() && VALID_CALLEES.indexOf(_object2.node.name) >= 0 && INVALID_METHODS.indexOf(_property2.node.name) < 0) {
          context = global$1[_object2.node.name];
          func = context[_property2.node.name];
        }

        if (_object2.isLiteral() && _property2.isIdentifier()) {
          var _type = typeof _object2.node.value;

          if (_type === "string" || _type === "number") {
            context = _object2.node.value;
            func = context[_property2.node.name];
          }
        }
      }

      if (func) {
        var args = path.get("arguments").map(function (arg) {
          return evaluateCached(arg, state);
        });
        if (!state.confident) return;
        return func.apply(context, args);
      }
    }

    deopt(path, state);
  }

  function evaluateQuasis(path, quasis, state, raw) {
    if (raw === void 0) {
      raw = false;
    }

    var str = "";
    var i = 0;
    var exprs = path.get("expressions");

    for (var _iterator3 = _createForOfIteratorHelperLoose(quasis), _step3; !(_step3 = _iterator3()).done;) {
      var elem = _step3.value;
      if (!state.confident) break;
      str += raw ? elem.value.raw : elem.value.cooked;
      var expr = exprs[i++];
      if (expr) str += String(evaluateCached(expr, state));
    }

    if (!state.confident) return;
    return str;
  }

  function evaluate$1() {
    var state = {
      confident: true,
      deoptPath: null,
      seen: new Map()
    };
    var value = evaluateCached(this, state);
    if (!state.confident) value = undefined;
    return {
      confident: state.confident,
      deopt: state.deoptPath,
      value: value
    };
  }

  var NodePath_evaluation = /*#__PURE__*/Object.freeze({
    __proto__: null,
    evaluateTruthy: evaluateTruthy,
    evaluate: evaluate$1
  });

  function getFunctionArity (node) {
    var params = node.params;

    for (var i = 0; i < params.length; i++) {
      var param = params[i];

      if (isAssignmentPattern(param) || isRestElement(param)) {
        return i;
      }
    }

    return params.length;
  }

  function makeStatementFormatter(fn) {
    return {
      code: function code(str) {
        return "/* @babel/template */;\n" + str;
      },
      validate: function validate() {},
      unwrap: function unwrap(ast) {
        return fn(ast.program.body.slice(1));
      }
    };
  }

  var smart$1 = makeStatementFormatter(function (body) {
    if (body.length > 1) {
      return body;
    } else {
      return body[0];
    }
  });
  var statements$1 = makeStatementFormatter(function (body) {
    return body;
  });
  var statement$1 = makeStatementFormatter(function (body) {
    if (body.length === 0) {
      throw new Error("Found nothing to return.");
    }

    if (body.length > 1) {
      throw new Error("Found multiple statements but wanted one");
    }

    return body[0];
  });
  var expression$1 = {
    code: function code(str) {
      return "(\n" + str + "\n)";
    },
    validate: function validate(ast) {
      if (ast.program.body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }

      if (expression$1.unwrap(ast).start === 0) {
        throw new Error("Parse result included parens.");
      }
    },
    unwrap: function unwrap(_ref) {
      var program = _ref.program;

      var _program$body = _slicedToArray$2(program.body, 1),
          stmt = _program$body[0];

      assertExpressionStatement(stmt);
      return stmt.expression;
    }
  };
  var program$1 = {
    code: function code(str) {
      return str;
    },
    validate: function validate() {},
    unwrap: function unwrap(ast) {
      return ast.program;
    }
  };

  var _excluded$3 = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
  function merge$1(a, b) {
    var _b$placeholderWhiteli = b.placeholderWhitelist,
        placeholderWhitelist = _b$placeholderWhiteli === void 0 ? a.placeholderWhitelist : _b$placeholderWhiteli,
        _b$placeholderPattern = b.placeholderPattern,
        placeholderPattern = _b$placeholderPattern === void 0 ? a.placeholderPattern : _b$placeholderPattern,
        _b$preserveComments = b.preserveComments,
        preserveComments = _b$preserveComments === void 0 ? a.preserveComments : _b$preserveComments,
        _b$syntacticPlacehold = b.syntacticPlaceholders,
        syntacticPlaceholders = _b$syntacticPlacehold === void 0 ? a.syntacticPlaceholders : _b$syntacticPlacehold;
    return {
      parser: Object.assign({}, a.parser, b.parser),
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      preserveComments: preserveComments,
      syntacticPlaceholders: syntacticPlaceholders
    };
  }
  function validate$1(opts) {
    if (opts != null && typeof opts !== "object") {
      throw new Error("Unknown template options.");
    }

    var _ref = opts || {},
        placeholderWhitelist = _ref.placeholderWhitelist,
        placeholderPattern = _ref.placeholderPattern,
        preserveComments = _ref.preserveComments,
        syntacticPlaceholders = _ref.syntacticPlaceholders,
        parser = _objectWithoutPropertiesLoose(_ref, _excluded$3);

    if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
      throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
    }

    if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
      throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
    }

    if (preserveComments != null && typeof preserveComments !== "boolean") {
      throw new Error("'.preserveComments' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
      throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
    }

    if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    return {
      parser: parser,
      placeholderWhitelist: placeholderWhitelist || undefined,
      placeholderPattern: placeholderPattern == null ? undefined : placeholderPattern,
      preserveComments: preserveComments == null ? undefined : preserveComments,
      syntacticPlaceholders: syntacticPlaceholders == null ? undefined : syntacticPlaceholders
    };
  }
  function normalizeReplacements(replacements) {
    if (Array.isArray(replacements)) {
      return replacements.reduce(function (acc, replacement, i) {
        acc["$" + i] = replacement;
        return acc;
      }, {});
    } else if (typeof replacements === "object" || replacements == null) {
      return replacements || undefined;
    }

    throw new Error("Template replacements must be an array, object, null, or undefined");
  }

  var PATTERN = /^[_$A-Z0-9]+$/;
  function parseAndBuildMetadata(formatter, code, opts) {
    var placeholderWhitelist = opts.placeholderWhitelist,
        placeholderPattern = opts.placeholderPattern,
        preserveComments = opts.preserveComments,
        syntacticPlaceholders = opts.syntacticPlaceholders;
    var ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
    removePropertiesDeep(ast, {
      preserveComments: preserveComments
    });
    formatter.validate(ast);
    var syntactic = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var legacy = {
      placeholders: [],
      placeholderNames: new Set()
    };
    var isLegacyRef = {
      value: undefined
    };
    traverse$1(ast, placeholderVisitorHandler, {
      syntactic: syntactic,
      legacy: legacy,
      isLegacyRef: isLegacyRef,
      placeholderWhitelist: placeholderWhitelist,
      placeholderPattern: placeholderPattern,
      syntacticPlaceholders: syntacticPlaceholders
    });
    return Object.assign({
      ast: ast
    }, isLegacyRef.value ? legacy : syntactic);
  }

  function placeholderVisitorHandler(node, ancestors, state) {
    var _state$placeholderWhi;

    var name;

    if (isPlaceholder(node)) {
      if (state.syntacticPlaceholders === false) {
        throw new Error("%%foo%%-style placeholders can't be used when " + "'.syntacticPlaceholders' is false.");
      } else {
        name = node.name.name;
        state.isLegacyRef.value = false;
      }
    } else if (state.isLegacyRef.value === false || state.syntacticPlaceholders) {
      return;
    } else if (isIdentifier(node) || isJSXIdentifier(node)) {
      name = node.name;
      state.isLegacyRef.value = true;
    } else if (isStringLiteral(node)) {
      name = node.value;
      state.isLegacyRef.value = true;
    } else {
      return;
    }

    if (!state.isLegacyRef.value && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
      throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible" + " with '.syntacticPlaceholders: true'");
    }

    if (state.isLegacyRef.value && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name))) {
      return;
    }

    ancestors = ancestors.slice();
    var _ancestors = ancestors[ancestors.length - 1],
        parent = _ancestors.node,
        key = _ancestors.key;
    var type;

    if (isStringLiteral(node) || isPlaceholder(node, {
      expectedNode: "StringLiteral"
    })) {
      type = "string";
    } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction$1(parent) && key === "params") {
      type = "param";
    } else if (isExpressionStatement(parent) && !isPlaceholder(node)) {
      type = "statement";
      ancestors = ancestors.slice(0, -1);
    } else if (isStatement(node) && isPlaceholder(node)) {
      type = "statement";
    } else {
      type = "other";
    }

    var _ref = state.isLegacyRef.value ? state.legacy : state.syntactic,
        placeholders = _ref.placeholders,
        placeholderNames = _ref.placeholderNames;

    placeholders.push({
      name: name,
      type: type,
      resolve: function resolve(ast) {
        return resolveAncestors(ast, ancestors);
      },
      isDuplicate: placeholderNames.has(name)
    });
    placeholderNames.add(name);
  }

  function resolveAncestors(ast, ancestors) {
    var parent = ast;

    for (var i = 0; i < ancestors.length - 1; i++) {
      var _ancestors$i = ancestors[i],
          _key = _ancestors$i.key,
          _index = _ancestors$i.index;

      if (_index === undefined) {
        parent = parent[_key];
      } else {
        parent = parent[_key][_index];
      }
    }

    var _ancestors2 = ancestors[ancestors.length - 1],
        key = _ancestors2.key,
        index = _ancestors2.index;
    return {
      parent: parent,
      key: key,
      index: index
    };
  }

  function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
    var plugins = (parserOpts.plugins || []).slice();

    if (syntacticPlaceholders !== false) {
      plugins.push("placeholders");
    }

    parserOpts = Object.assign({
      allowReturnOutsideFunction: true,
      allowSuperOutsideMethod: true,
      sourceType: "module"
    }, parserOpts, {
      plugins: plugins
    });

    try {
      return parse$8(code, parserOpts);
    } catch (err) {
      var loc = err.loc;

      if (loc) {
        err.message += "\n" + codeFrameColumns(code, {
          start: loc
        });
        err.code = "BABEL_TEMPLATE_PARSE_ERROR";
      }

      throw err;
    }
  }

  function populatePlaceholders(metadata, replacements) {
    var ast = cloneNode(metadata.ast);

    if (replacements) {
      metadata.placeholders.forEach(function (placeholder) {
        if (!Object.prototype.hasOwnProperty.call(replacements, placeholder.name)) {
          var placeholderName = placeholder.name;
          throw new Error("Error: No substitution given for \"" + placeholderName + "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['" + placeholderName + "'])}\n            - { placeholderPattern: /^" + placeholderName + "$/ }");
        }
      });
      Object.keys(replacements).forEach(function (key) {
        if (!metadata.placeholderNames.has(key)) {
          throw new Error("Unknown substitution \"" + key + "\" given");
        }
      });
    }

    metadata.placeholders.slice().reverse().forEach(function (placeholder) {
      try {
        applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
      } catch (e) {
        e.message = "@babel/template placeholder \"" + placeholder.name + "\": " + e.message;
        throw e;
      }
    });
    return ast;
  }

  function applyReplacement(placeholder, ast, replacement) {
    if (placeholder.isDuplicate) {
      if (Array.isArray(replacement)) {
        replacement = replacement.map(function (node) {
          return cloneNode(node);
        });
      } else if (typeof replacement === "object") {
        replacement = cloneNode(replacement);
      }
    }

    var _placeholder$resolve = placeholder.resolve(ast),
        parent = _placeholder$resolve.parent,
        key = _placeholder$resolve.key,
        index = _placeholder$resolve.index;

    if (placeholder.type === "string") {
      if (typeof replacement === "string") {
        replacement = stringLiteral(replacement);
      }

      if (!replacement || !isStringLiteral(replacement)) {
        throw new Error("Expected string substitution");
      }
    } else if (placeholder.type === "statement") {
      if (index === undefined) {
        if (!replacement) {
          replacement = emptyStatement();
        } else if (Array.isArray(replacement)) {
          replacement = blockStatement(replacement);
        } else if (typeof replacement === "string") {
          replacement = expressionStatement(identifier(replacement));
        } else if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        }
      } else {
        if (replacement && !Array.isArray(replacement)) {
          if (typeof replacement === "string") {
            replacement = identifier(replacement);
          }

          if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        }
      }
    } else if (placeholder.type === "param") {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }

      if (index === undefined) throw new Error("Assertion failure.");
    } else {
      if (typeof replacement === "string") {
        replacement = identifier(replacement);
      }

      if (Array.isArray(replacement)) {
        throw new Error("Cannot replace single expression with an array.");
      }
    }

    if (index === undefined) {
      validate$3(parent, key, replacement);
      parent[key] = replacement;
    } else {
      var items = parent[key].slice();

      if (placeholder.type === "statement" || placeholder.type === "param") {
        if (replacement == null) {
          items.splice(index, 1);
        } else if (Array.isArray(replacement)) {
          items.splice.apply(items, [index, 1].concat(_toConsumableArray(replacement)));
        } else {
          items[index] = replacement;
        }
      } else {
        items[index] = replacement;
      }

      validate$3(parent, key, items);
      parent[key] = items;
    }
  }

  function stringTemplate(formatter, code, opts) {
    code = formatter.code(code);
    var metadata;
    return function (arg) {
      var replacements = normalizeReplacements(arg);
      if (!metadata) metadata = parseAndBuildMetadata(formatter, code, opts);
      return formatter.unwrap(populatePlaceholders(metadata, replacements));
    };
  }

  function literalTemplate(formatter, tpl, opts) {
    var _buildLiteralData = buildLiteralData(formatter, tpl, opts),
        metadata = _buildLiteralData.metadata,
        names = _buildLiteralData.names;

    return function (arg) {
      var defaultReplacements = {};
      arg.forEach(function (replacement, i) {
        defaultReplacements[names[i]] = replacement;
      });
      return function (arg) {
        var replacements = normalizeReplacements(arg);

        if (replacements) {
          Object.keys(replacements).forEach(function (key) {
            if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {
              throw new Error("Unexpected replacement overlap.");
            }
          });
        }

        return formatter.unwrap(populatePlaceholders(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
      };
    };
  }

  function buildLiteralData(formatter, tpl, opts) {
    var names;
    var nameSet;
    var metadata;
    var prefix = "";

    do {
      prefix += "$";
      var result = buildTemplateCode(tpl, prefix);
      names = result.names;
      nameSet = new Set(names);
      metadata = parseAndBuildMetadata(formatter, formatter.code(result.code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
    } while (metadata.placeholders.some(function (placeholder) {
      return placeholder.isDuplicate && nameSet.has(placeholder.name);
    }));

    return {
      metadata: metadata,
      names: names
    };
  }

  function buildTemplateCode(tpl, prefix) {
    var names = [];
    var code = tpl[0];

    for (var i = 1; i < tpl.length; i++) {
      var value = "" + prefix + (i - 1);
      names.push(value);
      code += value + tpl[i];
    }

    return {
      names: names,
      code: code
    };
  }

  var NO_PLACEHOLDER = validate$1({
    placeholderPattern: false
  });
  function createTemplateBuilder(formatter, defaultOpts) {
    var templateFnCache = new WeakMap();
    var templateAstCache = new WeakMap();
    var cachedOpts = defaultOpts || validate$1(null);
    return Object.assign(function (tpl) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (typeof tpl === "string") {
        if (args.length > 1) throw new Error("Unexpected extra params.");
        return extendedTrace(stringTemplate(formatter, tpl, merge$1(cachedOpts, validate$1(args[0]))));
      } else if (Array.isArray(tpl)) {
        var builder = templateFnCache.get(tpl);

        if (!builder) {
          builder = literalTemplate(formatter, tpl, cachedOpts);
          templateFnCache.set(tpl, builder);
        }

        return extendedTrace(builder(args));
      } else if (typeof tpl === "object" && tpl) {
        if (args.length > 0) throw new Error("Unexpected extra params.");
        return createTemplateBuilder(formatter, merge$1(cachedOpts, validate$1(tpl)));
      }

      throw new Error("Unexpected template param " + typeof tpl);
    }, {
      ast: function ast(tpl) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return stringTemplate(formatter, tpl, merge$1(merge$1(cachedOpts, validate$1(args[0])), NO_PLACEHOLDER))();
        } else if (Array.isArray(tpl)) {
          var builder = templateAstCache.get(tpl);

          if (!builder) {
            builder = literalTemplate(formatter, tpl, merge$1(cachedOpts, NO_PLACEHOLDER));
            templateAstCache.set(tpl, builder);
          }

          return builder(args)();
        }

        throw new Error("Unexpected template param " + typeof tpl);
      }
    });
  }

  function extendedTrace(fn) {
    var rootStack = "";

    try {
      throw new Error();
    } catch (error) {
      if (error.stack) {
        rootStack = error.stack.split("\n").slice(3).join("\n");
      }
    }

    return function (arg) {
      try {
        return fn(arg);
      } catch (err) {
        err.stack += "\n    =============\n" + rootStack;
        throw err;
      }
    };
  }

  var smart = createTemplateBuilder(smart$1);
  var statement = createTemplateBuilder(statement$1);
  var statements = createTemplateBuilder(statements$1);
  var expression = createTemplateBuilder(expression$1);
  var program = createTemplateBuilder(program$1);
  var template$2 = Object.assign(smart.bind(undefined), {
    smart: smart,
    statement: statement,
    statements: statements,
    expression: expression,
    program: program,
    ast: smart.ast
  });

  var buildPropertyMethodAssignmentWrapper = template$2("\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var buildGeneratorPropertyMethodAssignmentWrapper = template$2("\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n");
  var visitor$2 = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      if (path.node.name !== state.name) return;
      var localDeclar = path.scope.getBindingIdentifier(state.name);
      if (localDeclar !== state.outerDeclar) return;
      state.selfReference = true;
      path.stop();
    }
  };

  function getNameFromLiteralId(id) {
    if (isNullLiteral(id)) {
      return "null";
    }

    if (isRegExpLiteral(id)) {
      return "_" + id.pattern + "_" + id.flags;
    }

    if (isTemplateLiteral(id)) {
      return id.quasis.map(function (quasi) {
        return quasi.value.raw;
      }).join("");
    }

    if (id.value !== undefined) {
      return id.value + "";
    }

    return "";
  }

  function wrap$1(state, method, id, scope) {
    if (state.selfReference) {
      if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
        scope.rename(id.name);
      } else {
        if (!isFunction$1(method)) return;
        var build = buildPropertyMethodAssignmentWrapper;

        if (method.generator) {
          build = buildGeneratorPropertyMethodAssignmentWrapper;
        }

        var _template = build({
          FUNCTION: method,
          FUNCTION_ID: id,
          FUNCTION_KEY: scope.generateUidIdentifier(id.name)
        }).expression;
        var params = _template.callee.body.body[0].params;

        for (var i = 0, len = getFunctionArity(method); i < len; i++) {
          params.push(scope.generateUidIdentifier("x"));
        }

        return _template;
      }
    }

    method.id = id;
    scope.getProgramParent().references[id.name] = true;
  }

  function visit$2(node, name, scope) {
    var state = {
      selfAssignment: false,
      selfReference: false,
      outerDeclar: scope.getBindingIdentifier(name),
      references: [],
      name: name
    };
    var binding = scope.getOwnBinding(name);

    if (binding) {
      if (binding.kind === "param") {
        state.selfReference = true;
      }
    } else if (state.outerDeclar || scope.hasGlobal(name)) {
      scope.traverse(node, visitor$2, state);
    }

    return state;
  }

  function nameFunction (_ref, localBinding) {
    var node = _ref.node,
        parent = _ref.parent,
        scope = _ref.scope,
        id = _ref.id;

    if (localBinding === void 0) {
      localBinding = false;
    }

    if (node.id) return;

    if ((isObjectProperty(parent) || isObjectMethod(parent, {
      kind: "method"
    })) && (!parent.computed || isLiteral(parent.key))) {
      id = parent.key;
    } else if (isVariableDeclarator(parent)) {
      id = parent.id;

      if (isIdentifier(id) && !localBinding) {
        var binding = scope.parent.getBinding(id.name);

        if (binding && binding.constant && scope.getBinding(id.name) === binding) {
          node.id = cloneNode(id);
          node.id[NOT_LOCAL_BINDING] = true;
          return;
        }
      }
    } else if (isAssignmentExpression(parent, {
      operator: "="
    })) {
      id = parent.left;
    } else if (!id) {
      return;
    }

    var name;

    if (id && isLiteral(id)) {
      name = getNameFromLiteralId(id);
    } else if (id && isIdentifier(id)) {
      name = id.name;
    }

    if (name === undefined) {
      return;
    }

    name = toBindingIdentifierName(name);
    id = identifier(name);
    id[NOT_LOCAL_BINDING] = true;
    var state = visit$2(node, name, scope);
    return wrap$1(state, node, id, scope) || node;
  }

  function toComputedKey() {
    var key;

    if (this.isMemberExpression()) {
      key = this.node.property;
    } else if (this.isProperty() || this.isMethod()) {
      key = this.node.key;
    } else {
      throw new ReferenceError("todo");
    }

    if (!this.node.computed) {
      if (isIdentifier(key)) key = stringLiteral(key.name);
    }

    return key;
  }
  function ensureBlock() {
    var body = this.get("body");
    var bodyNode = body.node;

    if (Array.isArray(body)) {
      throw new Error("Can't convert array path to a block statement");
    }

    if (!bodyNode) {
      throw new Error("Can't convert node without a body");
    }

    if (body.isBlockStatement()) {
      return bodyNode;
    }

    var statements = [];
    var stringPath = "body";
    var key;
    var listKey;

    if (body.isStatement()) {
      listKey = "body";
      key = 0;
      statements.push(body.node);
    } else {
      stringPath += ".body.0";

      if (this.isFunction()) {
        key = "argument";
        statements.push(returnStatement(body.node));
      } else {
        key = "expression";
        statements.push(expressionStatement(body.node));
      }
    }

    this.node.body = blockStatement(statements);
    var parentPath = this.get(stringPath);
    body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
    return this.node;
  }
  function arrowFunctionToShadowed() {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  }
  function unwrapFunctionEnvironment() {
    if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
      throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
    }

    hoistFunctionEnvironment(this);
  }
  function arrowFunctionToExpression(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$allowInsertArrow = _ref.allowInsertArrow,
        allowInsertArrow = _ref$allowInsertArrow === void 0 ? true : _ref$allowInsertArrow,
        _ref$specCompliant = _ref.specCompliant,
        specCompliant = _ref$specCompliant === void 0 ? false : _ref$specCompliant,
        _ref$noNewArrows = _ref.noNewArrows,
        noNewArrows = _ref$noNewArrows === void 0 ? !specCompliant : _ref$noNewArrows;

    if (!this.isArrowFunctionExpression()) {
      throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
    }

    var thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);
    this.ensureBlock();
    this.node.type = "FunctionExpression";

    if (!noNewArrows) {
      var checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier("arrowCheckId");

      if (checkBinding) {
        this.parentPath.scope.push({
          id: checkBinding,
          init: objectExpression([])
        });
      }

      this.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
      this.replaceWith(callExpression(memberExpression(nameFunction(this, true) || this.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    }
  }

  function hoistFunctionEnvironment(fnPath, noNewArrows, allowInsertArrow) {
    if (noNewArrows === void 0) {
      noNewArrows = true;
    }

    if (allowInsertArrow === void 0) {
      allowInsertArrow = true;
    }

    var thisEnvFn = fnPath.findParent(function (p) {
      return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({
        "static": false
      });
    });
    var inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === "constructor";

    if (thisEnvFn.isClassProperty()) {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    }

    var _getScopeInformation = getScopeInformation(fnPath),
        thisPaths = _getScopeInformation.thisPaths,
        argumentsPaths = _getScopeInformation.argumentsPaths,
        newTargetPaths = _getScopeInformation.newTargetPaths,
        superProps = _getScopeInformation.superProps,
        superCalls = _getScopeInformation.superCalls;

    if (inConstructor && superCalls.length > 0) {
      if (!allowInsertArrow) {
        throw superCalls[0].buildCodeFrameError("Unable to handle nested super() usage in arrow");
      }

      var allSuperCalls = [];
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          allSuperCalls.push(child);
        }
      });
      var superBinding = getSuperBinding(thisEnvFn);
      allSuperCalls.forEach(function (superCall) {
        var callee = identifier(superBinding);
        callee.loc = superCall.node.callee.loc;
        superCall.get("callee").replaceWith(callee);
      });
    }

    if (argumentsPaths.length > 0) {
      var argumentsBinding = getBinding(thisEnvFn, "arguments", function () {
        return identifier("arguments");
      });
      argumentsPaths.forEach(function (argumentsChild) {
        var argsRef = identifier(argumentsBinding);
        argsRef.loc = argumentsChild.node.loc;
        argumentsChild.replaceWith(argsRef);
      });
    }

    if (newTargetPaths.length > 0) {
      var newTargetBinding = getBinding(thisEnvFn, "newtarget", function () {
        return metaProperty(identifier("new"), identifier("target"));
      });
      newTargetPaths.forEach(function (targetChild) {
        var targetRef = identifier(newTargetBinding);
        targetRef.loc = targetChild.node.loc;
        targetChild.replaceWith(targetRef);
      });
    }

    if (superProps.length > 0) {
      if (!allowInsertArrow) {
        throw superProps[0].buildCodeFrameError("Unable to handle nested super.prop usage");
      }

      var flatSuperProps = superProps.reduce(function (acc, superProp) {
        return acc.concat(standardizeSuperProperty(superProp));
      }, []);
      flatSuperProps.forEach(function (superProp) {
        var key = superProp.node.computed ? "" : superProp.get("property").node.name;
        var isAssignment = superProp.parentPath.isAssignmentExpression({
          left: superProp.node
        });
        var isCall = superProp.parentPath.isCallExpression({
          callee: superProp.node
        });
        var superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
        var args = [];

        if (superProp.node.computed) {
          args.push(superProp.get("property").node);
        }

        if (isAssignment) {
          var value = superProp.parentPath.node.right;
          args.push(value);
        }

        var call = callExpression(identifier(superBinding), args);

        if (isCall) {
          superProp.parentPath.unshiftContainer("arguments", thisExpression());
          superProp.replaceWith(memberExpression(call, identifier("call")));
          thisPaths.push(superProp.parentPath.get("arguments.0"));
        } else if (isAssignment) {
          superProp.parentPath.replaceWith(call);
        } else {
          superProp.replaceWith(call);
        }
      });
    }

    var thisBinding;

    if (thisPaths.length > 0 || !noNewArrows) {
      thisBinding = getThisBinding(thisEnvFn, inConstructor);

      if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
        thisPaths.forEach(function (thisChild) {
          var thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
          thisRef.loc = thisChild.node.loc;
          thisChild.replaceWith(thisRef);
        });
        if (!noNewArrows) thisBinding = null;
      }
    }

    return thisBinding;
  }

  function standardizeSuperProperty(superProp) {
    if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
      var assignmentPath = superProp.parentPath;
      var op = assignmentPath.node.operator.slice(0, -1);
      var value = assignmentPath.node.right;
      assignmentPath.node.operator = "=";

      if (superProp.node.computed) {
        var tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        assignmentPath.get("left").replaceWith(memberExpression(superProp.node.object, assignmentExpression("=", tmp, superProp.node.property), true));
        assignmentPath.get("right").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));
      } else {
        assignmentPath.get("left").replaceWith(memberExpression(superProp.node.object, superProp.node.property));
        assignmentPath.get("right").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));
      }

      return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
    } else if (superProp.parentPath.isUpdateExpression()) {
      var updateExpr = superProp.parentPath;

      var _tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");

      var computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
      var parts = [assignmentExpression("=", _tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression("+", identifier(_tmp.name), numericLiteral(1)))];

      if (!superProp.parentPath.node.prefix) {
        parts.push(identifier(_tmp.name));
      }

      updateExpr.replaceWith(sequenceExpression(parts));
      var left = updateExpr.get("expressions.0.right");
      var right = updateExpr.get("expressions.1.left");
      return [left, right];
    }

    return [superProp];
  }

  function hasSuperClass(thisEnvFn) {
    return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
  }

  function getThisBinding(thisEnvFn, inConstructor) {
    return getBinding(thisEnvFn, "this", function (thisBinding) {
      if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
      var supers = new WeakSet();
      thisEnvFn.traverse({
        Function: function Function(child) {
          if (child.isArrowFunctionExpression()) return;
          child.skip();
        },
        ClassProperty: function ClassProperty(child) {
          child.skip();
        },
        CallExpression: function CallExpression(child) {
          if (!child.get("callee").isSuper()) return;
          if (supers.has(child.node)) return;
          supers.add(child.node);
          child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
        }
      });
    });
  }

  function getSuperBinding(thisEnvFn) {
    return getBinding(thisEnvFn, "supercall", function () {
      var argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
      return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
    });
  }

  function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
    var op = isAssignment ? "set" : "get";
    return getBinding(thisEnvFn, "superprop_" + op + ":" + (propName || ""), function () {
      var argsList = [];
      var fnBody;

      if (propName) {
        fnBody = memberExpression(_super(), identifier(propName));
      } else {
        var method = thisEnvFn.scope.generateUidIdentifier("prop");
        argsList.unshift(method);
        fnBody = memberExpression(_super(), identifier(method.name), true);
      }

      if (isAssignment) {
        var valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
        argsList.push(valueIdent);
        fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
      }

      return arrowFunctionExpression(argsList, fnBody);
    });
  }

  function getBinding(thisEnvFn, key, init) {
    var cacheKey = "binding:" + key;
    var data = thisEnvFn.getData(cacheKey);

    if (!data) {
      var id = thisEnvFn.scope.generateUidIdentifier(key);
      data = id.name;
      thisEnvFn.setData(cacheKey, data);
      thisEnvFn.scope.push({
        id: id,
        init: init(data)
      });
    }

    return data;
  }

  function getScopeInformation(fnPath) {
    var thisPaths = [];
    var argumentsPaths = [];
    var newTargetPaths = [];
    var superProps = [];
    var superCalls = [];
    fnPath.traverse({
      ClassProperty: function ClassProperty(child) {
        child.skip();
      },
      Function: function Function(child) {
        if (child.isArrowFunctionExpression()) return;
        child.skip();
      },
      ThisExpression: function ThisExpression(child) {
        thisPaths.push(child);
      },
      JSXIdentifier: function JSXIdentifier(child) {
        if (child.node.name !== "this") return;

        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }

        thisPaths.push(child);
      },
      CallExpression: function CallExpression(child) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression: function MemberExpression(child) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        if (child.node.name !== "arguments") return;
        argumentsPaths.push(child);
      },
      MetaProperty: function MetaProperty(child) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    return {
      thisPaths: thisPaths,
      argumentsPaths: argumentsPaths,
      newTargetPaths: newTargetPaths,
      superProps: superProps,
      superCalls: superCalls
    };
  }

  var NodePath_conversion = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toComputedKey: toComputedKey,
    ensureBlock: ensureBlock,
    arrowFunctionToShadowed: arrowFunctionToShadowed,
    unwrapFunctionEnvironment: unwrapFunctionEnvironment,
    arrowFunctionToExpression: arrowFunctionToExpression
  });

  function matchesPattern(pattern, allowPartial) {
    return matchesPattern$1(this.node, pattern, allowPartial);
  }
  function has$b(key) {
    var val = this.node && this.node[key];

    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }
  function isStatic() {
    return this.scope.isStatic(this.node);
  }
  var is = has$b;
  function isnt(key) {
    return !this.has(key);
  }
  function equals(key, value) {
    return this.node[key] === value;
  }
  function isNodeType(type) {
    return isType$1(this.type, type);
  }
  function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
  }
  function canSwapBetweenExpressionAndStatement(replacement) {
    if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
      return false;
    }

    if (this.isExpression()) {
      return isBlockStatement(replacement);
    } else if (this.isBlockStatement()) {
      return isExpression(replacement);
    }

    return false;
  }
  function isCompletionRecord(allowInsideFunction) {
    var path = this;
    var first = true;

    do {
      var container = path.container;

      if (path.isFunction() && !first) {
        return !!allowInsideFunction;
      }

      first = false;

      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());

    return true;
  }
  function isStatementOrBlock() {
    if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
      return false;
    } else {
      return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
    }
  }
  function referencesImport(moduleSource, importName) {
    if (!this.isReferencedIdentifier()) {
      if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
        value: importName
      }) : this.node.property.name === importName)) {
        var object = this.get("object");
        return object.isReferencedIdentifier() && object.referencesImport(moduleSource, "*");
      }

      return false;
    }

    var binding = this.scope.getBinding(this.node.name);
    if (!binding || binding.kind !== "module") return false;
    var path = binding.path;
    var parent = path.parentPath;
    if (!parent.isImportDeclaration()) return false;

    if (parent.node.source.value === moduleSource) {
      if (!importName) return true;
    } else {
      return false;
    }

    if (path.isImportDefaultSpecifier() && importName === "default") {
      return true;
    }

    if (path.isImportNamespaceSpecifier() && importName === "*") {
      return true;
    }

    if (path.isImportSpecifier() && isIdentifier(path.node.imported, {
      name: importName
    })) {
      return true;
    }

    return false;
  }
  function getSource$1() {
    var node = this.node;

    if (node.end) {
      var code = this.hub.getCode();
      if (code) return code.slice(node.start, node.end);
    }

    return "";
  }
  function willIMaybeExecuteBefore(target) {
    return this._guessExecutionStatusRelativeTo(target) !== "after";
  }

  function getOuterFunction(path) {
    return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;
  }

  function isExecutionUncertain(type, key) {
    switch (type) {
      case "LogicalExpression":
        return key === "right";

      case "ConditionalExpression":
      case "IfStatement":
        return key === "consequent" || key === "alternate";

      case "WhileStatement":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForOfStatement":
        return key === "body";

      case "ForStatement":
        return key === "body" || key === "update";

      case "SwitchStatement":
        return key === "cases";

      case "TryStatement":
        return key === "handler";

      case "AssignmentPattern":
        return key === "right";

      case "OptionalMemberExpression":
        return key === "property";

      case "OptionalCallExpression":
        return key === "arguments";

      default:
        return false;
    }
  }

  function isExecutionUncertainInList(paths, maxIndex) {
    for (var i = 0; i < maxIndex; i++) {
      var path = paths[i];

      if (isExecutionUncertain(path.parent.type, path.parentKey)) {
        return true;
      }
    }

    return false;
  }

  function _guessExecutionStatusRelativeTo(target) {
    var funcParent = {
      "this": getOuterFunction(this),
      target: getOuterFunction(target)
    };

    if (funcParent.target.node !== funcParent["this"].node) {
      return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);
    }

    var paths = {
      target: target.getAncestry(),
      "this": this.getAncestry()
    };
    if (paths.target.indexOf(this) >= 0) return "after";
    if (paths["this"].indexOf(target) >= 0) return "before";
    var commonPath;
    var commonIndex = {
      target: 0,
      "this": 0
    };

    while (!commonPath && commonIndex["this"] < paths["this"].length) {
      var path = paths["this"][commonIndex["this"]];
      commonIndex.target = paths.target.indexOf(path);

      if (commonIndex.target >= 0) {
        commonPath = path;
      } else {
        commonIndex["this"]++;
      }
    }

    if (!commonPath) {
      throw new Error("Internal Babel error - The two compared nodes" + " don't appear to belong to the same program.");
    }

    if (isExecutionUncertainInList(paths["this"], commonIndex["this"] - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
      return "unknown";
    }

    var divergence = {
      "this": paths["this"][commonIndex["this"] - 1],
      target: paths.target[commonIndex.target - 1]
    };

    if (divergence.target.listKey && divergence["this"].listKey && divergence.target.container === divergence["this"].container) {
      return divergence.target.key > divergence["this"].key ? "before" : "after";
    }

    var keys = VISITOR_KEYS[commonPath.type];
    var keyPosition = {
      "this": keys.indexOf(divergence["this"].parentKey),
      target: keys.indexOf(divergence.target.parentKey)
    };
    return keyPosition.target > keyPosition["this"] ? "before" : "after";
  }
  var executionOrderCheckedNodes = new WeakSet();
  function _guessExecutionStatusRelativeToDifferentFunctions(target) {
    if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {
      return "unknown";
    }

    var binding = target.scope.getBinding(target.node.id.name);
    if (!binding.references) return "before";
    var referencePaths = binding.referencePaths;
    var allStatus;

    for (var _iterator = _createForOfIteratorHelperLoose(referencePaths), _step; !(_step = _iterator()).done;) {
      var path = _step.value;
      var childOfFunction = !!path.find(function (path) {
        return path.node === target.node;
      });
      if (childOfFunction) continue;

      if (path.key !== "callee" || !path.parentPath.isCallExpression()) {
        return "unknown";
      }

      if (executionOrderCheckedNodes.has(path.node)) continue;
      executionOrderCheckedNodes.add(path.node);

      var status = this._guessExecutionStatusRelativeTo(path);

      executionOrderCheckedNodes["delete"](path.node);

      if (allStatus && allStatus !== status) {
        return "unknown";
      } else {
        allStatus = status;
      }
    }

    return allStatus;
  }
  function resolve$4(dangerous, resolved) {
    return this._resolve(dangerous, resolved) || this;
  }
  function _resolve(dangerous, resolved) {
    if (resolved && resolved.indexOf(this) >= 0) return;
    resolved = resolved || [];
    resolved.push(this);

    if (this.isVariableDeclarator()) {
      if (this.get("id").isIdentifier()) {
        return this.get("init").resolve(dangerous, resolved);
      }
    } else if (this.isReferencedIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return;
      if (!binding.constant) return;
      if (binding.kind === "module") return;

      if (binding.path !== this) {
        var ret = binding.path.resolve(dangerous, resolved);
        if (this.find(function (parent) {
          return parent.node === ret.node;
        })) return;
        return ret;
      }
    } else if (this.isTypeCastExpression()) {
      return this.get("expression").resolve(dangerous, resolved);
    } else if (dangerous && this.isMemberExpression()) {
      var targetKey = this.toComputedKey();
      if (!isLiteral(targetKey)) return;
      var targetName = targetKey.value;
      var target = this.get("object").resolve(dangerous, resolved);

      if (target.isObjectExpression()) {
        var props = target.get("properties");

        for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;
          if (!prop.isProperty()) continue;
          var key = prop.get("key");
          var match = prop.isnt("computed") && key.isIdentifier({
            name: targetName
          });
          match = match || key.isLiteral({
            value: targetName
          });
          if (match) return prop.get("value").resolve(dangerous, resolved);
        }
      } else if (target.isArrayExpression() && !isNaN(+targetName)) {
        var elems = target.get("elements");
        var elem = elems[targetName];
        if (elem) return elem.resolve(dangerous, resolved);
      }
    }
  }
  function isConstantExpression() {
    if (this.isIdentifier()) {
      var binding = this.scope.getBinding(this.node.name);
      if (!binding) return false;
      return binding.constant;
    }

    if (this.isLiteral()) {
      if (this.isRegExpLiteral()) {
        return false;
      }

      if (this.isTemplateLiteral()) {
        return this.get("expressions").every(function (expression) {
          return expression.isConstantExpression();
        });
      }

      return true;
    }

    if (this.isUnaryExpression()) {
      if (this.node.operator !== "void") {
        return false;
      }

      return this.get("argument").isConstantExpression();
    }

    if (this.isBinaryExpression()) {
      return this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
    }

    return false;
  }
  function isInStrictMode() {
    var start = this.isProgram() ? this : this.parentPath;
    var strictParent = start.find(function (path) {
      if (path.isProgram({
        sourceType: "module"
      })) return true;
      if (path.isClass()) return true;
      if (!path.isProgram() && !path.isFunction()) return false;

      if (path.isArrowFunctionExpression() && !path.get("body").isBlockStatement()) {
        return false;
      }

      var body = path.isFunction() ? path.node.body : path.node;

      for (var _iterator3 = _createForOfIteratorHelperLoose(body.directives), _step3; !(_step3 = _iterator3()).done;) {
        var directive = _step3.value;

        if (directive.value.value === "use strict") {
          return true;
        }
      }
    });
    return !!strictParent;
  }

  var NodePath_introspection = /*#__PURE__*/Object.freeze({
    __proto__: null,
    matchesPattern: matchesPattern,
    has: has$b,
    isStatic: isStatic,
    is: is,
    isnt: isnt,
    equals: equals,
    isNodeType: isNodeType,
    canHaveVariableDeclarationOrExpression: canHaveVariableDeclarationOrExpression,
    canSwapBetweenExpressionAndStatement: canSwapBetweenExpressionAndStatement,
    isCompletionRecord: isCompletionRecord,
    isStatementOrBlock: isStatementOrBlock,
    referencesImport: referencesImport,
    getSource: getSource$1,
    willIMaybeExecuteBefore: willIMaybeExecuteBefore,
    _guessExecutionStatusRelativeTo: _guessExecutionStatusRelativeTo,
    _guessExecutionStatusRelativeToDifferentFunctions: _guessExecutionStatusRelativeToDifferentFunctions,
    resolve: resolve$4,
    _resolve: _resolve,
    isConstantExpression: isConstantExpression,
    isInStrictMode: isInStrictMode
  });

  function call(key) {
    var opts = this.opts;
    this.debug(key);

    if (this.node) {
      if (this._call(opts[key])) return true;
    }

    if (this.node) {
      return this._call(opts[this.node.type] && opts[this.node.type][key]);
    }

    return false;
  }
  function _call(fns) {
    if (!fns) return false;

    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {
      var fn = _step.value;
      if (!fn) continue;
      var node = this.node;
      if (!node) return true;
      var ret = fn.call(this.state, this, this.state);

      if (ret && typeof ret === "object" && typeof ret.then === "function") {
        throw new Error("You appear to be using a plugin with an async traversal visitor, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");
      }

      if (ret) {
        throw new Error("Unexpected return value from visitor method " + fn);
      }

      if (this.node !== node) return true;
      if (this._traverseFlags > 0) return true;
    }

    return false;
  }
  function isDenylisted() {
    var _this$opts$denylist;

    var denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
    return denylist && denylist.indexOf(this.node.type) > -1;
  }
  function visit$1() {
    if (!this.node) {
      return false;
    }

    if (this.isDenylisted()) {
      return false;
    }

    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {
      return false;
    }

    if (this.shouldSkip || this.call("enter") || this.shouldSkip) {
      this.debug("Skip...");
      return this.shouldStop;
    }

    this.debug("Recursing into...");
    traverse.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
    this.call("exit");
    return this.shouldStop;
  }
  function skip() {
    this.shouldSkip = true;
  }
  function skipKey(key) {
    if (this.skipKeys == null) {
      this.skipKeys = {};
    }

    this.skipKeys[key] = true;
  }
  function stop() {
    this._traverseFlags |= SHOULD_SKIP | SHOULD_STOP;
  }
  function setScope() {
    if (this.opts && this.opts.noScope) return;
    var path = this.parentPath;
    if (this.key === "key" && path.isMethod()) path = path.parentPath;
    var target;

    while (path && !target) {
      if (path.opts && path.opts.noScope) return;
      target = path.scope;
      path = path.parentPath;
    }

    this.scope = this.getScope(target);
    if (this.scope) this.scope.init();
  }
  function setContext(context) {
    if (this.skipKeys != null) {
      this.skipKeys = {};
    }

    this._traverseFlags = 0;

    if (context) {
      this.context = context;
      this.state = context.state;
      this.opts = context.opts;
    }

    this.setScope();
    return this;
  }
  function resync() {
    if (this.removed) return;

    this._resyncParent();

    this._resyncList();

    this._resyncKey();
  }
  function _resyncParent() {
    if (this.parentPath) {
      this.parent = this.parentPath.node;
    }
  }
  function _resyncKey() {
    if (!this.container) return;
    if (this.node === this.container[this.key]) return;

    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (var _i = 0, _Object$keys = Object.keys(this.container); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];

        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }

    this.key = null;
  }
  function _resyncList() {
    if (!this.parent || !this.inList) return;
    var newContainer = this.parent[this.listKey];
    if (this.container === newContainer) return;
    this.container = newContainer || null;
  }
  function _resyncRemoved() {
    if (this.key == null || !this.container || this.container[this.key] !== this.node) {
      this._markRemoved();
    }
  }
  function popContext() {
    this.contexts.pop();

    if (this.contexts.length > 0) {
      this.setContext(this.contexts[this.contexts.length - 1]);
    } else {
      this.setContext(undefined);
    }
  }
  function pushContext(context) {
    this.contexts.push(context);
    this.setContext(context);
  }
  function setup$1(parentPath, container, listKey, key) {
    this.listKey = listKey;
    this.container = container;
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }
  function setKey(key) {
    var _this$node;

    this.key = key;
    this.node = this.container[this.key];
    this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
  }
  function requeue(pathToQueue) {
    if (pathToQueue === void 0) {
      pathToQueue = this;
    }

    if (pathToQueue.removed) return;
    var contexts = this.contexts;

    for (var _iterator2 = _createForOfIteratorHelperLoose(contexts), _step2; !(_step2 = _iterator2()).done;) {
      var context = _step2.value;
      context.maybeQueue(pathToQueue);
    }
  }
  function _getQueueContexts() {
    var path = this;
    var contexts = this.contexts;

    while (!contexts.length) {
      path = path.parentPath;
      if (!path) break;
      contexts = path.contexts;
    }

    return contexts;
  }

  var NodePath_context = /*#__PURE__*/Object.freeze({
    __proto__: null,
    call: call,
    _call: _call,
    isDenylisted: isDenylisted,
    isBlacklisted: isDenylisted,
    visit: visit$1,
    skip: skip,
    skipKey: skipKey,
    stop: stop,
    setScope: setScope,
    setContext: setContext,
    resync: resync,
    _resyncParent: _resyncParent,
    _resyncKey: _resyncKey,
    _resyncList: _resyncList,
    _resyncRemoved: _resyncRemoved,
    popContext: popContext,
    pushContext: pushContext,
    setup: setup$1,
    setKey: setKey,
    requeue: requeue,
    _getQueueContexts: _getQueueContexts
  });

  var hooks = [function (self, parent) {
    var removeParent = self.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self.key === "declaration" && parent.isExportDeclaration() || self.key === "body" && parent.isLabeledStatement() || self.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === "expression" && parent.isExpressionStatement();

    if (removeParent) {
      parent.remove();
      return true;
    }
  }, function (self, parent) {
    if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
      parent.replaceWith(parent.node.expressions[0]);
      return true;
    }
  }, function (self, parent) {
    if (parent.isBinary()) {
      if (self.key === "left") {
        parent.replaceWith(parent.node.right);
      } else {
        parent.replaceWith(parent.node.left);
      }

      return true;
    }
  }, function (self, parent) {
    if (parent.isIfStatement() && (self.key === "consequent" || self.key === "alternate") || self.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
      self.replaceWith({
        type: "BlockStatement",
        body: []
      });
      return true;
    }
  }];

  function remove() {
    var _this$opts;

    this._assertUnremoved();

    this.resync();

    if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
      this._removeFromScope();
    }

    if (this._callRemovalHooks()) {
      this._markRemoved();

      return;
    }

    this.shareCommentsWithSiblings();

    this._remove();

    this._markRemoved();
  }
  function _removeFromScope() {
    var _this = this;

    var bindings = this.getBindingIdentifiers();
    Object.keys(bindings).forEach(function (name) {
      return _this.scope.removeBinding(name);
    });
  }
  function _callRemovalHooks() {
    for (var _iterator = _createForOfIteratorHelperLoose(hooks), _step; !(_step = _iterator()).done;) {
      var fn = _step.value;
      if (fn(this, this.parentPath)) return true;
    }
  }
  function _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this._replaceWith(null);
    }
  }
  function _markRemoved() {
    this._traverseFlags |= SHOULD_SKIP | REMOVED;
    if (this.parent) path$3.get(this.parent)["delete"](this.node);
    this.node = null;
  }
  function _assertUnremoved() {
    if (this.removed) {
      throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
    }
  }

  var NodePath_removal = /*#__PURE__*/Object.freeze({
    __proto__: null,
    remove: remove,
    _removeFromScope: _removeFromScope,
    _callRemovalHooks: _callRemovalHooks,
    _remove: _remove,
    _markRemoved: _markRemoved,
    _assertUnremoved: _assertUnremoved
  });

  var referenceVisitor$1 = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {
        return;
      }

      if (path.node.name === "this") {
        var scope = path.scope;

        do {
          if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
        } while (scope = scope.parent);

        if (scope) state.breakOnScopePaths.push(scope.path);
      }

      var binding = path.scope.getBinding(path.node.name);
      if (!binding) return;

      for (var _iterator = _createForOfIteratorHelperLoose(binding.constantViolations), _step; !(_step = _iterator()).done;) {
        var violation = _step.value;

        if (violation.scope !== binding.path.scope) {
          state.mutableBinding = true;
          path.stop();
          return;
        }
      }

      if (binding !== state.scope.getBinding(path.node.name)) return;
      state.bindings[path.node.name] = binding;
    }
  };

  var PathHoister = function () {
    function PathHoister(path, scope) {
      this.breakOnScopePaths = void 0;
      this.bindings = void 0;
      this.mutableBinding = void 0;
      this.scopes = void 0;
      this.scope = void 0;
      this.path = void 0;
      this.attachAfter = void 0;
      this.breakOnScopePaths = [];
      this.bindings = {};
      this.mutableBinding = false;
      this.scopes = [];
      this.scope = scope;
      this.path = path;
      this.attachAfter = false;
    }

    var _proto = PathHoister.prototype;

    _proto.isCompatibleScope = function isCompatibleScope(scope) {
      for (var _i = 0, _Object$keys = Object.keys(this.bindings); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var binding = this.bindings[key];

        if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
          return false;
        }
      }

      return true;
    };

    _proto.getCompatibleScopes = function getCompatibleScopes() {
      var scope = this.path.scope;

      do {
        if (this.isCompatibleScope(scope)) {
          this.scopes.push(scope);
        } else {
          break;
        }

        if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {
          break;
        }
      } while (scope = scope.parent);
    };

    _proto.getAttachmentPath = function getAttachmentPath() {
      var path = this._getAttachmentPath();

      if (!path) return;
      var targetScope = path.scope;

      if (targetScope.path === path) {
        targetScope = path.scope.parent;
      }

      if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(this.bindings); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];
          if (!targetScope.hasOwnBinding(name)) continue;
          var binding = this.bindings[name];

          if (binding.kind === "param" || binding.path.parentKey === "params") {
            continue;
          }

          var bindingParentPath = this.getAttachmentParentForPath(binding.path);

          if (bindingParentPath.key >= path.key) {
            this.attachAfter = true;
            path = binding.path;

            for (var _iterator2 = _createForOfIteratorHelperLoose(binding.constantViolations), _step2; !(_step2 = _iterator2()).done;) {
              var violationPath = _step2.value;

              if (this.getAttachmentParentForPath(violationPath).key > path.key) {
                path = violationPath;
              }
            }
          }
        }
      }

      return path;
    };

    _proto._getAttachmentPath = function _getAttachmentPath() {
      var scopes = this.scopes;
      var scope = scopes.pop();
      if (!scope) return;

      if (scope.path.isFunction()) {
        if (this.hasOwnParamBindings(scope)) {
          if (this.scope === scope) return;
          var bodies = scope.path.get("body").get("body");

          for (var i = 0; i < bodies.length; i++) {
            if (bodies[i].node._blockHoist) continue;
            return bodies[i];
          }
        } else {
          return this.getNextScopeAttachmentParent();
        }
      } else if (scope.path.isProgram()) {
        return this.getNextScopeAttachmentParent();
      }
    };

    _proto.getNextScopeAttachmentParent = function getNextScopeAttachmentParent() {
      var scope = this.scopes.pop();
      if (scope) return this.getAttachmentParentForPath(scope.path);
    };

    _proto.getAttachmentParentForPath = function getAttachmentParentForPath(path) {
      do {
        if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
          return path;
        }
      } while (path = path.parentPath);
    };

    _proto.hasOwnParamBindings = function hasOwnParamBindings(scope) {
      for (var _i3 = 0, _Object$keys3 = Object.keys(this.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        if (!scope.hasOwnBinding(name)) continue;
        var binding = this.bindings[name];
        if (binding.kind === "param" && binding.constant) return true;
      }

      return false;
    };

    _proto.run = function run() {
      this.path.traverse(referenceVisitor$1, this);
      if (this.mutableBinding) return;
      this.getCompatibleScopes();
      var attachTo = this.getAttachmentPath();
      if (!attachTo) return;
      if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
      var uid = attachTo.scope.generateUidIdentifier("ref");
      var declarator = variableDeclarator(uid, this.path.node);
      var insertFn = this.attachAfter ? "insertAfter" : "insertBefore";

      var _attachTo$insertFn = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]),
          _attachTo$insertFn2 = _slicedToArray$2(_attachTo$insertFn, 1),
          attached = _attachTo$insertFn2[0];

      var parent = this.path.parentPath;

      if (parent.isJSXElement() && this.path.container === parent.node.children) {
        uid = jsxExpressionContainer(uid);
      }

      this.path.replaceWith(cloneNode(uid));
      return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
    };

    return PathHoister;
  }();

  function insertBefore(nodes_) {
    this._assertUnremoved();

    var nodes = this._verifyNodeList(nodes_);

    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertBefore(nodes);
    } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) nodes.push(this.node);
      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertBefore(nodes);
    } else if (this.isStatementOrBlock()) {
      var node = this.node;
      var shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));
      return this.unshiftContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function _containerInsert(from, nodes) {
    var _this$container;

    this.updateSiblingKeys(from, nodes.length);
    var paths = [];

    (_this$container = this.container).splice.apply(_this$container, [from, 0].concat(_toConsumableArray(nodes)));

    for (var i = 0; i < nodes.length; i++) {
      var to = from + i;
      var path = this.getSibling(to);
      paths.push(path);

      if (this.context && this.context.queue) {
        path.pushContext(this.context);
      }
    }

    var contexts = this._getQueueContexts();

    for (var _i = 0, _paths = paths; _i < _paths.length; _i++) {
      var _path = _paths[_i];

      _path.setScope();

      _path.debug("Inserted.");

      for (var _iterator = _createForOfIteratorHelperLoose(contexts), _step; !(_step = _iterator()).done;) {
        var context = _step.value;
        context.maybeQueue(_path, true);
      }
    }

    return paths;
  }
  function _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }
  function _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }
  function insertAfter(nodes_) {
    this._assertUnremoved();

    var nodes = this._verifyNodeList(nodes_);

    var parentPath = this.parentPath;

    if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
      return parentPath.insertAfter(nodes.map(function (node) {
        return isExpression(node) ? expressionStatement(node) : node;
      }));
    } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
      if (this.node) {
        var node = this.node;
        var scope = this.scope;

        if (scope.path.isPattern()) {
          assertExpression(node);
          this.replaceWith(callExpression(arrowFunctionExpression([], node), []));
          this.get("callee.body").insertAfter(nodes);
          return [this];
        }

        if (parentPath.isMethod({
          computed: true,
          key: node
        })) {
          scope = scope.parent;
        }

        var temp = scope.generateDeclaredUidIdentifier();
        nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node)));
        nodes.push(expressionStatement(cloneNode(temp)));
      }

      return this.replaceExpressionWithStatements(nodes);
    } else if (Array.isArray(this.container)) {
      return this._containerInsertAfter(nodes);
    } else if (this.isStatementOrBlock()) {
      var _node = this.node;
      var shouldInsertCurrentNode = _node && (!this.isExpressionStatement() || _node.expression != null);
      this.replaceWith(blockStatement(shouldInsertCurrentNode ? [_node] : []));
      return this.pushContainer("body", nodes);
    } else {
      throw new Error("We don't know what to do with this node type. " + "We were previously a Statement but we can't fit in here?");
    }
  }
  function updateSiblingKeys(fromIndex, incrementBy) {
    if (!this.parent) return;
    var paths = path$3.get(this.parent);

    for (var _iterator2 = _createForOfIteratorHelperLoose(paths), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _slicedToArray$2(_step2.value, 2),
          path = _step2$value[1];

      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }
  function _verifyNodeList(nodes) {
    if (!nodes) {
      return [];
    }

    if (!Array.isArray(nodes)) {
      nodes = [nodes];
    }

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      var msg = void 0;

      if (!node) {
        msg = "has falsy node";
      } else if (typeof node !== "object") {
        msg = "contains a non-object node";
      } else if (!node.type) {
        msg = "without a type";
      } else if (node instanceof NodePath) {
        msg = "has a NodePath when it expected a raw object";
      }

      if (msg) {
        var type = Array.isArray(node) ? "array" : typeof node;
        throw new Error("Node list " + msg + " with the index of " + i + " and type of " + type);
      }
    }

    return nodes;
  }
  function unshiftContainer(listKey, nodes) {
    this._assertUnremoved();

    nodes = this._verifyNodeList(nodes);
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: this.node[listKey],
      listKey: listKey,
      key: 0
    }).setContext(this.context);
    return path._containerInsertBefore(nodes);
  }
  function pushContainer(listKey, nodes) {
    this._assertUnremoved();

    var verifiedNodes = this._verifyNodeList(nodes);

    var container = this.node[listKey];
    var path = NodePath.get({
      parentPath: this,
      parent: this.node,
      container: container,
      listKey: listKey,
      key: container.length
    }).setContext(this.context);
    return path.replaceWithMultiple(verifiedNodes);
  }
  function hoist$3(scope) {
    if (scope === void 0) {
      scope = this.scope;
    }

    var hoister = new PathHoister(this, scope);
    return hoister.run();
  }

  var NodePath_modification = /*#__PURE__*/Object.freeze({
    __proto__: null,
    insertBefore: insertBefore,
    _containerInsert: _containerInsert,
    _containerInsertBefore: _containerInsertBefore,
    _containerInsertAfter: _containerInsertAfter,
    insertAfter: insertAfter,
    updateSiblingKeys: updateSiblingKeys,
    _verifyNodeList: _verifyNodeList,
    unshiftContainer: unshiftContainer,
    pushContainer: pushContainer,
    hoist: hoist$3
  });

  var NORMAL_COMPLETION = 0;
  var BREAK_COMPLETION = 1;

  function NormalCompletion(path) {
    return {
      type: NORMAL_COMPLETION,
      path: path
    };
  }

  function BreakCompletion(path) {
    return {
      type: BREAK_COMPLETION,
      path: path
    };
  }

  function getOpposite() {
    if (this.key === "left") {
      return this.getSibling("right");
    } else if (this.key === "right") {
      return this.getSibling("left");
    }

    return null;
  }

  function addCompletionRecords(path, records, context) {
    if (path) return records.concat(_getCompletionRecords(path, context));
    return records;
  }

  function completionRecordForSwitch(cases, records, context) {
    var lastNormalCompletions = [];

    for (var i = 0; i < cases.length; i++) {
      var casePath = cases[i];

      var caseCompletions = _getCompletionRecords(casePath, context);

      var normalCompletions = [];
      var breakCompletions = [];

      for (var _iterator = _createForOfIteratorHelperLoose(caseCompletions), _step; !(_step = _iterator()).done;) {
        var c = _step.value;

        if (c.type === NORMAL_COMPLETION) {
          normalCompletions.push(c);
        }

        if (c.type === BREAK_COMPLETION) {
          breakCompletions.push(c);
        }
      }

      if (normalCompletions.length) {
        lastNormalCompletions = normalCompletions;
      }

      records = records.concat(breakCompletions);
    }

    records = records.concat(lastNormalCompletions);
    return records;
  }

  function normalCompletionToBreak(completions) {
    completions.forEach(function (c) {
      c.type = BREAK_COMPLETION;
    });
  }

  function replaceBreakStatementInBreakCompletion(completions, reachable) {
    completions.forEach(function (c) {
      if (c.path.isBreakStatement({
        label: null
      })) {
        if (reachable) {
          c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
        } else {
          c.path.remove();
        }
      }
    });
  }

  function getStatementListCompletion(paths, context) {
    var completions = [];

    if (context.canHaveBreak) {
      var lastNormalCompletions = [];

      for (var i = 0; i < paths.length; i++) {
        var path = paths[i];
        var newContext = Object.assign({}, context, {
          inCaseClause: false
        });

        if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
          newContext.shouldPopulateBreak = false;
        }

        var statementCompletions = _getCompletionRecords(path, newContext);

        if (statementCompletions.length > 0 && statementCompletions.every(function (c) {
          return c.type === BREAK_COMPLETION;
        })) {
          if (lastNormalCompletions.length > 0 && statementCompletions.every(function (c) {
            return c.path.isBreakStatement({
              label: null
            });
          })) {
            normalCompletionToBreak(lastNormalCompletions);
            completions = completions.concat(lastNormalCompletions);

            if (lastNormalCompletions.some(function (c) {
              return c.path.isDeclaration();
            })) {
              completions = completions.concat(statementCompletions);
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }

            replaceBreakStatementInBreakCompletion(statementCompletions, false);
          } else {
            completions = completions.concat(statementCompletions);

            if (!context.shouldPopulateBreak) {
              replaceBreakStatementInBreakCompletion(statementCompletions, true);
            }
          }

          break;
        }

        if (i === paths.length - 1) {
          completions = completions.concat(statementCompletions);
        } else {
          completions = completions.concat(statementCompletions.filter(function (c) {
            return c.type === BREAK_COMPLETION;
          }));
          lastNormalCompletions = statementCompletions.filter(function (c) {
            return c.type === NORMAL_COMPLETION;
          });
        }
      }
    } else if (paths.length) {
      completions = completions.concat(_getCompletionRecords(paths[paths.length - 1], context));
    }

    return completions;
  }

  function _getCompletionRecords(path, context) {
    var records = [];

    if (path.isIfStatement()) {
      records = addCompletionRecords(path.get("consequent"), records, context);
      records = addCompletionRecords(path.get("alternate"), records, context);
    } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {
      records = addCompletionRecords(path.get("body"), records, context);
    } else if (path.isProgram() || path.isBlockStatement()) {
      records = records.concat(getStatementListCompletion(path.get("body"), context));
    } else if (path.isFunction()) {
      return _getCompletionRecords(path.get("body"), context);
    } else if (path.isTryStatement()) {
      records = addCompletionRecords(path.get("block"), records, context);
      records = addCompletionRecords(path.get("handler"), records, context);
    } else if (path.isCatchClause()) {
      records = addCompletionRecords(path.get("body"), records, context);
    } else if (path.isSwitchStatement()) {
      records = completionRecordForSwitch(path.get("cases"), records, context);
    } else if (path.isSwitchCase()) {
      records = records.concat(getStatementListCompletion(path.get("consequent"), {
        canHaveBreak: true,
        shouldPopulateBreak: false,
        inCaseClause: true
      }));
    } else if (path.isBreakStatement()) {
      records.push(BreakCompletion(path));
    } else {
      records.push(NormalCompletion(path));
    }

    return records;
  }

  function getCompletionRecords() {
    var records = _getCompletionRecords(this, {
      canHaveBreak: false,
      shouldPopulateBreak: false,
      inCaseClause: false
    });

    return records.map(function (r) {
      return r.path;
    });
  }
  function getSibling(key) {
    return NodePath.get({
      parentPath: this.parentPath,
      parent: this.parent,
      container: this.container,
      listKey: this.listKey,
      key: key
    }).setContext(this.context);
  }
  function getPrevSibling() {
    return this.getSibling(this.key - 1);
  }
  function getNextSibling() {
    return this.getSibling(this.key + 1);
  }
  function getAllNextSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(++_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(++_key);
    }

    return siblings;
  }
  function getAllPrevSiblings() {
    var _key = this.key;
    var sibling = this.getSibling(--_key);
    var siblings = [];

    while (sibling.node) {
      siblings.push(sibling);
      sibling = this.getSibling(--_key);
    }

    return siblings;
  }

  function get$2(key, context) {
    if (context === void 0) {
      context = true;
    }

    if (context === true) context = this.context;
    var parts = key.split(".");

    if (parts.length === 1) {
      return this._getKey(key, context);
    } else {
      return this._getPattern(parts, context);
    }
  }
  function _getKey(key, context) {
    var _this = this;

    var node = this.node;
    var container = node[key];

    if (Array.isArray(container)) {
      return container.map(function (_, i) {
        return NodePath.get({
          listKey: key,
          parentPath: _this,
          parent: node,
          container: container,
          key: i
        }).setContext(context);
      });
    } else {
      return NodePath.get({
        parentPath: this,
        parent: node,
        container: node,
        key: key
      }).setContext(context);
    }
  }
  function _getPattern(parts, context) {
    var path = this;

    for (var _iterator2 = _createForOfIteratorHelperLoose(parts), _step2; !(_step2 = _iterator2()).done;) {
      var part = _step2.value;

      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part, context);
        }
      }
    }

    return path;
  }

  function getBindingIdentifiers(duplicates) {
    return getBindingIdentifiers$1(this.node, duplicates);
  }

  function getOuterBindingIdentifiers(duplicates) {
    return getOuterBindingIdentifiers$1(this.node, duplicates);
  }
  function getBindingIdentifierPaths(duplicates, outerOnly) {
    if (duplicates === void 0) {
      duplicates = false;
    }

    if (outerOnly === void 0) {
      outerOnly = false;
    }

    var path = this;
    var search = [].concat(path);
    var ids = Object.create(null);

    while (search.length) {
      var id = search.shift();
      if (!id) continue;
      if (!id.node) continue;
      var keys = getBindingIdentifiers$1.keys[id.node.type];

      if (id.isIdentifier()) {
        if (duplicates) {
          var _ids = ids[id.node.name] = ids[id.node.name] || [];

          _ids.push(id);
        } else {
          ids[id.node.name] = id;
        }

        continue;
      }

      if (id.isExportDeclaration()) {
        var declaration = id.get("declaration");

        if (declaration.isDeclaration()) {
          search.push(declaration);
        }

        continue;
      }

      if (outerOnly) {
        if (id.isFunctionDeclaration()) {
          search.push(id.get("id"));
          continue;
        }

        if (id.isFunctionExpression()) {
          continue;
        }
      }

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var _key2 = keys[i];
          var child = id.get(_key2);

          if (Array.isArray(child) || child.node) {
            search = search.concat(child);
          }
        }
      }
    }

    return ids;
  }
  function getOuterBindingIdentifierPaths(duplicates) {
    return this.getBindingIdentifierPaths(duplicates, true);
  }

  var NodePath_family = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getOpposite: getOpposite,
    getCompletionRecords: getCompletionRecords,
    getSibling: getSibling,
    getPrevSibling: getPrevSibling,
    getNextSibling: getNextSibling,
    getAllNextSiblings: getAllNextSiblings,
    getAllPrevSiblings: getAllPrevSiblings,
    get: get$2,
    _getKey: _getKey,
    _getPattern: _getPattern,
    getBindingIdentifiers: getBindingIdentifiers,
    getOuterBindingIdentifiers: getOuterBindingIdentifiers,
    getBindingIdentifierPaths: getBindingIdentifierPaths,
    getOuterBindingIdentifierPaths: getOuterBindingIdentifierPaths
  });

  function shareCommentsWithSiblings() {
    if (typeof this.key === "string") return;
    var node = this.node;
    if (!node) return;
    var trailing = node.trailingComments;
    var leading = node.leadingComments;
    if (!trailing && !leading) return;
    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);
    var hasPrev = Boolean(prev.node);
    var hasNext = Boolean(next.node);

    if (hasPrev && !hasNext) {
      prev.addComments("trailing", trailing);
    } else if (hasNext && !hasPrev) {
      next.addComments("leading", leading);
    }
  }
  function addComment(type, content, line) {
    addComment$1(this.node, type, content, line);
  }
  function addComments(type, comments) {
    addComments$1(this.node, type, comments);
  }

  var NodePath_comments = /*#__PURE__*/Object.freeze({
    __proto__: null,
    shareCommentsWithSiblings: shareCommentsWithSiblings,
    addComment: addComment,
    addComments: addComments
  });

  var _debug = browser$5("babel");

  var REMOVED = 1 << 0;
  var SHOULD_STOP = 1 << 1;
  var SHOULD_SKIP = 1 << 2;

  var NodePath = function () {
    function NodePath(hub, parent) {
      this.contexts = [];
      this.state = null;
      this.opts = null;
      this._traverseFlags = 0;
      this.skipKeys = null;
      this.parentPath = null;
      this.container = null;
      this.listKey = null;
      this.key = null;
      this.node = null;
      this.type = null;
      this.parent = parent;
      this.hub = hub;
      this.data = null;
      this.context = null;
      this.scope = null;
    }

    NodePath.get = function get(_ref) {
      var hub = _ref.hub,
          parentPath = _ref.parentPath,
          parent = _ref.parent,
          container = _ref.container,
          listKey = _ref.listKey,
          key = _ref.key;

      if (!hub && parentPath) {
        hub = parentPath.hub;
      }

      if (!parent) {
        throw new Error("To get a node path the parent needs to exist");
      }

      var targetNode = container[key];
      var paths = path$3.get(parent);

      if (!paths) {
        paths = new Map();
        path$3.set(parent, paths);
      }

      var path = paths.get(targetNode);

      if (!path) {
        path = new NodePath(hub, parent);
        if (targetNode) paths.set(targetNode, path);
      }

      path.setup(parentPath, container, listKey, key);
      return path;
    };

    var _proto = NodePath.prototype;

    _proto.getScope = function getScope(scope) {
      return this.isScope() ? new Scope$1(this) : scope;
    };

    _proto.setData = function setData(key, val) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      return this.data[key] = val;
    };

    _proto.getData = function getData(key, def) {
      if (this.data == null) {
        this.data = Object.create(null);
      }

      var val = this.data[key];
      if (val === undefined && def !== undefined) val = this.data[key] = def;
      return val;
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(msg, Error) {
      if (Error === void 0) {
        Error = SyntaxError;
      }

      return this.hub.buildError(this.node, msg, Error);
    };

    _proto.traverse = function traverse$1(visitor, state) {
      traverse(this.node, visitor, this.scope, state, this);
    };

    _proto.set = function set(key, node) {
      validate$3(this.node, key, node);
      this.node[key] = node;
    };

    _proto.getPathLocation = function getPathLocation() {
      var parts = [];
      var path = this;

      do {
        var key = path.key;
        if (path.inList) key = path.listKey + "[" + key + "]";
        parts.unshift(key);
      } while (path = path.parentPath);

      return parts.join(".");
    };

    _proto.debug = function debug(message) {
      if (!_debug.enabled) return;

      _debug(this.getPathLocation() + " " + this.type + ": " + message);
    };

    _proto.toString = function toString() {
      return generate$1(this.node).code;
    };

    _createClass(NodePath, [{
      key: "inList",
      get: function get() {
        return !!this.listKey;
      },
      set: function set(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
    }, {
      key: "parentKey",
      get: function get() {
        return this.listKey || this.key;
      }
    }, {
      key: "shouldSkip",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_SKIP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_SKIP;
        } else {
          this._traverseFlags &= ~SHOULD_SKIP;
        }
      }
    }, {
      key: "shouldStop",
      get: function get() {
        return !!(this._traverseFlags & SHOULD_STOP);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= SHOULD_STOP;
        } else {
          this._traverseFlags &= ~SHOULD_STOP;
        }
      }
    }, {
      key: "removed",
      get: function get() {
        return !!(this._traverseFlags & REMOVED);
      },
      set: function set(v) {
        if (v) {
          this._traverseFlags |= REMOVED;
        } else {
          this._traverseFlags &= ~REMOVED;
        }
      }
    }]);

    return NodePath;
  }();

  Object.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);

  var _loop2 = function _loop2() {
    var type = _step.value;
    var typeKey = "is" + type;
    var fn = t$p[typeKey];

    NodePath.prototype[typeKey] = function (opts) {
      return fn(this.node, opts);
    };

    NodePath.prototype["assert" + type] = function (opts) {
      if (!fn(this.node, opts)) {
        throw new TypeError("Expected node path of type " + type);
      }
    };
  };

  for (var _iterator = _createForOfIteratorHelperLoose(TYPES), _step; !(_step = _iterator()).done;) {
    _loop2();
  }

  var _loop = function _loop() {
    var type = _Object$keys$1[_i$1];
    if (type[0] === "_") return "continue";
    if (TYPES.indexOf(type) < 0) TYPES.push(type);
    var virtualType = virtualTypes[type];

    NodePath.prototype["is" + type] = function (opts) {
      return virtualType.checkPath(this, opts);
    };
  };

  for (var _i$1 = 0, _Object$keys$1 = Object.keys(virtualTypes); _i$1 < _Object$keys$1.length; _i$1++) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }

  var TraversalContext = function () {
    function TraversalContext(scope, opts, state, parentPath) {
      this.queue = null;
      this.priorityQueue = null;
      this.parentPath = parentPath;
      this.scope = scope;
      this.state = state;
      this.opts = opts;
    }

    var _proto = TraversalContext.prototype;

    _proto.shouldVisit = function shouldVisit(node) {
      var opts = this.opts;
      if (opts.enter || opts.exit) return true;
      if (opts[node.type]) return true;
      var keys = VISITOR_KEYS[node.type];
      if (!(keys != null && keys.length)) return false;

      for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        if (node[key]) return true;
      }

      return false;
    };

    _proto.create = function create(node, obj, key, listKey) {
      return NodePath.get({
        parentPath: this.parentPath,
        parent: node,
        container: obj,
        key: key,
        listKey: listKey
      });
    };

    _proto.maybeQueue = function maybeQueue(path, notPriority) {
      if (this.queue) {
        if (notPriority) {
          this.queue.push(path);
        } else {
          this.priorityQueue.push(path);
        }
      }
    };

    _proto.visitMultiple = function visitMultiple(container, parent, listKey) {
      if (container.length === 0) return false;
      var queue = [];

      for (var key = 0; key < container.length; key++) {
        var node = container[key];

        if (node && this.shouldVisit(node)) {
          queue.push(this.create(parent, container, key, listKey));
        }
      }

      return this.visitQueue(queue);
    };

    _proto.visitSingle = function visitSingle(node, key) {
      if (this.shouldVisit(node[key])) {
        return this.visitQueue([this.create(node, node, key)]);
      } else {
        return false;
      }
    };

    _proto.visitQueue = function visitQueue(queue) {
      this.queue = queue;
      this.priorityQueue = [];
      var visited = new WeakSet();
      var stop = false;

      for (var _iterator2 = _createForOfIteratorHelperLoose(queue), _step2; !(_step2 = _iterator2()).done;) {
        var path = _step2.value;
        path.resync();

        if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {
          path.pushContext(this);
        }

        if (path.key === null) continue;
        var node = path.node;
        if (visited.has(node)) continue;
        if (node) visited.add(node);

        if (path.visit()) {
          stop = true;
          break;
        }

        if (this.priorityQueue.length) {
          stop = this.visitQueue(this.priorityQueue);
          this.priorityQueue = [];
          this.queue = queue;
          if (stop) break;
        }
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(queue), _step3; !(_step3 = _iterator3()).done;) {
        var _path = _step3.value;

        _path.popContext();
      }

      this.queue = null;
      return stop;
    };

    _proto.visit = function visit(node, key) {
      var nodes = node[key];
      if (!nodes) return false;

      if (Array.isArray(nodes)) {
        return this.visitMultiple(nodes, node, key);
      } else {
        return this.visitSingle(node, key);
      }
    };

    return TraversalContext;
  }();

  function explode$1(visitor) {
    if (visitor._exploded) return visitor;
    visitor._exploded = true;

    for (var _i = 0, _Object$keys = Object.keys(visitor); _i < _Object$keys.length; _i++) {
      var nodeType = _Object$keys[_i];
      if (shouldIgnoreKey(nodeType)) continue;
      var parts = nodeType.split("|");
      if (parts.length === 1) continue;
      var fns = visitor[nodeType];
      delete visitor[nodeType];

      for (var _iterator = _createForOfIteratorHelperLoose(parts), _step; !(_step = _iterator()).done;) {
        var part = _step.value;
        visitor[part] = fns;
      }
    }

    verify(visitor);
    delete visitor.__esModule;
    ensureEntranceObjects(visitor);
    ensureCallbackArrays(visitor);

    for (var _i2 = 0, _Object$keys2 = Object.keys(visitor); _i2 < _Object$keys2.length; _i2++) {
      var _nodeType = _Object$keys2[_i2];
      if (shouldIgnoreKey(_nodeType)) continue;
      var wrapper = virtualTypes[_nodeType];
      if (!wrapper) continue;
      var _fns = visitor[_nodeType];

      for (var _i3 = 0, _Object$keys3 = Object.keys(_fns); _i3 < _Object$keys3.length; _i3++) {
        var type = _Object$keys3[_i3];
        _fns[type] = wrapCheck(wrapper, _fns[type]);
      }

      delete visitor[_nodeType];

      if (wrapper.types) {
        for (var _iterator2 = _createForOfIteratorHelperLoose(wrapper.types), _step2; !(_step2 = _iterator2()).done;) {
          var _type = _step2.value;

          if (visitor[_type]) {
            mergePair(visitor[_type], _fns);
          } else {
            visitor[_type] = _fns;
          }
        }
      } else {
        mergePair(visitor, _fns);
      }
    }

    for (var _i4 = 0, _Object$keys4 = Object.keys(visitor); _i4 < _Object$keys4.length; _i4++) {
      var _nodeType2 = _Object$keys4[_i4];
      if (shouldIgnoreKey(_nodeType2)) continue;
      var _fns2 = visitor[_nodeType2];
      var aliases = FLIPPED_ALIAS_KEYS[_nodeType2];
      var deprecatedKey = DEPRECATED_KEYS[_nodeType2];

      if (deprecatedKey) {
        console.trace("Visitor defined for " + _nodeType2 + " but it has been renamed to " + deprecatedKey);
        aliases = [deprecatedKey];
      }

      if (!aliases) continue;
      delete visitor[_nodeType2];

      for (var _iterator3 = _createForOfIteratorHelperLoose(aliases), _step3; !(_step3 = _iterator3()).done;) {
        var alias = _step3.value;
        var existing = visitor[alias];

        if (existing) {
          mergePair(existing, _fns2);
        } else {
          visitor[alias] = Object.assign({}, _fns2);
        }
      }
    }

    for (var _i5 = 0, _Object$keys5 = Object.keys(visitor); _i5 < _Object$keys5.length; _i5++) {
      var _nodeType3 = _Object$keys5[_i5];
      if (shouldIgnoreKey(_nodeType3)) continue;
      ensureCallbackArrays(visitor[_nodeType3]);
    }

    return visitor;
  }
  function verify(visitor) {
    if (visitor._verified) return;

    if (typeof visitor === "function") {
      throw new Error("You passed `traverse()` a function when it expected a visitor object, " + "are you sure you didn't mean `{ enter: Function }`?");
    }

    for (var _i6 = 0, _Object$keys6 = Object.keys(visitor); _i6 < _Object$keys6.length; _i6++) {
      var nodeType = _Object$keys6[_i6];

      if (nodeType === "enter" || nodeType === "exit") {
        validateVisitorMethods(nodeType, visitor[nodeType]);
      }

      if (shouldIgnoreKey(nodeType)) continue;

      if (TYPES.indexOf(nodeType) < 0) {
        throw new Error("You gave us a visitor for the node type " + nodeType + " but it's not a valid type");
      }

      var visitors = visitor[nodeType];

      if (typeof visitors === "object") {
        for (var _i7 = 0, _Object$keys7 = Object.keys(visitors); _i7 < _Object$keys7.length; _i7++) {
          var visitorKey = _Object$keys7[_i7];

          if (visitorKey === "enter" || visitorKey === "exit") {
            validateVisitorMethods(nodeType + "." + visitorKey, visitors[visitorKey]);
          } else {
            throw new Error("You passed `traverse()` a visitor object with the property " + (nodeType + " that has the invalid property " + visitorKey));
          }
        }
      }
    }

    visitor._verified = true;
  }

  function validateVisitorMethods(path, val) {
    var fns = [].concat(val);

    for (var _iterator4 = _createForOfIteratorHelperLoose(fns), _step4; !(_step4 = _iterator4()).done;) {
      var fn = _step4.value;

      if (typeof fn !== "function") {
        throw new TypeError("Non-function found defined in " + path + " with type " + typeof fn);
      }
    }
  }

  function merge(visitors, states, wrapper) {
    if (states === void 0) {
      states = [];
    }

    var rootVisitor = {};

    for (var i = 0; i < visitors.length; i++) {
      var visitor = visitors[i];
      var state = states[i];
      explode$1(visitor);

      for (var _i8 = 0, _Object$keys8 = Object.keys(visitor); _i8 < _Object$keys8.length; _i8++) {
        var type = _Object$keys8[_i8];
        var visitorType = visitor[type];

        if (state || wrapper) {
          visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);
        }

        var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};
        mergePair(nodeVisitor, visitorType);
      }
    }

    return rootVisitor;
  }

  function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
    var newVisitor = {};

    var _loop = function _loop() {
      var key = _Object$keys9[_i9];
      var fns = oldVisitor[key];
      if (!Array.isArray(fns)) return "continue";
      fns = fns.map(function (fn) {
        var newFn = fn;

        if (state) {
          newFn = function newFn(path) {
            return fn.call(state, path, state);
          };
        }

        if (wrapper) {
          newFn = wrapper(state.key, key, newFn);
        }

        if (newFn !== fn) {
          newFn.toString = function () {
            return fn.toString();
          };
        }

        return newFn;
      });
      newVisitor[key] = fns;
    };

    for (var _i9 = 0, _Object$keys9 = Object.keys(oldVisitor); _i9 < _Object$keys9.length; _i9++) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }

    return newVisitor;
  }

  function ensureEntranceObjects(obj) {
    for (var _i10 = 0, _Object$keys10 = Object.keys(obj); _i10 < _Object$keys10.length; _i10++) {
      var key = _Object$keys10[_i10];
      if (shouldIgnoreKey(key)) continue;
      var fns = obj[key];

      if (typeof fns === "function") {
        obj[key] = {
          enter: fns
        };
      }
    }
  }

  function ensureCallbackArrays(obj) {
    if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
    if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
  }

  function wrapCheck(wrapper, fn) {
    var newFn = function newFn(path) {
      if (wrapper.checkPath(path)) {
        return fn.apply(this, arguments);
      }
    };

    newFn.toString = function () {
      return fn.toString();
    };

    return newFn;
  }

  function shouldIgnoreKey(key) {
    if (key[0] === "_") return true;
    if (key === "enter" || key === "exit" || key === "shouldSkip") return true;

    if (key === "denylist" || key === "noScope" || key === "skipKeys" || key === "blacklist") {
      return true;
    }

    return false;
  }

  function mergePair(dest, src) {
    for (var _i11 = 0, _Object$keys11 = Object.keys(src); _i11 < _Object$keys11.length; _i11++) {
      var key = _Object$keys11[_i11];
      dest[key] = [].concat(dest[key] || [], src[key]);
    }
  }

  var visitors = /*#__PURE__*/Object.freeze({
    __proto__: null,
    explode: explode$1,
    verify: verify,
    merge: merge
  });

  function traverse(parent, opts, scope, state, parentPath) {
    if (opts === void 0) {
      opts = {};
    }

    if (!parent) return;

    if (!opts.noScope && !scope) {
      if (parent.type !== "Program" && parent.type !== "File") {
        throw new Error("You must pass a scope and parentPath unless traversing a Program/File. " + ("Instead of that you tried to traverse a " + parent.type + " node without ") + "passing scope and parentPath.");
      }
    }

    if (!VISITOR_KEYS[parent.type]) {
      return;
    }

    explode$1(opts);
    traverse.node(parent, opts, scope, state, parentPath);
  }
  traverse.visitors = visitors;
  traverse.verify = verify;
  traverse.explode = explode$1;

  traverse.cheap = function (node, enter) {
    return traverseFast(node, enter);
  };

  traverse.node = function (node, opts, scope, state, parentPath, skipKeys) {
    var keys = VISITOR_KEYS[node.type];
    if (!keys) return;
    var context = new TraversalContext(scope, opts, state, parentPath);

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      if (skipKeys && skipKeys[key]) continue;
      if (context.visit(node, key)) return;
    }
  };

  traverse.clearNode = function (node, opts) {
    removeProperties(node, opts);
    path$3["delete"](node);
  };

  traverse.removeProperties = function (tree, opts) {
    traverseFast(tree, traverse.clearNode, opts);
    return tree;
  };

  function hasDenylistedType(path, state) {
    if (path.node.type === state.type) {
      state.has = true;
      path.stop();
    }
  }

  traverse.hasType = function (tree, type, denylistTypes) {
    if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
    if (tree.type === type) return true;
    var state = {
      has: false,
      type: type
    };
    traverse(tree, {
      noScope: true,
      denylist: denylistTypes,
      enter: hasDenylistedType
    }, null, state);
    return state.has;
  };

  traverse.cache = cache$4;

  var jsx = {
    minVersion: "7.0.0-beta.0",
    ast: function ast() {
      return template$2.program.ast('\nvar REACT_ELEMENT_TYPE;\nexport default function _createRawReactElement(type, props, key, children) {\n  if (!REACT_ELEMENT_TYPE) {\n    REACT_ELEMENT_TYPE =\n      (typeof Symbol === "function" &&\n        \n        Symbol["for"] &&\n        Symbol["for"]("react.element")) ||\n      0xeac7;\n  }\n  var defaultProps = type && type.defaultProps;\n  var childrenLength = arguments.length - 3;\n  if (!props && childrenLength !== 0) {\n    \n    \n    props = { children: void 0 };\n  }\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = new Array(childrenLength);\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 3];\n    }\n    props.children = childArray;\n  }\n  if (props && defaultProps) {\n    for (var propName in defaultProps) {\n      if (props[propName] === void 0) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  } else if (!props) {\n    props = defaultProps || {};\n  }\n  return {\n    $$typeof: REACT_ELEMENT_TYPE,\n    type: type,\n    key: key === undefined ? null : "" + key,\n    ref: null,\n    props: props,\n    _owner: null,\n  };\n}\n');
    }
  };
  var objectSpread2 = {
    minVersion: "7.5.0",
    ast: function ast() {
      return template$2.program.ast('\nimport defineProperty from "defineProperty";\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(\n          target,\n          key,\n          Object.getOwnPropertyDescriptor(source, key)\n        );\n      });\n    }\n  }\n  return target;\n}\n');
    }
  };
  var _typeof = {
    minVersion: "7.0.0-beta.0",
    ast: function ast() {
      return template$2.program.ast('\nexport default function _typeof(obj) {\n  "@babel/helpers - typeof";\n  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj &&\n        typeof Symbol === "function" &&\n        obj.constructor === Symbol &&\n        obj !== Symbol.prototype\n        ? "symbol"\n        : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\n');
    }
  };
  var wrapRegExp = {
    minVersion: "7.2.6",
    ast: function ast() {
      return template$2.program.ast('\nimport setPrototypeOf from "setPrototypeOf";\nimport inherits from "inherits";\nexport default function _wrapRegExp() {\n  _wrapRegExp = function (re, groups) {\n    return new BabelRegExp(re, undefined, groups);\n  };\n  var _super = RegExp.prototype;\n  var _groups = new WeakMap();\n  function BabelRegExp(re, flags, groups) {\n    var _this = new RegExp(re, flags);\n    \n    _groups.set(_this, groups || _groups.get(re));\n    return setPrototypeOf(_this, BabelRegExp.prototype);\n  }\n  inherits(BabelRegExp, RegExp);\n  BabelRegExp.prototype.exec = function (str) {\n    var result = _super.exec.call(this, str);\n    if (result) result.groups = buildGroups(result, this);\n    return result;\n  };\n  BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\n    if (typeof substitution === "string") {\n      var groups = _groups.get(this);\n      return _super[Symbol.replace].call(\n        this,\n        str,\n        substitution.replace(/\\$<([^>]+)>/g, function (_, name) {\n          return "$" + groups[name];\n        })\n      );\n    } else if (typeof substitution === "function") {\n      var _this = this;\n      return _super[Symbol.replace].call(this, str, function () {\n        var args = arguments;\n        \n        if (typeof args[args.length - 1] !== "object") {\n          args = [].slice.call(args);\n          args.push(buildGroups(args, _this));\n        }\n        return substitution.apply(this, args);\n      });\n    } else {\n      return _super[Symbol.replace].call(this, str, substitution);\n    }\n  };\n  function buildGroups(result, re) {\n    \n    \n    var g = _groups.get(re);\n    return Object.keys(g).reduce(function (groups, name) {\n      groups[name] = result[g[name]];\n      return groups;\n    }, Object.create(null));\n  }\n  return _wrapRegExp.apply(this, arguments);\n}\n');
    }
  };

  var generated = /*#__PURE__*/Object.freeze({
    __proto__: null,
    jsx: jsx,
    objectSpread2: objectSpread2,
    'typeof': _typeof,
    wrapRegExp: wrapRegExp
  });

  var _templateObject$n, _templateObject2$b, _templateObject3$a, _templateObject4$6, _templateObject5$4, _templateObject6$4, _templateObject7$3, _templateObject8$2, _templateObject9$2, _templateObject10$2, _templateObject11$2, _templateObject12$2, _templateObject13$2, _templateObject14$1, _templateObject15$1, _templateObject16$1, _templateObject17, _templateObject18, _templateObject19, _templateObject20, _templateObject21, _templateObject22, _templateObject23, _templateObject24, _templateObject25, _templateObject26, _templateObject27, _templateObject28, _templateObject29, _templateObject30, _templateObject31, _templateObject32, _templateObject33, _templateObject34, _templateObject35, _templateObject36, _templateObject37, _templateObject38, _templateObject39, _templateObject40, _templateObject41, _templateObject42, _templateObject43, _templateObject44, _templateObject45, _templateObject46, _templateObject47, _templateObject48, _templateObject49, _templateObject50, _templateObject51, _templateObject52, _templateObject53, _templateObject54, _templateObject55, _templateObject56, _templateObject57, _templateObject58, _templateObject59, _templateObject60, _templateObject61, _templateObject62, _templateObject63, _templateObject64, _templateObject65, _templateObject66, _templateObject67, _templateObject68, _templateObject69, _templateObject70, _templateObject71, _templateObject72, _templateObject73, _templateObject74, _templateObject75, _templateObject76, _templateObject77, _templateObject78, _templateObject79, _templateObject80, _templateObject81, _templateObject82, _templateObject83, _templateObject84;
  var helpers$1 = Object.assign({
    __proto__: null
  }, generated);

  var helper$2 = function helper(minVersion) {
    return function (tpl) {
      return {
        minVersion: minVersion,
        ast: function ast() {
          return template$2.program.ast(tpl);
        }
      };
    };
  };

  helpers$1.asyncIterator = helper$2("7.0.0-beta.0")(_templateObject$n || (_templateObject$n = _taggedTemplateLiteralLoose(["\n  export default function _asyncIterator(iterable) {\n    var method;\n    if (typeof Symbol !== \"undefined\") {\n      if (Symbol.asyncIterator) method = iterable[Symbol.asyncIterator];\n      if (method == null && Symbol.iterator) method = iterable[Symbol.iterator];\n    }\n    if (method == null) method = iterable[\"@@asyncIterator\"];\n    if (method == null) method = iterable[\"@@iterator\"]\n    if (method == null) throw new TypeError(\"Object is not async iterable\");\n    return method.call(iterable);\n  }\n"])));
  helpers$1.AwaitValue = helper$2("7.0.0-beta.0")(_templateObject2$b || (_templateObject2$b = _taggedTemplateLiteralLoose(["\n  export default function _AwaitValue(value) {\n    this.wrapped = value;\n  }\n"])));
  helpers$1.AsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject3$a || (_templateObject3$a = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function AsyncGenerator(gen) {\n    var front, back;\n\n    function send(key, arg) {\n      return new Promise(function (resolve, reject) {\n        var request = {\n          key: key,\n          arg: arg,\n          resolve: resolve,\n          reject: reject,\n          next: null,\n        };\n\n        if (back) {\n          back = back.next = request;\n        } else {\n          front = back = request;\n          resume(key, arg);\n        }\n      });\n    }\n\n    function resume(key, arg) {\n      try {\n        var result = gen[key](arg)\n        var value = result.value;\n        var wrappedAwait = value instanceof AwaitValue;\n\n        Promise.resolve(wrappedAwait ? value.wrapped : value).then(\n          function (arg) {\n            if (wrappedAwait) {\n              resume(key === \"return\" ? \"return\" : \"next\", arg);\n              return\n            }\n\n            settle(result.done ? \"return\" : \"normal\", arg);\n          },\n          function (err) { resume(\"throw\", err); });\n      } catch (err) {\n        settle(\"throw\", err);\n      }\n    }\n\n    function settle(type, value) {\n      switch (type) {\n        case \"return\":\n          front.resolve({ value: value, done: true });\n          break;\n        case \"throw\":\n          front.reject(value);\n          break;\n        default:\n          front.resolve({ value: value, done: false });\n          break;\n      }\n\n      front = front.next;\n      if (front) {\n        resume(front.key, front.arg);\n      } else {\n        back = null;\n      }\n    }\n\n    this._invoke = send;\n\n    // Hide \"return\" method if generator return is not supported\n    if (typeof gen.return !== \"function\") {\n      this.return = undefined;\n    }\n  }\n\n  AsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () { return this; };\n\n  AsyncGenerator.prototype.next = function (arg) { return this._invoke(\"next\", arg); };\n  AsyncGenerator.prototype.throw = function (arg) { return this._invoke(\"throw\", arg); };\n  AsyncGenerator.prototype.return = function (arg) { return this._invoke(\"return\", arg); };\n"])));
  helpers$1.wrapAsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject4$6 || (_templateObject4$6 = _taggedTemplateLiteralLoose(["\n  import AsyncGenerator from \"AsyncGenerator\";\n\n  export default function _wrapAsyncGenerator(fn) {\n    return function () {\n      return new AsyncGenerator(fn.apply(this, arguments));\n    };\n  }\n"])));
  helpers$1.awaitAsyncGenerator = helper$2("7.0.0-beta.0")(_templateObject5$4 || (_templateObject5$4 = _taggedTemplateLiteralLoose(["\n  import AwaitValue from \"AwaitValue\";\n\n  export default function _awaitAsyncGenerator(value) {\n    return new AwaitValue(value);\n  }\n"])));
  helpers$1.asyncGeneratorDelegate = helper$2("7.0.0-beta.0")(_templateObject6$4 || (_templateObject6$4 = _taggedTemplateLiteralLoose(["\n  export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n    var iter = {}, waiting = false;\n\n    function pump(key, value) {\n      waiting = true;\n      value = new Promise(function (resolve) { resolve(inner[key](value)); });\n      return { done: false, value: awaitWrap(value) };\n    };\n\n    iter[typeof Symbol !== \"undefined\" && Symbol.iterator || \"@@iterator\"] = function () { return this; };\n\n    iter.next = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n      return pump(\"next\", value);\n    };\n\n    if (typeof inner.throw === \"function\") {\n      iter.throw = function (value) {\n        if (waiting) {\n          waiting = false;\n          throw value;\n        }\n        return pump(\"throw\", value);\n      };\n    }\n\n    if (typeof inner.return === \"function\") {\n      iter.return = function (value) {\n        if (waiting) {\n          waiting = false;\n          return value;\n        }\n        return pump(\"return\", value);\n      };\n    }\n\n    return iter;\n  }\n"])));
  helpers$1.asyncToGenerator = helper$2("7.0.0-beta.0")(_templateObject7$3 || (_templateObject7$3 = _taggedTemplateLiteralLoose(["\n  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n    try {\n      var info = gen[key](arg);\n      var value = info.value;\n    } catch (error) {\n      reject(error);\n      return;\n    }\n\n    if (info.done) {\n      resolve(value);\n    } else {\n      Promise.resolve(value).then(_next, _throw);\n    }\n  }\n\n  export default function _asyncToGenerator(fn) {\n    return function () {\n      var self = this, args = arguments;\n      return new Promise(function (resolve, reject) {\n        var gen = fn.apply(self, args);\n        function _next(value) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n        }\n        function _throw(err) {\n          asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n        }\n\n        _next(undefined);\n      });\n    };\n  }\n"])));
  helpers$1.classCallCheck = helper$2("7.0.0-beta.0")(_templateObject8$2 || (_templateObject8$2 = _taggedTemplateLiteralLoose(["\n  export default function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n"])));
  helpers$1.createClass = helper$2("7.0.0-beta.0")(_templateObject9$2 || (_templateObject9$2 = _taggedTemplateLiteralLoose(["\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i ++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  export default function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n"])));
  helpers$1.defineEnumerableProperties = helper$2("7.0.0-beta.0")(_templateObject10$2 || (_templateObject10$2 = _taggedTemplateLiteralLoose(["\n  export default function _defineEnumerableProperties(obj, descs) {\n    for (var key in descs) {\n      var desc = descs[key];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, key, desc);\n    }\n\n    // Symbols are not enumerated over by for-in loops. If native\n    // Symbols are available, fetch all of the descs object's own\n    // symbol properties and define them on our target object too.\n    if (Object.getOwnPropertySymbols) {\n      var objectSymbols = Object.getOwnPropertySymbols(descs);\n      for (var i = 0; i < objectSymbols.length; i++) {\n        var sym = objectSymbols[i];\n        var desc = descs[sym];\n        desc.configurable = desc.enumerable = true;\n        if (\"value\" in desc) desc.writable = true;\n        Object.defineProperty(obj, sym, desc);\n      }\n    }\n    return obj;\n  }\n"])));
  helpers$1.defaults = helper$2("7.0.0-beta.0")(_templateObject11$2 || (_templateObject11$2 = _taggedTemplateLiteralLoose(["\n  export default function _defaults(obj, defaults) {\n    var keys = Object.getOwnPropertyNames(defaults);\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var value = Object.getOwnPropertyDescriptor(defaults, key);\n      if (value && value.configurable && obj[key] === undefined) {\n        Object.defineProperty(obj, key, value);\n      }\n    }\n    return obj;\n  }\n"])));
  helpers$1.defineProperty = helper$2("7.0.0-beta.0")(_templateObject12$2 || (_templateObject12$2 = _taggedTemplateLiteralLoose(["\n  export default function _defineProperty(obj, key, value) {\n    // Shortcircuit the slow defineProperty path when possible.\n    // We are trying to avoid issues where setters defined on the\n    // prototype cause side effects under the fast path of simple\n    // assignment. By checking for existence of the property with\n    // the in operator, we can optimize most of this overhead away.\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  }\n"])));
  helpers$1["extends"] = helper$2("7.0.0-beta.0")(_templateObject13$2 || (_templateObject13$2 = _taggedTemplateLiteralLoose(["\n  export default function _extends() {\n    _extends = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n\n    return _extends.apply(this, arguments);\n  }\n"])));
  helpers$1.objectSpread = helper$2("7.0.0-beta.0")(_templateObject14$1 || (_templateObject14$1 = _taggedTemplateLiteralLoose(["\n  import defineProperty from \"defineProperty\";\n\n  export default function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = (arguments[i] != null) ? Object(arguments[i]) : {};\n      var ownKeys = Object.keys(source);\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n      ownKeys.forEach(function(key) {\n        defineProperty(target, key, source[key]);\n      });\n    }\n    return target;\n  }\n"])));
  helpers$1.inherits = helper$2("7.0.0-beta.0")(_templateObject15$1 || (_templateObject15$1 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) setPrototypeOf(subClass, superClass);\n  }\n"])));
  helpers$1.inheritsLoose = helper$2("7.0.0-beta.0")(_templateObject16$1 || (_templateObject16$1 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n\n  export default function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    setPrototypeOf(subClass, superClass);\n  }\n"])));
  helpers$1.getPrototypeOf = helper$2("7.0.0-beta.0")(_templateObject17 || (_templateObject17 = _taggedTemplateLiteralLoose(["\n  export default function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf\n      ? Object.getPrototypeOf\n      : function _getPrototypeOf(o) {\n          return o.__proto__ || Object.getPrototypeOf(o);\n        };\n    return _getPrototypeOf(o);\n  }\n"])));
  helpers$1.setPrototypeOf = helper$2("7.0.0-beta.0")(_templateObject18 || (_templateObject18 = _taggedTemplateLiteralLoose(["\n  export default function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n"])));
  helpers$1.isNativeReflectConstruct = helper$2("7.9.0")(_templateObject19 || (_templateObject19 = _taggedTemplateLiteralLoose(["\n  export default function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n    // core-js@3\n    if (Reflect.construct.sham) return false;\n\n    // Proxy can't be polyfilled. Every browser implemented\n    // proxies before or at the same time as Reflect.construct,\n    // so if they support Proxy they also support Reflect.construct.\n    if (typeof Proxy === \"function\") return true;\n\n    // Since Reflect.construct can't be properly polyfilled, some\n    // implementations (e.g. core-js@2) don't set the correct internal slots.\n    // Those polyfills don't allow us to subclass built-ins, so we need to\n    // use our fallback implementation.\n    try {\n      // If the internal slots aren't set, this throws an error similar to\n      //   TypeError: this is not a Boolean object.\n\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n"])));
  helpers$1.construct = helper$2("7.0.0-beta.0")(_templateObject20 || (_templateObject20 = _taggedTemplateLiteralLoose(["\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n\n  export default function _construct(Parent, args, Class) {\n    if (isNativeReflectConstruct()) {\n      _construct = Reflect.construct;\n    } else {\n      // NOTE: If Parent !== Class, the correct __proto__ is set *after*\n      //       calling the constructor.\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    // Avoid issues with Class being present but undefined when it wasn't\n    // present in the original call.\n    return _construct.apply(null, arguments);\n  }\n"])));
  helpers$1.isNativeFunction = helper$2("7.0.0-beta.0")(_templateObject21 || (_templateObject21 = _taggedTemplateLiteralLoose(["\n  export default function _isNativeFunction(fn) {\n    // Note: This function returns \"true\" for core-js functions.\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n"])));
  helpers$1.wrapNativeSuper = helper$2("7.0.0-beta.0")(_templateObject22 || (_templateObject22 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import setPrototypeOf from \"setPrototypeOf\";\n  import isNativeFunction from \"isNativeFunction\";\n  import construct from \"construct\";\n\n  export default function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return construct(Class, arguments, getPrototypeOf(this).constructor)\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true,\n        }\n      });\n\n      return setPrototypeOf(Wrapper, Class);\n    }\n\n    return _wrapNativeSuper(Class)\n  }\n"])));
  helpers$1["instanceof"] = helper$2("7.0.0-beta.0")(_templateObject23 || (_templateObject23 = _taggedTemplateLiteralLoose(["\n  export default function _instanceof(left, right) {\n    if (right != null && typeof Symbol !== \"undefined\" && right[Symbol.hasInstance]) {\n      return !!right[Symbol.hasInstance](left);\n    } else {\n      return left instanceof right;\n    }\n  }\n"])));
  helpers$1.interopRequireDefault = helper$2("7.0.0-beta.0")(_templateObject24 || (_templateObject24 = _taggedTemplateLiteralLoose(["\n  export default function _interopRequireDefault(obj) {\n    return obj && obj.__esModule ? obj : { default: obj };\n  }\n"])));
  helpers$1.interopRequireWildcard = helper$2("7.14.0")(_templateObject25 || (_templateObject25 = _taggedTemplateLiteralLoose(["\n  function _getRequireWildcardCache(nodeInterop) {\n    if (typeof WeakMap !== \"function\") return null;\n\n    var cacheBabelInterop = new WeakMap();\n    var cacheNodeInterop = new WeakMap();\n    return (_getRequireWildcardCache = function (nodeInterop) {\n      return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n    })(nodeInterop);\n  }\n\n  export default function _interopRequireWildcard(obj, nodeInterop) {\n    if (!nodeInterop && obj && obj.__esModule) {\n      return obj;\n    }\n\n    if (obj === null || (typeof obj !== \"object\" && typeof obj !== \"function\")) {\n      return { default: obj }\n    }\n\n    var cache = _getRequireWildcardCache(nodeInterop);\n    if (cache && cache.has(obj)) {\n      return cache.get(obj);\n    }\n\n    var newObj = {};\n    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n    for (var key in obj) {\n      if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n        var desc = hasPropertyDescriptor\n          ? Object.getOwnPropertyDescriptor(obj, key)\n          : null;\n        if (desc && (desc.get || desc.set)) {\n          Object.defineProperty(newObj, key, desc);\n        } else {\n          newObj[key] = obj[key];\n        }\n      }\n    }\n    newObj.default = obj;\n    if (cache) {\n      cache.set(obj, newObj);\n    }\n    return newObj;\n  }\n"])));
  helpers$1.newArrowCheck = helper$2("7.0.0-beta.0")(_templateObject26 || (_templateObject26 = _taggedTemplateLiteralLoose(["\n  export default function _newArrowCheck(innerThis, boundThis) {\n    if (innerThis !== boundThis) {\n      throw new TypeError(\"Cannot instantiate an arrow function\");\n    }\n  }\n"])));
  helpers$1.objectDestructuringEmpty = helper$2("7.0.0-beta.0")(_templateObject27 || (_templateObject27 = _taggedTemplateLiteralLoose(["\n  export default function _objectDestructuringEmpty(obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  }\n"])));
  helpers$1.objectWithoutPropertiesLoose = helper$2("7.0.0-beta.0")(_templateObject28 || (_templateObject28 = _taggedTemplateLiteralLoose(["\n  export default function _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n\n    for (i = 0; i < sourceKeys.length; i++) {\n      key = sourceKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n"])));
  helpers$1.objectWithoutProperties = helper$2("7.0.0-beta.0")(_templateObject29 || (_templateObject29 = _taggedTemplateLiteralLoose(["\n  import objectWithoutPropertiesLoose from \"objectWithoutPropertiesLoose\";\n\n  export default function _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n\n    var target = objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n\n    if (Object.getOwnPropertySymbols) {\n      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n      for (i = 0; i < sourceSymbolKeys.length; i++) {\n        key = sourceSymbolKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n"])));
  helpers$1.assertThisInitialized = helper$2("7.0.0-beta.0")(_templateObject30 || (_templateObject30 = _taggedTemplateLiteralLoose(["\n  export default function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n"])));
  helpers$1.possibleConstructorReturn = helper$2("7.0.0-beta.0")(_templateObject31 || (_templateObject31 = _taggedTemplateLiteralLoose(["\n  import assertThisInitialized from \"assertThisInitialized\";\n\n  export default function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    }\n    return assertThisInitialized(self);\n  }\n"])));
  helpers$1.createSuper = helper$2("7.9.0")(_templateObject32 || (_templateObject32 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n  import isNativeReflectConstruct from \"isNativeReflectConstruct\";\n  import possibleConstructorReturn from \"possibleConstructorReturn\";\n\n  export default function _createSuper(Derived) {\n    var hasNativeReflectConstruct = isNativeReflectConstruct();\n\n    return function _createSuperInternal() {\n      var Super = getPrototypeOf(Derived), result;\n      if (hasNativeReflectConstruct) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return possibleConstructorReturn(this, result);\n    }\n  }\n "])));
  helpers$1.superPropBase = helper$2("7.0.0-beta.0")(_templateObject33 || (_templateObject33 = _taggedTemplateLiteralLoose(["\n  import getPrototypeOf from \"getPrototypeOf\";\n\n  export default function _superPropBase(object, property) {\n    // Yes, this throws if object is null to being with, that's on purpose.\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n"])));
  helpers$1.get = helper$2("7.0.0-beta.0")(_templateObject34 || (_templateObject34 = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n\n  export default function _get(target, property, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get;\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = superPropBase(target, property);\n\n        if (!base) return;\n\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(receiver);\n        }\n\n        return desc.value;\n      };\n    }\n    return _get(target, property, receiver || target);\n  }\n"])));
  helpers$1.set = helper$2("7.0.0-beta.0")(_templateObject35 || (_templateObject35 = _taggedTemplateLiteralLoose(["\n  import superPropBase from \"superPropBase\";\n  import defineProperty from \"defineProperty\";\n\n  function set(target, property, value, receiver) {\n    if (typeof Reflect !== \"undefined\" && Reflect.set) {\n      set = Reflect.set;\n    } else {\n      set = function set(target, property, value, receiver) {\n        var base = superPropBase(target, property);\n        var desc;\n\n        if (base) {\n          desc = Object.getOwnPropertyDescriptor(base, property);\n          if (desc.set) {\n            desc.set.call(receiver, value);\n            return true;\n          } else if (!desc.writable) {\n            // Both getter and non-writable fall into this.\n            return false;\n          }\n        }\n\n        // Without a super that defines the property, spec boils down to\n        // \"define on receiver\" for some reason.\n        desc = Object.getOwnPropertyDescriptor(receiver, property);\n        if (desc) {\n          if (!desc.writable) {\n            // Setter, getter, and non-writable fall into this.\n            return false;\n          }\n\n          desc.value = value;\n          Object.defineProperty(receiver, property, desc);\n        } else {\n          // Avoid setters that may be defined on Sub's prototype, but not on\n          // the instance.\n          defineProperty(receiver, property, value);\n        }\n\n        return true;\n      };\n    }\n\n    return set(target, property, value, receiver);\n  }\n\n  export default function _set(target, property, value, receiver, isStrict) {\n    var s = set(target, property, value, receiver || target);\n    if (!s && isStrict) {\n      throw new Error('failed to set property');\n    }\n\n    return value;\n  }\n"])));
  helpers$1.taggedTemplateLiteral = helper$2("7.0.0-beta.0")(_templateObject36 || (_templateObject36 = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteral(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    return Object.freeze(Object.defineProperties(strings, {\n        raw: { value: Object.freeze(raw) }\n    }));\n  }\n"])));
  helpers$1.taggedTemplateLiteralLoose = helper$2("7.0.0-beta.0")(_templateObject37 || (_templateObject37 = _taggedTemplateLiteralLoose(["\n  export default function _taggedTemplateLiteralLoose(strings, raw) {\n    if (!raw) { raw = strings.slice(0); }\n    strings.raw = raw;\n    return strings;\n  }\n"])));
  helpers$1.readOnlyError = helper$2("7.0.0-beta.0")(_templateObject38 || (_templateObject38 = _taggedTemplateLiteralLoose(["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\"\" + name + \"\\\" is read-only\");\n  }\n"], ["\n  export default function _readOnlyError(name) {\n    throw new TypeError(\"\\\\\"\" + name + \"\\\\\" is read-only\");\n  }\n"])));
  helpers$1.writeOnlyError = helper$2("7.12.13")(_templateObject39 || (_templateObject39 = _taggedTemplateLiteralLoose(["\n  export default function _writeOnlyError(name) {\n    throw new TypeError(\"\\\"\" + name + \"\\\" is write-only\");\n  }\n"], ["\n  export default function _writeOnlyError(name) {\n    throw new TypeError(\"\\\\\"\" + name + \"\\\\\" is write-only\");\n  }\n"])));
  helpers$1.classNameTDZError = helper$2("7.0.0-beta.0")(_templateObject40 || (_templateObject40 = _taggedTemplateLiteralLoose(["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\"\" + name + \"\\\" cannot be referenced in computed property keys.\");\n  }\n"], ["\n  export default function _classNameTDZError(name) {\n    throw new Error(\"Class \\\\\"\" + name + \"\\\\\" cannot be referenced in computed property keys.\");\n  }\n"])));
  helpers$1.temporalUndefined = helper$2("7.0.0-beta.0")(_templateObject41 || (_templateObject41 = _taggedTemplateLiteralLoose(["\n  // This function isn't mean to be called, but to be used as a reference.\n  // We can't use a normal object because it isn't hoisted.\n  export default function _temporalUndefined() {}\n"])));
  helpers$1.tdz = helper$2("7.5.5")(_templateObject42 || (_templateObject42 = _taggedTemplateLiteralLoose(["\n  export default function _tdzError(name) {\n    throw new ReferenceError(name + \" is not defined - temporal dead zone\");\n  }\n"])));
  helpers$1.temporalRef = helper$2("7.0.0-beta.0")(_templateObject43 || (_templateObject43 = _taggedTemplateLiteralLoose(["\n  import undef from \"temporalUndefined\";\n  import err from \"tdz\";\n\n  export default function _temporalRef(val, name) {\n    return val === undef ? err(name) : val;\n  }\n"])));
  helpers$1.slicedToArray = helper$2("7.0.0-beta.0")(_templateObject44 || (_templateObject44 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimit from \"iterableToArrayLimit\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArray(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimit(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"])));
  helpers$1.slicedToArrayLoose = helper$2("7.0.0-beta.0")(_templateObject45 || (_templateObject45 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArrayLimitLoose from \"iterableToArrayLimitLoose\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _slicedToArrayLoose(arr, i) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArrayLimitLoose(arr, i) ||\n      unsupportedIterableToArray(arr, i) ||\n      nonIterableRest()\n    );\n  }\n"])));
  helpers$1.toArray = helper$2("7.0.0-beta.0")(_templateObject46 || (_templateObject46 = _taggedTemplateLiteralLoose(["\n  import arrayWithHoles from \"arrayWithHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableRest from \"nonIterableRest\";\n\n  export default function _toArray(arr) {\n    return (\n      arrayWithHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableRest()\n    );\n  }\n"])));
  helpers$1.toConsumableArray = helper$2("7.0.0-beta.0")(_templateObject47 || (_templateObject47 = _taggedTemplateLiteralLoose(["\n  import arrayWithoutHoles from \"arrayWithoutHoles\";\n  import iterableToArray from \"iterableToArray\";\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n  import nonIterableSpread from \"nonIterableSpread\";\n\n  export default function _toConsumableArray(arr) {\n    return (\n      arrayWithoutHoles(arr) ||\n      iterableToArray(arr) ||\n      unsupportedIterableToArray(arr) ||\n      nonIterableSpread()\n    );\n  }\n"])));
  helpers$1.arrayWithoutHoles = helper$2("7.0.0-beta.0")(_templateObject48 || (_templateObject48 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return arrayLikeToArray(arr);\n  }\n"])));
  helpers$1.arrayWithHoles = helper$2("7.0.0-beta.0")(_templateObject49 || (_templateObject49 = _taggedTemplateLiteralLoose(["\n  export default function _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n  }\n"])));
  helpers$1.maybeArrayLike = helper$2("7.9.0")(_templateObject50 || (_templateObject50 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _maybeArrayLike(next, arr, i) {\n    if (arr && !Array.isArray(arr) && typeof arr.length === \"number\") {\n      var len = arr.length;\n      return arrayLikeToArray(arr, i !== void 0 && i < len ? i : len);\n    }\n    return next(arr, i);\n  }\n"])));
  helpers$1.iterableToArray = helper$2("7.0.0-beta.0")(_templateObject51 || (_templateObject51 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n  }\n"])));
  helpers$1.iterableToArrayLimit = helper$2("7.0.0-beta.0")(_templateObject52 || (_templateObject52 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of `for...of` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _i = arr == null ? null : (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"], ["\n  export default function _iterableToArrayLimit(arr, i) {\n    // this is an expanded form of \\`for...of\\` that properly supports abrupt completions of\n    // iterators etc. variable names have been minimised to reduce the size of this massive\n    // helper. sometimes spec compliance is annoying :(\n    //\n    // _n = _iteratorNormalCompletion\n    // _d = _didIteratorError\n    // _e = _iteratorError\n    // _i = _iterator\n    // _s = _step\n\n    var _i = arr == null ? null : (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _s, _e;\n    try {\n      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n"])));
  helpers$1.iterableToArrayLimitLoose = helper$2("7.0.0-beta.0")(_templateObject53 || (_templateObject53 = _taggedTemplateLiteralLoose(["\n  export default function _iterableToArrayLimitLoose(arr, i) {\n    var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]);\n    if (_i == null) return;\n\n    var _arr = [];\n    for (_i = _i.call(arr), _step; !(_step = _i.next()).done;) {\n      _arr.push(_step.value);\n      if (i && _arr.length === i) break;\n    }\n    return _arr;\n  }\n"])));
  helpers$1.unsupportedIterableToArray = helper$2("7.9.0")(_templateObject54 || (_templateObject54 = _taggedTemplateLiteralLoose(["\n  import arrayLikeToArray from \"arrayLikeToArray\";\n\n  export default function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))\n      return arrayLikeToArray(o, minLen);\n  }\n"])));
  helpers$1.arrayLikeToArray = helper$2("7.9.0")(_templateObject55 || (_templateObject55 = _taggedTemplateLiteralLoose(["\n  export default function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n"])));
  helpers$1.nonIterableSpread = helper$2("7.0.0-beta.0")(_templateObject56 || (_templateObject56 = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableSpread() {\n    throw new TypeError(\n      \"Invalid attempt to spread non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"])));
  helpers$1.nonIterableRest = helper$2("7.0.0-beta.0")(_templateObject57 || (_templateObject57 = _taggedTemplateLiteralLoose(["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"], ["\n  export default function _nonIterableRest() {\n    throw new TypeError(\n      \"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"\n    );\n  }\n"])));
  helpers$1.createForOfIteratorHelper = helper$2("7.9.0")(_templateObject58 || (_templateObject58 = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = it.call(o);\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  // s: start (create the iterator)\n  // n: next\n  // e: error (called whenever something throws)\n  // f: finish (always called at the end)\n\n  export default function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (!it) {\n      // Fallback for engines without symbol support\n      if (\n        Array.isArray(o) ||\n        (it = unsupportedIterableToArray(o)) ||\n        (allowArrayLike && o && typeof o.length === \"number\")\n      ) {\n        if (it) o = it;\n        var i = 0;\n        var F = function(){};\n        return {\n          s: F,\n          n: function() {\n            if (i >= o.length) return { done: true };\n            return { done: false, value: o[i++] };\n          },\n          e: function(e) { throw e; },\n          f: F,\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    var normalCompletion = true, didErr = false, err;\n\n    return {\n      s: function() {\n        it = it.call(o);\n      },\n      n: function() {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function(e) {\n        didErr = true;\n        err = e;\n      },\n      f: function() {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n"])));
  helpers$1.createForOfIteratorHelperLoose = helper$2("7.9.0")(_templateObject59 || (_templateObject59 = _taggedTemplateLiteralLoose(["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    // Fallback for engines without symbol support\n    if (\n      Array.isArray(o) ||\n      (it = unsupportedIterableToArray(o)) ||\n      (allowArrayLike && o && typeof o.length === \"number\")\n    ) {\n      if (it) o = it;\n      var i = 0;\n      return function() {\n        if (i >= o.length) return { done: true };\n        return { done: false, value: o[i++] };\n      }\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n"], ["\n  import unsupportedIterableToArray from \"unsupportedIterableToArray\";\n\n  export default function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n    if (it) return (it = it.call(o)).next.bind(it);\n\n    // Fallback for engines without symbol support\n    if (\n      Array.isArray(o) ||\n      (it = unsupportedIterableToArray(o)) ||\n      (allowArrayLike && o && typeof o.length === \"number\")\n    ) {\n      if (it) o = it;\n      var i = 0;\n      return function() {\n        if (i >= o.length) return { done: true };\n        return { done: false, value: o[i++] };\n      }\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n"])));
  helpers$1.skipFirstGeneratorNext = helper$2("7.0.0-beta.0")(_templateObject60 || (_templateObject60 = _taggedTemplateLiteralLoose(["\n  export default function _skipFirstGeneratorNext(fn) {\n    return function () {\n      var it = fn.apply(this, arguments);\n      it.next();\n      return it;\n    }\n  }\n"])));
  helpers$1.toPrimitive = helper$2("7.1.5")(_templateObject61 || (_templateObject61 = _taggedTemplateLiteralLoose(["\n  export default function _toPrimitive(\n    input,\n    hint /*: \"default\" | \"string\" | \"number\" | void */\n  ) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n"])));
  helpers$1.toPropertyKey = helper$2("7.1.5")(_templateObject62 || (_templateObject62 = _taggedTemplateLiteralLoose(["\n  import toPrimitive from \"toPrimitive\";\n\n  export default function _toPropertyKey(arg) {\n    var key = toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n"])));
  helpers$1.initializerWarningHelper = helper$2("7.0.0-beta.0")(_templateObject63 || (_templateObject63 = _taggedTemplateLiteralLoose(["\n    export default function _initializerWarningHelper(descriptor, context){\n        throw new Error(\n          'Decorating class property failed. Please ensure that ' +\n          'proposal-class-properties is enabled and runs after the decorators transform.'\n        );\n    }\n"])));
  helpers$1.initializerDefineProperty = helper$2("7.0.0-beta.0")(_templateObject64 || (_templateObject64 = _taggedTemplateLiteralLoose(["\n    export default function _initializerDefineProperty(target, property, descriptor, context){\n        if (!descriptor) return;\n\n        Object.defineProperty(target, property, {\n            enumerable: descriptor.enumerable,\n            configurable: descriptor.configurable,\n            writable: descriptor.writable,\n            value: descriptor.initializer ? descriptor.initializer.call(context) : void 0,\n        });\n    }\n"])));
  helpers$1.applyDecoratedDescriptor = helper$2("7.0.0-beta.0")(_templateObject65 || (_templateObject65 = _taggedTemplateLiteralLoose(["\n    export default function _applyDecoratedDescriptor(target, property, decorators, descriptor, context){\n        var desc = {};\n        Object.keys(descriptor).forEach(function(key){\n            desc[key] = descriptor[key];\n        });\n        desc.enumerable = !!desc.enumerable;\n        desc.configurable = !!desc.configurable;\n        if ('value' in desc || desc.initializer){\n            desc.writable = true;\n        }\n\n        desc = decorators.slice().reverse().reduce(function(desc, decorator){\n            return decorator(target, property, desc) || desc;\n        }, desc);\n\n        if (context && desc.initializer !== void 0){\n            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n            desc.initializer = undefined;\n        }\n\n        if (desc.initializer === void 0){\n            Object.defineProperty(target, property, desc);\n            desc = null;\n        }\n\n        return desc;\n    }\n"])));
  helpers$1.classPrivateFieldLooseKey = helper$2("7.0.0-beta.0")(_templateObject66 || (_templateObject66 = _taggedTemplateLiteralLoose(["\n  var id = 0;\n  export default function _classPrivateFieldKey(name) {\n    return \"__private_\" + (id++) + \"_\" + name;\n  }\n"])));
  helpers$1.classPrivateFieldLooseBase = helper$2("7.0.0-beta.0")(_templateObject67 || (_templateObject67 = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateFieldBase(receiver, privateKey) {\n    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {\n      throw new TypeError(\"attempted to use private field on non-instance\");\n    }\n    return receiver;\n  }\n"])));
  helpers$1.classPrivateFieldGet = helper$2("7.0.0-beta.0")(_templateObject68 || (_templateObject68 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorGet from \"classApplyDescriptorGet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldGet(receiver, privateMap) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"get\");\n    return classApplyDescriptorGet(receiver, descriptor);\n  }\n"])));
  helpers$1.classPrivateFieldSet = helper$2("7.0.0-beta.0")(_templateObject69 || (_templateObject69 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorSet from \"classApplyDescriptorSet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldSet(receiver, privateMap, value) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n    classApplyDescriptorSet(receiver, descriptor, value);\n    return value;\n  }\n"])));
  helpers$1.classPrivateFieldDestructureSet = helper$2("7.4.4")(_templateObject70 || (_templateObject70 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorDestructureSet from \"classApplyDescriptorDestructureSet\";\n  import classExtractFieldDescriptor from \"classExtractFieldDescriptor\";\n  export default function _classPrivateFieldDestructureSet(receiver, privateMap) {\n    var descriptor = classExtractFieldDescriptor(receiver, privateMap, \"set\");\n    return classApplyDescriptorDestructureSet(receiver, descriptor);\n  }\n"])));
  helpers$1.classExtractFieldDescriptor = helper$2("7.13.10")(_templateObject71 || (_templateObject71 = _taggedTemplateLiteralLoose(["\n  export default function _classExtractFieldDescriptor(receiver, privateMap, action) {\n    if (!privateMap.has(receiver)) {\n      throw new TypeError(\"attempted to \" + action + \" private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n  }\n"])));
  helpers$1.classStaticPrivateFieldSpecGet = helper$2("7.0.2")(_templateObject72 || (_templateObject72 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorGet from \"classApplyDescriptorGet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldSpecGet(receiver, classConstructor, descriptor) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"get\");\n    return classApplyDescriptorGet(receiver, descriptor);\n  }\n"])));
  helpers$1.classStaticPrivateFieldSpecSet = helper$2("7.0.2")(_templateObject73 || (_templateObject73 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorSet from \"classApplyDescriptorSet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldSpecSet(receiver, classConstructor, descriptor, value) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n    classApplyDescriptorSet(receiver, descriptor, value);\n    return value;\n  }\n"])));
  helpers$1.classStaticPrivateMethodGet = helper$2("7.3.2")(_templateObject74 || (_templateObject74 = _taggedTemplateLiteralLoose(["\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  export default function _classStaticPrivateMethodGet(receiver, classConstructor, method) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    return method;\n  }\n"])));
  helpers$1.classStaticPrivateMethodSet = helper$2("7.3.2")(_templateObject75 || (_templateObject75 = _taggedTemplateLiteralLoose(["\n  export default function _classStaticPrivateMethodSet() {\n    throw new TypeError(\"attempted to set read only static private field\");\n  }\n"])));
  helpers$1.classApplyDescriptorGet = helper$2("7.13.10")(_templateObject76 || (_templateObject76 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorGet(receiver, descriptor) {\n    if (descriptor.get) {\n      return descriptor.get.call(receiver);\n    }\n    return descriptor.value;\n  }\n"])));
  helpers$1.classApplyDescriptorSet = helper$2("7.13.10")(_templateObject77 || (_templateObject77 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorSet(receiver, descriptor, value) {\n    if (descriptor.set) {\n      descriptor.set.call(receiver, value);\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n      descriptor.value = value;\n    }\n  }\n"])));
  helpers$1.classApplyDescriptorDestructureSet = helper$2("7.13.10")(_templateObject78 || (_templateObject78 = _taggedTemplateLiteralLoose(["\n  export default function _classApplyDescriptorDestructureSet(receiver, descriptor) {\n    if (descriptor.set) {\n      if (!(\"__destrObj\" in descriptor)) {\n        descriptor.__destrObj = {\n          set value(v) {\n            descriptor.set.call(receiver, v)\n          },\n        };\n      }\n      return descriptor.__destrObj;\n    } else {\n      if (!descriptor.writable) {\n        // This should only throw in strict mode, but class bodies are\n        // always strict and private fields can only be used inside\n        // class bodies.\n        throw new TypeError(\"attempted to set read only private field\");\n      }\n\n      return descriptor;\n    }\n  }\n"])));
  helpers$1.classStaticPrivateFieldDestructureSet = helper$2("7.13.10")(_templateObject79 || (_templateObject79 = _taggedTemplateLiteralLoose(["\n  import classApplyDescriptorDestructureSet from \"classApplyDescriptorDestructureSet\";\n  import classCheckPrivateStaticAccess from \"classCheckPrivateStaticAccess\";\n  import classCheckPrivateStaticFieldDescriptor from \"classCheckPrivateStaticFieldDescriptor\";\n  export default function _classStaticPrivateFieldDestructureSet(receiver, classConstructor, descriptor) {\n    classCheckPrivateStaticAccess(receiver, classConstructor);\n    classCheckPrivateStaticFieldDescriptor(descriptor, \"set\");\n    return classApplyDescriptorDestructureSet(receiver, descriptor);\n  }\n"])));
  helpers$1.classCheckPrivateStaticAccess = helper$2("7.13.10")(_templateObject80 || (_templateObject80 = _taggedTemplateLiteralLoose(["\n  export default function _classCheckPrivateStaticAccess(receiver, classConstructor) {\n    if (receiver !== classConstructor) {\n      throw new TypeError(\"Private static access of wrong provenance\");\n    }\n  }\n"])));
  helpers$1.classCheckPrivateStaticFieldDescriptor = helper$2("7.13.10")(_templateObject81 || (_templateObject81 = _taggedTemplateLiteralLoose(["\n  export default function _classCheckPrivateStaticFieldDescriptor(descriptor, action) {\n    if (descriptor === undefined) {\n      throw new TypeError(\"attempted to \" + action + \" private static field before its declaration\");\n    }\n  }\n"])));
  helpers$1.decorate = helper$2("7.1.5")(_templateObject82 || (_templateObject82 = _taggedTemplateLiteralLoose(["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"], ["\n  import toArray from \"toArray\";\n  import toPropertyKey from \"toPropertyKey\";\n\n  // These comments are stripped by @babel/template\n  /*::\n  type PropertyDescriptor =\n    | {\n        value: any,\n        writable: boolean,\n        configurable: boolean,\n        enumerable: boolean,\n      }\n    | {\n        get?: () => any,\n        set?: (v: any) => void,\n        configurable: boolean,\n        enumerable: boolean,\n      };\n\n  type FieldDescriptor ={\n    writable: boolean,\n    configurable: boolean,\n    enumerable: boolean,\n  };\n\n  type Placement = \"static\" | \"prototype\" | \"own\";\n  type Key = string | symbol; // PrivateName is not supported yet.\n\n  type ElementDescriptor =\n    | {\n        kind: \"method\",\n        key: Key,\n        placement: Placement,\n        descriptor: PropertyDescriptor\n      }\n    | {\n        kind: \"field\",\n        key: Key,\n        placement: Placement,\n        descriptor: FieldDescriptor,\n        initializer?: () => any,\n      };\n\n  // This is exposed to the user code\n  type ElementObjectInput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n  };\n\n  // This is exposed to the user code\n  type ElementObjectOutput = ElementDescriptor & {\n    [@@toStringTag]?: \"Descriptor\"\n    extras?: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  // This is exposed to the user code\n  type ClassObject = {\n    [@@toStringTag]?: \"Descriptor\",\n    kind: \"class\",\n    elements: ElementDescriptor[],\n  };\n\n  type ElementDecorator = (descriptor: ElementObjectInput) => ?ElementObjectOutput;\n  type ClassDecorator = (descriptor: ClassObject) => ?ClassObject;\n  type ClassFinisher = <A, B>(cl: Class<A>) => Class<B>;\n\n  // Only used by Babel in the transform output, not part of the spec.\n  type ElementDefinition =\n    | {\n        kind: \"method\",\n        value: any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n      }\n    | {\n        kind: \"field\",\n        value: () => any,\n        key: Key,\n        static?: boolean,\n        decorators?: ElementDecorator[],\n    };\n\n  declare function ClassFactory<C>(initialize: (instance: C) => void): {\n    F: Class<C>,\n    d: ElementDefinition[]\n  }\n\n  */\n\n  /*::\n  // Various combinations with/without extras and with one or many finishers\n\n  type ElementFinisherExtras = {\n    element: ElementDescriptor,\n    finisher?: ClassFinisher,\n    extras?: ElementDescriptor[],\n  };\n\n  type ElementFinishersExtras = {\n    element: ElementDescriptor,\n    finishers: ClassFinisher[],\n    extras: ElementDescriptor[],\n  };\n\n  type ElementsFinisher = {\n    elements: ElementDescriptor[],\n    finisher?: ClassFinisher,\n  };\n\n  type ElementsFinishers = {\n    elements: ElementDescriptor[],\n    finishers: ClassFinisher[],\n  };\n\n  */\n\n  /*::\n\n  type Placements = {\n    static: Key[],\n    prototype: Key[],\n    own: Key[],\n  };\n\n  */\n\n  // ClassDefinitionEvaluation (Steps 26-*)\n  export default function _decorate(\n    decorators /*: ClassDecorator[] */,\n    factory /*: ClassFactory */,\n    superClass /*: ?Class<*> */,\n    mixins /*: ?Array<Function> */,\n  ) /*: Class<*> */ {\n    var api = _getDecoratorsApi();\n    if (mixins) {\n      for (var i = 0; i < mixins.length; i++) {\n        api = mixins[i](api);\n      }\n    }\n\n    var r = factory(function initialize(O) {\n      api.initializeInstanceElements(O, decorated.elements);\n    }, superClass);\n    var decorated = api.decorateClass(\n      _coalesceClassElements(r.d.map(_createElementDescriptor)),\n      decorators,\n    );\n\n    api.initializeClassElements(r.F, decorated.elements);\n\n    return api.runClassFinishers(r.F, decorated.finishers);\n  }\n\n  function _getDecoratorsApi() {\n    _getDecoratorsApi = function() {\n      return api;\n    };\n\n    var api = {\n      elementsDefinitionOrder: [[\"method\"], [\"field\"]],\n\n      // InitializeInstanceElements\n      initializeInstanceElements: function(\n        /*::<C>*/ O /*: C */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            if (element.kind === kind && element.placement === \"own\") {\n              this.defineClassElement(O, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // InitializeClassElements\n      initializeClassElements: function(\n        /*::<C>*/ F /*: Class<C> */,\n        elements /*: ElementDescriptor[] */,\n      ) {\n        var proto = F.prototype;\n\n        [\"method\", \"field\"].forEach(function(kind) {\n          elements.forEach(function(element /*: ElementDescriptor */) {\n            var placement = element.placement;\n            if (\n              element.kind === kind &&\n              (placement === \"static\" || placement === \"prototype\")\n            ) {\n              var receiver = placement === \"static\" ? F : proto;\n              this.defineClassElement(receiver, element);\n            }\n          }, this);\n        }, this);\n      },\n\n      // DefineClassElement\n      defineClassElement: function(\n        /*::<C>*/ receiver /*: C | Class<C> */,\n        element /*: ElementDescriptor */,\n      ) {\n        var descriptor /*: PropertyDescriptor */ = element.descriptor;\n        if (element.kind === \"field\") {\n          var initializer = element.initializer;\n          descriptor = {\n            enumerable: descriptor.enumerable,\n            writable: descriptor.writable,\n            configurable: descriptor.configurable,\n            value: initializer === void 0 ? void 0 : initializer.call(receiver),\n          };\n        }\n        Object.defineProperty(receiver, element.key, descriptor);\n      },\n\n      // DecorateClass\n      decorateClass: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var newElements /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n        var placements /*: Placements */ = {\n          static: [],\n          prototype: [],\n          own: [],\n        };\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          this.addElementPlacement(element, placements);\n        }, this);\n\n        elements.forEach(function(element /*: ElementDescriptor */) {\n          if (!_hasDecorators(element)) return newElements.push(element);\n\n          var elementFinishersExtras /*: ElementFinishersExtras */ = this.decorateElement(\n            element,\n            placements,\n          );\n          newElements.push(elementFinishersExtras.element);\n          newElements.push.apply(newElements, elementFinishersExtras.extras);\n          finishers.push.apply(finishers, elementFinishersExtras.finishers);\n        }, this);\n\n        if (!decorators) {\n          return { elements: newElements, finishers: finishers };\n        }\n\n        var result /*: ElementsFinishers */ = this.decorateConstructor(\n          newElements,\n          decorators,\n        );\n        finishers.push.apply(finishers, result.finishers);\n        result.finishers = finishers;\n\n        return result;\n      },\n\n      // AddElementPlacement\n      addElementPlacement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n        silent /*: boolean */,\n      ) {\n        var keys = placements[element.placement];\n        if (!silent && keys.indexOf(element.key) !== -1) {\n          throw new TypeError(\"Duplicated element (\" + element.key + \")\");\n        }\n        keys.push(element.key);\n      },\n\n      // DecorateElement\n      decorateElement: function(\n        element /*: ElementDescriptor */,\n        placements /*: Placements */,\n      ) /*: ElementFinishersExtras */ {\n        var extras /*: ElementDescriptor[] */ = [];\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (\n          var decorators = element.decorators, i = decorators.length - 1;\n          i >= 0;\n          i--\n        ) {\n          // (inlined) RemoveElementPlacement\n          var keys = placements[element.placement];\n          keys.splice(keys.indexOf(element.key), 1);\n\n          var elementObject /*: ElementObjectInput */ = this.fromElementDescriptor(\n            element,\n          );\n          var elementFinisherExtras /*: ElementFinisherExtras */ = this.toElementFinisherExtras(\n            (0, decorators[i])(elementObject) /*: ElementObjectOutput */ ||\n              elementObject,\n          );\n\n          element = elementFinisherExtras.element;\n          this.addElementPlacement(element, placements);\n\n          if (elementFinisherExtras.finisher) {\n            finishers.push(elementFinisherExtras.finisher);\n          }\n\n          var newExtras /*: ElementDescriptor[] | void */ =\n            elementFinisherExtras.extras;\n          if (newExtras) {\n            for (var j = 0; j < newExtras.length; j++) {\n              this.addElementPlacement(newExtras[j], placements);\n            }\n            extras.push.apply(extras, newExtras);\n          }\n        }\n\n        return { element: element, finishers: finishers, extras: extras };\n      },\n\n      // DecorateConstructor\n      decorateConstructor: function(\n        elements /*: ElementDescriptor[] */,\n        decorators /*: ClassDecorator[] */,\n      ) /*: ElementsFinishers */ {\n        var finishers /*: ClassFinisher[] */ = [];\n\n        for (var i = decorators.length - 1; i >= 0; i--) {\n          var obj /*: ClassObject */ = this.fromClassDescriptor(elements);\n          var elementsAndFinisher /*: ElementsFinisher */ = this.toClassDescriptor(\n            (0, decorators[i])(obj) /*: ClassObject */ || obj,\n          );\n\n          if (elementsAndFinisher.finisher !== undefined) {\n            finishers.push(elementsAndFinisher.finisher);\n          }\n\n          if (elementsAndFinisher.elements !== undefined) {\n            elements = elementsAndFinisher.elements;\n\n            for (var j = 0; j < elements.length - 1; j++) {\n              for (var k = j + 1; k < elements.length; k++) {\n                if (\n                  elements[j].key === elements[k].key &&\n                  elements[j].placement === elements[k].placement\n                ) {\n                  throw new TypeError(\n                    \"Duplicated element (\" + elements[j].key + \")\",\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        return { elements: elements, finishers: finishers };\n      },\n\n      // FromElementDescriptor\n      fromElementDescriptor: function(\n        element /*: ElementDescriptor */,\n      ) /*: ElementObject */ {\n        var obj /*: ElementObject */ = {\n          kind: element.kind,\n          key: element.key,\n          placement: element.placement,\n          descriptor: element.descriptor,\n        };\n\n        var desc = {\n          value: \"Descriptor\",\n          configurable: true,\n        };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        if (element.kind === \"field\") obj.initializer = element.initializer;\n\n        return obj;\n      },\n\n      // ToElementDescriptors\n      toElementDescriptors: function(\n        elementObjects /*: ElementObject[] */,\n      ) /*: ElementDescriptor[] */ {\n        if (elementObjects === undefined) return;\n        return toArray(elementObjects).map(function(elementObject) {\n          var element = this.toElementDescriptor(elementObject);\n          this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\");\n          this.disallowProperty(elementObject, \"extras\", \"An element descriptor\");\n          return element;\n        }, this);\n      },\n\n      // ToElementDescriptor\n      toElementDescriptor: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementDescriptor */ {\n        var kind = String(elementObject.kind);\n        if (kind !== \"method\" && kind !== \"field\") {\n          throw new TypeError(\n            'An element descriptor\\\\'s .kind property must be either \"method\" or' +\n              ' \"field\", but a decorator created an element descriptor with' +\n              ' .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        var key = toPropertyKey(elementObject.key);\n\n        var placement = String(elementObject.placement);\n        if (\n          placement !== \"static\" &&\n          placement !== \"prototype\" &&\n          placement !== \"own\"\n        ) {\n          throw new TypeError(\n            'An element descriptor\\\\'s .placement property must be one of \"static\",' +\n              ' \"prototype\" or \"own\", but a decorator created an element descriptor' +\n              ' with .placement \"' +\n              placement +\n              '\"',\n          );\n        }\n\n        var descriptor /*: PropertyDescriptor */ = elementObject.descriptor;\n\n        this.disallowProperty(elementObject, \"elements\", \"An element descriptor\");\n\n        var element /*: ElementDescriptor */ = {\n          kind: kind,\n          key: key,\n          placement: placement,\n          descriptor: Object.assign({}, descriptor),\n        };\n\n        if (kind !== \"field\") {\n          this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\");\n        } else {\n          this.disallowProperty(\n            descriptor,\n            \"get\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"set\",\n            \"The property descriptor of a field descriptor\",\n          );\n          this.disallowProperty(\n            descriptor,\n            \"value\",\n            \"The property descriptor of a field descriptor\",\n          );\n\n          element.initializer = elementObject.initializer;\n        }\n\n        return element;\n      },\n\n      toElementFinisherExtras: function(\n        elementObject /*: ElementObject */,\n      ) /*: ElementFinisherExtras */ {\n        var element /*: ElementDescriptor */ = this.toElementDescriptor(\n          elementObject,\n        );\n        var finisher /*: ClassFinisher */ = _optionalCallableProperty(\n          elementObject,\n          \"finisher\",\n        );\n        var extras /*: ElementDescriptors[] */ = this.toElementDescriptors(\n          elementObject.extras,\n        );\n\n        return { element: element, finisher: finisher, extras: extras };\n      },\n\n      // FromClassDescriptor\n      fromClassDescriptor: function(\n        elements /*: ElementDescriptor[] */,\n      ) /*: ClassObject */ {\n        var obj = {\n          kind: \"class\",\n          elements: elements.map(this.fromElementDescriptor, this),\n        };\n\n        var desc = { value: \"Descriptor\", configurable: true };\n        Object.defineProperty(obj, Symbol.toStringTag, desc);\n\n        return obj;\n      },\n\n      // ToClassDescriptor\n      toClassDescriptor: function(\n        obj /*: ClassObject */,\n      ) /*: ElementsFinisher */ {\n        var kind = String(obj.kind);\n        if (kind !== \"class\") {\n          throw new TypeError(\n            'A class descriptor\\\\'s .kind property must be \"class\", but a decorator' +\n              ' created a class descriptor with .kind \"' +\n              kind +\n              '\"',\n          );\n        }\n\n        this.disallowProperty(obj, \"key\", \"A class descriptor\");\n        this.disallowProperty(obj, \"placement\", \"A class descriptor\");\n        this.disallowProperty(obj, \"descriptor\", \"A class descriptor\");\n        this.disallowProperty(obj, \"initializer\", \"A class descriptor\");\n        this.disallowProperty(obj, \"extras\", \"A class descriptor\");\n\n        var finisher = _optionalCallableProperty(obj, \"finisher\");\n        var elements = this.toElementDescriptors(obj.elements);\n\n        return { elements: elements, finisher: finisher };\n      },\n\n      // RunClassFinishers\n      runClassFinishers: function(\n        constructor /*: Class<*> */,\n        finishers /*: ClassFinisher[] */,\n      ) /*: Class<*> */ {\n        for (var i = 0; i < finishers.length; i++) {\n          var newConstructor /*: ?Class<*> */ = (0, finishers[i])(constructor);\n          if (newConstructor !== undefined) {\n            // NOTE: This should check if IsConstructor(newConstructor) is false.\n            if (typeof newConstructor !== \"function\") {\n              throw new TypeError(\"Finishers must return a constructor.\");\n            }\n            constructor = newConstructor;\n          }\n        }\n        return constructor;\n      },\n\n      disallowProperty: function(obj, name, objectType) {\n        if (obj[name] !== undefined) {\n          throw new TypeError(objectType + \" can't have a .\" + name + \" property.\");\n        }\n      }\n    };\n\n    return api;\n  }\n\n  // ClassElementEvaluation\n  function _createElementDescriptor(\n    def /*: ElementDefinition */,\n  ) /*: ElementDescriptor */ {\n    var key = toPropertyKey(def.key);\n\n    var descriptor /*: PropertyDescriptor */;\n    if (def.kind === \"method\") {\n      descriptor = {\n        value: def.value,\n        writable: true,\n        configurable: true,\n        enumerable: false,\n      };\n    } else if (def.kind === \"get\") {\n      descriptor = { get: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"set\") {\n      descriptor = { set: def.value, configurable: true, enumerable: false };\n    } else if (def.kind === \"field\") {\n      descriptor = { configurable: true, writable: true, enumerable: true };\n    }\n\n    var element /*: ElementDescriptor */ = {\n      kind: def.kind === \"field\" ? \"field\" : \"method\",\n      key: key,\n      placement: def.static\n        ? \"static\"\n        : def.kind === \"field\"\n        ? \"own\"\n        : \"prototype\",\n      descriptor: descriptor,\n    };\n    if (def.decorators) element.decorators = def.decorators;\n    if (def.kind === \"field\") element.initializer = def.value;\n\n    return element;\n  }\n\n  // CoalesceGetterSetter\n  function _coalesceGetterSetter(\n    element /*: ElementDescriptor */,\n    other /*: ElementDescriptor */,\n  ) {\n    if (element.descriptor.get !== undefined) {\n      other.descriptor.get = element.descriptor.get;\n    } else {\n      other.descriptor.set = element.descriptor.set;\n    }\n  }\n\n  // CoalesceClassElements\n  function _coalesceClassElements(\n    elements /*: ElementDescriptor[] */,\n  ) /*: ElementDescriptor[] */ {\n    var newElements /*: ElementDescriptor[] */ = [];\n\n    var isSameElement = function(\n      other /*: ElementDescriptor */,\n    ) /*: boolean */ {\n      return (\n        other.kind === \"method\" &&\n        other.key === element.key &&\n        other.placement === element.placement\n      );\n    };\n\n    for (var i = 0; i < elements.length; i++) {\n      var element /*: ElementDescriptor */ = elements[i];\n      var other /*: ElementDescriptor */;\n\n      if (\n        element.kind === \"method\" &&\n        (other = newElements.find(isSameElement))\n      ) {\n        if (\n          _isDataDescriptor(element.descriptor) ||\n          _isDataDescriptor(other.descriptor)\n        ) {\n          if (_hasDecorators(element) || _hasDecorators(other)) {\n            throw new ReferenceError(\n              \"Duplicated methods (\" + element.key + \") can't be decorated.\",\n            );\n          }\n          other.descriptor = element.descriptor;\n        } else {\n          if (_hasDecorators(element)) {\n            if (_hasDecorators(other)) {\n              throw new ReferenceError(\n                \"Decorators can't be placed on different accessors with for \" +\n                  \"the same property (\" +\n                  element.key +\n                  \").\",\n              );\n            }\n            other.decorators = element.decorators;\n          }\n          _coalesceGetterSetter(element, other);\n        }\n      } else {\n        newElements.push(element);\n      }\n    }\n\n    return newElements;\n  }\n\n  function _hasDecorators(element /*: ElementDescriptor */) /*: boolean */ {\n    return element.decorators && element.decorators.length;\n  }\n\n  function _isDataDescriptor(desc /*: PropertyDescriptor */) /*: boolean */ {\n    return (\n      desc !== undefined &&\n      !(desc.value === undefined && desc.writable === undefined)\n    );\n  }\n\n  function _optionalCallableProperty /*::<T>*/(\n    obj /*: T */,\n    name /*: $Keys<T> */,\n  ) /*: ?Function */ {\n    var value = obj[name];\n    if (value !== undefined && typeof value !== \"function\") {\n      throw new TypeError(\"Expected '\" + name + \"' to be a function\");\n    }\n    return value;\n  }\n\n"])));
  helpers$1.classPrivateMethodGet = helper$2("7.1.6")(_templateObject83 || (_templateObject83 = _taggedTemplateLiteralLoose(["\n  export default function _classPrivateMethodGet(receiver, privateSet, fn) {\n    if (!privateSet.has(receiver)) {\n      throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return fn;\n  }\n"])));
  {
    helpers$1.classPrivateMethodSet = helper$2("7.1.6")(_templateObject84 || (_templateObject84 = _taggedTemplateLiteralLoose(["\n    export default function _classPrivateMethodSet() {\n      throw new TypeError(\"attempted to reassign private method\");\n    }\n  "])));
  }

  function makePath(path) {
    var parts = [];

    for (; path.parentPath; path = path.parentPath) {
      parts.push(path.key);
      if (path.inList) parts.push(path.listKey);
    }

    return parts.reverse().join(".");
  }

  var fileClass = undefined;

  function getHelperMetadata(file) {
    var globals = new Set();
    var localBindingNames = new Set();
    var dependencies = new Map();
    var exportName;
    var exportPath;
    var exportBindingAssignments = [];
    var importPaths = [];
    var importBindingsReferences = [];
    var dependencyVisitor = {
      ImportDeclaration: function ImportDeclaration(child) {
        var name = child.node.source.value;

        if (!helpers$1[name]) {
          throw child.buildCodeFrameError("Unknown helper " + name);
        }

        if (child.get("specifiers").length !== 1 || !child.get("specifiers.0").isImportDefaultSpecifier()) {
          throw child.buildCodeFrameError("Helpers can only import a default value");
        }

        var bindingIdentifier = child.node.specifiers[0].local;
        dependencies.set(bindingIdentifier, name);
        importPaths.push(makePath(child));
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(child) {
        var decl = child.get("declaration");

        if (decl.isFunctionDeclaration()) {
          if (!decl.node.id) {
            throw decl.buildCodeFrameError("Helpers should give names to their exported func declaration");
          }

          exportName = decl.node.id.name;
        }

        exportPath = makePath(child);
      },
      ExportAllDeclaration: function ExportAllDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(child) {
        throw child.buildCodeFrameError("Helpers can only export default");
      },
      Statement: function Statement(child) {
        if (child.isModuleDeclaration()) return;
        child.skip();
      }
    };
    var referenceVisitor = {
      Program: function Program(path) {
        var bindings = path.scope.getAllBindings();
        Object.keys(bindings).forEach(function (name) {
          if (name === exportName) return;
          if (dependencies.has(bindings[name].identifier)) return;
          localBindingNames.add(name);
        });
      },
      ReferencedIdentifier: function ReferencedIdentifier(child) {
        var name = child.node.name;
        var binding = child.scope.getBinding(name, true);

        if (!binding) {
          globals.add(name);
        } else if (dependencies.has(binding.identifier)) {
          importBindingsReferences.push(makePath(child));
        }
      },
      AssignmentExpression: function AssignmentExpression(child) {
        var left = child.get("left");
        if (!(exportName in left.getBindingIdentifiers())) return;

        if (!left.isIdentifier()) {
          throw left.buildCodeFrameError("Only simple assignments to exports are allowed in helpers");
        }

        var binding = child.scope.getBinding(exportName);

        if (binding != null && binding.scope.path.isProgram()) {
          exportBindingAssignments.push(makePath(child));
        }
      }
    };
    traverse(file.ast, dependencyVisitor, file.scope);
    traverse(file.ast, referenceVisitor, file.scope);
    if (!exportPath) throw new Error("Helpers must default-export something.");
    exportBindingAssignments.reverse();
    return {
      globals: Array.from(globals),
      localBindingNames: Array.from(localBindingNames),
      dependencies: dependencies,
      exportBindingAssignments: exportBindingAssignments,
      exportPath: exportPath,
      exportName: exportName,
      importBindingsReferences: importBindingsReferences,
      importPaths: importPaths
    };
  }

  function permuteHelperAST(file, metadata, id, localBindings, getDependency) {
    if (localBindings && !id) {
      throw new Error("Unexpected local bindings for module-based helpers.");
    }

    if (!id) return;
    var localBindingNames = metadata.localBindingNames,
        dependencies = metadata.dependencies,
        exportBindingAssignments = metadata.exportBindingAssignments,
        exportPath = metadata.exportPath,
        exportName = metadata.exportName,
        importBindingsReferences = metadata.importBindingsReferences,
        importPaths = metadata.importPaths;
    var dependenciesRefs = {};
    dependencies.forEach(function (name, id) {
      dependenciesRefs[id.name] = typeof getDependency === "function" && getDependency(name) || id;
    });
    var toRename = {};
    var bindings = new Set(localBindings || []);
    localBindingNames.forEach(function (name) {
      var newName = name;

      while (bindings.has(newName)) {
        newName = "_" + newName;
      }

      if (newName !== name) toRename[name] = newName;
    });

    if (id.type === "Identifier" && exportName !== id.name) {
      toRename[exportName] = id.name;
    }

    var visitor = {
      Program: function Program(path) {
        var exp = path.get(exportPath);
        var imps = importPaths.map(function (p) {
          return path.get(p);
        });
        var impsBindingRefs = importBindingsReferences.map(function (p) {
          return path.get(p);
        });
        var decl = exp.get("declaration");

        if (id.type === "Identifier") {
          if (decl.isFunctionDeclaration()) {
            exp.replaceWith(decl);
          } else {
            exp.replaceWith(variableDeclaration("var", [variableDeclarator(id, decl.node)]));
          }
        } else if (id.type === "MemberExpression") {
          if (decl.isFunctionDeclaration()) {
            exportBindingAssignments.forEach(function (assignPath) {
              var assign = path.get(assignPath);
              assign.replaceWith(assignmentExpression("=", id, assign.node));
            });
            exp.replaceWith(decl);
            path.pushContainer("body", expressionStatement(assignmentExpression("=", id, identifier(exportName))));
          } else {
            exp.replaceWith(expressionStatement(assignmentExpression("=", id, decl.node)));
          }
        } else {
          throw new Error("Unexpected helper format.");
        }

        Object.keys(toRename).forEach(function (name) {
          path.scope.rename(name, toRename[name]);
        });

        for (var _iterator = _createForOfIteratorHelperLoose(imps), _step; !(_step = _iterator()).done;) {
          var _path = _step.value;

          _path.remove();
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(impsBindingRefs), _step2; !(_step2 = _iterator2()).done;) {
          var _path2 = _step2.value;
          var node = cloneNode(dependenciesRefs[_path2.node.name]);

          _path2.replaceWith(node);
        }

        path.stop();
      }
    };
    traverse(file.ast, visitor, file.scope);
  }

  var helperData = Object.create(null);

  function loadHelper(name) {
    if (!helperData[name]) {
      var helper = helpers$1[name];

      if (!helper) {
        throw Object.assign(new ReferenceError("Unknown helper " + name), {
          code: "BABEL_HELPER_UNKNOWN",
          helper: name
        });
      }

      var fn = function fn() {
        var file$1 = {
          ast: file(helper.ast())
        };

        if (fileClass) {
          return new fileClass({
            filename: "babel-helper://" + name
          }, file$1);
        }

        return file$1;
      };

      var metadata = getHelperMetadata(fn());
      helperData[name] = {
        build: function build(getDependency, id, localBindings) {
          var file = fn();
          permuteHelperAST(file, metadata, id, localBindings, getDependency);
          return {
            nodes: file.ast.program.body,
            globals: metadata.globals
          };
        },
        minVersion: function minVersion() {
          return helper.minVersion;
        },
        dependencies: metadata.dependencies
      };
    }

    return helperData[name];
  }

  function get$1(name, getDependency, id, localBindings) {
    return loadHelper(name).build(getDependency, id, localBindings);
  }
  function minVersion$3(name) {
    return loadHelper(name).minVersion();
  }
  function getDependencies(name) {
    return Array.from(loadHelper(name).dependencies.values());
  }
  function ensure(name, newFileClass) {
    if (!fileClass) {
      fileClass = newFileClass;
    }

    loadHelper(name);
  }
  var list = Object.keys(helpers$1).map(function (name) {
    return name.replace(/^_/, "");
  }).filter(function (name) {
    return name !== "__esModule";
  });

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */

  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      }

      var test1 = new String('abc');
      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      }

      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      }

      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty$1.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  var isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
  };

  var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
  }, "/$$rollup_base$$/node_modules/util/node_modules/inherits");

  var util$5 = createCommonjsModule(function (module, exports) {
    var formatRegExp = /%[sdj%]/g;

    exports.format = function (f) {
      if (!isString(f)) {
        var objects = [];

        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }

        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function (x) {
        if (x === '%%') return '%';
        if (i >= len) return x;

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

          default:
            return x;
        }
      });

      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }

      return str;
    };

    exports.deprecate = function (fn, msg) {
      if (isUndefined(commonjsGlobal.process)) {
        return function () {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      if (browser$6.noDeprecation === true) {
        return fn;
      }

      var warned = false;

      function deprecated() {
        if (!warned) {
          if (browser$6.throwDeprecation) {
            throw new Error(msg);
          } else if (browser$6.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }

          warned = true;
        }

        return fn.apply(this, arguments);
      }

      return deprecated;
    };

    var debugs = {};
    var debugEnviron;

    exports.debuglog = function (set) {
      if (isUndefined(debugEnviron)) debugEnviron = browser$6.env.NODE_DEBUG || '';
      set = set.toUpperCase();

      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = browser$6.pid;

          debugs[set] = function () {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function () {};
        }
      }

      return debugs[set];
    };

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];

      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }

      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }

    exports.inspect = inspect;
    inspect.colors = {
      'bold': [1, 22],
      'italic': [3, 23],
      'underline': [4, 24],
      'inverse': [7, 27],
      'white': [37, 39],
      'grey': [90, 39],
      'black': [30, 39],
      'blue': [34, 39],
      'cyan': [36, 39],
      'green': [32, 39],
      'magenta': [35, 39],
      'red': [31, 39],
      'yellow': [33, 39]
    };
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      'regexp': 'red'
    };

    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }

    function stylizeNoColor(str, styleType) {
      return str;
    }

    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }

    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);

        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }

        return ret;
      }

      var primitive = formatPrimitive(ctx, value);

      if (primitive) {
        return primitive;
      }

      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }

        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }

        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }

        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '',
          array = false,
          braces = ['{', '}'];

      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);
      var output;

      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }

    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }

      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      if (isNull(value)) return ctx.stylize('null', 'null');
    }

    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }

    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];

      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }

      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }

    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };

      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }

      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }

      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }

          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }

      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }

        name = JSON.stringify('' + key);

        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }

    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function (prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    function isArray(ar) {
      return Array.isArray(ar);
    }

    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }

    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }

    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }

    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }

    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }

    exports.isString = isString;

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }

    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }

    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }

    exports.isRegExp = isRegExp;

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }

    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }

    exports.isDate = isDate;

    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }

    exports.isError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }

    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || typeof arg === 'undefined';
    }

    exports.isPrimitive = isPrimitive;
    exports.isBuffer = isBufferBrowser;

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }

    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }

    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }

    exports.log = function () {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };

    exports.inherits = inherits_browser;

    exports._extend = function (origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i = keys.length;

      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }

      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
  }, "/$$rollup_base$$/node_modules/util");

  var assert_1 = createCommonjsModule(function (module) {
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */

    function compare(a, b) {
      if (a === b) {
        return 0;
      }

      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) {
        return -1;
      }

      if (y < x) {
        return 1;
      }

      return 0;
    }

    function isBuffer(b) {
      if (commonjsGlobal.Buffer && typeof commonjsGlobal.Buffer.isBuffer === 'function') {
        return commonjsGlobal.Buffer.isBuffer(b);
      }

      return !!(b != null && b._isBuffer);
    }

    var hasOwn = Object.prototype.hasOwnProperty;
    var pSlice = Array.prototype.slice;

    var functionsHaveNames = function () {
      return function foo() {}.name === 'foo';
    }();

    function pToString(obj) {
      return Object.prototype.toString.call(obj);
    }

    function isView(arrbuf) {
      if (isBuffer(arrbuf)) {
        return false;
      }

      if (typeof commonjsGlobal.ArrayBuffer !== 'function') {
        return false;
      }

      if (typeof ArrayBuffer.isView === 'function') {
        return ArrayBuffer.isView(arrbuf);
      }

      if (!arrbuf) {
        return false;
      }

      if (arrbuf instanceof DataView) {
        return true;
      }

      if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
        return true;
      }

      return false;
    }

    var assert = module.exports = ok;
    var regex = /\s*function\s+([^\(\s]*)\s*/;

    function getName(func) {
      if (!util$5.isFunction(func)) {
        return;
      }

      if (functionsHaveNames) {
        return func.name;
      }

      var str = func.toString();
      var match = str.match(regex);
      return match && match[1];
    }

    assert.AssertionError = function AssertionError(options) {
      this.name = 'AssertionError';
      this.actual = options.actual;
      this.expected = options.expected;
      this.operator = options.operator;

      if (options.message) {
        this.message = options.message;
        this.generatedMessage = false;
      } else {
        this.message = getMessage(this);
        this.generatedMessage = true;
      }

      var stackStartFunction = options.stackStartFunction || fail;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, stackStartFunction);
      } else {
        var err = new Error();

        if (err.stack) {
          var out = err.stack;
          var fn_name = getName(stackStartFunction);
          var idx = out.indexOf('\n' + fn_name);

          if (idx >= 0) {
            var next_line = out.indexOf('\n', idx + 1);
            out = out.substring(next_line + 1);
          }

          this.stack = out;
        }
      }
    };

    util$5.inherits(assert.AssertionError, Error);

    function truncate(s, n) {
      if (typeof s === 'string') {
        return s.length < n ? s : s.slice(0, n);
      } else {
        return s;
      }
    }

    function inspect(something) {
      if (functionsHaveNames || !util$5.isFunction(something)) {
        return util$5.inspect(something);
      }

      var rawname = getName(something);
      var name = rawname ? ': ' + rawname : '';
      return '[Function' + name + ']';
    }

    function getMessage(self) {
      return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
    }

    function fail(actual, expected, message, operator, stackStartFunction) {
      throw new assert.AssertionError({
        message: message,
        actual: actual,
        expected: expected,
        operator: operator,
        stackStartFunction: stackStartFunction
      });
    }

    assert.fail = fail;

    function ok(value, message) {
      if (!value) fail(value, true, message, '==', assert.ok);
    }

    assert.ok = ok;

    assert.equal = function equal(actual, expected, message) {
      if (actual != expected) fail(actual, expected, message, '==', assert.equal);
    };

    assert.notEqual = function notEqual(actual, expected, message) {
      if (actual == expected) {
        fail(actual, expected, message, '!=', assert.notEqual);
      }
    };

    assert.deepEqual = function deepEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
      }
    };

    assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
      if (!_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
      }
    };

    function _deepEqual(actual, expected, strict, memos) {
      if (actual === expected) {
        return true;
      } else if (isBuffer(actual) && isBuffer(expected)) {
        return compare(actual, expected) === 0;
      } else if (util$5.isDate(actual) && util$5.isDate(expected)) {
        return actual.getTime() === expected.getTime();
      } else if (util$5.isRegExp(actual) && util$5.isRegExp(expected)) {
        return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
      } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
        return strict ? actual === expected : actual == expected;
      } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
        return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;
      } else if (isBuffer(actual) !== isBuffer(expected)) {
        return false;
      } else {
        memos = memos || {
          actual: [],
          expected: []
        };
        var actualIndex = memos.actual.indexOf(actual);

        if (actualIndex !== -1) {
          if (actualIndex === memos.expected.indexOf(expected)) {
            return true;
          }
        }

        memos.actual.push(actual);
        memos.expected.push(expected);
        return objEquiv(actual, expected, strict, memos);
      }
    }

    function isArguments(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    }

    function objEquiv(a, b, strict, actualVisitedObjects) {
      if (a === null || a === undefined || b === null || b === undefined) return false;
      if (util$5.isPrimitive(a) || util$5.isPrimitive(b)) return a === b;
      if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
      var aIsArgs = isArguments(a);
      var bIsArgs = isArguments(b);
      if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

      if (aIsArgs) {
        a = pSlice.call(a);
        b = pSlice.call(b);
        return _deepEqual(a, b, strict);
      }

      var ka = objectKeys(a);
      var kb = objectKeys(b);
      var key, i;
      if (ka.length !== kb.length) return false;
      ka.sort();
      kb.sort();

      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] !== kb[i]) return false;
      }

      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
      }

      return true;
    }

    assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, false)) {
        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
      }
    };

    assert.notDeepStrictEqual = notDeepStrictEqual;

    function notDeepStrictEqual(actual, expected, message) {
      if (_deepEqual(actual, expected, true)) {
        fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
      }
    }

    assert.strictEqual = function strictEqual(actual, expected, message) {
      if (actual !== expected) {
        fail(actual, expected, message, '===', assert.strictEqual);
      }
    };

    assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
      if (actual === expected) {
        fail(actual, expected, message, '!==', assert.notStrictEqual);
      }
    };

    function expectedException(actual, expected) {
      if (!actual || !expected) {
        return false;
      }

      if (Object.prototype.toString.call(expected) == '[object RegExp]') {
        return expected.test(actual);
      }

      try {
        if (actual instanceof expected) {
          return true;
        }
      } catch (e) {}

      if (Error.isPrototypeOf(expected)) {
        return false;
      }

      return expected.call({}, actual) === true;
    }

    function _tryBlock(block) {
      var error;

      try {
        block();
      } catch (e) {
        error = e;
      }

      return error;
    }

    function _throws(shouldThrow, block, expected, message) {
      var actual;

      if (typeof block !== 'function') {
        throw new TypeError('"block" argument must be a function');
      }

      if (typeof expected === 'string') {
        message = expected;
        expected = null;
      }

      actual = _tryBlock(block);
      message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

      if (shouldThrow && !actual) {
        fail(actual, expected, 'Missing expected exception' + message);
      }

      var userProvidedMessage = typeof message === 'string';
      var isUnwantedException = !shouldThrow && util$5.isError(actual);
      var isUnexpectedException = !shouldThrow && actual && !expected;

      if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
        fail(actual, expected, 'Got unwanted exception' + message);
      }

      if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
        throw actual;
      }
    }

    assert["throws"] = function (block, error, message) {
      _throws(true, block, error, message);
    };

    assert.doesNotThrow = function (block, error, message) {
      _throws(false, block, error, message);
    };

    assert.ifError = function (err) {
      if (err) throw err;
    };

    function strict(value, message) {
      if (!value) fail(value, true, message, '==', strict);
    }

    assert.strict = objectAssign(strict, assert, {
      equal: assert.strictEqual,
      deepEqual: assert.deepStrictEqual,
      notEqual: assert.notStrictEqual,
      notDeepEqual: assert.notDeepStrictEqual
    });
    assert.strict.strict = assert.strict;

    var objectKeys = Object.keys || function (obj) {
      var keys = [];

      for (var key in obj) {
        if (hasOwn.call(obj, key)) keys.push(key);
      }

      return keys;
    };
  }, "/$$rollup_base$$/node_modules/assert");

  var ImportBuilder = function () {
    function ImportBuilder(importedSource, scope, hub) {
      this._statements = [];
      this._resultName = null;
      this._scope = null;
      this._hub = null;
      this._importedSource = void 0;
      this._scope = scope;
      this._hub = hub;
      this._importedSource = importedSource;
    }

    var _proto = ImportBuilder.prototype;

    _proto.done = function done() {
      return {
        statements: this._statements,
        resultName: this._resultName
      };
    };

    _proto["import"] = function _import() {
      this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));

      return this;
    };

    _proto.require = function require() {
      this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));

      return this;
    };

    _proto.namespace = function namespace(name) {
      if (name === void 0) {
        name = "namespace";
      }

      var local = this._scope.generateUidIdentifier(name);

      var statement = this._statements[this._statements.length - 1];
      assert_1(statement.type === "ImportDeclaration");
      assert_1(statement.specifiers.length === 0);
      statement.specifiers = [importNamespaceSpecifier(local)];
      this._resultName = cloneNode(local);
      return this;
    };

    _proto["default"] = function _default(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert_1(statement.type === "ImportDeclaration");
      assert_1(statement.specifiers.length === 0);
      statement.specifiers = [importDefaultSpecifier(name)];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.named = function named(name, importName) {
      if (importName === "default") return this["default"](name);
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];
      assert_1(statement.type === "ImportDeclaration");
      assert_1(statement.specifiers.length === 0);
      statement.specifiers = [importSpecifier(name, identifier(importName))];
      this._resultName = cloneNode(name);
      return this;
    };

    _proto["var"] = function _var(name) {
      name = this._scope.generateUidIdentifier(name);
      var statement = this._statements[this._statements.length - 1];

      if (statement.type !== "ExpressionStatement") {
        assert_1(this._resultName);
        statement = expressionStatement(this._resultName);

        this._statements.push(statement);
      }

      this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(name, statement.expression)]);
      this._resultName = cloneNode(name);
      return this;
    };

    _proto.defaultInterop = function defaultInterop() {
      return this._interop(this._hub.addHelper("interopRequireDefault"));
    };

    _proto.wildcardInterop = function wildcardInterop() {
      return this._interop(this._hub.addHelper("interopRequireWildcard"));
    };

    _proto._interop = function _interop(callee) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = callExpression(callee, [statement.expression]);
      } else if (statement.type === "VariableDeclaration") {
        assert_1(statement.declarations.length === 1);
        statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
      } else {
        assert_1.fail("Unexpected type.");
      }

      return this;
    };

    _proto.prop = function prop(name) {
      var statement = this._statements[this._statements.length - 1];

      if (statement.type === "ExpressionStatement") {
        statement.expression = memberExpression(statement.expression, identifier(name));
      } else if (statement.type === "VariableDeclaration") {
        assert_1(statement.declarations.length === 1);
        statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name));
      } else {
        assert_1.fail("Unexpected type:" + statement.type);
      }

      return this;
    };

    _proto.read = function read(name) {
      this._resultName = memberExpression(this._resultName, identifier(name));
    };

    return ImportBuilder;
  }();

  function isModule(path) {
    var sourceType = path.node.sourceType;

    if (sourceType !== "module" && sourceType !== "script") {
      throw path.buildCodeFrameError("Unknown sourceType \"" + sourceType + "\", cannot transform.");
    }

    return path.node.sourceType === "module";
  }

  var ImportInjector = function () {
    function ImportInjector(path, importedSource, opts) {
      this._defaultOpts = {
        importedSource: null,
        importedType: "commonjs",
        importedInterop: "babel",
        importingInterop: "babel",
        ensureLiveReference: false,
        ensureNoContext: false,
        importPosition: "before"
      };
      var programPath = path.find(function (p) {
        return p.isProgram();
      });
      this._programPath = programPath;
      this._programScope = programPath.scope;
      this._hub = programPath.hub;
      this._defaultOpts = this._applyDefaults(importedSource, opts, true);
    }

    var _proto = ImportInjector.prototype;

    _proto.addDefault = function addDefault(importedSourceIn, opts) {
      return this.addNamed("default", importedSourceIn, opts);
    };

    _proto.addNamed = function addNamed(importName, importedSourceIn, opts) {
      assert_1(typeof importName === "string");
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
    };

    _proto.addNamespace = function addNamespace(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
    };

    _proto.addSideEffect = function addSideEffect(importedSourceIn, opts) {
      return this._generateImport(this._applyDefaults(importedSourceIn, opts), false);
    };

    _proto._applyDefaults = function _applyDefaults(importedSource, opts, isInit) {
      if (isInit === void 0) {
        isInit = false;
      }

      var optsList = [];

      if (typeof importedSource === "string") {
        optsList.push({
          importedSource: importedSource
        });
        optsList.push(opts);
      } else {
        assert_1(!opts, "Unexpected secondary arguments.");
        optsList.push(importedSource);
      }

      var newOpts = Object.assign({}, this._defaultOpts);

      var _loop = function _loop() {
        var opts = _optsList[_i];
        if (!opts) return "continue";
        Object.keys(newOpts).forEach(function (key) {
          if (opts[key] !== undefined) newOpts[key] = opts[key];
        });

        if (!isInit) {
          if (opts.nameHint !== undefined) newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== undefined) newOpts.blockHoist = opts.blockHoist;
        }
      };

      for (var _i = 0, _optsList = optsList; _i < _optsList.length; _i++) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }

      return newOpts;
    };

    _proto._generateImport = function _generateImport(opts, importName) {
      var isDefault = importName === "default";
      var isNamed = !!importName && !isDefault;
      var isNamespace = importName === null;
      var importedSource = opts.importedSource,
          importedType = opts.importedType,
          importedInterop = opts.importedInterop,
          importingInterop = opts.importingInterop,
          ensureLiveReference = opts.ensureLiveReference,
          ensureNoContext = opts.ensureNoContext,
          nameHint = opts.nameHint,
          importPosition = opts.importPosition,
          blockHoist = opts.blockHoist;
      var name = nameHint || importName;
      var isMod = isModule(this._programPath);
      var isModuleForNode = isMod && importingInterop === "node";
      var isModuleForBabel = isMod && importingInterop === "babel";

      if (importPosition === "after" && !isMod) {
        throw new Error("\"importPosition\": \"after\" is only supported in modules");
      }

      var builder = new ImportBuilder(importedSource, this._programScope, this._hub);

      if (importedType === "es6") {
        if (!isModuleForNode && !isModuleForBabel) {
          throw new Error("Cannot import an ES6 module from CommonJS");
        }

        builder["import"]();

        if (isNamespace) {
          builder.namespace(nameHint || importedSource);
        } else if (isDefault || isNamed) {
          builder.named(name, importName);
        }
      } else if (importedType !== "commonjs") {
        throw new Error("Unexpected interopType \"" + importedType + "\"");
      } else if (importedInterop === "babel") {
        if (isModuleForNode) {
          name = name !== "default" ? name : importedSource;
          var es6Default = importedSource + "$es6Default";
          builder["import"]();

          if (isNamespace) {
            builder["default"](es6Default)["var"](name || importedSource).wildcardInterop();
          } else if (isDefault) {
            if (ensureLiveReference) {
              builder["default"](es6Default)["var"](name || importedSource).defaultInterop().read("default");
            } else {
              builder["default"](es6Default)["var"](name).defaultInterop().prop(importName);
            }
          } else if (isNamed) {
            builder["default"](es6Default).read(importName);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource).wildcardInterop();
          } else if ((isDefault || isNamed) && ensureLiveReference) {
            if (isDefault) {
              name = name !== "default" ? name : importedSource;
              builder["var"](name).read(importName);
              builder.defaultInterop();
            } else {
              builder["var"](importedSource).read(importName);
            }
          } else if (isDefault) {
            builder["var"](name).defaultInterop().prop(importName);
          } else if (isNamed) {
            builder["var"](name).prop(importName);
          }
        }
      } else if (importedInterop === "compiled") {
        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault || isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder.namespace(name || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault || isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder.prop(importName)["var"](name);
            }
          }
        }
      } else if (importedInterop === "uncompiled") {
        if (isDefault && ensureLiveReference) {
          throw new Error("No live reference for commonjs default");
        }

        if (isModuleForNode) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder["default"](importedSource).read(name);
          }
        } else if (isModuleForBabel) {
          builder["import"]();

          if (isNamespace) {
            builder["default"](name || importedSource);
          } else if (isDefault) {
            builder["default"](name);
          } else if (isNamed) {
            builder.named(name, importName);
          }
        } else {
          builder.require();

          if (isNamespace) {
            builder["var"](name || importedSource);
          } else if (isDefault) {
            builder["var"](name);
          } else if (isNamed) {
            if (ensureLiveReference) {
              builder["var"](importedSource).read(name);
            } else {
              builder["var"](name).prop(importName);
            }
          }
        }
      } else {
        throw new Error("Unknown importedInterop \"" + importedInterop + "\".");
      }

      var _builder$done = builder.done(),
          statements = _builder$done.statements,
          resultName = _builder$done.resultName;

      this._insertStatements(statements, importPosition, blockHoist);

      if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
        return sequenceExpression([numericLiteral(0), resultName]);
      }

      return resultName;
    };

    _proto._insertStatements = function _insertStatements(statements, importPosition, blockHoist) {
      if (importPosition === void 0) {
        importPosition = "before";
      }

      if (blockHoist === void 0) {
        blockHoist = 3;
      }

      var body = this._programPath.get("body");

      if (importPosition === "after") {
        for (var i = body.length - 1; i >= 0; i--) {
          if (body[i].isImportDeclaration()) {
            body[i].insertAfter(statements);
            return;
          }
        }
      } else {
        statements.forEach(function (node) {
          node._blockHoist = blockHoist;
        });
        var targetPath = body.find(function (p) {
          var val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });

        if (targetPath) {
          targetPath.insertBefore(statements);
          return;
        }
      }

      this._programPath.unshiftContainer("body", statements);
    };

    return ImportInjector;
  }();

  function addDefault(path, importedSource, opts) {
    return new ImportInjector(path).addDefault(importedSource, opts);
  }
  function addNamed(path, name, importedSource, opts) {
    return new ImportInjector(path).addNamed(name, importedSource, opts);
  }
  function addNamespace(path, importedSource, opts) {
    return new ImportInjector(path).addNamespace(importedSource, opts);
  }

  function willPathCastToBoolean$1(path) {
    var maybeWrapped = path;
    var node = maybeWrapped.node,
        parentPath = maybeWrapped.parentPath;

    if (parentPath.isLogicalExpression()) {
      var _parentPath$node = parentPath.node,
          operator = _parentPath$node.operator,
          right = _parentPath$node.right;

      if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
        return willPathCastToBoolean$1(parentPath);
      }
    }

    if (parentPath.isSequenceExpression()) {
      var expressions = parentPath.node.expressions;

      if (expressions[expressions.length - 1] === node) {
        return willPathCastToBoolean$1(parentPath);
      } else {
        return true;
      }
    }

    return parentPath.isConditional({
      test: node
    }) || parentPath.isUnaryExpression({
      operator: "!"
    }) || parentPath.isLoop({
      test: node
    });
  }

  var AssignmentMemoiser = function () {
    function AssignmentMemoiser() {
      this._map = void 0;
      this._map = new WeakMap();
    }

    var _proto = AssignmentMemoiser.prototype;

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.get = function get(key) {
      if (!this.has(key)) return;

      var record = this._map.get(key);

      var value = record.value;
      record.count--;

      if (record.count === 0) {
        return assignmentExpression("=", value, key);
      }

      return value;
    };

    _proto.set = function set(key, value, count) {
      return this._map.set(key, {
        count: count,
        value: value
      });
    };

    return AssignmentMemoiser;
  }();

  function toNonOptional(path, base) {
    var node = path.node;

    if (path.isOptionalMemberExpression()) {
      return memberExpression(base, node.property, node.computed);
    }

    if (path.isOptionalCallExpression()) {
      var callee = path.get("callee");

      if (path.node.optional && callee.isOptionalMemberExpression()) {
        var object = callee.node.object;
        var context = path.scope.maybeGenerateMemoised(object) || object;
        callee.get("object").replaceWith(assignmentExpression("=", context, object));
        return callExpression(memberExpression(base, identifier("call")), [context].concat(_toConsumableArray(node.arguments)));
      }

      return callExpression(base, node.arguments);
    }

    return path.node;
  }

  function isInDetachedTree(path) {
    while (path) {
      if (path.isProgram()) break;
      var _path = path,
          parentPath = _path.parentPath,
          container = _path.container,
          listKey = _path.listKey;
      var parentNode = parentPath.node;

      if (listKey) {
        if (container !== parentNode[listKey]) return true;
      } else {
        if (container !== parentNode) return true;
      }

      path = parentPath;
    }

    return false;
  }

  var handle = {
    memoise: function memoise() {},
    handle: function handle(member, noDocumentAll) {
      var node = member.node,
          parent = member.parent,
          parentPath = member.parentPath,
          scope = member.scope;

      if (member.isOptionalMemberExpression()) {
        if (isInDetachedTree(member)) return;
        var endPath = member.find(function (_ref) {
          var node = _ref.node,
              parent = _ref.parent,
              parentPath = _ref.parentPath;

          if (parentPath.isOptionalMemberExpression()) {
            return parent.optional || parent.object !== node;
          }

          if (parentPath.isOptionalCallExpression()) {
            return node !== member.node && parent.optional || parent.callee !== node;
          }

          return true;
        });

        if (scope.path.isPattern()) {
          endPath.replaceWith(callExpression(arrowFunctionExpression([], endPath.node), []));
          return;
        }

        var willEndPathCastToBoolean = willPathCastToBoolean$1(endPath);
        var rootParentPath = endPath.parentPath;

        if (rootParentPath.isUpdateExpression({
          argument: node
        }) || rootParentPath.isAssignmentExpression({
          left: node
        })) {
          throw member.buildCodeFrameError("can't handle assignment");
        }

        var isDeleteOperation = rootParentPath.isUnaryExpression({
          operator: "delete"
        });

        if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get("property").isPrivateName()) {
          throw member.buildCodeFrameError("can't delete a private class element");
        }

        var startingOptional = member;

        for (;;) {
          if (startingOptional.isOptionalMemberExpression()) {
            if (startingOptional.node.optional) break;
            startingOptional = startingOptional.get("object");
            continue;
          } else if (startingOptional.isOptionalCallExpression()) {
            if (startingOptional.node.optional) break;
            startingOptional = startingOptional.get("callee");
            continue;
          }

          throw new Error("Internal error: unexpected " + startingOptional.node.type);
        }

        var startingProp = startingOptional.isOptionalMemberExpression() ? "object" : "callee";
        var startingNode = startingOptional.node[startingProp];
        var baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);
        var baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;
        var parentIsOptionalCall = parentPath.isOptionalCallExpression({
          callee: node
        });
        var parentIsCall = parentPath.isCallExpression({
          callee: node
        });
        startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));

        if (parentIsOptionalCall) {
          if (parent.optional) {
            parentPath.replaceWith(this.optionalCall(member, parent.arguments));
          } else {
            parentPath.replaceWith(this.call(member, parent.arguments));
          }
        } else if (parentIsCall) {
          member.replaceWith(this.boundGet(member));
        } else {
          member.replaceWith(this.get(member));
        }

        var regular = member.node;

        for (var current = member; current !== endPath;) {
          var _current = current,
              _parentPath = _current.parentPath;

          if (_parentPath === endPath && parentIsOptionalCall && parent.optional) {
            regular = _parentPath.node;
            break;
          }

          regular = toNonOptional(_parentPath, regular);
          current = _parentPath;
        }

        var context;
        var endParentPath = endPath.parentPath;

        if (isMemberExpression(regular) && endParentPath.isOptionalCallExpression({
          callee: endPath.node,
          optional: true
        })) {
          var _regular = regular,
              object = _regular.object;
          context = member.scope.maybeGenerateMemoised(object);

          if (context) {
            regular.object = assignmentExpression("=", context, object);
          }
        }

        var replacementPath = endPath;

        if (isDeleteOperation) {
          replacementPath = endParentPath;
          regular = endParentPath.node;
        }

        var baseMemoised = baseNeedsMemoised ? assignmentExpression("=", cloneNode(baseRef), cloneNode(startingNode)) : cloneNode(baseRef);

        if (willEndPathCastToBoolean) {
          var nonNullishCheck;

          if (noDocumentAll) {
            nonNullishCheck = binaryExpression("!=", baseMemoised, nullLiteral());
          } else {
            nonNullishCheck = logicalExpression("&&", binaryExpression("!==", baseMemoised, nullLiteral()), binaryExpression("!==", cloneNode(baseRef), scope.buildUndefinedNode()));
          }

          replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, regular));
        } else {
          var nullishCheck;

          if (noDocumentAll) {
            nullishCheck = binaryExpression("==", baseMemoised, nullLiteral());
          } else {
            nullishCheck = logicalExpression("||", binaryExpression("===", baseMemoised, nullLiteral()), binaryExpression("===", cloneNode(baseRef), scope.buildUndefinedNode()));
          }

          replacementPath.replaceWith(conditionalExpression(nullishCheck, isDeleteOperation ? booleanLiteral(true) : scope.buildUndefinedNode(), regular));
        }

        if (context) {
          var endParent = endParentPath.node;
          endParentPath.replaceWith(optionalCallExpression(optionalMemberExpression(endParent.callee, identifier("call"), false, true), [cloneNode(context)].concat(_toConsumableArray(endParent.arguments)), false));
        }

        return;
      }

      if (parentPath.isUpdateExpression({
        argument: node
      })) {
        if (this.simpleSet) {
          member.replaceWith(this.simpleSet(member));
          return;
        }

        var operator = parent.operator,
            prefix = parent.prefix;
        this.memoise(member, 2);
        var value = binaryExpression(operator[0], unaryExpression("+", this.get(member)), numericLiteral(1));

        if (prefix) {
          parentPath.replaceWith(this.set(member, value));
        } else {
          var _scope = member.scope;

          var ref = _scope.generateUidIdentifierBasedOnNode(node);

          _scope.push({
            id: ref
          });

          value.left = assignmentExpression("=", cloneNode(ref), value.left);
          parentPath.replaceWith(sequenceExpression([this.set(member, value), cloneNode(ref)]));
        }

        return;
      }

      if (parentPath.isAssignmentExpression({
        left: node
      })) {
        if (this.simpleSet) {
          member.replaceWith(this.simpleSet(member));
          return;
        }

        var _operator = parent.operator,
            _value = parent.right;

        if (_operator === "=") {
          parentPath.replaceWith(this.set(member, _value));
        } else {
          var operatorTrunc = _operator.slice(0, -1);

          if (LOGICAL_OPERATORS.includes(operatorTrunc)) {
            this.memoise(member, 1);
            parentPath.replaceWith(logicalExpression(operatorTrunc, this.get(member), this.set(member, _value)));
          } else {
            this.memoise(member, 2);
            parentPath.replaceWith(this.set(member, binaryExpression(operatorTrunc, this.get(member), _value)));
          }
        }

        return;
      }

      if (parentPath.isCallExpression({
        callee: node
      })) {
        parentPath.replaceWith(this.call(member, parent.arguments));
        return;
      }

      if (parentPath.isOptionalCallExpression({
        callee: node
      })) {
        if (scope.path.isPattern()) {
          parentPath.replaceWith(callExpression(arrowFunctionExpression([], parentPath.node), []));
          return;
        }

        parentPath.replaceWith(this.optionalCall(member, parent.arguments));
        return;
      }

      if (parentPath.isForXStatement({
        left: node
      }) || parentPath.isObjectProperty({
        value: node
      }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isObjectProperty({
        value: parent
      }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({
        left: node
      }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {
        member.replaceWith(this.destructureSet(member));
        return;
      }

      if (parentPath.isTaggedTemplateExpression()) {
        member.replaceWith(this.boundGet(member));
      } else {
        member.replaceWith(this.get(member));
      }
    }
  };
  function memberExpressionToFunctions(path, visitor, state) {
    path.traverse(visitor, Object.assign({}, handle, state, {
      memoiser: new AssignmentMemoiser()
    }));
  }

  function optimiseCallExpression(callee, thisNode, args, optional) {
    if (args.length === 1 && isSpreadElement(args[0]) && isIdentifier(args[0].argument, {
      name: "arguments"
    })) {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("apply"), false, true), [thisNode, args[0].argument], false);
      }

      return callExpression(memberExpression(callee, identifier("apply")), [thisNode, args[0].argument]);
    } else {
      if (optional) {
        return optionalCallExpression(optionalMemberExpression(callee, identifier("call"), false, true), [thisNode].concat(_toConsumableArray(args)), false);
      }

      return callExpression(memberExpression(callee, identifier("call")), [thisNode].concat(_toConsumableArray(args)));
    }
  }

  var _environmentVisitor;

  function getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {
    objectRef = cloneNode(objectRef);
    var targetRef = isStatic || isPrivateMethod ? objectRef : memberExpression(objectRef, identifier("prototype"));
    return callExpression(file.addHelper("getPrototypeOf"), [targetRef]);
  }

  function skipAllButComputedKey(path) {
    if (!path.node.computed) {
      path.skip();
      return;
    }

    var keys = VISITOR_KEYS[path.type];

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      if (key !== "key") path.skipKey(key);
    }
  }
  var environmentVisitor = (_environmentVisitor = {}, _environmentVisitor[(staticBlock ? "StaticBlock|" : "") + "ClassPrivateProperty|TypeAnnotation"] = function ClassPrivatePropertyTypeAnnotation(path) {
    path.skip();
  }, _environmentVisitor.Function = function Function(path) {
    if (path.isMethod()) return;
    if (path.isArrowFunctionExpression()) return;
    path.skip();
  }, _environmentVisitor["Method|ClassProperty"] = function MethodClassProperty(path) {
    skipAllButComputedKey(path);
  }, _environmentVisitor);
  var visitor$1 = traverse.visitors.merge([environmentVisitor, {
    Super: function Super(path, state) {
      var node = path.node,
          parentPath = path.parentPath;
      if (!parentPath.isMemberExpression({
        object: node
      })) return;
      state.handle(parentPath);
    }
  }]);
  var unshadowSuperBindingVisitor = traverse.visitors.merge([environmentVisitor, {
    Scopable: function Scopable(path, _ref) {
      var refName = _ref.refName;
      var binding = path.scope.getOwnBinding(refName);

      if (binding && binding.identifier.name === refName) {
        path.scope.rename(refName);
      }
    }
  }]);
  var specHandlers = {
    memoise: function memoise(superMember, count) {
      var scope = superMember.scope,
          node = superMember.node;
      var computed = node.computed,
          property = node.property;

      if (!computed) {
        return;
      }

      var memo = scope.maybeGenerateMemoised(property);

      if (!memo) {
        return;
      }

      this.memoiser.set(property, memo, count);
    },
    prop: function prop(superMember) {
      var _superMember$node = superMember.node,
          computed = _superMember$node.computed,
          property = _superMember$node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      if (computed) {
        return cloneNode(property);
      }

      return stringLiteral(property.name);
    },
    get: function get(superMember) {
      return this._get(superMember, this._getThisRefs());
    },
    _get: function _get(superMember, thisRefs) {
      var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("get"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs["this"]]);
    },
    _getThisRefs: function _getThisRefs() {
      if (!this.isDerivedConstructor) {
        return {
          "this": thisExpression()
        };
      }

      var thisRef = this.scope.generateDeclaredUidIdentifier("thisSuper");
      return {
        memo: assignmentExpression("=", thisRef, thisExpression()),
        "this": cloneNode(thisRef)
      };
    },
    set: function set(superMember, value) {
      var thisRefs = this._getThisRefs();

      var proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);
      return callExpression(this.file.addHelper("set"), [thisRefs.memo ? sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs["this"], booleanLiteral(superMember.isInStrictMode())]);
    },
    destructureSet: function destructureSet(superMember) {
      throw superMember.buildCodeFrameError("Destructuring to a super field is not supported yet.");
    },
    call: function call(superMember, args) {
      var thisRefs = this._getThisRefs();

      return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, false);
    },
    optionalCall: function optionalCall(superMember, args) {
      var thisRefs = this._getThisRefs();

      return optimiseCallExpression(this._get(superMember, thisRefs), cloneNode(thisRefs["this"]), args, true);
    }
  };
  var looseHandlers = Object.assign({}, specHandlers, {
    prop: function prop(superMember) {
      var property = superMember.node.property;

      if (this.memoiser.has(property)) {
        return cloneNode(this.memoiser.get(property));
      }

      return cloneNode(property);
    },
    get: function get(superMember) {
      var isStatic = this.isStatic,
          getSuperRef = this.getSuperRef;
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      var object;

      if (isStatic) {
        var _getSuperRef;

        object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : memberExpression(identifier("Function"), identifier("prototype"));
      } else {
        var _getSuperRef2;

        object = memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : identifier("Object"), identifier("prototype"));
      }

      return memberExpression(object, prop, computed);
    },
    set: function set(superMember, value) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return assignmentExpression("=", memberExpression(thisExpression(), prop, computed), value);
    },
    destructureSet: function destructureSet(superMember) {
      var computed = superMember.node.computed;
      var prop = this.prop(superMember);
      return memberExpression(thisExpression(), prop, computed);
    },
    call: function call(superMember, args) {
      return optimiseCallExpression(this.get(superMember), thisExpression(), args, false);
    },
    optionalCall: function optionalCall(superMember, args) {
      return optimiseCallExpression(this.get(superMember), thisExpression(), args, true);
    }
  });

  var ReplaceSupers = function () {
    function ReplaceSupers(opts) {
      var _opts$constantSuper;

      var path = opts.methodPath;
      this.methodPath = path;
      this.isDerivedConstructor = path.isClassMethod({
        kind: "constructor"
      }) && !!opts.superRef;
      this.isStatic = path.isObjectMethod() || path.node["static"] || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());
      this.isPrivateMethod = path.isPrivate() && path.isMethod();
      this.file = opts.file;
      this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;
      this.opts = opts;
    }

    var _proto = ReplaceSupers.prototype;

    _proto.getObjectRef = function getObjectRef() {
      return cloneNode(this.opts.objectRef || this.opts.getObjectRef());
    };

    _proto.getSuperRef = function getSuperRef() {
      if (this.opts.superRef) return cloneNode(this.opts.superRef);
      if (this.opts.getSuperRef) return cloneNode(this.opts.getSuperRef());
    };

    _proto.replace = function replace() {
      if (this.opts.refToPreserve) {
        this.methodPath.traverse(unshadowSuperBindingVisitor, {
          refName: this.opts.refToPreserve.name
        });
      }

      var handler = this.constantSuper ? looseHandlers : specHandlers;
      memberExpressionToFunctions(this.methodPath, visitor$1, Object.assign({
        file: this.file,
        scope: this.methodPath.scope,
        isDerivedConstructor: this.isDerivedConstructor,
        isStatic: this.isStatic,
        isPrivateMethod: this.isPrivateMethod,
        getObjectRef: this.getObjectRef.bind(this),
        getSuperRef: this.getSuperRef.bind(this)
      }, handler));
    };

    return ReplaceSupers;
  }();

  function rewriteThis(programPath) {
    traverse(programPath.node, Object.assign({}, rewriteThisVisitor, {
      noScope: true
    }));
  }
  var rewriteThisVisitor = traverse.visitors.merge([environmentVisitor, {
    ThisExpression: function (_ThisExpression) {
      function ThisExpression(_x) {
        return _ThisExpression.apply(this, arguments);
      }

      ThisExpression.toString = function () {
        return _ThisExpression.toString();
      };

      return ThisExpression;
    }(function (path) {
      path.replaceWith(unaryExpression("void", numericLiteral(0), true));
    })
  }]);

  function simplifyAccess(path, bindingNames) {
    path.traverse(simpleAssignmentVisitor, {
      scope: path.scope,
      bindingNames: bindingNames,
      seen: new WeakSet()
    });
  }
  var simpleAssignmentVisitor = {
    UpdateExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            bindingNames = this.bindingNames;
        var arg = path.get("argument");
        if (!arg.isIdentifier()) return;
        var localName = arg.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {
          var operator = path.node.operator == "++" ? "+=" : "-=";
          path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));
        } else if (path.node.prefix) {
          path.replaceWith(assignmentExpression("=", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression("+", arg.node), numericLiteral(1))));
        } else {
          var old = path.scope.generateUidIdentifierBasedOnNode(arg.node, "old");
          var varName = old.name;
          path.scope.push({
            id: old
          });
          var binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));
          path.replaceWith(sequenceExpression([assignmentExpression("=", identifier(varName), unaryExpression("+", arg.node)), assignmentExpression("=", cloneNode(arg.node), binary), identifier(varName)]));
        }
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var scope = this.scope,
            seen = this.seen,
            bindingNames = this.bindingNames;
        if (path.node.operator === "=") return;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (!left.isIdentifier()) return;
        var localName = left.node.name;
        if (!bindingNames.has(localName)) return;

        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
          return;
        }

        path.node.right = binaryExpression(path.node.operator.slice(0, -1), cloneNode(path.node.left), path.node.right);
        path.node.operator = "=";
      }
    }
  };

  var _templateObject$m;
  function rewriteLiveReferences(programPath, metadata) {
    var imported = new Map();
    var exported = new Map();

    var requeueInParent = function requeueInParent(path) {
      programPath.requeue(path);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(metadata.source), _step; !(_step = _iterator()).done;) {
      var _step$value = _slicedToArray$2(_step.value, 2),
          source = _step$value[0],
          data = _step$value[1];

      for (var _iterator3 = _createForOfIteratorHelperLoose(data.imports), _step3; !(_step3 = _iterator3()).done;) {
        var _step3$value = _slicedToArray$2(_step3.value, 2),
            localName = _step3$value[0],
            importName = _step3$value[1];

        imported.set(localName, [source, importName, null]);
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(data.importsNamespace), _step4; !(_step4 = _iterator4()).done;) {
        var _localName = _step4.value;
        imported.set(_localName, [source, null, _localName]);
      }
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(metadata.local), _step2; !(_step2 = _iterator2()).done;) {
      var _exportMeta;

      var _step2$value = _slicedToArray$2(_step2.value, 2),
          local = _step2$value[0],
          _data = _step2$value[1];

      var exportMeta = exported.get(local);

      if (!exportMeta) {
        exportMeta = [];
        exported.set(local, exportMeta);
      }

      (_exportMeta = exportMeta).push.apply(_exportMeta, _toConsumableArray(_data.names));
    }

    var rewriteBindingInitVisitorState = {
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      exported: exported
    };
    programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
    simplifyAccess(programPath, new Set([].concat(_toConsumableArray(Array.from(imported.keys())), _toConsumableArray(Array.from(exported.keys())))));
    var rewriteReferencesVisitorState = {
      seen: new WeakSet(),
      metadata: metadata,
      requeueInParent: requeueInParent,
      scope: programPath.scope,
      imported: imported,
      exported: exported,
      buildImportReference: function buildImportReference(_ref, identNode) {
        var _ref2 = _slicedToArray$2(_ref, 3),
            source = _ref2[0],
            importName = _ref2[1],
            localName = _ref2[2];

        var meta = metadata.source.get(source);

        if (localName) {
          if (meta.lazy) identNode = callExpression(identNode, []);
          return identNode;
        }

        var namespace = identifier(meta.name);
        if (meta.lazy) namespace = callExpression(namespace, []);

        if (importName === "default" && meta.interop === "node-default") {
          return namespace;
        }

        var computed = metadata.stringSpecifiers.has(importName);
        return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);
      }
    };
    programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
  }
  var rewriteBindingInitVisitor = {
    Scope: function Scope(path) {
      path.skip();
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      var id = path.node.id;
      if (!id) throw new Error("Expected class to have a name");
      var localName = id.name;
      var exportNames = exported.get(localName) || [];

      if (exportNames.length > 0) {
        var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
        statement._blockHoist = path.node._blockHoist;
        requeueInParent(path.insertAfter(statement)[0]);
      }
    },
    VariableDeclaration: function VariableDeclaration(path) {
      var requeueInParent = this.requeueInParent,
          exported = this.exported,
          metadata = this.metadata;
      Object.keys(path.getOuterBindingIdentifiers()).forEach(function (localName) {
        var exportNames = exported.get(localName) || [];

        if (exportNames.length > 0) {
          var statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));
          statement._blockHoist = path.node._blockHoist;
          requeueInParent(path.insertAfter(statement)[0]);
        }
      });
    }
  };

  var buildBindingExportAssignmentExpression = function buildBindingExportAssignmentExpression(metadata, exportNames, localExpr) {
    return (exportNames || []).reduce(function (expr, exportName) {
      var stringSpecifiers = metadata.stringSpecifiers;
      var computed = stringSpecifiers.has(exportName);
      return assignmentExpression("=", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);
    }, localExpr);
  };

  var buildImportThrow = function buildImportThrow(localName) {
    return template$2.expression.ast(_templateObject$m || (_templateObject$m = _taggedTemplateLiteralLoose(["\n    (function() {\n      throw new Error('\"' + '", "' + '\" is read-only.');\n    })()\n  "])), localName);
  };

  var rewriteReferencesVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      var seen = this.seen,
          buildImportReference = this.buildImportReference,
          scope = this.scope,
          imported = this.imported,
          requeueInParent = this.requeueInParent;
      if (seen.has(path.node)) return;
      seen.add(path.node);
      var localName = path.node.name;
      var importData = imported.get(localName);

      if (importData) {
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = scope.getBinding(localName);
        if (rootBinding !== localBinding) return;
        var ref = buildImportReference(importData, path.node);
        ref.loc = path.node.loc;

        if ((path.parentPath.isCallExpression({
          callee: path.node
        }) || path.parentPath.isOptionalCallExpression({
          callee: path.node
        }) || path.parentPath.isTaggedTemplateExpression({
          tag: path.node
        })) && isMemberExpression(ref)) {
          path.replaceWith(sequenceExpression([numericLiteral(0), ref]));
        } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {
          var object = ref.object,
              property = ref.property;
          path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));
        } else {
          path.replaceWith(ref);
        }

        requeueInParent(path);
        path.skip();
      }
    },
    AssignmentExpression: {
      exit: function exit(path) {
        var _this = this;

        var scope = this.scope,
            seen = this.seen,
            imported = this.imported,
            exported = this.exported,
            requeueInParent = this.requeueInParent,
            buildImportReference = this.buildImportReference;
        if (seen.has(path.node)) return;
        seen.add(path.node);
        var left = path.get("left");
        if (left.isMemberExpression()) return;

        if (left.isIdentifier()) {
          var localName = left.node.name;

          if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {
            return;
          }

          var exportedNames = exported.get(localName);
          var importData = imported.get(localName);

          if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
            assert_1(path.node.operator === "=", "Path was not simplified");
            var assignment = path.node;

            if (importData) {
              assignment.left = buildImportReference(importData, assignment.left);
              assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);
            }

            path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));
            requeueInParent(path);
          }
        } else {
          var ids = left.getOuterBindingIdentifiers();
          var programScopeIds = Object.keys(ids).filter(function (localName) {
            return scope.getBinding(localName) === path.scope.getBinding(localName);
          });
          var id = programScopeIds.find(function (localName) {
            return imported.has(localName);
          });

          if (id) {
            path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);
          }

          var items = [];
          programScopeIds.forEach(function (localName) {
            var exportedNames = exported.get(localName) || [];

            if (exportedNames.length > 0) {
              items.push(buildBindingExportAssignmentExpression(_this.metadata, exportedNames, identifier(localName)));
            }
          });

          if (items.length > 0) {
            var node = sequenceExpression(items);

            if (path.parentPath.isExpressionStatement()) {
              node = expressionStatement(node);
              node._blockHoist = path.parentPath.node._blockHoist;
            }

            var statement = path.insertAfter(node)[0];
            requeueInParent(statement);
          }
        }
      }
    },
    "ForOfStatement|ForInStatement": function ForOfStatementForInStatement(path) {
      var scope = path.scope,
          node = path.node;
      var left = node.left;
      var exported = this.exported,
          programScope = this.scope;

      if (!isVariableDeclaration(left)) {
        var didTransform = false;
        var bodyPath = path.get("body");
        var loopBodyScope = bodyPath.scope;

        for (var _i = 0, _Object$keys = Object.keys(getOuterBindingIdentifiers$1(left)); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];

          if (exported.get(name) && programScope.getBinding(name) === scope.getBinding(name)) {
            didTransform = true;

            if (loopBodyScope.hasOwnBinding(name)) {
              loopBodyScope.rename(name);
            }
          }
        }

        if (!didTransform) {
          return;
        }

        var newLoopId = scope.generateUidIdentifierBasedOnNode(left);
        bodyPath.unshiftContainer("body", expressionStatement(assignmentExpression("=", left, newLoopId)));
        path.get("left").replaceWith(variableDeclaration("let", [variableDeclarator(cloneNode(newLoopId))]));
        scope.registerDeclaration(path.get("left"));
      }
    }
  };

  function normalizeArray(parts, allowAboveRoot) {
    var up = 0;

    for (var i = parts.length - 1; i >= 0; i--) {
      var last = parts[i];

      if (last === '.') {
        parts.splice(i, 1);
      } else if (last === '..') {
        parts.splice(i, 1);
        up++;
      } else if (up) {
        parts.splice(i, 1);
        up--;
      }
    }

    if (allowAboveRoot) {
      for (; up--; up) {
        parts.unshift('..');
      }
    }

    return parts;
  }

  var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;

  var splitPath = function splitPath(filename) {
    return splitPathRe.exec(filename).slice(1);
  };

  function resolve$3() {
    var resolvedPath = '',
        resolvedAbsolute = false;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path = i >= 0 ? arguments[i] : '/';

      if (typeof path !== 'string') {
        throw new TypeError('Arguments to path.resolve must be strings');
      } else if (!path) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charAt(0) === '/';
    }

    resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function (p) {
      return !!p;
    }), !resolvedAbsolute).join('/');
    return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
  }
  function normalize$1(path) {
    var isPathAbsolute = isAbsolute(path),
        trailingSlash = substr(path, -1) === '/';
    path = normalizeArray(filter(path.split('/'), function (p) {
      return !!p;
    }), !isPathAbsolute).join('/');

    if (!path && !isPathAbsolute) {
      path = '.';
    }

    if (path && trailingSlash) {
      path += '/';
    }

    return (isPathAbsolute ? '/' : '') + path;
  }
  function isAbsolute(path) {
    return path.charAt(0) === '/';
  }
  function join() {
    var paths = Array.prototype.slice.call(arguments, 0);
    return normalize$1(filter(paths, function (p, index) {
      if (typeof p !== 'string') {
        throw new TypeError('Arguments to path.join must be strings');
      }

      return p;
    }).join('/'));
  }
  function relative(from, to) {
    from = resolve$3(from).substr(1);
    to = resolve$3(to).substr(1);

    function trim(arr) {
      var start = 0;

      for (; start < arr.length; start++) {
        if (arr[start] !== '') break;
      }

      var end = arr.length - 1;

      for (; end >= 0; end--) {
        if (arr[end] !== '') break;
      }

      if (start > end) return [];
      return arr.slice(start, end - start + 1);
    }

    var fromParts = trim(from.split('/'));
    var toParts = trim(to.split('/'));
    var length = Math.min(fromParts.length, toParts.length);
    var samePartsLength = length;

    for (var i = 0; i < length; i++) {
      if (fromParts[i] !== toParts[i]) {
        samePartsLength = i;
        break;
      }
    }

    var outputParts = [];

    for (var i = samePartsLength; i < fromParts.length; i++) {
      outputParts.push('..');
    }

    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    return outputParts.join('/');
  }
  var sep$1 = '/';
  var delimiter = ':';
  function dirname(path) {
    var result = splitPath(path),
        root = result[0],
        dir = result[1];

    if (!root && !dir) {
      return '.';
    }

    if (dir) {
      dir = dir.substr(0, dir.length - 1);
    }

    return root + dir;
  }
  function basename(path, ext) {
    var f = splitPath(path)[2];

    if (ext && f.substr(-1 * ext.length) === ext) {
      f = f.substr(0, f.length - ext.length);
    }

    return f;
  }
  function extname(path) {
    return splitPath(path)[3];
  }
  var path$1 = {
    extname: extname,
    basename: basename,
    dirname: dirname,
    sep: sep$1,
    delimiter: delimiter,
    relative: relative,
    join: join,
    isAbsolute: isAbsolute,
    normalize: normalize$1,
    resolve: resolve$3
  };

  function filter(xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];

    for (var i = 0; i < xs.length; i++) {
      if (f(xs[i], i, xs)) res.push(xs[i]);
    }

    return res;
  }

  var substr = 'ab'.substr(-1) === 'b' ? function (str, start, len) {
    return str.substr(start, len);
  } : function (str, start, len) {
    if (start < 0) start = str.length + start;
    return str.substr(start, len);
  };

  var path$2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    resolve: resolve$3,
    normalize: normalize$1,
    isAbsolute: isAbsolute,
    join: join,
    relative: relative,
    sep: sep$1,
    delimiter: delimiter,
    dirname: dirname,
    basename: basename,
    extname: extname,
    'default': path$1
  });

  function hasExports(metadata) {
    return metadata.hasExports;
  }
  function isSideEffectImport(source) {
    return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
  }
  function validateImportInteropOption(importInterop) {
    if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
      throw new Error(".importInterop must be one of \"none\", \"babel\", \"node\", or a function returning one of those values (received " + importInterop + ").");
    }

    return importInterop;
  }

  function resolveImportInterop(importInterop, source) {
    if (typeof importInterop === "function") {
      return validateImportInteropOption(importInterop(source));
    }

    return importInterop;
  }

  function normalizeModuleAndLoadMetadata(programPath, exportName, _ref) {
    var importInterop = _ref.importInterop,
        _ref$initializeReexpo = _ref.initializeReexports,
        initializeReexports = _ref$initializeReexpo === void 0 ? false : _ref$initializeReexpo,
        _ref$lazy = _ref.lazy,
        lazy = _ref$lazy === void 0 ? false : _ref$lazy,
        _ref$esNamespaceOnly = _ref.esNamespaceOnly,
        esNamespaceOnly = _ref$esNamespaceOnly === void 0 ? false : _ref$esNamespaceOnly;

    if (!exportName) {
      exportName = programPath.scope.generateUidIdentifier("exports").name;
    }

    var stringSpecifiers = new Set();
    nameAnonymousExports(programPath);

    var _getModuleMetadata = getModuleMetadata(programPath, {
      initializeReexports: initializeReexports,
      lazy: lazy
    }, stringSpecifiers),
        local = _getModuleMetadata.local,
        source = _getModuleMetadata.source,
        hasExports = _getModuleMetadata.hasExports;

    removeModuleDeclarations(programPath);

    for (var _iterator = _createForOfIteratorHelperLoose(source), _step; !(_step = _iterator()).done;) {
      var _step$value = _slicedToArray$2(_step.value, 2),
          metadata = _step$value[1];

      if (metadata.importsNamespace.size > 0) {
        metadata.name = metadata.importsNamespace.values().next().value;
      }

      var resolvedInterop = resolveImportInterop(importInterop, metadata.source);

      if (resolvedInterop === "none") {
        metadata.interop = "none";
      } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
        metadata.interop = "node-namespace";
      } else if (resolvedInterop === "node" && metadata.interop === "default") {
        metadata.interop = "node-default";
      } else if (esNamespaceOnly && metadata.interop === "namespace") {
        metadata.interop = "default";
      }
    }

    return {
      exportName: exportName,
      exportNameListName: null,
      hasExports: hasExports,
      local: local,
      source: source,
      stringSpecifiers: stringSpecifiers
    };
  }

  function getExportSpecifierName$1(path, stringSpecifiers) {
    if (path.isIdentifier()) {
      return path.node.name;
    } else if (path.isStringLiteral()) {
      var stringValue = path.node.value;

      if (!isIdentifierName(stringValue)) {
        stringSpecifiers.add(stringValue);
      }

      return stringValue;
    } else {
      throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + path.node.type);
    }
  }

  function assertExportSpecifier(path) {
    if (path.isExportSpecifier()) {
      return;
    } else if (path.isExportNamespaceSpecifier()) {
      throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-proposal-export-namespace-from`.");
    } else {
      throw path.buildCodeFrameError("Unexpected export specifier type");
    }
  }

  function getModuleMetadata(programPath, _ref2, stringSpecifiers) {
    var lazy = _ref2.lazy,
        initializeReexports = _ref2.initializeReexports;
    var localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
    var sourceData = new Map();

    var getData = function getData(sourceNode) {
      var source = sourceNode.value;
      var data = sourceData.get(source);

      if (!data) {
        data = {
          name: programPath.scope.generateUidIdentifier(basename(source, extname(source))).name,
          interop: "none",
          loc: null,
          imports: new Map(),
          importsNamespace: new Set(),
          reexports: new Map(),
          reexportNamespace: new Set(),
          reexportAll: null,
          lazy: false,
          source: source
        };
        sourceData.set(source, data);
      }

      return data;
    };

    var hasExports = false;
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        var data = getData(child.node.source);
        if (!data.loc) data.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          if (spec.isImportDefaultSpecifier()) {
            var localName = spec.get("local").node.name;
            data.imports.set(localName, "default");
            var reexport = localData.get(localName);

            if (reexport) {
              localData["delete"](localName);
              reexport.names.forEach(function (name) {
                data.reexports.set(name, "default");
              });
            }
          } else if (spec.isImportNamespaceSpecifier()) {
            var _localName = spec.get("local").node.name;
            data.importsNamespace.add(_localName);

            var _reexport = localData.get(_localName);

            if (_reexport) {
              localData["delete"](_localName);

              _reexport.names.forEach(function (name) {
                data.reexportNamespace.add(name);
              });
            }
          } else if (spec.isImportSpecifier()) {
            var importName = getExportSpecifierName$1(spec.get("imported"), stringSpecifiers);
            var _localName2 = spec.get("local").node.name;
            data.imports.set(_localName2, importName);

            var _reexport2 = localData.get(_localName2);

            if (_reexport2) {
              localData["delete"](_localName2);

              _reexport2.names.forEach(function (name) {
                data.reexports.set(name, importName);
              });
            }
          }
        });
      } else if (child.isExportAllDeclaration()) {
        hasExports = true;

        var _data = getData(child.node.source);

        if (!_data.loc) _data.loc = child.node.loc;
        _data.reexportAll = {
          loc: child.node.loc
        };
      } else if (child.isExportNamedDeclaration() && child.node.source) {
        hasExports = true;

        var _data2 = getData(child.node.source);

        if (!_data2.loc) _data2.loc = child.node.loc;
        child.get("specifiers").forEach(function (spec) {
          assertExportSpecifier(spec);
          var importName = getExportSpecifierName$1(spec.get("local"), stringSpecifiers);
          var exportName = getExportSpecifierName$1(spec.get("exported"), stringSpecifiers);

          _data2.reexports.set(exportName, importName);

          if (exportName === "__esModule") {
            throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
          }
        });
      } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
        hasExports = true;
      }
    });

    for (var _iterator2 = _createForOfIteratorHelperLoose(sourceData.values()), _step2; !(_step2 = _iterator2()).done;) {
      var metadata = _step2.value;
      var needsDefault = false;
      var needsNamed = false;

      if (metadata.importsNamespace.size > 0) {
        needsDefault = true;
        needsNamed = true;
      }

      if (metadata.reexportAll) {
        needsNamed = true;
      }

      for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.imports.values()), _step4; !(_step4 = _iterator4()).done;) {
        var importName = _step4.value;
        if (importName === "default") needsDefault = true;else needsNamed = true;
      }

      for (var _iterator5 = _createForOfIteratorHelperLoose(metadata.reexports.values()), _step5; !(_step5 = _iterator5()).done;) {
        var _importName = _step5.value;
        if (_importName === "default") needsDefault = true;else needsNamed = true;
      }

      if (needsDefault && needsNamed) {
        metadata.interop = "namespace";
      } else if (needsDefault) {
        metadata.interop = "default";
      }
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(sourceData), _step3; !(_step3 = _iterator3()).done;) {
      var _step3$value = _slicedToArray$2(_step3.value, 2),
          source = _step3$value[0],
          _metadata = _step3$value[1];

      if (lazy !== false && !(isSideEffectImport(_metadata) || _metadata.reexportAll)) {
        if (lazy === true) {
          _metadata.lazy = !/\./.test(source);
        } else if (Array.isArray(lazy)) {
          _metadata.lazy = lazy.indexOf(source) !== -1;
        } else if (typeof lazy === "function") {
          _metadata.lazy = lazy(source);
        } else {
          throw new Error(".lazy must be a boolean, string array, or function");
        }
      }
    }

    return {
      hasExports: hasExports,
      local: localData,
      source: sourceData
    };
  }

  function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
    var bindingKindLookup = new Map();
    programPath.get("body").forEach(function (child) {
      var kind;

      if (child.isImportDeclaration()) {
        kind = "import";
      } else {
        if (child.isExportDefaultDeclaration()) child = child.get("declaration");

        if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child = child.get("declaration");
          } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
            child.get("specifiers").forEach(function (spec) {
              assertExportSpecifier(spec);
              bindingKindLookup.set(spec.get("local").node.name, "block");
            });
            return;
          }
        }

        if (child.isFunctionDeclaration()) {
          kind = "hoisted";
        } else if (child.isClassDeclaration()) {
          kind = "block";
        } else if (child.isVariableDeclaration({
          kind: "var"
        })) {
          kind = "var";
        } else if (child.isVariableDeclaration()) {
          kind = "block";
        } else {
          return;
        }
      }

      Object.keys(child.getOuterBindingIdentifiers()).forEach(function (name) {
        bindingKindLookup.set(name, kind);
      });
    });
    var localMetadata = new Map();

    var getLocalMetadata = function getLocalMetadata(idPath) {
      var localName = idPath.node.name;
      var metadata = localMetadata.get(localName);

      if (!metadata) {
        var kind = bindingKindLookup.get(localName);

        if (kind === undefined) {
          throw idPath.buildCodeFrameError("Exporting local \"" + localName + "\", which is not declared.");
        }

        metadata = {
          names: [],
          kind: kind
        };
        localMetadata.set(localName, metadata);
      }

      return metadata;
    };

    programPath.get("body").forEach(function (child) {
      if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
        if (child.node.declaration) {
          var declaration = child.get("declaration");
          var ids = declaration.getOuterBindingIdentifierPaths();
          Object.keys(ids).forEach(function (name) {
            if (name === "__esModule") {
              throw declaration.buildCodeFrameError('Illegal export "__esModule".');
            }

            getLocalMetadata(ids[name]).names.push(name);
          });
        } else {
          child.get("specifiers").forEach(function (spec) {
            var local = spec.get("local");
            var exported = spec.get("exported");
            var localMetadata = getLocalMetadata(local);
            var exportName = getExportSpecifierName$1(exported, stringSpecifiers);

            if (exportName === "__esModule") {
              throw exported.buildCodeFrameError('Illegal export "__esModule".');
            }

            localMetadata.names.push(exportName);
          });
        }
      } else if (child.isExportDefaultDeclaration()) {
        var _declaration = child.get("declaration");

        if (_declaration.isFunctionDeclaration() || _declaration.isClassDeclaration()) {
          getLocalMetadata(_declaration.get("id")).names.push("default");
        } else {
          throw _declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      }
    });
    return localMetadata;
  }

  function nameAnonymousExports(programPath) {
    programPath.get("body").forEach(function (child) {
      if (!child.isExportDefaultDeclaration()) return;
      splitExportDeclaration(child);
    });
  }

  function removeModuleDeclarations(programPath) {
    programPath.get("body").forEach(function (child) {
      if (child.isImportDeclaration()) {
        child.remove();
      } else if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child.node.declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(child.node.declaration);
        } else {
          child.remove();
        }
      } else if (child.isExportDefaultDeclaration()) {
        var declaration = child.get("declaration");

        if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
          declaration._blockHoist = child.node._blockHoist;
          child.replaceWith(declaration);
        } else {
          throw declaration.buildCodeFrameError("Unexpected default expression export.");
        }
      } else if (child.isExportAllDeclaration()) {
        child.remove();
      }
    });
  }

  {
    var originalGetModuleName = getModuleName;

    getModuleName = function getModuleName(rootOpts, pluginOpts) {
      var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;

      return originalGetModuleName(rootOpts, {
        moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
        moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
        getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
        moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
      });
    };
  }
  function getModuleName(rootOpts, pluginOpts) {
    var filename = rootOpts.filename,
        _rootOpts$filenameRel = rootOpts.filenameRelative,
        filenameRelative = _rootOpts$filenameRel === void 0 ? filename : _rootOpts$filenameRel,
        _rootOpts$sourceRoot = rootOpts.sourceRoot,
        sourceRoot = _rootOpts$sourceRoot === void 0 ? pluginOpts.moduleRoot : _rootOpts$sourceRoot;
    var moduleId = pluginOpts.moduleId,
        _pluginOpts$moduleIds2 = pluginOpts.moduleIds,
        moduleIds = _pluginOpts$moduleIds2 === void 0 ? !!moduleId : _pluginOpts$moduleIds2,
        getModuleId = pluginOpts.getModuleId,
        _pluginOpts$moduleRoo2 = pluginOpts.moduleRoot,
        moduleRoot = _pluginOpts$moduleRoo2 === void 0 ? sourceRoot : _pluginOpts$moduleRoo2;
    if (!moduleIds) return null;

    if (moduleId != null && !getModuleId) {
      return moduleId;
    }

    var moduleName = moduleRoot != null ? moduleRoot + "/" : "";

    if (filenameRelative) {
      var sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
      moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.(\w*?)$/, "");
    }

    moduleName = moduleName.replace(/\\/g, "/");

    if (getModuleId) {
      return getModuleId(moduleName) || moduleName;
    } else {
      return moduleName;
    }
  }

  var _templateObject$l, _templateObject2$a, _templateObject3$9, _templateObject4$5, _templateObject5$3, _templateObject6$3, _templateObject7$2, _templateObject8$1, _templateObject9$1, _templateObject10$1, _templateObject11$1, _templateObject12$1, _templateObject13$1;
  function rewriteModuleStatementsAndPrepareHeader(path, _ref) {
    var loose = _ref.loose,
        exportName = _ref.exportName,
        strict = _ref.strict,
        allowTopLevelThis = _ref.allowTopLevelThis,
        strictMode = _ref.strictMode,
        noInterop = _ref.noInterop,
        _ref$importInterop = _ref.importInterop,
        importInterop = _ref$importInterop === void 0 ? noInterop ? "none" : "babel" : _ref$importInterop,
        lazy = _ref.lazy,
        esNamespaceOnly = _ref.esNamespaceOnly,
        _ref$constantReexport = _ref.constantReexports,
        constantReexports = _ref$constantReexport === void 0 ? loose : _ref$constantReexport,
        _ref$enumerableModule = _ref.enumerableModuleMeta,
        enumerableModuleMeta = _ref$enumerableModule === void 0 ? loose : _ref$enumerableModule;
    validateImportInteropOption(importInterop);
    assert_1(isModule(path), "Cannot process module statements in a script");
    path.node.sourceType = "script";
    var meta = normalizeModuleAndLoadMetadata(path, exportName, {
      importInterop: importInterop,
      initializeReexports: constantReexports,
      lazy: lazy,
      esNamespaceOnly: esNamespaceOnly
    });

    if (!allowTopLevelThis) {
      rewriteThis(path);
    }

    rewriteLiveReferences(path, meta);

    if (strictMode !== false) {
      var hasStrict = path.node.directives.some(function (directive) {
        return directive.value.value === "use strict";
      });

      if (!hasStrict) {
        path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
      }
    }

    var headers = [];

    if (hasExports(meta) && !strict) {
      headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
    }

    var nameList = buildExportNameListDeclaration(path, meta);

    if (nameList) {
      meta.exportNameListName = nameList.name;
      headers.push(nameList.statement);
    }

    headers.push.apply(headers, _toConsumableArray(buildExportInitializationStatements(path, meta, constantReexports)));
    return {
      meta: meta,
      headers: headers
    };
  }
  function ensureStatementsHoisted(statements) {
    statements.forEach(function (header) {
      header._blockHoist = 3;
    });
  }
  function wrapInterop(programPath, expr, type) {
    if (type === "none") {
      return null;
    }

    if (type === "node-namespace") {
      return callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, booleanLiteral(true)]);
    } else if (type === "node-default") {
      return null;
    }

    var helper;

    if (type === "default") {
      helper = "interopRequireDefault";
    } else if (type === "namespace") {
      helper = "interopRequireWildcard";
    } else {
      throw new Error("Unknown interop: " + type);
    }

    return callExpression(programPath.hub.addHelper(helper), [expr]);
  }
  function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports) {
    if (constantReexports === void 0) {
      constantReexports = false;
    }

    var statements = [];
    var srcNamespace = identifier(sourceMetadata.name);
    if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);

    for (var _iterator = _createForOfIteratorHelperLoose(sourceMetadata.importsNamespace), _step; !(_step = _iterator()).done;) {
      var localName = _step.value;
      if (localName === sourceMetadata.name) continue;
      statements.push(template$2.statement(_templateObject$l || (_templateObject$l = _taggedTemplateLiteralLoose(["var NAME = SOURCE;"])))({
        NAME: localName,
        SOURCE: cloneNode(srcNamespace)
      }));
    }

    if (constantReexports) {
      statements.push.apply(statements, _toConsumableArray(buildReexportsFromMeta(metadata, sourceMetadata, true)));
    }

    for (var _iterator2 = _createForOfIteratorHelperLoose(sourceMetadata.reexportNamespace), _step2; !(_step2 = _iterator2()).done;) {
      var exportName = _step2.value;
      statements.push((sourceMetadata.lazy ? template$2.statement(_templateObject2$a || (_templateObject2$a = _taggedTemplateLiteralLoose(["\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          "]))) : template$2.statement(_templateObject3$9 || (_templateObject3$9 = _taggedTemplateLiteralLoose(["EXPORTS.NAME = NAMESPACE;"]))))({
        EXPORTS: metadata.exportName,
        NAME: exportName,
        NAMESPACE: cloneNode(srcNamespace)
      }));
    }

    if (sourceMetadata.reexportAll) {
      var statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);
      statement.loc = sourceMetadata.reexportAll.loc;
      statements.push(statement);
    }

    return statements;
  }
  var ReexportTemplate = {
    constant: template$2.statement(_templateObject4$5 || (_templateObject4$5 = _taggedTemplateLiteralLoose(["EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;"]))),
    constantComputed: template$2.statement(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteralLoose(["EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;"]))),
    spec: template$2(_templateObject6$3 || (_templateObject6$3 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    "])))
  };

  var buildReexportsFromMeta = function buildReexportsFromMeta(meta, metadata, constantReexports) {
    var namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);
    var stringSpecifiers = meta.stringSpecifiers;
    return Array.from(metadata.reexports, function (_ref2) {
      var _ref3 = _slicedToArray$2(_ref2, 2),
          exportName = _ref3[0],
          importName = _ref3[1];

      var NAMESPACE_IMPORT = cloneNode(namespace);

      if (importName === "default" && metadata.interop === "node-default") ; else if (stringSpecifiers.has(importName)) {
        NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);
      } else {
        NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));
      }

      var astNodes = {
        EXPORTS: meta.exportName,
        EXPORT_NAME: exportName,
        NAMESPACE_IMPORT: NAMESPACE_IMPORT
      };

      if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {
        if (stringSpecifiers.has(exportName)) {
          return ReexportTemplate.constantComputed(astNodes);
        } else {
          return ReexportTemplate.constant(astNodes);
        }
      } else {
        return ReexportTemplate.spec(astNodes);
      }
    });
  };

  function buildESModuleHeader(metadata, enumerableModuleMeta) {
    if (enumerableModuleMeta === void 0) {
      enumerableModuleMeta = false;
    }

    return (enumerableModuleMeta ? template$2.statement(_templateObject7$2 || (_templateObject7$2 = _taggedTemplateLiteralLoose(["\n        EXPORTS.__esModule = true;\n      "]))) : template$2.statement(_templateObject8$1 || (_templateObject8$1 = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      "]))))({
      EXPORTS: metadata.exportName
    });
  }

  function buildNamespaceReexport(metadata, namespace, constantReexports) {
    return (constantReexports ? template$2.statement(_templateObject9$1 || (_templateObject9$1 = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      "]))) : template$2.statement(_templateObject10$1 || (_templateObject10$1 = _taggedTemplateLiteralLoose(["\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    "]))))({
      NAMESPACE: namespace,
      EXPORTS: metadata.exportName,
      VERIFY_NAME_LIST: metadata.exportNameListName ? template$2(_templateObject11$1 || (_templateObject11$1 = _taggedTemplateLiteralLoose(["\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          "])))({
        EXPORTS_LIST: metadata.exportNameListName
      }) : null
    });
  }

  function buildExportNameListDeclaration(programPath, metadata) {
    var exportedVars = Object.create(null);

    for (var _iterator3 = _createForOfIteratorHelperLoose(metadata.local.values()), _step3; !(_step3 = _iterator3()).done;) {
      var data = _step3.value;

      for (var _iterator5 = _createForOfIteratorHelperLoose(data.names), _step5; !(_step5 = _iterator5()).done;) {
        var _name = _step5.value;
        exportedVars[_name] = true;
      }
    }

    var hasReexport = false;

    for (var _iterator4 = _createForOfIteratorHelperLoose(metadata.source.values()), _step4; !(_step4 = _iterator4()).done;) {
      var _data = _step4.value;

      for (var _iterator6 = _createForOfIteratorHelperLoose(_data.reexports.keys()), _step6; !(_step6 = _iterator6()).done;) {
        var exportName = _step6.value;
        exportedVars[exportName] = true;
      }

      for (var _iterator7 = _createForOfIteratorHelperLoose(_data.reexportNamespace), _step7; !(_step7 = _iterator7()).done;) {
        var _exportName = _step7.value;
        exportedVars[_exportName] = true;
      }

      hasReexport = hasReexport || !!_data.reexportAll;
    }

    if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
    var name = programPath.scope.generateUidIdentifier("exportNames");
    delete exportedVars["default"];
    return {
      name: name.name,
      statement: variableDeclaration("var", [variableDeclarator(name, valueToNode(exportedVars))])
    };
  }

  function buildExportInitializationStatements(programPath, metadata, constantReexports) {
    if (constantReexports === void 0) {
      constantReexports = false;
    }

    var initStatements = [];
    var exportNames = [];

    for (var _iterator8 = _createForOfIteratorHelperLoose(metadata.local), _step8; !(_step8 = _iterator8()).done;) {
      var _step8$value = _slicedToArray$2(_step8.value, 2),
          localName = _step8$value[0],
          data = _step8$value[1];

      if (data.kind === "import") ; else if (data.kind === "hoisted") {
        initStatements.push(buildInitStatement(metadata, data.names, identifier(localName)));
      } else {
        exportNames.push.apply(exportNames, _toConsumableArray(data.names));
      }
    }

    for (var _iterator9 = _createForOfIteratorHelperLoose(metadata.source.values()), _step9; !(_step9 = _iterator9()).done;) {
      var _data2 = _step9.value;

      if (!constantReexports) {
        initStatements.push.apply(initStatements, _toConsumableArray(buildReexportsFromMeta(metadata, _data2, false)));
      }

      for (var _iterator10 = _createForOfIteratorHelperLoose(_data2.reexportNamespace), _step10; !(_step10 = _iterator10()).done;) {
        var exportName = _step10.value;
        exportNames.push(exportName);
      }
    }

    initStatements.push.apply(initStatements, _toConsumableArray(chunk(exportNames, 100).map(function (members) {
      return buildInitStatement(metadata, members, programPath.scope.buildUndefinedNode());
    })));
    return initStatements;
  }

  var InitTemplate = {
    computed: template$2.expression(_templateObject12$1 || (_templateObject12$1 = _taggedTemplateLiteralLoose(["EXPORTS[\"NAME\"] = VALUE"]))),
    "default": template$2.expression(_templateObject13$1 || (_templateObject13$1 = _taggedTemplateLiteralLoose(["EXPORTS.NAME = VALUE"])))
  };

  function buildInitStatement(metadata, exportNames, initExpr) {
    var stringSpecifiers = metadata.stringSpecifiers,
        EXPORTS = metadata.exportName;
    return expressionStatement(exportNames.reduce(function (acc, exportName) {
      var params = {
        EXPORTS: EXPORTS,
        NAME: exportName,
        VALUE: acc
      };

      if (stringSpecifiers.has(exportName)) {
        return InitTemplate.computed(params);
      } else {
        return InitTemplate["default"](params);
      }
    }, initExpr));
  }

  function chunk(array, size) {
    var chunks = [];

    for (var i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }

    return chunks;
  }

  var SEMVER_SPEC_VERSION$3 = '2.0.0';
  var MAX_LENGTH$b = 256;
  var MAX_SAFE_INTEGER$7 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH$3 = 16;
  var constants$3 = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$3,
    MAX_LENGTH: MAX_LENGTH$b,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$7,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$3
  };

  var debug$5 = typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1$3 = debug$5;

  var re_1$3 = createCommonjsModule(function (module, exports) {
    var MAX_SAFE_COMPONENT_LENGTH = constants$3.MAX_SAFE_COMPONENT_LENGTH;
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;

    var createToken = function createToken(name, value, isGlobal) {
      var index = R++;
      debug_1$3(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
    createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
    createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
    createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
    createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
    createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
    createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
    createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
    createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
    createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
    createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
    createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
    createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
    createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
    createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
    createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
    createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
    createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
    createToken('STAR', '(<|>)?=?\\s*\\*');
    createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
  }, "/$$rollup_base$$/packages/babel-core/node_modules/semver/node_modules/semver-BABEL_8_BREAKING-true/internal");

  var opts$2 = ['includePrerelease', 'loose', 'rtl'];

  var parseOptions$2 = function parseOptions(options) {
    return !options ? {} : typeof options !== 'object' ? {
      loose: true
    } : opts$2.filter(function (k) {
      return options[k];
    }).reduce(function (options, k) {
      options[k] = true;
      return options;
    }, {});
  };

  var parseOptions_1$2 = parseOptions$2;

  var numeric$3 = /^[0-9]+$/;

  var compareIdentifiers$7 = function compareIdentifiers(a, b) {
    var anum = numeric$3.test(a);
    var bnum = numeric$3.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers$3 = function rcompareIdentifiers(a, b) {
    return compareIdentifiers$7(b, a);
  };

  var identifiers$3 = {
    compareIdentifiers: compareIdentifiers$7,
    rcompareIdentifiers: rcompareIdentifiers$3
  };

  var MAX_LENGTH$a = constants$3.MAX_LENGTH,
      MAX_SAFE_INTEGER$6 = constants$3.MAX_SAFE_INTEGER;
  var re$h = re_1$3.re,
      t$o = re_1$3.t;
  var compareIdentifiers$6 = identifiers$3.compareIdentifiers;

  var SemVer$3 = function () {
    function SemVer(version, options) {
      options = parseOptions_1$2(options);

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$a) {
        throw new TypeError("version is longer than " + MAX_LENGTH$a + " characters");
      }

      debug_1$3('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re$h[t$o.LOOSE] : re$h[t$o.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER$6 || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER$6 || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER$6 || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER$6) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1$3('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers$6(this.major, other.major) || compareIdentifiers$6(this.minor, other.minor) || compareIdentifiers$6(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1$3('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$6(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1$3('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$6(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$c = SemVer$3;

  var MAX_LENGTH$9 = constants$3.MAX_LENGTH;
  var re$g = re_1$3.re,
      t$n = re_1$3.t;

  var parse$7 = function parse(version, options) {
    options = parseOptions_1$2(options);

    if (version instanceof semver$c) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH$9) {
      return null;
    }

    var r = options.loose ? re$g[t$n.LOOSE] : re$g[t$n.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$c(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1$3 = parse$7;

  var valid$5 = function valid(version, options) {
    var v = parse_1$3(version, options);
    return v ? v.version : null;
  };

  var valid_1$2 = valid$5;

  var clean$2 = function clean(version, options) {
    var s = parse_1$3(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  };

  var clean_1$2 = clean$2;

  var inc$2 = function inc(version, release, options, identifier) {
    if (typeof options === 'string') {
      identifier = options;
      options = undefined;
    }

    try {
      return new semver$c(version, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };

  var inc_1$2 = inc$2;

  var compare$6 = function compare(a, b, loose) {
    return new semver$c(a, loose).compare(new semver$c(b, loose));
  };

  var compare_1$3 = compare$6;

  var eq$3 = function eq(a, b, loose) {
    return compare_1$3(a, b, loose) === 0;
  };

  var eq_1$3 = eq$3;

  var diff$2 = function diff(version1, version2) {
    if (eq_1$3(version1, version2)) {
      return null;
    } else {
      var v1 = parse_1$3(version1);
      var v2 = parse_1$3(version2);
      var hasPre = v1.prerelease.length || v2.prerelease.length;
      var prefix = hasPre ? 'pre' : '';
      var defaultResult = hasPre ? 'prerelease' : '';

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  };

  var diff_1$2 = diff$2;

  var major$2 = function major(a, loose) {
    return new semver$c(a, loose).major;
  };

  var major_1$2 = major$2;

  var minor$2 = function minor(a, loose) {
    return new semver$c(a, loose).minor;
  };

  var minor_1$2 = minor$2;

  var patch$2 = function patch(a, loose) {
    return new semver$c(a, loose).patch;
  };

  var patch_1$2 = patch$2;

  var prerelease$2 = function prerelease(version, options) {
    var parsed = parse_1$3(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };

  var prerelease_1$2 = prerelease$2;

  var rcompare$2 = function rcompare(a, b, loose) {
    return compare_1$3(b, a, loose);
  };

  var rcompare_1$2 = rcompare$2;

  var compareLoose$2 = function compareLoose(a, b) {
    return compare_1$3(a, b, true);
  };

  var compareLoose_1$2 = compareLoose$2;

  var compareBuild$2 = function compareBuild(a, b, loose) {
    var versionA = new semver$c(a, loose);
    var versionB = new semver$c(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };

  var compareBuild_1$2 = compareBuild$2;

  var sort$2 = function sort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1$2(a, b, loose);
    });
  };

  var sort_1$2 = sort$2;

  var rsort$2 = function rsort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1$2(b, a, loose);
    });
  };

  var rsort_1$2 = rsort$2;

  var gt$3 = function gt(a, b, loose) {
    return compare_1$3(a, b, loose) > 0;
  };

  var gt_1$3 = gt$3;

  var lt$3 = function lt(a, b, loose) {
    return compare_1$3(a, b, loose) < 0;
  };

  var lt_1$3 = lt$3;

  var neq$3 = function neq(a, b, loose) {
    return compare_1$3(a, b, loose) !== 0;
  };

  var neq_1$3 = neq$3;

  var gte$3 = function gte(a, b, loose) {
    return compare_1$3(a, b, loose) >= 0;
  };

  var gte_1$3 = gte$3;

  var lte$3 = function lte(a, b, loose) {
    return compare_1$3(a, b, loose) <= 0;
  };

  var lte_1$3 = lte$3;

  var cmp$3 = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1$3(a, b, loose);

      case '!=':
        return neq_1$3(a, b, loose);

      case '>':
        return gt_1$3(a, b, loose);

      case '>=':
        return gte_1$3(a, b, loose);

      case '<':
        return lt_1$3(a, b, loose);

      case '<=':
        return lte_1$3(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1$3 = cmp$3;

  var re$f = re_1$3.re,
      t$m = re_1$3.t;

  var coerce$3 = function coerce(version, options) {
    if (version instanceof semver$c) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re$f[t$m.COERCE]);
    } else {
      var next;

      while ((next = re$f[t$m.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re$f[t$m.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re$f[t$m.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1$3(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1$3 = coerce$3;

  var iterator$2 = function iterator(Yallist) {
    Yallist.prototype[Symbol.iterator] = regenerator.mark(function _callee() {
      var walker;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              walker = this.head;

            case 1:
              if (!walker) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return walker.value;

            case 4:
              walker = walker.next;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    });
  };

  var yallist$2 = Yallist$2;
  Yallist$2.Node = Node$2;
  Yallist$2.create = Yallist$2;

  function Yallist$2(list) {
    var self = this;

    if (!(self instanceof Yallist$2)) {
      self = new Yallist$2();
    }

    self.tail = null;
    self.head = null;
    self.length = 0;

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }

    return self;
  }

  Yallist$2.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }

    var next = node.next;
    var prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };

  Yallist$2.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var head = this.head;
    node.list = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length++;
  };

  Yallist$2.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var tail = this.tail;
    node.list = this;
    node.prev = tail;

    if (tail) {
      tail.next = node;
    }

    this.tail = node;

    if (!this.head) {
      this.head = node;
    }

    this.length++;
  };

  Yallist$2.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push$3(this, arguments[i]);
    }

    return this.length;
  };

  Yallist$2.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift$2(this, arguments[i]);
    }

    return this.length;
  };

  Yallist$2.prototype.pop = function () {
    if (!this.tail) {
      return undefined;
    }

    var res = this.tail.value;
    this.tail = this.tail.prev;

    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }

    this.length--;
    return res;
  };

  Yallist$2.prototype.shift = function () {
    if (!this.head) {
      return undefined;
    }

    var res = this.head.value;
    this.head = this.head.next;

    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }

    this.length--;
    return res;
  };

  Yallist$2.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };

  Yallist$2.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };

  Yallist$2.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist$2.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist$2.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$2();

    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }

    return res;
  };

  Yallist$2.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$2();

    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }

    return res;
  };

  Yallist$2.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }

    return acc;
  };

  Yallist$2.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }

    return acc;
  };

  Yallist$2.prototype.toArray = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }

    return arr;
  };

  Yallist$2.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }

    return arr;
  };

  Yallist$2.prototype.slice = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist$2();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }

    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist$2.prototype.sliceReverse = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist$2();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }

    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist$2.prototype.splice = function (start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }

    if (start < 0) {
      start = this.length + start;
    }

    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }

    var ret = [];

    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }

    if (walker === null) {
      walker = this.tail;
    }

    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }

    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      walker = insert$2(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
    }

    return ret;
  };

  Yallist$2.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;

    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }

    this.head = tail;
    this.tail = head;
    return this;
  };

  function insert$2(self, node, value) {
    var inserted = node === self.head ? new Node$2(value, null, node, self) : new Node$2(value, node, node.next, self);

    if (inserted.next === null) {
      self.tail = inserted;
    }

    if (inserted.prev === null) {
      self.head = inserted;
    }

    self.length++;
    return inserted;
  }

  function push$3(self, item) {
    self.tail = new Node$2(item, self.tail, null, self);

    if (!self.head) {
      self.head = self.tail;
    }

    self.length++;
  }

  function unshift$2(self, item) {
    self.head = new Node$2(item, null, self.head, self);

    if (!self.tail) {
      self.tail = self.head;
    }

    self.length++;
  }

  function Node$2(value, prev, next, list) {
    if (!(this instanceof Node$2)) {
      return new Node$2(value, prev, next, list);
    }

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

  try {
    iterator$2(Yallist$2);
  } catch (er) {}

  var MAX$2 = Symbol('max');
  var LENGTH$2 = Symbol('length');
  var LENGTH_CALCULATOR$2 = Symbol('lengthCalculator');
  var ALLOW_STALE$2 = Symbol('allowStale');
  var MAX_AGE$2 = Symbol('maxAge');
  var DISPOSE$2 = Symbol('dispose');
  var NO_DISPOSE_ON_SET$2 = Symbol('noDisposeOnSet');
  var LRU_LIST$2 = Symbol('lruList');
  var CACHE$2 = Symbol('cache');
  var UPDATE_AGE_ON_GET$2 = Symbol('updateAgeOnGet');

  var naiveLength$2 = function naiveLength() {
    return 1;
  };

  var LRUCache$2 = function () {
    function LRUCache(options) {
      if (typeof options === 'number') options = {
        max: options
      };
      if (!options) options = {};
      if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
      this[MAX$2] = options.max || Infinity;
      var lc = options.length || naiveLength$2;
      this[LENGTH_CALCULATOR$2] = typeof lc !== 'function' ? naiveLength$2 : lc;
      this[ALLOW_STALE$2] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
      this[MAX_AGE$2] = options.maxAge || 0;
      this[DISPOSE$2] = options.dispose;
      this[NO_DISPOSE_ON_SET$2] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET$2] = options.updateAgeOnGet || false;
      this.reset();
    }

    var _proto = LRUCache.prototype;

    _proto.rforEach = function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST$2].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep$2(this, fn, walker, thisp);
        walker = prev;
      }
    };

    _proto.forEach = function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST$2].head; walker !== null;) {
        var next = walker.next;
        forEachStep$2(this, fn, walker, thisp);
        walker = next;
      }
    };

    _proto.keys = function keys() {
      return this[LRU_LIST$2].toArray().map(function (k) {
        return k.key;
      });
    };

    _proto.values = function values() {
      return this[LRU_LIST$2].toArray().map(function (k) {
        return k.value;
      });
    };

    _proto.reset = function reset() {
      var _this = this;

      if (this[DISPOSE$2] && this[LRU_LIST$2] && this[LRU_LIST$2].length) {
        this[LRU_LIST$2].forEach(function (hit) {
          return _this[DISPOSE$2](hit.key, hit.value);
        });
      }

      this[CACHE$2] = new Map();
      this[LRU_LIST$2] = new yallist$2();
      this[LENGTH$2] = 0;
    };

    _proto.dump = function dump() {
      var _this2 = this;

      return this[LRU_LIST$2].map(function (hit) {
        return isStale$2(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    };

    _proto.dumpLru = function dumpLru() {
      return this[LRU_LIST$2];
    };

    _proto.set = function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE$2];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR$2](value, key);

      if (this[CACHE$2].has(key)) {
        if (len > this[MAX$2]) {
          _del$2(this, this[CACHE$2].get(key));

          return false;
        }

        var node = this[CACHE$2].get(key);
        var item = node.value;

        if (this[DISPOSE$2]) {
          if (!this[NO_DISPOSE_ON_SET$2]) this[DISPOSE$2](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH$2] += len - item.length;
        item.length = len;
        this.get(key);
        trim$2(this);
        return true;
      }

      var hit = new Entry$3(key, value, len, now, maxAge);

      if (hit.length > this[MAX$2]) {
        if (this[DISPOSE$2]) this[DISPOSE$2](key, value);
        return false;
      }

      this[LENGTH$2] += hit.length;
      this[LRU_LIST$2].unshift(hit);
      this[CACHE$2].set(key, this[LRU_LIST$2].head);
      trim$2(this);
      return true;
    };

    _proto.has = function has(key) {
      if (!this[CACHE$2].has(key)) return false;
      var hit = this[CACHE$2].get(key).value;
      return !isStale$2(this, hit);
    };

    _proto.get = function get(key) {
      return _get$2(this, key, true);
    };

    _proto.peek = function peek(key) {
      return _get$2(this, key, false);
    };

    _proto.pop = function pop() {
      var node = this[LRU_LIST$2].tail;
      if (!node) return null;

      _del$2(this, node);

      return node.value;
    };

    _proto.del = function del(key) {
      _del$2(this, this[CACHE$2].get(key));
    };

    _proto.load = function load(arr) {
      this.reset();
      var now = Date.now();

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now;

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };

    _proto.prune = function prune() {
      var _this3 = this;

      this[CACHE$2].forEach(function (value, key) {
        return _get$2(_this3, key, false);
      });
    };

    _createClass(LRUCache, [{
      key: "max",
      get: function get() {
        return this[MAX$2];
      },
      set: function set(mL) {
        if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
        this[MAX$2] = mL || Infinity;
        trim$2(this);
      }
    }, {
      key: "allowStale",
      get: function get() {
        return this[ALLOW_STALE$2];
      },
      set: function set(allowStale) {
        this[ALLOW_STALE$2] = !!allowStale;
      }
    }, {
      key: "maxAge",
      get: function get() {
        return this[MAX_AGE$2];
      },
      set: function set(mA) {
        if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
        this[MAX_AGE$2] = mA;
        trim$2(this);
      }
    }, {
      key: "lengthCalculator",
      get: function get() {
        return this[LENGTH_CALCULATOR$2];
      },
      set: function set(lC) {
        var _this4 = this;

        if (typeof lC !== 'function') lC = naiveLength$2;

        if (lC !== this[LENGTH_CALCULATOR$2]) {
          this[LENGTH_CALCULATOR$2] = lC;
          this[LENGTH$2] = 0;
          this[LRU_LIST$2].forEach(function (hit) {
            hit.length = _this4[LENGTH_CALCULATOR$2](hit.value, hit.key);
            _this4[LENGTH$2] += hit.length;
          });
        }

        trim$2(this);
      }
    }, {
      key: "length",
      get: function get() {
        return this[LENGTH$2];
      }
    }, {
      key: "itemCount",
      get: function get() {
        return this[LRU_LIST$2].length;
      }
    }]);

    return LRUCache;
  }();

  var _get$2 = function _get(self, key, doUse) {
    var node = self[CACHE$2].get(key);

    if (node) {
      var hit = node.value;

      if (isStale$2(self, hit)) {
        _del$2(self, node);

        if (!self[ALLOW_STALE$2]) return undefined;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET$2]) node.value.now = Date.now();
          self[LRU_LIST$2].unshiftNode(node);
        }
      }

      return hit.value;
    }
  };

  var isStale$2 = function isStale(self, hit) {
    if (!hit || !hit.maxAge && !self[MAX_AGE$2]) return false;
    var diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE$2] && diff > self[MAX_AGE$2];
  };

  var trim$2 = function trim(self) {
    if (self[LENGTH$2] > self[MAX$2]) {
      for (var walker = self[LRU_LIST$2].tail; self[LENGTH$2] > self[MAX$2] && walker !== null;) {
        var prev = walker.prev;

        _del$2(self, walker);

        walker = prev;
      }
    }
  };

  var _del$2 = function _del(self, node) {
    if (node) {
      var hit = node.value;
      if (self[DISPOSE$2]) self[DISPOSE$2](hit.key, hit.value);
      self[LENGTH$2] -= hit.length;
      self[CACHE$2]["delete"](hit.key);
      self[LRU_LIST$2].removeNode(node);
    }
  };

  var Entry$3 = function Entry(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  };

  var forEachStep$2 = function forEachStep(self, fn, node, thisp) {
    var hit = node.value;

    if (isStale$2(self, hit)) {
      _del$2(self, node);

      if (!self[ALLOW_STALE$2]) hit = undefined;
    }

    if (hit) fn.call(thisp, hit.value, hit.key, self);
  };

  var lruCache$2 = LRUCache$2;

  var Range$2 = function () {
    function Range(range, options) {
      var _this = this;

      options = parseOptions_1$2(options);

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof comparator$2) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return _this.parseRange(range.trim());
      }).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }

      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter(function (c) {
          return !isNullSet$2(c[0]);
        });
        if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
          for (var _iterator = _createForOfIteratorHelperLoose(this.set), _step; !(_step = _iterator()).done;) {
            var c = _step.value;

            if (c.length === 1 && isAny$2(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }

      this.format();
    }

    var _proto = Range.prototype;

    _proto.format = function format() {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    _proto.toString = function toString() {
      return this.range;
    };

    _proto.parseRange = function parseRange(range) {
      var _this2 = this;

      range = range.trim();
      var memoOpts = Object.keys(this.options).join(',');
      var memoKey = "parseRange:" + memoOpts + ":" + range;
      var cached = cache$3.get(memoKey);
      if (cached) return cached;
      var loose = this.options.loose;
      var hr = loose ? re$e[t$l.HYPHENRANGELOOSE] : re$e[t$l.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace$2(this.options.includePrerelease));
      debug_1$3('hyphen replace', range);
      range = range.replace(re$e[t$l.COMPARATORTRIM], comparatorTrimReplace$2);
      debug_1$3('comparator trim', range, re$e[t$l.COMPARATORTRIM]);
      range = range.replace(re$e[t$l.TILDETRIM], tildeTrimReplace$2);
      range = range.replace(re$e[t$l.CARETTRIM], caretTrimReplace$2);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re$e[t$l.COMPARATORLOOSE] : re$e[t$l.COMPARATOR];
      var rangeList = range.split(' ').map(function (comp) {
        return parseComparator$2(comp, _this2.options);
      }).join(' ').split(/\s+/).map(function (comp) {
        return replaceGTE0$2(comp, _this2.options);
      }).filter(this.options.loose ? function (comp) {
        return !!comp.match(compRe);
      } : function () {
        return true;
      }).map(function (comp) {
        return new comparator$2(comp, _this2.options);
      });
      rangeList.length;
      var rangeMap = new Map();

      for (var _iterator2 = _createForOfIteratorHelperLoose(rangeList), _step2; !(_step2 = _iterator2()).done;) {
        var comp = _step2.value;
        if (isNullSet$2(comp)) return [comp];
        rangeMap.set(comp.value, comp);
      }

      if (rangeMap.size > 1 && rangeMap.has('')) rangeMap["delete"]('');

      var result = _toConsumableArray(rangeMap.values());

      cache$3.set(memoKey, result);
      return result;
    };

    _proto.intersects = function intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable$2(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable$2(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    _proto.test = function test(version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$c(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet$2(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    return Range;
  }();

  var range$2 = Range$2;
  var cache$3 = new lruCache$2({
    max: 1000
  });
  var re$e = re_1$3.re,
      t$l = re_1$3.t,
      comparatorTrimReplace$2 = re_1$3.comparatorTrimReplace,
      tildeTrimReplace$2 = re_1$3.tildeTrimReplace,
      caretTrimReplace$2 = re_1$3.caretTrimReplace;

  var isNullSet$2 = function isNullSet(c) {
    return c.value === '<0.0.0-0';
  };

  var isAny$2 = function isAny(c) {
    return c.value === '';
  };

  var isSatisfiable$2 = function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }

    return result;
  };

  var parseComparator$2 = function parseComparator(comp, options) {
    debug_1$3('comp', comp, options);
    comp = replaceCarets$2(comp, options);
    debug_1$3('caret', comp);
    comp = replaceTildes$2(comp, options);
    debug_1$3('tildes', comp);
    comp = replaceXRanges$2(comp, options);
    debug_1$3('xrange', comp);
    comp = replaceStars$2(comp, options);
    debug_1$3('stars', comp);
    return comp;
  };

  var isX$2 = function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  };

  var replaceTildes$2 = function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde$2(comp, options);
    }).join(' ');
  };

  var replaceTilde$2 = function replaceTilde(comp, options) {
    var r = options.loose ? re$e[t$l.TILDELOOSE] : re$e[t$l.TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$3('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX$2(M)) {
        ret = '';
      } else if (isX$2(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0-0";
      } else if (isX$2(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0-0";
      } else if (pr) {
        debug_1$3('replaceTilde pr', pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$3('tilde return', ret);
      return ret;
    });
  };

  var replaceCarets$2 = function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret$2(comp, options);
    }).join(' ');
  };

  var replaceCaret$2 = function replaceCaret(comp, options) {
    debug_1$3('caret', comp, options);
    var r = options.loose ? re$e[t$l.CARETLOOSE] : re$e[t$l.CARET];
    var z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$3('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX$2(M)) {
        ret = '';
      } else if (isX$2(m)) {
        ret = ">=" + M + ".0.0" + z + " <" + (+M + 1) + ".0.0-0";
      } else if (isX$2(p)) {
        if (M === '0') {
          ret = ">=" + M + "." + m + ".0" + z + " <" + M + "." + (+m + 1) + ".0-0";
        } else {
          ret = ">=" + M + "." + m + ".0" + z + " <" + (+M + 1) + ".0.0-0";
        }
      } else if (pr) {
        debug_1$3('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0-0";
        }
      } else {
        debug_1$3('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0-0";
        }
      }

      debug_1$3('caret return', ret);
      return ret;
    });
  };

  var replaceXRanges$2 = function replaceXRanges(comp, options) {
    debug_1$3('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange$2(comp, options);
    }).join(' ');
  };

  var replaceXRange$2 = function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re$e[t$l.XRANGELOOSE] : re$e[t$l.XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug_1$3('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX$2(M);
      var xm = xM || isX$2(m);
      var xp = xm || isX$2(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      pr = options.includePrerelease ? '-0' : '';

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0-0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        if (gtlt === '<') pr = '-0';
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0-0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$3('xRange return', ret);
      return ret;
    });
  };

  var replaceStars$2 = function replaceStars(comp, options) {
    debug_1$3('replaceStars', comp, options);
    return comp.trim().replace(re$e[t$l.STAR], '');
  };

  var replaceGTE0$2 = function replaceGTE0(comp, options) {
    debug_1$3('replaceGTE0', comp, options);
    return comp.trim().replace(re$e[options.includePrerelease ? t$l.GTE0PRE : t$l.GTE0], '');
  };

  var hyphenReplace$2 = function hyphenReplace(incPr) {
    return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX$2(fM)) {
        from = '';
      } else if (isX$2(fm)) {
        from = ">=" + fM + ".0.0" + (incPr ? '-0' : '');
      } else if (isX$2(fp)) {
        from = ">=" + fM + "." + fm + ".0" + (incPr ? '-0' : '');
      } else if (fpr) {
        from = ">=" + from;
      } else {
        from = ">=" + from + (incPr ? '-0' : '');
      }

      if (isX$2(tM)) {
        to = '';
      } else if (isX$2(tm)) {
        to = "<" + (+tM + 1) + ".0.0-0";
      } else if (isX$2(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0-0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else if (incPr) {
        to = "<" + tM + "." + tm + "." + (+tp + 1) + "-0";
      } else {
        to = "<=" + to;
      }

      return (from + " " + to).trim();
    };
  };

  var testSet$2 = function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set.length; _i++) {
        debug_1$3(set[_i].semver);

        if (set[_i].semver === comparator$2.ANY) {
          continue;
        }

        if (set[_i].semver.prerelease.length > 0) {
          var allowed = set[_i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  };

  var ANY$8 = Symbol('SemVer ANY');

  var Comparator$2 = function () {
    function Comparator(comp, options) {
      options = parseOptions_1$2(options);

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      debug_1$3('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY$8) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug_1$3('comp', this);
    }

    var _proto = Comparator.prototype;

    _proto.parse = function parse(comp) {
      var r = this.options.loose ? re$d[t$k.COMPARATORLOOSE] : re$d[t$k.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY$8;
      } else {
        this.semver = new semver$c(m[2], this.options.loose);
      }
    };

    _proto.toString = function toString() {
      return this.value;
    };

    _proto.test = function test(version) {
      debug_1$3('Comparator.test', version, this.options.loose);

      if (this.semver === ANY$8 || version === ANY$8) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$c(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp_1$3(version, this.operator, this.semver, this.options);
    };

    _proto.intersects = function intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        return new range$2(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        return new range$2(this.value, options).test(comp.semver);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp_1$3(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp_1$3(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    _createClass(Comparator, null, [{
      key: "ANY",
      get: function get() {
        return ANY$8;
      }
    }]);

    return Comparator;
  }();

  var comparator$2 = Comparator$2;
  var re$d = re_1$3.re,
      t$k = re_1$3.t;

  var satisfies$2 = function satisfies(version, range, options) {
    try {
      range = new range$2(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  };

  var satisfies_1$2 = satisfies$2;

  var toComparators$2 = function toComparators(range, options) {
    return new range$2(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  };

  var toComparators_1$2 = toComparators$2;

  var maxSatisfying$2 = function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range$2(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new semver$c(max, options);
        }
      }
    });
    return max;
  };

  var maxSatisfying_1$2 = maxSatisfying$2;

  var minSatisfying$2 = function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range$2(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new semver$c(min, options);
        }
      }
    });
    return min;
  };

  var minSatisfying_1$2 = minSatisfying$2;

  var minVersion$2 = function minVersion(range, loose) {
    range = new range$2(range, loose);
    var minver = new semver$c('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new semver$c('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    var _loop = function _loop(i) {
      var comparators = range.set[i];
      var setMin = null;
      comparators.forEach(function (comparator) {
        var compver = new semver$c(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!setMin || gt_1$3(compver, setMin)) {
              setMin = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
      if (setMin && (!minver || gt_1$3(minver, setMin))) minver = setMin;
    };

    for (var i = 0; i < range.set.length; ++i) {
      _loop(i);
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  };

  var minVersion_1$2 = minVersion$2;

  var validRange$2 = function validRange(range, options) {
    try {
      return new range$2(range, options).range || '*';
    } catch (er) {
      return null;
    }
  };

  var valid$4 = validRange$2;

  var ANY$7 = comparator$2.ANY;

  var outside$2 = function outside(version, range, hilo, options) {
    version = new semver$c(version, options);
    range = new range$2(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt_1$3;
        ltefn = lte_1$3;
        ltfn = lt_1$3;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt_1$3;
        ltefn = gte_1$3;
        ltfn = gt_1$3;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies_1$2(version, range, options)) {
      return false;
    }

    var _loop = function _loop(i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY$7) {
          comparator = new comparator$2('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return {
          v: false
        };
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return {
          v: false
        };
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return {
          v: false
        };
      }
    };

    for (var i = 0; i < range.set.length; ++i) {
      var _ret = _loop(i);

      if (typeof _ret === "object") return _ret.v;
    }

    return true;
  };

  var outside_1$2 = outside$2;

  var gtr$2 = function gtr(version, range, options) {
    return outside_1$2(version, range, '>', options);
  };

  var gtr_1$2 = gtr$2;

  var ltr$2 = function ltr(version, range, options) {
    return outside_1$2(version, range, '<', options);
  };

  var ltr_1$2 = ltr$2;

  var intersects$2 = function intersects(r1, r2, options) {
    r1 = new range$2(r1, options);
    r2 = new range$2(r2, options);
    return r1.intersects(r2);
  };

  var intersects_1$2 = intersects$2;

  var simplify$2 = function simplify(versions, range, options) {
    var set = [];
    var min = null;
    var prev = null;
    var v = versions.sort(function (a, b) {
      return compare_1$3(a, b, options);
    });

    for (var _iterator = _createForOfIteratorHelperLoose(v), _step; !(_step = _iterator()).done;) {
      var version = _step.value;
      var included = satisfies_1$2(version, range, options);

      if (included) {
        prev = version;
        if (!min) min = version;
      } else {
        if (prev) {
          set.push([min, prev]);
        }

        prev = null;
        min = null;
      }
    }

    if (min) set.push([min, null]);
    var ranges = [];

    for (var _i = 0, _set = set; _i < _set.length; _i++) {
      var _set$_i = _slicedToArray$2(_set[_i], 2),
          _min = _set$_i[0],
          max = _set$_i[1];

      if (_min === max) ranges.push(_min);else if (!max && _min === v[0]) ranges.push('*');else if (!max) ranges.push(">=" + _min);else if (_min === v[0]) ranges.push("<=" + max);else ranges.push(_min + " - " + max);
    }

    var simplified = ranges.join(' || ');
    var original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };

  var ANY$6 = comparator$2.ANY;

  var subset$2 = function subset(sub, dom, options) {
    if (sub === dom) return true;
    sub = new range$2(sub, options);
    dom = new range$2(dom, options);
    var sawNonNull = false;

    OUTER: for (var _iterator = _createForOfIteratorHelperLoose(sub.set), _step; !(_step = _iterator()).done;) {
      var simpleSub = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(dom.set), _step2; !(_step2 = _iterator2()).done;) {
        var simpleDom = _step2.value;
        var isSub = simpleSubset$2(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) continue OUTER;
      }

      if (sawNonNull) return false;
    }

    return true;
  };

  var simpleSubset$2 = function simpleSubset(sub, dom, options) {
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === ANY$6) return dom.length === 1 && dom[0].semver === ANY$6;
    var eqSet = new Set();
    var gt, lt;

    for (var _iterator3 = _createForOfIteratorHelperLoose(sub), _step3; !(_step3 = _iterator3()).done;) {
      var c = _step3.value;
      if (c.operator === '>' || c.operator === '>=') gt = higherGT$2(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = lowerLT$2(lt, c, options);else eqSet.add(c.semver);
    }

    if (eqSet.size > 1) return null;
    var gtltComp;

    if (gt && lt) {
      gtltComp = compare_1$3(gt.semver, lt.semver, options);
      if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;
    }

    for (var _iterator4 = _createForOfIteratorHelperLoose(eqSet), _step4; !(_step4 = _iterator4()).done;) {
      var eq = _step4.value;
      if (gt && !satisfies_1$2(eq, String(gt), options)) return null;
      if (lt && !satisfies_1$2(eq, String(lt), options)) return null;

      for (var _iterator6 = _createForOfIteratorHelperLoose(dom), _step6; !(_step6 = _iterator6()).done;) {
        var _c = _step6.value;
        if (!satisfies_1$2(eq, String(_c), options)) return false;
      }

      return true;
    }

    var higher, lower;
    var hasDomLT, hasDomGT;

    for (var _iterator5 = _createForOfIteratorHelperLoose(dom), _step5; !(_step5 = _iterator5()).done;) {
      var _c2 = _step5.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

      if (gt) {
        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT$2(gt, _c2, options);
          if (higher === _c2 && higher !== gt) return false;
        } else if (gt.operator === '>=' && !satisfies_1$2(gt.semver, String(_c2), options)) return false;
      }

      if (lt) {
        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT$2(lt, _c2, options);
          if (lower === _c2 && lower !== lt) return false;
        } else if (lt.operator === '<=' && !satisfies_1$2(lt.semver, String(_c2), options)) return false;
      }

      if (!_c2.operator && (lt || gt) && gtltComp !== 0) return false;
    }

    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    return true;
  };

  var higherGT$2 = function higherGT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$3(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
  };

  var lowerLT$2 = function lowerLT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$3(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
  };

  var subset_1$2 = subset$2;

  ({
    re: re_1$3.re,
    src: re_1$3.src,
    tokens: re_1$3.t,
    SEMVER_SPEC_VERSION: constants$3.SEMVER_SPEC_VERSION,
    SemVer: semver$c,
    compareIdentifiers: identifiers$3.compareIdentifiers,
    rcompareIdentifiers: identifiers$3.rcompareIdentifiers,
    parse: parse_1$3,
    valid: valid_1$2,
    clean: clean_1$2,
    inc: inc_1$2,
    diff: diff_1$2,
    major: major_1$2,
    minor: minor_1$2,
    patch: patch_1$2,
    prerelease: prerelease_1$2,
    compare: compare_1$3,
    rcompare: rcompare_1$2,
    compareLoose: compareLoose_1$2,
    compareBuild: compareBuild_1$2,
    sort: sort_1$2,
    rsort: rsort_1$2,
    gt: gt_1$3,
    lt: lt_1$3,
    eq: eq_1$3,
    neq: neq_1$3,
    gte: gte_1$3,
    lte: lte_1$3,
    cmp: cmp_1$3,
    coerce: coerce_1$3,
    Comparator: comparator$2,
    Range: range$2,
    satisfies: satisfies_1$2,
    toComparators: toComparators_1$2,
    maxSatisfying: maxSatisfying_1$2,
    minSatisfying: minSatisfying_1$2,
    minVersion: minVersion_1$2,
    validRange: valid$4,
    outside: outside_1$2,
    gtr: gtr_1$2,
    ltr: ltr_1$2,
    intersects: intersects_1$2,
    simplifyRange: simplify$2,
    subset: subset_1$2
  });

  var semver$b = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  }, "/$$rollup_base$$/packages/babel-core/node_modules/semver/node_modules/semver-BABEL_8_BREAKING-false");

  var semver$a = semver$b;

  var errorVisitor = {
    enter: function enter(path, state) {
      var loc = path.node.loc;

      if (loc) {
        state.loc = loc;
        path.stop();
      }
    }
  };

  var File = function () {
    function File(options, _ref) {
      var _this = this;

      var code = _ref.code,
          ast = _ref.ast,
          inputMap = _ref.inputMap;
      this._map = new Map();
      this.opts = void 0;
      this.declarations = {};
      this.path = null;
      this.ast = {};
      this.scope = void 0;
      this.metadata = {};
      this.code = "";
      this.inputMap = null;
      this.hub = {
        file: this,
        getCode: function getCode() {
          return _this.code;
        },
        getScope: function getScope() {
          return _this.scope;
        },
        addHelper: this.addHelper.bind(this),
        buildError: this.buildCodeFrameError.bind(this)
      };
      this.opts = options;
      this.code = code;
      this.ast = ast;
      this.inputMap = inputMap;
      this.path = NodePath.get({
        hub: this.hub,
        parentPath: null,
        parent: this.ast,
        container: this.ast,
        key: "program"
      }).setContext();
      this.scope = this.path.scope;
    }

    var _proto = File.prototype;

    _proto.set = function set(key, val) {
      if (key === "helpersNamespace") {
        throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility." + "If you are using @babel/plugin-external-helpers you will need to use a newer " + "version than the one you currently have installed. " + "If you have your own implementation, you'll want to explore using 'helperGenerator' " + "alongside 'file.availableHelper()'.");
      }

      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.has = function has(key) {
      return this._map.has(key);
    };

    _proto.getModuleName = function getModuleName$1() {
      return getModuleName(this.opts, this.opts);
    };

    _proto.addImport = function addImport() {
      throw new Error("This API has been removed. If you're looking for this " + "functionality in Babel 7, you should import the " + "'@babel/helper-module-imports' module and use the functions exposed " + " from that module, such as 'addNamed' or 'addDefault'.");
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      var minVersion;

      try {
        minVersion = minVersion$3(name);
      } catch (err) {
        if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
        return false;
      }

      if (typeof versionRange !== "string") return true;
      if (semver$a.valid(versionRange)) versionRange = "^" + versionRange;
      return !semver$a.intersects("<" + minVersion, versionRange) && !semver$a.intersects(">=8.0.0", versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      var _this2 = this;

      var declar = this.declarations[name];
      if (declar) return cloneNode(declar);
      var generator = this.get("helperGenerator");

      if (generator) {
        var res = generator(name);
        if (res) return res;
      }

      ensure(name, File);
      var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);
      var dependencies = {};

      for (var _iterator = _createForOfIteratorHelperLoose(getDependencies(name)), _step; !(_step = _iterator()).done;) {
        var dep = _step.value;
        dependencies[dep] = this.addHelper(dep);
      }

      var _helpers$get = get$1(name, function (dep) {
        return dependencies[dep];
      }, uid, Object.keys(this.scope.getAllBindings())),
          nodes = _helpers$get.nodes,
          globals = _helpers$get.globals;

      globals.forEach(function (name) {
        if (_this2.path.scope.hasBinding(name, true)) {
          _this2.path.scope.rename(name);
        }
      });
      nodes.forEach(function (node) {
        node._compact = true;
      });
      this.path.unshiftContainer("body", nodes);
      this.path.get("body").forEach(function (path) {
        if (nodes.indexOf(path.node) === -1) return;
        if (path.isVariableDeclaration()) _this2.scope.registerDeclaration(path);
      });
      return uid;
    };

    _proto.addTemplateObject = function addTemplateObject() {
      throw new Error("This function has been moved into the template literal transform itself.");
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, _Error) {
      if (_Error === void 0) {
        _Error = SyntaxError;
      }

      var loc = node && (node.loc || node._loc);

      if (!loc && node) {
        var state = {
          loc: null
        };
        traverse(node, errorVisitor, this.scope, state);
        loc = state.loc;
        var txt = "This is an error on an internal node. Probably an internal error.";
        if (loc) txt += " Location has been estimated.";
        msg += " (" + txt + ")";
      }

      if (loc) {
        var _this$opts$highlightC = this.opts.highlightCode,
            highlightCode = _this$opts$highlightC === void 0 ? true : _this$opts$highlightC;
        msg += "\n" + codeFrameColumns(this.code, {
          start: {
            line: loc.start.line,
            column: loc.start.column + 1
          },
          end: loc.end && loc.start.line === loc.end.line ? {
            line: loc.end.line,
            column: loc.end.column + 1
          } : undefined
        }, {
          highlightCode: highlightCode
        });
      }

      return new _Error(msg);
    };

    _createClass(File, [{
      key: "shebang",
      get: function get() {
        var interpreter = this.path.node.interpreter;
        return interpreter ? interpreter.value : "";
      },
      set: function set(value) {
        if (value) {
          this.path.get("interpreter").replaceWith(interpreterDirective(value));
        } else {
          this.path.get("interpreter").remove();
        }
      }
    }]);

    return File;
  }();

  var _templateObject$k;

  var buildUmdWrapper = function buildUmdWrapper(replacements) {
    return template$2(_templateObject$k || (_templateObject$k = _taggedTemplateLiteralLoose(["\n    (function (root, factory) {\n      if (typeof define === \"function\" && define.amd) {\n        define(AMD_ARGUMENTS, factory);\n      } else if (typeof exports === \"object\") {\n        factory(COMMON_ARGUMENTS);\n      } else {\n        factory(BROWSER_ARGUMENTS);\n      }\n    })(UMD_ROOT, function (FACTORY_PARAMETERS) {\n      FACTORY_BODY\n    });\n  "])))(replacements);
  };

  function buildGlobal(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    var container = functionExpression(null, [identifier("global")], blockStatement(body));
    var tree = program$2([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
    body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
    buildHelpers(body, namespace, allowlist);
    return tree;
  }

  function buildModule(allowlist) {
    var body = [];
    var refs = buildHelpers(body, null, allowlist);
    body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(function (name) {
      return exportSpecifier(cloneNode(refs[name]), identifier(name));
    })));
    return program$2(body, [], "module");
  }

  function buildUmd(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
    buildHelpers(body, namespace, allowlist);
    return program$2([buildUmdWrapper({
      FACTORY_PARAMETERS: identifier("global"),
      BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
      COMMON_ARGUMENTS: identifier("exports"),
      AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
      FACTORY_BODY: body,
      UMD_ROOT: identifier("this")
    })]);
  }

  function buildVar(allowlist) {
    var namespace = identifier("babelHelpers");
    var body = [];
    body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
    var tree = program$2(body);
    buildHelpers(body, namespace, allowlist);
    body.push(expressionStatement(namespace));
    return tree;
  }

  function buildHelpers(body, namespace, allowlist) {
    var getHelperReference = function getHelperReference(name) {
      return namespace ? memberExpression(namespace, identifier(name)) : identifier("_" + name);
    };

    var refs = {};
    list.forEach(function (name) {
      if (allowlist && allowlist.indexOf(name) < 0) return;
      var ref = refs[name] = getHelperReference(name);
      ensure(name, File);

      var _helpers$get = get$1(name, getHelperReference, ref),
          nodes = _helpers$get.nodes;

      body.push.apply(body, _toConsumableArray(nodes));
    });
    return refs;
  }

  function babelBuildExternalHelpers (allowlist, outputType) {
    if (outputType === void 0) {
      outputType = "global";
    }

    var tree;
    var build = {
      global: buildGlobal,
      module: buildModule,
      umd: buildUmd,
      "var": buildVar
    }[outputType];

    if (build) {
      tree = build(allowlist);
    } else {
      throw new Error("Unsupported output type " + outputType);
    }

    return generate$1(tree).code;
  }

  var _marked$9 = regenerator.mark(findPackageData),
      _marked2$5 = regenerator.mark(findRelativeConfig),
      _marked3$3 = regenerator.mark(findRootConfig),
      _marked4$2 = regenerator.mark(loadConfig$1),
      _marked5$2 = regenerator.mark(resolveShowConfigPath);

  function findConfigUpwards(rootDir) {
    return null;
  }
  function findPackageData(filepath) {
    return regenerator.wrap(function findPackageData$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", {
              filepath: filepath,
              directories: [],
              pkg: null,
              isPackage: false
            });

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$9);
  }
  function findRelativeConfig(pkgData, envName, caller) {
    return regenerator.wrap(function findRelativeConfig$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", {
              config: null,
              ignore: null
            });

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$5);
  }
  function findRootConfig(dirname, envName, caller) {
    return regenerator.wrap(function findRootConfig$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", null);

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3$3);
  }
  function loadConfig$1(name, dirname, envName, caller) {
    return regenerator.wrap(function loadConfig$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            throw new Error("Cannot load " + name + " relative to " + dirname + " in a browser");

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked4$2);
  }
  function resolveShowConfigPath(dirname) {
    return regenerator.wrap(function resolveShowConfigPath$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            return _context5.abrupt("return", null);

          case 1:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked5$2);
  }
  var ROOT_CONFIG_FILENAMES = [];
  function resolvePlugin(name, dirname) {
    return null;
  }
  function resolvePreset(name, dirname) {
    return null;
  }
  function loadPlugin(name, dirname) {
    throw new Error("Cannot load plugin " + name + " relative to " + dirname + " in a browser");
  }
  function loadPreset(name, dirname) {
    throw new Error("Cannot load preset " + name + " relative to " + dirname + " in a browser");
  }

  function getEnv(defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = "development";
    }

    return browser$6.env.BABEL_ENV || undefined || defaultValue;
  }

  var GENSYNC_START = Symbol["for"]("gensync:v1:start");
  var GENSYNC_SUSPEND = Symbol["for"]("gensync:v1:suspend");
  var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
  var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
  var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
  var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
  var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
  var gensync = Object.assign(function gensync(optsOrFn) {
    var genFn = optsOrFn;

    if (typeof optsOrFn !== "function") {
      genFn = newGenerator(optsOrFn);
    } else {
      genFn = wrapGenerator(optsOrFn);
    }

    return Object.assign(genFn, makeFunctionAPI(genFn));
  }, {
    all: buildOperation({
      name: "all",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);
        return items.map(function (item) {
          return evaluateSync(item);
        });
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          Promise.resolve().then(function () {
            return resolve([]);
          });
          return;
        }

        var count = 0;
        var results = items.map(function () {
          return undefined;
        });
        items.forEach(function (item, i) {
          evaluateAsync(item, function (val) {
            results[i] = val;
            count += 1;
            if (count === results.length) resolve(results);
          }, reject);
        });
      }
    }),
    race: buildOperation({
      name: "race",
      arity: 1,
      sync: function sync(args) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        return evaluateSync(items[0]);
      },
      async: function async(args, resolve, reject) {
        var items = Array.from(args[0]);

        if (items.length === 0) {
          throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
        }

        for (var _i = 0, _items = items; _i < _items.length; _i++) {
          var item = _items[_i];
          evaluateAsync(item, resolve, reject);
        }
      }
    })
  });

  function makeFunctionAPI(genFn) {
    var fns = {
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return evaluateSync(genFn.apply(this, args));
      },
      async: function async() {
        var _this = this;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return new Promise(function (resolve, reject) {
          evaluateAsync(genFn.apply(_this, args), resolve, reject);
        });
      },
      errback: function errback() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        var cb = args.pop();

        if (typeof cb !== "function") {
          throw makeError("Asynchronous function called without callback", GENSYNC_ERRBACK_NO_CALLBACK);
        }

        var gen;

        try {
          gen = genFn.apply(this, args);
        } catch (err) {
          cb(err);
          return;
        }

        evaluateAsync(gen, function (val) {
          return cb(undefined, val);
        }, function (err) {
          return cb(err);
        });
      }
    };
    return fns;
  }

  function assertTypeof(type, name, value, allowUndefined) {
    if (typeof value === type || allowUndefined && typeof value === "undefined") {
      return;
    }

    var msg;

    if (allowUndefined) {
      msg = "Expected opts." + name + " to be either a " + type + ", or undefined.";
    } else {
      msg = "Expected opts." + name + " to be a " + type + ".";
    }

    throw makeError(msg, GENSYNC_OPTIONS_ERROR);
  }

  function makeError(msg, code) {
    return Object.assign(new Error(msg), {
      code: code
    });
  }

  function newGenerator(_ref) {
    var name = _ref.name,
        arity = _ref.arity,
        _sync = _ref.sync,
        _async = _ref.async,
        errback = _ref.errback;
    assertTypeof("string", "name", name, true);
    assertTypeof("number", "arity", arity, true);
    assertTypeof("function", "sync", _sync);
    assertTypeof("function", "async", _async, true);
    assertTypeof("function", "errback", errback, true);

    if (_async && errback) {
      throw makeError("Expected one of either opts.async or opts.errback, but got _both_.", GENSYNC_OPTIONS_ERROR);
    }

    if (typeof name !== "string") {
      var fnName;

      if (errback && errback.name && errback.name !== "errback") {
        fnName = errback.name;
      }

      if (_async && _async.name && _async.name !== "async") {
        fnName = _async.name.replace(/Async$/, "");
      }

      if (_sync && _sync.name && _sync.name !== "sync") {
        fnName = _sync.name.replace(/Sync$/, "");
      }

      if (typeof fnName === "string") {
        name = fnName;
      }
    }

    if (typeof arity !== "number") {
      arity = _sync.length;
    }

    return buildOperation({
      name: name,
      arity: arity,
      sync: function sync(args) {
        return _sync.apply(this, args);
      },
      async: function async(args, resolve, reject) {
        if (_async) {
          _async.apply(this, args).then(resolve, reject);
        } else if (errback) {
          errback.call.apply(errback, [this].concat(_toConsumableArray(args), [function (err, value) {
            if (err == null) resolve(value);else reject(err);
          }]));
        } else {
          resolve(_sync.apply(this, args));
        }
      }
    });
  }

  function wrapGenerator(genFn) {
    return setFunctionMetadata(genFn.name, genFn.length, function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return genFn.apply(this, args);
    });
  }

  function buildOperation(_ref2) {
    var name = _ref2.name,
        arity = _ref2.arity,
        sync = _ref2.sync,
        async = _ref2.async;
    return setFunctionMetadata(name, arity, regenerator.mark(function _callee() {
      var resume,
          _len5,
          args,
          _key5,
          res,
          result,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return GENSYNC_START;

            case 2:
              resume = _context.sent;

              for (_len5 = _args.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = _args[_key5];
              }

              if (resume) {
                _context.next = 7;
                break;
              }

              res = sync.call(this, args);
              return _context.abrupt("return", res);

            case 7:
              try {
                async.call(this, args, function (value) {
                  if (result) return;
                  result = {
                    value: value
                  };
                  resume();
                }, function (err) {
                  if (result) return;
                  result = {
                    err: err
                  };
                  resume();
                });
              } catch (err) {
                result = {
                  err: err
                };
                resume();
              }

              _context.next = 10;
              return GENSYNC_SUSPEND;

            case 10:
              if (!result.hasOwnProperty("err")) {
                _context.next = 12;
                break;
              }

              throw result.err;

            case 12:
              return _context.abrupt("return", result.value);

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  }

  function evaluateSync(gen) {
    var value;

    while (!(_gen$next = gen.next(), value = _gen$next.value, _gen$next).done) {
      var _gen$next;

      assertStart(value, gen);
    }

    return value;
  }

  function evaluateAsync(gen, resolve, reject) {
    (function step() {
      try {
        var value;

        var _loop = function _loop() {
          assertStart(value, gen);
          var sync = true;
          var didSyncResume = false;
          var out = gen.next(function () {
            if (sync) {
              didSyncResume = true;
            } else {
              step();
            }
          });
          sync = false;
          assertSuspend(out, gen);

          if (!didSyncResume) {
            return {
              v: void 0
            };
          }
        };

        while (!(_gen$next2 = gen.next(), value = _gen$next2.value, _gen$next2).done) {
          var _gen$next2;

          var _ret = _loop();

          if (typeof _ret === "object") return _ret.v;
        }

        return resolve(value);
      } catch (err) {
        return reject(err);
      }
    })();
  }

  function assertStart(value, gen) {
    if (value === GENSYNC_START) return;
    throwError(gen, makeError("Got unexpected yielded value in gensync generator: " + JSON.stringify(value) + ". Did you perhaps mean to use 'yield*' instead of 'yield'?", GENSYNC_EXPECTED_START));
  }

  function assertSuspend(_ref3, gen) {
    var value = _ref3.value,
        done = _ref3.done;
    if (!done && value === GENSYNC_SUSPEND) return;
    throwError(gen, makeError(done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : "Expected GENSYNC_SUSPEND, got " + JSON.stringify(value) + ". If you get this, it is probably a gensync bug.", GENSYNC_EXPECTED_SUSPEND));
  }

  function throwError(gen, err) {
    if (gen["throw"]) gen["throw"](err);
    throw err;
  }

  function setFunctionMetadata(name, arity, fn) {
    if (typeof name === "string") {
      var nameDesc = Object.getOwnPropertyDescriptor(fn, "name");

      if (!nameDesc || nameDesc.configurable) {
        Object.defineProperty(fn, "name", Object.assign(nameDesc || {}, {
          configurable: true,
          value: name
        }));
      }
    }

    if (typeof arity === "number") {
      var lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");

      if (!lengthDesc || lengthDesc.configurable) {
        Object.defineProperty(fn, "length", Object.assign(lengthDesc || {}, {
          configurable: true,
          value: arity
        }));
      }
    }

    return fn;
  }

  var id = function id(x) {
    return x;
  };

  var runGenerator = gensync(regenerator.mark(function _callee(item) {
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(item, "t0", 1);

          case 1:
            return _context.abrupt("return", _context.t0);

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var isAsync = gensync({
    sync: function sync() {
      return false;
    },
    errback: function errback(cb) {
      return cb(null, true);
    }
  });
  function maybeAsync(fn, message) {
    return gensync({
      sync: function sync() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var result = fn.apply(this, args);
        if (isThenable$1(result)) throw new Error(message);
        return result;
      },
      async: function async() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return Promise.resolve(fn.apply(this, args));
      }
    });
  }
  var withKind = gensync({
    sync: function sync(cb) {
      return cb("sync");
    },
    async: function async(cb) {
      return cb("async");
    }
  });
  function forwardAsync(action, cb) {
    var g = gensync(action);
    return withKind(function (kind) {
      var adapted = g[kind];
      return cb(adapted);
    });
  }
  var onFirstPause = gensync({
    name: "onFirstPause",
    arity: 2,
    sync: function sync(item) {
      return runGenerator.sync(item);
    },
    errback: function errback(item, firstPause, cb) {
      var completed = false;
      runGenerator.errback(item, function (err, value) {
        completed = true;
        cb(err, value);
      });

      if (!completed) {
        firstPause();
      }
    }
  });
  var waitFor = gensync({
    sync: id,
    async: id
  });
  function isThenable$1(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  function mergeOptions(target, source) {
    for (var _i = 0, _Object$keys = Object.keys(source); _i < _Object$keys.length; _i++) {
      var k = _Object$keys[_i];

      if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
        var parserOpts = source[k];
        var targetObj = target[k] || (target[k] = {});
        mergeDefaultFields(targetObj, parserOpts);
      } else {
        var val = source[k];
        if (val !== undefined) target[k] = val;
      }
    }
  }

  function mergeDefaultFields(target, source) {
    for (var _i2 = 0, _Object$keys2 = Object.keys(source); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      var val = source[k];
      if (val !== undefined) target[k] = val;
    }
  }

  function isIterableIterator(value) {
    return !!value && typeof value.next === "function" && typeof value[Symbol.iterator] === "function";
  }

  var Plugin$1 = function Plugin(plugin, options, key) {
    this.key = void 0;
    this.manipulateOptions = void 0;
    this.post = void 0;
    this.pre = void 0;
    this.visitor = void 0;
    this.parserOverride = void 0;
    this.generatorOverride = void 0;
    this.options = void 0;
    this.key = plugin.name || key;
    this.manipulateOptions = plugin.manipulateOptions;
    this.post = plugin.post;
    this.pre = plugin.pre;
    this.visitor = plugin.visitor || {};
    this.parserOverride = plugin.parserOverride;
    this.generatorOverride = plugin.generatorOverride;
    this.options = options;
  };

  var _marked$8 = regenerator.mark(genTrue),
      _marked2$4 = regenerator.mark(getCachedValue),
      _marked3$2 = regenerator.mark(getCachedValueOrWait);

  var synchronize = function synchronize(gen) {
    return gensync(gen).sync;
  };

  function genTrue() {
    return regenerator.wrap(function genTrue$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", true);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$8);
  }

  function makeWeakCache(handler) {
    return makeCachedFunction(WeakMap, handler);
  }
  function makeWeakCacheSync(handler) {
    return synchronize(makeWeakCache(handler));
  }
  function makeStrongCache(handler) {
    return makeCachedFunction(Map, handler);
  }
  function makeStrongCacheSync(handler) {
    return synchronize(makeStrongCache(handler));
  }

  function makeCachedFunction(CallCache, handler) {
    var callCacheSync = new CallCache();
    var callCacheAsync = new CallCache();
    var futureCache = new CallCache();
    return regenerator.mark(function cachedFunction(arg, data) {
      var asyncContext, callCache, cached, cache, handlerResult, finishLock, value, gen;
      return regenerator.wrap(function cachedFunction$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(isAsync(), "t0", 1);

            case 1:
              asyncContext = _context2.t0;
              callCache = asyncContext ? callCacheAsync : callCacheSync;
              return _context2.delegateYield(getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data), "t1", 4);

            case 4:
              cached = _context2.t1;

              if (!cached.valid) {
                _context2.next = 7;
                break;
              }

              return _context2.abrupt("return", cached.value);

            case 7:
              cache = new CacheConfigurator(data);
              handlerResult = handler(arg, cache);

              if (!isIterableIterator(handlerResult)) {
                _context2.next = 15;
                break;
              }

              gen = handlerResult;
              return _context2.delegateYield(onFirstPause(gen, function () {
                finishLock = setupAsyncLocks(cache, futureCache, arg);
              }), "t2", 12);

            case 12:
              value = _context2.t2;
              _context2.next = 16;
              break;

            case 15:
              value = handlerResult;

            case 16:
              updateFunctionCache(callCache, cache, arg, value);

              if (finishLock) {
                futureCache["delete"](arg);
                finishLock.release(value);
              }

              return _context2.abrupt("return", value);

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, cachedFunction);
    });
  }

  function getCachedValue(cache, arg, data) {
    var cachedValue, _iterator, _step, _step$value, _value, valid;

    return regenerator.wrap(function getCachedValue$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            cachedValue = cache.get(arg);

            if (!cachedValue) {
              _context3.next = 10;
              break;
            }

            _iterator = _createForOfIteratorHelperLoose(cachedValue);

          case 3:
            if ((_step = _iterator()).done) {
              _context3.next = 10;
              break;
            }

            _step$value = _step.value, _value = _step$value.value, valid = _step$value.valid;
            return _context3.delegateYield(valid(data), "t0", 6);

          case 6:
            if (!_context3.t0) {
              _context3.next = 8;
              break;
            }

            return _context3.abrupt("return", {
              valid: true,
              value: _value
            });

          case 8:
            _context3.next = 3;
            break;

          case 10:
            return _context3.abrupt("return", {
              valid: false,
              value: null
            });

          case 11:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked2$4);
  }

  function getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
    var cached, _cached, _value2;

    return regenerator.wrap(function getCachedValueOrWait$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.delegateYield(getCachedValue(callCache, arg, data), "t0", 1);

          case 1:
            cached = _context4.t0;

            if (!cached.valid) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return", cached);

          case 4:
            if (!asyncContext) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(getCachedValue(futureCache, arg, data), "t1", 6);

          case 6:
            _cached = _context4.t1;

            if (!_cached.valid) {
              _context4.next = 11;
              break;
            }

            return _context4.delegateYield(waitFor(_cached.value.promise), "t2", 9);

          case 9:
            _value2 = _context4.t2;
            return _context4.abrupt("return", {
              valid: true,
              value: _value2
            });

          case 11:
            return _context4.abrupt("return", {
              valid: false,
              value: null
            });

          case 12:
          case "end":
            return _context4.stop();
        }
      }
    }, _marked3$2);
  }

  function setupAsyncLocks(config, futureCache, arg) {
    var finishLock = new Lock();
    updateFunctionCache(futureCache, config, arg, finishLock);
    return finishLock;
  }

  function updateFunctionCache(cache, config, arg, value) {
    if (!config.configured()) config.forever();
    var cachedValue = cache.get(arg);
    config.deactivate();

    switch (config.mode()) {
      case "forever":
        cachedValue = [{
          value: value,
          valid: genTrue
        }];
        cache.set(arg, cachedValue);
        break;

      case "invalidate":
        cachedValue = [{
          value: value,
          valid: config.validator()
        }];
        cache.set(arg, cachedValue);
        break;

      case "valid":
        if (cachedValue) {
          cachedValue.push({
            value: value,
            valid: config.validator()
          });
        } else {
          cachedValue = [{
            value: value,
            valid: config.validator()
          }];
          cache.set(arg, cachedValue);
        }

    }
  }

  var CacheConfigurator = function () {
    function CacheConfigurator(data) {
      this._active = true;
      this._never = false;
      this._forever = false;
      this._invalidate = false;
      this._configured = false;
      this._pairs = [];
      this._data = void 0;
      this._data = data;
    }

    var _proto = CacheConfigurator.prototype;

    _proto.simple = function simple() {
      return makeSimpleConfigurator(this);
    };

    _proto.mode = function mode() {
      if (this._never) return "never";
      if (this._forever) return "forever";
      if (this._invalidate) return "invalidate";
      return "valid";
    };

    _proto.forever = function forever() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never) {
        throw new Error("Caching has already been configured with .never()");
      }

      this._forever = true;
      this._configured = true;
    };

    _proto.never = function never() {
      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._forever) {
        throw new Error("Caching has already been configured with .forever()");
      }

      this._never = true;
      this._configured = true;
    };

    _proto.using = function using(handler) {
      var _this = this;

      if (!this._active) {
        throw new Error("Cannot change caching after evaluation has completed.");
      }

      if (this._never || this._forever) {
        throw new Error("Caching has already been configured with .never or .forever()");
      }

      this._configured = true;
      var key = handler(this._data);
      var fn = maybeAsync(handler, "You appear to be using an async cache handler, but Babel has been called synchronously");

      if (isThenable$1(key)) {
        return key.then(function (key) {
          _this._pairs.push([key, fn]);

          return key;
        });
      }

      this._pairs.push([key, fn]);

      return key;
    };

    _proto.invalidate = function invalidate(handler) {
      this._invalidate = true;
      return this.using(handler);
    };

    _proto.validator = function validator() {
      var pairs = this._pairs;
      return regenerator.mark(function _callee(data) {
        var _iterator2, _step2, _step2$value, key, fn;

        return regenerator.wrap(function _callee$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _iterator2 = _createForOfIteratorHelperLoose(pairs);

              case 1:
                if ((_step2 = _iterator2()).done) {
                  _context5.next = 10;
                  break;
                }

                _step2$value = _slicedToArray$2(_step2.value, 2), key = _step2$value[0], fn = _step2$value[1];
                _context5.t0 = key;
                return _context5.delegateYield(fn(data), "t1", 5);

              case 5:
                _context5.t2 = _context5.t1;

                if (!(_context5.t0 !== _context5.t2)) {
                  _context5.next = 8;
                  break;
                }

                return _context5.abrupt("return", false);

              case 8:
                _context5.next = 1;
                break;

              case 10:
                return _context5.abrupt("return", true);

              case 11:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee);
      });
    };

    _proto.deactivate = function deactivate() {
      this._active = false;
    };

    _proto.configured = function configured() {
      return this._configured;
    };

    return CacheConfigurator;
  }();

  function makeSimpleConfigurator(cache) {
    function cacheFn(val) {
      if (typeof val === "boolean") {
        if (val) cache.forever();else cache.never();
        return;
      }

      return cache.using(function () {
        return assertSimpleType(val());
      });
    }

    cacheFn.forever = function () {
      return cache.forever();
    };

    cacheFn.never = function () {
      return cache.never();
    };

    cacheFn.using = function (cb) {
      return cache.using(function () {
        return assertSimpleType(cb());
      });
    };

    cacheFn.invalidate = function (cb) {
      return cache.invalidate(function () {
        return assertSimpleType(cb());
      });
    };

    return cacheFn;
  }

  function assertSimpleType(value) {
    if (isThenable$1(value)) {
      throw new Error("You appear to be using an async cache handler, " + "which your current version of Babel does not support. " + "We may add support for this in the future, " + "but if you're on the most recent version of @babel/core and still " + "seeing this error, then you'll need to synchronously handle your caching logic.");
    }

    if (value != null && typeof value !== "string" && typeof value !== "boolean" && typeof value !== "number") {
      throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
    }

    return value;
  }

  var Lock = function () {
    function Lock() {
      var _this2 = this;

      this.released = false;
      this.promise = void 0;
      this._resolve = void 0;
      this.promise = new Promise(function (resolve) {
        _this2._resolve = resolve;
      });
    }

    var _proto2 = Lock.prototype;

    _proto2.release = function release(value) {
      this.released = true;

      this._resolve(value);
    };

    return Lock;
  }();

  var jsReleases = [
  	{
  		name: "nodejs",
  		version: "0.2.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.3.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.4.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.5.0",
  		date: "2011-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.6.0",
  		date: "2011-11-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.7.0",
  		date: "2012-01-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.8.0",
  		date: "2012-06-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.9.0",
  		date: "2012-07-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.10.0",
  		date: "2013-03-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.11.0",
  		date: "2013-03-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "0.12.0",
  		date: "2015-02-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "iojs",
  		version: "1.0.0",
  		date: "2015-01-14"
  	},
  	{
  		name: "iojs",
  		version: "1.1.0",
  		date: "2015-02-03"
  	},
  	{
  		name: "iojs",
  		version: "1.2.0",
  		date: "2015-02-11"
  	},
  	{
  		name: "iojs",
  		version: "1.3.0",
  		date: "2015-02-20"
  	},
  	{
  		name: "iojs",
  		version: "1.5.0",
  		date: "2015-03-06"
  	},
  	{
  		name: "iojs",
  		version: "1.6.0",
  		date: "2015-03-20"
  	},
  	{
  		name: "iojs",
  		version: "2.0.0",
  		date: "2015-05-04"
  	},
  	{
  		name: "iojs",
  		version: "2.1.0",
  		date: "2015-05-24"
  	},
  	{
  		name: "iojs",
  		version: "2.2.0",
  		date: "2015-06-01"
  	},
  	{
  		name: "iojs",
  		version: "2.3.0",
  		date: "2015-06-13"
  	},
  	{
  		name: "iojs",
  		version: "2.4.0",
  		date: "2015-07-17"
  	},
  	{
  		name: "iojs",
  		version: "2.5.0",
  		date: "2015-07-28"
  	},
  	{
  		name: "iojs",
  		version: "3.0.0",
  		date: "2015-08-04"
  	},
  	{
  		name: "iojs",
  		version: "3.1.0",
  		date: "2015-08-19"
  	},
  	{
  		name: "iojs",
  		version: "3.2.0",
  		date: "2015-08-25"
  	},
  	{
  		name: "iojs",
  		version: "3.3.0",
  		date: "2015-09-02"
  	},
  	{
  		name: "nodejs",
  		version: "4.0.0",
  		date: "2015-09-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.1.0",
  		date: "2015-09-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.2.0",
  		date: "2015-10-12",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.3.0",
  		date: "2016-02-09",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.4.0",
  		date: "2016-03-08",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.5.0",
  		date: "2016-08-16",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.6.0",
  		date: "2016-09-27",
  		lts: "Argon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "4.7.0",
  		date: "2016-12-06",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.8.0",
  		date: "2017-02-21",
  		lts: "Argon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "4.9.0",
  		date: "2018-03-28",
  		lts: "Argon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "5.0.0",
  		date: "2015-10-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.1.0",
  		date: "2015-11-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.2.0",
  		date: "2015-12-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.3.0",
  		date: "2015-12-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.4.0",
  		date: "2016-01-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.5.0",
  		date: "2016-01-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.6.0",
  		date: "2016-02-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.7.0",
  		date: "2016-02-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.8.0",
  		date: "2016-03-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.9.0",
  		date: "2016-03-16",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.10.0",
  		date: "2016-04-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.11.0",
  		date: "2016-04-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "5.12.0",
  		date: "2016-06-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.0.0",
  		date: "2016-04-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.1.0",
  		date: "2016-05-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.2.0",
  		date: "2016-05-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.3.0",
  		date: "2016-07-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.4.0",
  		date: "2016-08-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.5.0",
  		date: "2016-08-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.6.0",
  		date: "2016-09-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.7.0",
  		date: "2016-09-27",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.8.0",
  		date: "2016-10-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.9.0",
  		date: "2016-10-18",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.10.0",
  		date: "2017-02-21",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.11.0",
  		date: "2017-06-06",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.12.0",
  		date: "2017-11-06",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.13.0",
  		date: "2018-02-10",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.14.0",
  		date: "2018-03-28",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.15.0",
  		date: "2018-11-27",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "6.16.0",
  		date: "2018-12-26",
  		lts: "Boron",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "6.17.0",
  		date: "2019-02-28",
  		lts: "Boron",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "7.0.0",
  		date: "2016-10-25",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.1.0",
  		date: "2016-11-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.2.0",
  		date: "2016-11-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.3.0",
  		date: "2016-12-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.4.0",
  		date: "2017-01-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.5.0",
  		date: "2017-01-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.6.0",
  		date: "2017-02-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.7.0",
  		date: "2017-02-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.8.0",
  		date: "2017-03-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.9.0",
  		date: "2017-04-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "7.10.0",
  		date: "2017-05-02",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.0.0",
  		date: "2017-05-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.1.0",
  		date: "2017-06-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.2.0",
  		date: "2017-07-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.3.0",
  		date: "2017-08-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.4.0",
  		date: "2017-08-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.5.0",
  		date: "2017-09-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.6.0",
  		date: "2017-09-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.7.0",
  		date: "2017-10-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.8.0",
  		date: "2017-10-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.9.0",
  		date: "2017-10-31",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.10.0",
  		date: "2018-03-06",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.11.0",
  		date: "2018-03-28",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "8.12.0",
  		date: "2018-09-10",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.13.0",
  		date: "2018-11-20",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.14.0",
  		date: "2018-11-27",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "8.15.0",
  		date: "2018-12-26",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.16.0",
  		date: "2019-04-16",
  		lts: "Carbon",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "8.17.0",
  		date: "2019-12-17",
  		lts: "Carbon",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "9.0.0",
  		date: "2017-10-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.1.0",
  		date: "2017-11-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.2.0",
  		date: "2017-11-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.3.0",
  		date: "2017-12-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.4.0",
  		date: "2018-01-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.5.0",
  		date: "2018-01-31",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.6.0",
  		date: "2018-02-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.7.0",
  		date: "2018-03-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.8.0",
  		date: "2018-03-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.9.0",
  		date: "2018-03-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "9.10.0",
  		date: "2018-03-28",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "9.11.0",
  		date: "2018-04-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.0.0",
  		date: "2018-04-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.1.0",
  		date: "2018-05-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.2.0",
  		date: "2018-05-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.3.0",
  		date: "2018-05-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.4.0",
  		date: "2018-06-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.5.0",
  		date: "2018-06-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.6.0",
  		date: "2018-07-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.7.0",
  		date: "2018-07-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.8.0",
  		date: "2018-08-01",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.9.0",
  		date: "2018-08-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.10.0",
  		date: "2018-09-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.11.0",
  		date: "2018-09-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.12.0",
  		date: "2018-10-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.13.0",
  		date: "2018-10-30",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.14.0",
  		date: "2018-11-27",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.15.0",
  		date: "2018-12-26",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.16.0",
  		date: "2019-05-28",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.17.0",
  		date: "2019-10-22",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.18.0",
  		date: "2019-12-17",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.19.0",
  		date: "2020-02-05",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.20.0",
  		date: "2020-03-26",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.21.0",
  		date: "2020-06-02",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "10.22.0",
  		date: "2020-07-21",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.23.0",
  		date: "2020-10-27",
  		lts: "Dubnium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "10.24.0",
  		date: "2021-02-23",
  		lts: "Dubnium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "11.0.0",
  		date: "2018-10-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.1.0",
  		date: "2018-10-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.2.0",
  		date: "2018-11-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.3.0",
  		date: "2018-11-27",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "11.4.0",
  		date: "2018-12-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.5.0",
  		date: "2018-12-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.6.0",
  		date: "2018-12-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.7.0",
  		date: "2019-01-17",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.8.0",
  		date: "2019-01-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.9.0",
  		date: "2019-01-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.10.0",
  		date: "2019-02-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.11.0",
  		date: "2019-03-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.12.0",
  		date: "2019-03-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.13.0",
  		date: "2019-03-28",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.14.0",
  		date: "2019-04-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "11.15.0",
  		date: "2019-04-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.0.0",
  		date: "2019-04-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.1.0",
  		date: "2019-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.2.0",
  		date: "2019-05-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.3.0",
  		date: "2019-05-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.4.0",
  		date: "2019-06-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.5.0",
  		date: "2019-06-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.6.0",
  		date: "2019-07-03",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.7.0",
  		date: "2019-07-23",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.8.0",
  		date: "2019-08-06",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.9.0",
  		date: "2019-08-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.10.0",
  		date: "2019-09-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.11.0",
  		date: "2019-09-25",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.12.0",
  		date: "2019-10-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.13.0",
  		date: "2019-10-21",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.14.0",
  		date: "2019-12-17",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.15.0",
  		date: "2020-02-05",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.16.0",
  		date: "2020-02-11",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.17.0",
  		date: "2020-05-26",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.18.0",
  		date: "2020-06-02",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "12.19.0",
  		date: "2020-10-06",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.20.0",
  		date: "2020-11-24",
  		lts: "Erbium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "12.21.0",
  		date: "2021-02-23",
  		lts: "Erbium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "13.0.0",
  		date: "2019-10-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.1.0",
  		date: "2019-11-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.2.0",
  		date: "2019-11-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.3.0",
  		date: "2019-12-03",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.4.0",
  		date: "2019-12-17",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "13.5.0",
  		date: "2019-12-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.6.0",
  		date: "2020-01-07",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.7.0",
  		date: "2020-01-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.8.0",
  		date: "2020-02-05",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "13.9.0",
  		date: "2020-02-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.10.0",
  		date: "2020-03-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.11.0",
  		date: "2020-03-12",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.12.0",
  		date: "2020-03-26",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.13.0",
  		date: "2020-04-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "13.14.0",
  		date: "2020-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.0.0",
  		date: "2020-04-21",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.1.0",
  		date: "2020-04-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.2.0",
  		date: "2020-05-05",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.3.0",
  		date: "2020-05-19",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.4.0",
  		date: "2020-06-02",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "14.5.0",
  		date: "2020-06-30",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.6.0",
  		date: "2020-07-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.7.0",
  		date: "2020-07-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.8.0",
  		date: "2020-08-11",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.9.0",
  		date: "2020-08-27",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.10.0",
  		date: "2020-09-08",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.11.0",
  		date: "2020-09-15",
  		lts: false,
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "14.12.0",
  		date: "2020-09-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.13.0",
  		date: "2020-09-29",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.14.0",
  		date: "2020-10-15",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.15.0",
  		date: "2020-10-27",
  		lts: "Fermium",
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "14.16.0",
  		date: "2021-02-23",
  		lts: "Fermium",
  		security: true
  	},
  	{
  		name: "nodejs",
  		version: "15.0.0",
  		date: "2020-10-20",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.1.0",
  		date: "2020-11-04",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.2.0",
  		date: "2020-11-10",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.3.0",
  		date: "2020-11-24",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.4.0",
  		date: "2020-12-09",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.5.0",
  		date: "2020-12-22",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.6.0",
  		date: "2021-01-14",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.7.0",
  		date: "2021-01-25",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.8.0",
  		date: "2021-02-02",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.9.0",
  		date: "2021-02-18",
  		lts: false,
  		security: false
  	},
  	{
  		name: "nodejs",
  		version: "15.10.0",
  		date: "2021-02-23",
  		lts: false,
  		security: true
  	}
  ];

  var browsers$2 = {
    A: "ie",
    B: "edge",
    C: "firefox",
    D: "chrome",
    E: "safari",
    F: "opera",
    G: "ios_saf",
    H: "op_mini",
    I: "android",
    J: "bb",
    K: "op_mob",
    L: "and_chr",
    M: "and_ff",
    N: "ie_mob",
    O: "and_uc",
    P: "samsung",
    Q: "and_qq",
    R: "baidu",
    S: "kaios"
  };

  var browsers_1 = browsers$2;
  var browsers$1 = {
    browsers: browsers_1
  };

  var browserVersions$1 = {
    "0": "43",
    "1": "44",
    "2": "45",
    "3": "46",
    "4": "47",
    "5": "48",
    "6": "49",
    "7": "50",
    "8": "51",
    "9": "52",
    A: "10",
    B: "11",
    C: "12",
    D: "7",
    E: "8",
    F: "9",
    G: "90",
    H: "4",
    I: "6",
    J: "13",
    K: "14",
    L: "15",
    M: "16",
    N: "17",
    O: "18",
    P: "87",
    Q: "62",
    R: "79",
    S: "80",
    T: "81",
    U: "83",
    V: "84",
    W: "85",
    X: "86",
    Y: "88",
    Z: "89",
    a: "91",
    b: "5",
    c: "19",
    d: "20",
    e: "21",
    f: "22",
    g: "23",
    h: "24",
    i: "25",
    j: "26",
    k: "27",
    l: "28",
    m: "29",
    n: "30",
    o: "31",
    p: "32",
    q: "33",
    r: "34",
    s: "35",
    t: "36",
    u: "37",
    v: "38",
    w: "39",
    x: "40",
    y: "41",
    z: "42",
    AB: "53",
    BB: "54",
    CB: "55",
    DB: "56",
    EB: "57",
    FB: "58",
    GB: "60",
    HB: "63",
    IB: "64",
    JB: "65",
    KB: "66",
    LB: "67",
    MB: "68",
    NB: "69",
    OB: "70",
    PB: "71",
    QB: "72",
    RB: "73",
    SB: "74",
    TB: "75",
    UB: "76",
    VB: "11.1",
    WB: "12.1",
    XB: "3",
    YB: "59",
    ZB: "61",
    aB: "77",
    bB: "78",
    cB: "3.2",
    dB: "10.1",
    eB: "11.5",
    fB: "4.2-4.3",
    gB: "5.5",
    hB: "2",
    iB: "82",
    jB: "3.5",
    kB: "3.6",
    lB: "92",
    mB: "93",
    nB: "94",
    oB: "3.1",
    pB: "5.1",
    qB: "6.1",
    rB: "7.1",
    sB: "9.1",
    tB: "13.1",
    uB: "14.1",
    vB: "TP",
    wB: "9.5-9.6",
    xB: "10.0-10.1",
    yB: "10.5",
    zB: "10.6",
    "0B": "11.6",
    "1B": "4.0-4.1",
    "2B": "5.0-5.1",
    "3B": "6.0-6.1",
    "4B": "7.0-7.1",
    "5B": "8.1-8.4",
    "6B": "9.0-9.2",
    "7B": "9.3",
    "8B": "10.0-10.2",
    "9B": "10.3",
    AC: "11.0-11.2",
    BC: "11.3-11.4",
    CC: "12.0-12.1",
    DC: "12.2-12.4",
    EC: "13.0-13.1",
    FC: "13.2",
    GC: "13.3",
    HC: "13.4-13.7",
    IC: "14.0-14.4",
    JC: "14.5-14.6",
    KC: "all",
    LC: "2.1",
    MC: "2.2",
    NC: "2.3",
    OC: "4.1",
    PC: "4.4",
    QC: "4.4.3-4.4.4",
    RC: "12.12",
    SC: "5.0-5.4",
    TC: "6.2-6.4",
    UC: "7.2-7.4",
    VC: "8.2",
    WC: "9.2",
    XC: "11.1-11.2",
    YC: "12.0",
    ZC: "13.0",
    aC: "14.0",
    bC: "10.4",
    cC: "7.12",
    dC: "2.5"
  };

  var browserVersions_1 = browserVersions$1;
  var browserVersions = {
    browserVersions: browserVersions_1
  };

  var agents$2 = {
    A: {
      A: {
        I: 0.0131217,
        D: 0.00621152,
        E: 0.0199047,
        F: 0.0928884,
        A: 0.0132698,
        B: 0.849265,
        gB: 0.009298
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gB", "I", "D", "E", "F", "A", "B", "", "", ""],
      E: "IE",
      F: {
        gB: 962323200,
        I: 998870400,
        D: 1161129600,
        E: 1237420800,
        F: 1300060800,
        A: 1346716800,
        B: 1381968000
      }
    },
    B: {
      A: {
        C: 0.008408,
        J: 0.004267,
        K: 0.004204,
        L: 0.004204,
        M: 0.008408,
        N: 0.033632,
        O: 0.092488,
        R: 0,
        S: 0.004298,
        T: 0.00944,
        U: 0.00415,
        V: 0.008408,
        W: 0.008408,
        X: 0.012612,
        P: 0.012612,
        Y: 0.016816,
        Z: 0.079876,
        G: 3.01006,
        a: 0.2102
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "J", "K", "L", "M", "N", "O", "R", "S", "T", "U", "V", "W", "X", "P", "Y", "Z", "G", "a", "", "", ""],
      E: "Edge",
      F: {
        C: 1438128000,
        J: 1447286400,
        K: 1470096000,
        L: 1491868800,
        M: 1508198400,
        N: 1525046400,
        O: 1542067200,
        R: 1579046400,
        S: 1581033600,
        T: 1586736000,
        U: 1590019200,
        V: 1594857600,
        W: 1598486400,
        X: 1602201600,
        P: 1605830400,
        Y: 1611360000,
        Z: 1614816000,
        G: 1618358400,
        a: 1622073600
      },
      D: {
        C: "ms",
        J: "ms",
        K: "ms",
        L: "ms",
        M: "ms",
        N: "ms",
        O: "ms"
      }
    },
    C: {
      A: {
        "0": 0.058856,
        "1": 0.004204,
        "2": 0.004204,
        "3": 0.004525,
        "4": 0.004271,
        "5": 0.008408,
        "6": 0.004538,
        "7": 0.004267,
        "8": 0.004204,
        "9": 0.071468,
        hB: 0.012813,
        XB: 0.004271,
        H: 0.02102,
        b: 0.004879,
        I: 0.020136,
        D: 0.005725,
        E: 0.004525,
        F: 0.00533,
        A: 0.004283,
        B: 0.008408,
        C: 0.004471,
        J: 0.004486,
        K: 0.00453,
        L: 0.008542,
        M: 0.004417,
        N: 0.004425,
        O: 0.008542,
        c: 0.004443,
        d: 0.004283,
        e: 0.008542,
        f: 0.013698,
        g: 0.008542,
        h: 0.008786,
        i: 0.017084,
        j: 0.004317,
        k: 0.004393,
        l: 0.004418,
        m: 0.008834,
        n: 0.008542,
        o: 0.008928,
        p: 0.004471,
        q: 0.009284,
        r: 0.004707,
        s: 0.009076,
        t: 0.004425,
        u: 0.004783,
        v: 0.004271,
        w: 0.004783,
        x: 0.00487,
        y: 0.005029,
        z: 0.0047,
        AB: 0.004335,
        BB: 0.004204,
        CB: 0.004204,
        DB: 0.012612,
        EB: 0.004425,
        FB: 0.004204,
        YB: 0.004204,
        GB: 0.008408,
        ZB: 0.00472,
        Q: 0.004425,
        HB: 0.02102,
        IB: 0.00415,
        JB: 0.004267,
        KB: 0.008408,
        LB: 0.004267,
        MB: 0.012612,
        NB: 0.00415,
        OB: 0.004204,
        PB: 0.004425,
        QB: 0.008408,
        RB: 0.00415,
        SB: 0.00415,
        TB: 0.008542,
        UB: 0.004298,
        aB: 0.004204,
        bB: 0.14714,
        R: 0.008408,
        S: 0.008408,
        T: 0.012612,
        iB: 0.016816,
        U: 0.012612,
        V: 0.025224,
        W: 0.02102,
        X: 0.033632,
        P: 0.071468,
        Y: 2.3122,
        Z: 0.029428,
        G: 0,
        a: 0,
        jB: 0.008786,
        kB: 0.00487
      },
      B: "moz",
      C: ["hB", "XB", "jB", "kB", "H", "b", "I", "D", "E", "F", "A", "B", "C", "J", "K", "L", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "YB", "GB", "ZB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "aB", "bB", "R", "S", "T", "iB", "U", "V", "W", "X", "P", "Y", "Z", "G", "a", ""],
      E: "Firefox",
      F: {
        "0": 1450137600,
        "1": 1453852800,
        "2": 1457395200,
        "3": 1461628800,
        "4": 1465257600,
        "5": 1470096000,
        "6": 1474329600,
        "7": 1479168000,
        "8": 1485216000,
        "9": 1488844800,
        hB: 1161648000,
        XB: 1213660800,
        jB: 1246320000,
        kB: 1264032000,
        H: 1300752000,
        b: 1308614400,
        I: 1313452800,
        D: 1317081600,
        E: 1317081600,
        F: 1320710400,
        A: 1324339200,
        B: 1327968000,
        C: 1331596800,
        J: 1335225600,
        K: 1338854400,
        L: 1342483200,
        M: 1346112000,
        N: 1349740800,
        O: 1353628800,
        c: 1357603200,
        d: 1361232000,
        e: 1364860800,
        f: 1368489600,
        g: 1372118400,
        h: 1375747200,
        i: 1379376000,
        j: 1386633600,
        k: 1391472000,
        l: 1395100800,
        m: 1398729600,
        n: 1402358400,
        o: 1405987200,
        p: 1409616000,
        q: 1413244800,
        r: 1417392000,
        s: 1421107200,
        t: 1424736000,
        u: 1428278400,
        v: 1431475200,
        w: 1435881600,
        x: 1439251200,
        y: 1442880000,
        z: 1446508800,
        AB: 1492560000,
        BB: 1497312000,
        CB: 1502150400,
        DB: 1506556800,
        EB: 1510617600,
        FB: 1516665600,
        YB: 1520985600,
        GB: 1525824000,
        ZB: 1529971200,
        Q: 1536105600,
        HB: 1540252800,
        IB: 1544486400,
        JB: 1548720000,
        KB: 1552953600,
        LB: 1558396800,
        MB: 1562630400,
        NB: 1567468800,
        OB: 1571788800,
        PB: 1575331200,
        QB: 1578355200,
        RB: 1581379200,
        SB: 1583798400,
        TB: 1586304000,
        UB: 1588636800,
        aB: 1591056000,
        bB: 1593475200,
        R: 1595894400,
        S: 1598313600,
        T: 1600732800,
        iB: 1603152000,
        U: 1605571200,
        V: 1607990400,
        W: 1611619200,
        X: 1614038400,
        P: 1616457600,
        Y: 1618790400,
        Z: 1622505600,
        G: null,
        a: null
      }
    },
    D: {
      A: {
        "0": 0.008408,
        "1": 0.004465,
        "2": 0.004642,
        "3": 0.004891,
        "4": 0.008408,
        "5": 0.02102,
        "6": 0.214404,
        "7": 0.004204,
        "8": 0.016816,
        "9": 0.004204,
        H: 0.004706,
        b: 0.004879,
        I: 0.004879,
        D: 0.005591,
        E: 0.005591,
        F: 0.005591,
        A: 0.004534,
        B: 0.004464,
        C: 0.010424,
        J: 0.0083,
        K: 0.004706,
        L: 0.015087,
        M: 0.004393,
        N: 0.004393,
        O: 0.008652,
        c: 0.008542,
        d: 0.004393,
        e: 0.004317,
        f: 0.012612,
        g: 0.008786,
        h: 0.008408,
        i: 0.004461,
        j: 0.004298,
        k: 0.004326,
        l: 0.0047,
        m: 0.004538,
        n: 0.008542,
        o: 0.008596,
        p: 0.004566,
        q: 0.004204,
        r: 0.008408,
        s: 0.012612,
        t: 0.004335,
        u: 0.004464,
        v: 0.025224,
        w: 0.004464,
        x: 0.012612,
        y: 0.0236,
        z: 0.004403,
        AB: 0.058856,
        BB: 0.008408,
        CB: 0.012612,
        DB: 0.04204,
        EB: 0.008408,
        FB: 0.008408,
        YB: 0.008408,
        GB: 0.016816,
        ZB: 0.121916,
        Q: 0.008408,
        HB: 0.02102,
        IB: 0.025224,
        JB: 0.02102,
        KB: 0.02102,
        LB: 0.033632,
        MB: 0.029428,
        NB: 0.067264,
        OB: 0.071468,
        PB: 0.025224,
        QB: 0.058856,
        RB: 0.02102,
        SB: 0.113508,
        TB: 0.092488,
        UB: 0.067264,
        aB: 0.029428,
        bB: 0.075672,
        R: 0.18918,
        S: 0.1051,
        T: 0.079876,
        U: 0.130324,
        V: 0.100896,
        W: 0.243832,
        X: 0.16816,
        P: 0.311096,
        Y: 0.344728,
        Z: 1.0468,
        G: 21.4866,
        a: 0.790352,
        lB: 0.025224,
        mB: 0.004204,
        nB: 0
      },
      B: "webkit",
      C: ["", "", "", "H", "b", "I", "D", "E", "F", "A", "B", "C", "J", "K", "L", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "YB", "GB", "ZB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "aB", "bB", "R", "S", "T", "U", "V", "W", "X", "P", "Y", "Z", "G", "a", "lB", "mB", "nB"],
      E: "Chrome",
      F: {
        "0": 1432080000,
        "1": 1437523200,
        "2": 1441152000,
        "3": 1444780800,
        "4": 1449014400,
        "5": 1453248000,
        "6": 1456963200,
        "7": 1460592000,
        "8": 1464134400,
        "9": 1469059200,
        H: 1264377600,
        b: 1274745600,
        I: 1283385600,
        D: 1287619200,
        E: 1291248000,
        F: 1296777600,
        A: 1299542400,
        B: 1303862400,
        C: 1307404800,
        J: 1312243200,
        K: 1316131200,
        L: 1316131200,
        M: 1319500800,
        N: 1323734400,
        O: 1328659200,
        c: 1332892800,
        d: 1337040000,
        e: 1340668800,
        f: 1343692800,
        g: 1348531200,
        h: 1352246400,
        i: 1357862400,
        j: 1361404800,
        k: 1364428800,
        l: 1369094400,
        m: 1374105600,
        n: 1376956800,
        o: 1384214400,
        p: 1389657600,
        q: 1392940800,
        r: 1397001600,
        s: 1400544000,
        t: 1405468800,
        u: 1409011200,
        v: 1412640000,
        w: 1416268800,
        x: 1421798400,
        y: 1425513600,
        z: 1429401600,
        AB: 1472601600,
        BB: 1476230400,
        CB: 1480550400,
        DB: 1485302400,
        EB: 1489017600,
        FB: 1492560000,
        YB: 1496707200,
        GB: 1500940800,
        ZB: 1504569600,
        Q: 1508198400,
        HB: 1512518400,
        IB: 1516752000,
        JB: 1520294400,
        KB: 1523923200,
        LB: 1527552000,
        MB: 1532390400,
        NB: 1536019200,
        OB: 1539648000,
        PB: 1543968000,
        QB: 1548720000,
        RB: 1552348800,
        SB: 1555977600,
        TB: 1559606400,
        UB: 1564444800,
        aB: 1568073600,
        bB: 1571702400,
        R: 1575936000,
        S: 1580860800,
        T: 1586304000,
        U: 1589846400,
        V: 1594684800,
        W: 1598313600,
        X: 1601942400,
        P: 1605571200,
        Y: 1611014400,
        Z: 1614556800,
        G: 1618272000,
        a: 1621987200,
        lB: null,
        mB: null,
        nB: null
      }
    },
    E: {
      A: {
        H: 0,
        b: 0.008542,
        I: 0.004656,
        D: 0.004465,
        E: 0.218608,
        F: 0.004891,
        A: 0.004425,
        B: 0.008408,
        C: 0.012612,
        J: 0.088284,
        K: 2.26175,
        oB: 0,
        cB: 0.008692,
        pB: 0.109304,
        qB: 0.00456,
        rB: 0.004283,
        sB: 0.02102,
        dB: 0.02102,
        VB: 0.058856,
        WB: 0.088284,
        tB: 0.395176,
        uB: 0.748312,
        vB: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "oB", "cB", "H", "b", "pB", "I", "qB", "D", "rB", "E", "F", "sB", "A", "dB", "B", "VB", "C", "WB", "J", "tB", "K", "uB", "vB", "", ""],
      E: "Safari",
      F: {
        oB: 1205798400,
        cB: 1226534400,
        H: 1244419200,
        b: 1275868800,
        pB: 1311120000,
        I: 1343174400,
        qB: 1382400000,
        D: 1382400000,
        rB: 1410998400,
        E: 1413417600,
        F: 1443657600,
        sB: 1458518400,
        A: 1474329600,
        dB: 1490572800,
        B: 1505779200,
        VB: 1522281600,
        C: 1537142400,
        WB: 1553472000,
        J: 1568851200,
        tB: 1585008000,
        K: 1600214400,
        uB: 1619395200,
        vB: null
      }
    },
    F: {
      A: {
        "0": 0.008542,
        "1": 0.004227,
        "2": 0.004725,
        "3": 0.008408,
        "4": 0.008942,
        "5": 0.004707,
        "6": 0.004827,
        "7": 0.004707,
        "8": 0.004707,
        "9": 0.004326,
        F: 0.0082,
        B: 0.016581,
        C: 0.004317,
        L: 0.00685,
        M: 0.00685,
        N: 0.00685,
        O: 0.005014,
        c: 0.006015,
        d: 0.004879,
        e: 0.006597,
        f: 0.006597,
        g: 0.013434,
        h: 0.006702,
        i: 0.006015,
        j: 0.005595,
        k: 0.004393,
        l: 0.008652,
        m: 0.004879,
        n: 0.004879,
        o: 0.004711,
        p: 0.005152,
        q: 0.005014,
        r: 0.009758,
        s: 0.004879,
        t: 0.008408,
        u: 0.004283,
        v: 0.004367,
        w: 0.004534,
        x: 0.008408,
        y: 0.004227,
        z: 0.004418,
        AB: 0.008922,
        BB: 0.014349,
        CB: 0.004425,
        DB: 0.00472,
        EB: 0.004425,
        FB: 0.004425,
        GB: 0.00472,
        Q: 0.004532,
        HB: 0.004566,
        IB: 0.02283,
        JB: 0.00867,
        KB: 0.004656,
        LB: 0.004642,
        MB: 0.004298,
        NB: 0.00944,
        OB: 0.00415,
        PB: 0.004271,
        QB: 0.004298,
        RB: 0.096692,
        SB: 0.008408,
        TB: 0.433012,
        UB: 0.437216,
        wB: 0.00685,
        xB: 0,
        yB: 0.008392,
        zB: 0.004706,
        VB: 0.006229,
        eB: 0.004879,
        "0B": 0.008786,
        WB: 0.00472
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "F", "wB", "xB", "yB", "zB", "B", "VB", "eB", "0B", "C", "WB", "L", "M", "N", "O", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "Q", "HB", "IB", "JB", "KB", "LB", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "", "", ""],
      E: "Opera",
      F: {
        "0": 1486425600,
        "1": 1490054400,
        "2": 1494374400,
        "3": 1498003200,
        "4": 1502236800,
        "5": 1506470400,
        "6": 1510099200,
        "7": 1515024000,
        "8": 1517961600,
        "9": 1521676800,
        F: 1150761600,
        wB: 1223424000,
        xB: 1251763200,
        yB: 1267488000,
        zB: 1277942400,
        B: 1292457600,
        VB: 1302566400,
        eB: 1309219200,
        "0B": 1323129600,
        C: 1323129600,
        WB: 1352073600,
        L: 1372723200,
        M: 1377561600,
        N: 1381104000,
        O: 1386288000,
        c: 1390867200,
        d: 1393891200,
        e: 1399334400,
        f: 1401753600,
        g: 1405987200,
        h: 1409616000,
        i: 1413331200,
        j: 1417132800,
        k: 1422316800,
        l: 1425945600,
        m: 1430179200,
        n: 1433808000,
        o: 1438646400,
        p: 1442448000,
        q: 1445904000,
        r: 1449100800,
        s: 1454371200,
        t: 1457308800,
        u: 1462320000,
        v: 1465344000,
        w: 1470096000,
        x: 1474329600,
        y: 1477267200,
        z: 1481587200,
        AB: 1525910400,
        BB: 1530144000,
        CB: 1534982400,
        DB: 1537833600,
        EB: 1543363200,
        FB: 1548201600,
        GB: 1554768000,
        Q: 1561593600,
        HB: 1566259200,
        IB: 1570406400,
        JB: 1573689600,
        KB: 1578441600,
        LB: 1583971200,
        MB: 1587513600,
        NB: 1592956800,
        OB: 1595894400,
        PB: 1600128000,
        QB: 1603238400,
        RB: 1613520000,
        SB: 1612224000,
        TB: 1616544000,
        UB: 1619568000
      },
      D: {
        F: "o",
        B: "o",
        C: "o",
        wB: "o",
        xB: "o",
        yB: "o",
        zB: "o",
        VB: "o",
        eB: "o",
        "0B": "o",
        WB: "o"
      }
    },
    G: {
      A: {
        E: 0.00144955,
        cB: 0,
        "1B": 0,
        fB: 0.00289911,
        "2B": 0.00869732,
        "3B": 0.0449361,
        "4B": 0.0304406,
        "5B": 0.0202937,
        "6B": 0.0217433,
        "7B": 0.147854,
        "8B": 0.0347893,
        "9B": 0.149304,
        AC: 0.0855236,
        BC: 0.0739272,
        CC: 0.0768263,
        DC: 0.246424,
        EC: 0.0666794,
        FC: 0.0333397,
        GC: 0.172497,
        HC: 0.572573,
        IC: 10.1498,
        JC: 1.93225
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cB", "1B", "fB", "2B", "3B", "4B", "E", "5B", "6B", "7B", "8B", "9B", "AC", "BC", "CC", "DC", "EC", "FC", "GC", "HC", "IC", "JC", "", "", ""],
      E: "Safari on iOS",
      F: {
        cB: 1270252800,
        "1B": 1283904000,
        fB: 1299628800,
        "2B": 1331078400,
        "3B": 1359331200,
        "4B": 1394409600,
        E: 1410912000,
        "5B": 1413763200,
        "6B": 1442361600,
        "7B": 1458518400,
        "8B": 1473724800,
        "9B": 1490572800,
        AC: 1505779200,
        BC: 1522281600,
        CC: 1537142400,
        DC: 1553472000,
        EC: 1568851200,
        FC: 1572220800,
        GC: 1580169600,
        HC: 1585008000,
        IC: 1600214400,
        JC: 1619395200
      }
    },
    H: {
      A: {
        KC: 1.18546
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "KC", "", "", ""],
      E: "Opera Mini",
      F: {
        KC: 1426464000
      }
    },
    I: {
      A: {
        XB: 0,
        H: 0.0263634,
        G: 0,
        LC: 0,
        MC: 0,
        NC: 0,
        OC: 0.0301296,
        fB: 0.0979213,
        PC: 0,
        QC: 0.43688
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "LC", "MC", "NC", "XB", "H", "OC", "fB", "PC", "QC", "G", "", "", ""],
      E: "Android Browser",
      F: {
        LC: 1256515200,
        MC: 1274313600,
        NC: 1291593600,
        XB: 1298332800,
        H: 1318896000,
        OC: 1341792000,
        fB: 1374624000,
        PC: 1386547200,
        QC: 1401667200,
        G: 1618704000
      }
    },
    J: {
      A: {
        D: 0,
        A: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "A", "", "", ""],
      E: "Blackberry Browser",
      F: {
        D: 1325376000,
        A: 1359504000
      }
    },
    K: {
      A: {
        A: 0,
        B: 0,
        C: 0,
        Q: 0.0111391,
        VB: 0,
        eB: 0,
        WB: 0
      },
      B: "o",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "VB", "eB", "C", "WB", "Q", "", "", ""],
      E: "Opera Mobile",
      F: {
        A: 1287100800,
        B: 1300752000,
        VB: 1314835200,
        eB: 1318291200,
        C: 1330300800,
        WB: 1349740800,
        Q: 1613433600
      },
      D: {
        Q: "webkit"
      }
    },
    L: {
      A: {
        G: 38.7167
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "", "", ""],
      E: "Chrome for Android",
      F: {
        G: 1618704000
      }
    },
    M: {
      A: {
        P: 0.278256
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "P", "", "", ""],
      E: "Firefox for Android",
      F: {
        P: 1616457600
      }
    },
    N: {
      A: {
        A: 0.0115934,
        B: 0.022664
      },
      B: "ms",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""],
      E: "IE Mobile",
      F: {
        A: 1340150400,
        B: 1353456000
      }
    },
    O: {
      A: {
        RC: 1.36809
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "RC", "", "", ""],
      E: "UC Browser for Android",
      F: {
        RC: 1471392000
      },
      D: {
        RC: "webkit"
      }
    },
    P: {
      A: {
        H: 0.309232,
        SC: 0.0103543,
        TC: 0.010304,
        UC: 0.0824619,
        VC: 0.0103584,
        WC: 0.0721541,
        dB: 0.0412309,
        XC: 0.164924,
        YC: 0.113385,
        ZC: 0.412309,
        aC: 2.19555
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "H", "SC", "TC", "UC", "VC", "WC", "dB", "XC", "YC", "ZC", "aC", "", "", ""],
      E: "Samsung Internet",
      F: {
        H: 1461024000,
        SC: 1481846400,
        TC: 1509408000,
        UC: 1528329600,
        VC: 1546128000,
        WC: 1554163200,
        dB: 1567900800,
        XC: 1582588800,
        YC: 1593475200,
        ZC: 1605657600,
        aC: 1618531200
      }
    },
    Q: {
      A: {
        bC: 0.185504
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "bC", "", "", ""],
      E: "QQ Browser",
      F: {
        bC: 1589846400
      }
    },
    R: {
      A: {
        cC: 0
      },
      B: "webkit",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "cC", "", "", ""],
      E: "Baidu Browser",
      F: {
        cC: 1491004800
      }
    },
    S: {
      A: {
        dC: 0.098549
      },
      B: "moz",
      C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "dC", "", "", ""],
      E: "KaiOS Browser",
      F: {
        dC: 1527811200
      }
    }
  };

  var browsers = browsers$1.browsers;
  var versions$1 = browserVersions.browserVersions;

  function unpackBrowserVersions(versionsData) {
    return Object.keys(versionsData).reduce(function (usage, version) {
      usage[versions$1[version]] = versionsData[version];
      return usage;
    }, {});
  }

  var agents_1 = Object.keys(agents$2).reduce(function (map, key) {
    var versionsData = agents$2[key];
    map[browsers[key]] = Object.keys(versionsData).reduce(function (data, entry) {
      if (entry === 'A') {
        data.usage_global = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'C') {
        data.versions = versionsData[entry].reduce(function (list, version) {
          if (version === '') {
            list.push(null);
          } else {
            list.push(versions$1[version]);
          }

          return list;
        }, []);
      } else if (entry === 'D') {
        data.prefix_exceptions = unpackBrowserVersions(versionsData[entry]);
      } else if (entry === 'E') {
        data.browser = versionsData[entry];
      } else if (entry === 'F') {
        data.release_date = Object.keys(versionsData[entry]).reduce(function (map2, key2) {
          map2[versions$1[key2]] = versionsData[entry][key2];
          return map2;
        }, {});
      } else {
        data.prefix = versionsData[entry];
      }

      return data;
    }, {});
    return map;
  }, {});
  var agents$1 = {
    agents: agents_1
  };

  var v4 = {
  	start: "2015-09-08",
  	lts: "2015-10-12",
  	maintenance: "2017-04-01",
  	end: "2018-04-30",
  	codename: "Argon"
  };
  var v5 = {
  	start: "2015-10-29",
  	maintenance: "2016-04-30",
  	end: "2016-06-30"
  };
  var v6 = {
  	start: "2016-04-26",
  	lts: "2016-10-18",
  	maintenance: "2018-04-30",
  	end: "2019-04-30",
  	codename: "Boron"
  };
  var v7 = {
  	start: "2016-10-25",
  	maintenance: "2017-04-30",
  	end: "2017-06-30"
  };
  var v8 = {
  	start: "2017-05-30",
  	lts: "2017-10-31",
  	maintenance: "2019-01-01",
  	end: "2019-12-31",
  	codename: "Carbon"
  };
  var v9 = {
  	start: "2017-10-01",
  	maintenance: "2018-04-01",
  	end: "2018-06-30"
  };
  var v10 = {
  	start: "2018-04-24",
  	lts: "2018-10-30",
  	maintenance: "2020-05-19",
  	end: "2021-04-30",
  	codename: "Dubnium"
  };
  var v11 = {
  	start: "2018-10-23",
  	maintenance: "2019-04-22",
  	end: "2019-06-01"
  };
  var v12 = {
  	start: "2019-04-23",
  	lts: "2019-10-21",
  	maintenance: "2020-11-30",
  	end: "2022-04-30",
  	codename: "Erbium"
  };
  var v13 = {
  	start: "2019-10-22",
  	maintenance: "2020-04-01",
  	end: "2020-06-01"
  };
  var v14 = {
  	start: "2020-04-21",
  	lts: "2020-10-27",
  	maintenance: "2021-10-19",
  	end: "2023-04-30",
  	codename: "Fermium"
  };
  var v15 = {
  	start: "2020-10-20",
  	maintenance: "2021-04-01",
  	end: "2021-06-01"
  };
  var v16 = {
  	start: "2021-04-20",
  	lts: "2021-10-26",
  	maintenance: "2022-10-18",
  	end: "2024-04-30",
  	codename: ""
  };
  var jsEOL = {
  	"v0.8": {
  	start: "2012-06-25",
  	end: "2014-07-31"
  },
  	"v0.10": {
  	start: "2013-03-11",
  	end: "2016-10-31"
  },
  	"v0.12": {
  	start: "2015-02-06",
  	end: "2016-12-31"
  },
  	v4: v4,
  	v5: v5,
  	v6: v6,
  	v7: v7,
  	v8: v8,
  	v9: v9,
  	v10: v10,
  	v11: v11,
  	v12: v12,
  	v13: v13,
  	v14: v14,
  	v15: v15,
  	v16: v16
  };

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
  });

  var versions = {
    "0.20": "39",
    "0.21": "41",
    "0.22": "41",
    "0.23": "41",
    "0.24": "41",
    "0.25": "42",
    "0.26": "42",
    "0.27": "43",
    "0.28": "43",
    "0.29": "43",
    "0.30": "44",
    "0.31": "45",
    "0.32": "45",
    "0.33": "45",
    "0.34": "45",
    "0.35": "45",
    "0.36": "47",
    "0.37": "49",
    "1.0": "49",
    "1.1": "50",
    "1.2": "51",
    "1.3": "52",
    "1.4": "53",
    "1.5": "54",
    "1.6": "56",
    "1.7": "58",
    "1.8": "59",
    "2.0": "61",
    "2.1": "61",
    "3.0": "66",
    "3.1": "66",
    "4.0": "69",
    "4.1": "69",
    "4.2": "69",
    "5.0": "73",
    "6.0": "76",
    "6.1": "76",
    "7.0": "78",
    "7.1": "78",
    "7.2": "78",
    "7.3": "78",
    "8.0": "80",
    "8.1": "80",
    "8.2": "80",
    "8.3": "80",
    "8.4": "80",
    "8.5": "80",
    "9.0": "83",
    "9.1": "83",
    "9.2": "83",
    "9.3": "83",
    "9.4": "83",
    "10.0": "85",
    "10.1": "85",
    "10.2": "85",
    "10.3": "85",
    "10.4": "85",
    "11.0": "87",
    "11.1": "87",
    "11.2": "87",
    "11.3": "87",
    "11.4": "87",
    "12.0": "89",
    "13.0": "91",
    "13.1": "91",
    "14.0": "92"
  };

  function BrowserslistError(message) {
    this.name = 'BrowserslistError';
    this.message = message;
    this.browserslist = true;

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, BrowserslistError);
    }
  }

  BrowserslistError.prototype = Error.prototype;
  var error = BrowserslistError;

  function noop() {}

  var browser$2 = {
    loadQueries: function loadQueries() {
      throw new error('Sharable configs are not supported in client-side build of Browserslist');
    },
    getStat: function getStat(opts) {
      return opts.stats;
    },
    loadConfig: function loadConfig(opts) {
      if (opts.config) {
        throw new error('Browserslist config are not supported in client-side build');
      }
    },
    loadCountry: function loadCountry() {
      throw new error('Country statistics are not supported ' + 'in client-side build of Browserslist');
    },
    loadFeature: function loadFeature() {
      throw new error('Supports queries are not available in client-side build of Browserslist');
    },
    currentNode: function currentNode(resolve, context) {
      return resolve(['maintained node versions'], context)[0];
    },
    parseConfig: noop,
    readConfig: noop,
    findConfig: noop,
    clearCaches: noop,
    oldDataWarning: noop
  };

  var fs$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  var agents = agents$1.agents;
  var YEAR = 365.259641 * 24 * 60 * 60 * 1000;
  var ANDROID_EVERGREEN_FIRST = 37;
  var QUERY_OR = 1;
  var QUERY_AND = 2;

  function isVersionsMatch(versionA, versionB) {
    return (versionA + '.').indexOf(versionB + '.') === 0;
  }

  function isEolReleased(name) {
    var version = name.slice(1);
    return jsReleases.some(function (i) {
      return isVersionsMatch(i.version, version);
    });
  }

  function normalize(versions) {
    return versions.filter(function (version) {
      return typeof version === 'string';
    });
  }

  function normalizeElectron(version) {
    var versionToUse = version;

    if (version.split('.').length === 3) {
      versionToUse = version.split('.').slice(0, -1).join('.');
    }

    return versionToUse;
  }

  function nameMapper(name) {
    return function mapName(version) {
      return name + ' ' + version;
    };
  }

  function getMajor(version) {
    return parseInt(version.split('.')[0]);
  }

  function getMajorVersions(released, number) {
    if (released.length === 0) return [];
    var majorVersions = uniq(released.map(getMajor));
    var minimum = majorVersions[majorVersions.length - number];

    if (!minimum) {
      return released;
    }

    var selected = [];

    for (var i = released.length - 1; i >= 0; i--) {
      if (minimum > getMajor(released[i])) break;
      selected.unshift(released[i]);
    }

    return selected;
  }

  function uniq(array) {
    var filtered = [];

    for (var i = 0; i < array.length; i++) {
      if (filtered.indexOf(array[i]) === -1) filtered.push(array[i]);
    }

    return filtered;
  }

  function fillUsage(result, name, data) {
    for (var i in data) {
      result[name + ' ' + i] = data[i];
    }
  }

  function generateFilter(sign, version) {
    version = parseFloat(version);

    if (sign === '>') {
      return function (v) {
        return parseFloat(v) > version;
      };
    } else if (sign === '>=') {
      return function (v) {
        return parseFloat(v) >= version;
      };
    } else if (sign === '<') {
      return function (v) {
        return parseFloat(v) < version;
      };
    } else {
      return function (v) {
        return parseFloat(v) <= version;
      };
    }
  }

  function generateSemverFilter(sign, version) {
    version = version.split('.').map(parseSimpleInt);
    version[1] = version[1] || 0;
    version[2] = version[2] || 0;

    if (sign === '>') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) > 0;
      };
    } else if (sign === '>=') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(v, version) >= 0;
      };
    } else if (sign === '<') {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) > 0;
      };
    } else {
      return function (v) {
        v = v.split('.').map(parseSimpleInt);
        return compareSemver(version, v) >= 0;
      };
    }
  }

  function parseSimpleInt(x) {
    return parseInt(x);
  }

  function compare$5(a, b) {
    if (a < b) return -1;
    if (a > b) return +1;
    return 0;
  }

  function compareSemver(a, b) {
    return compare$5(parseInt(a[0]), parseInt(b[0])) || compare$5(parseInt(a[1] || '0'), parseInt(b[1] || '0')) || compare$5(parseInt(a[2] || '0'), parseInt(b[2] || '0'));
  }

  function semverFilterLoose(operator, range) {
    range = range.split('.').map(parseSimpleInt);

    if (typeof range[1] === 'undefined') {
      range[1] = 'x';
    }

    switch (operator) {
      case '<=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) <= 0;
        };

      default:
      case '>=':
        return function (version) {
          version = version.split('.').map(parseSimpleInt);
          return compareSemverLoose(version, range) >= 0;
        };
    }
  }

  function compareSemverLoose(version, range) {
    if (version[0] !== range[0]) {
      return version[0] < range[0] ? -1 : +1;
    }

    if (range[1] === 'x') {
      return 0;
    }

    if (version[1] !== range[1]) {
      return version[1] < range[1] ? -1 : +1;
    }

    return 0;
  }

  function resolveVersion(data, version) {
    if (data.versions.indexOf(version) !== -1) {
      return version;
    } else if (browserslist.versionAliases[data.name][version]) {
      return browserslist.versionAliases[data.name][version];
    } else {
      return false;
    }
  }

  function normalizeVersion(data, version) {
    var resolved = resolveVersion(data, version);

    if (resolved) {
      return resolved;
    } else if (data.versions.length === 1) {
      return data.versions[0];
    } else {
      return false;
    }
  }

  function filterByYear(since, context) {
    since = since / 1000;
    return Object.keys(agents).reduce(function (selected, name) {
      var data = byName(name, context);
      if (!data) return selected;
      var versions = Object.keys(data.releaseDate).filter(function (v) {
        return data.releaseDate[v] >= since;
      });
      return selected.concat(versions.map(nameMapper(data.name)));
    }, []);
  }

  function cloneData(data) {
    return {
      name: data.name,
      versions: data.versions,
      released: data.released,
      releaseDate: data.releaseDate
    };
  }

  function mapVersions(data, map) {
    data.versions = data.versions.map(function (i) {
      return map[i] || i;
    });
    data.released = data.versions.map(function (i) {
      return map[i] || i;
    });
    var fixedDate = {};

    for (var i in data.releaseDate) {
      fixedDate[map[i] || i] = data.releaseDate[i];
    }

    data.releaseDate = fixedDate;
    return data;
  }

  function byName(name, context) {
    name = name.toLowerCase();
    name = browserslist.aliases[name] || name;

    if (context.mobileToDesktop && browserslist.desktopNames[name]) {
      var desktop = browserslist.data[browserslist.desktopNames[name]];

      if (name === 'android') {
        return normalizeAndroidData(cloneData(browserslist.data[name]), desktop);
      } else {
        var cloned = cloneData(desktop);
        cloned.name = name;

        if (name === 'op_mob') {
          cloned = mapVersions(cloned, {
            '10.0-10.1': '10'
          });
        }

        return cloned;
      }
    }

    return browserslist.data[name];
  }

  function normalizeAndroidVersions(androidVersions, chromeVersions) {
    var firstEvergreen = ANDROID_EVERGREEN_FIRST;
    var last = chromeVersions[chromeVersions.length - 1];
    return androidVersions.filter(function (version) {
      return /^(?:[2-4]\.|[34]$)/.test(version);
    }).concat(chromeVersions.slice(firstEvergreen - last - 1));
  }

  function normalizeAndroidData(android, chrome) {
    android.released = normalizeAndroidVersions(android.released, chrome.released);
    android.versions = normalizeAndroidVersions(android.versions, chrome.versions);
    return android;
  }

  function checkName(name, context) {
    var data = byName(name, context);
    if (!data) throw new error('Unknown browser ' + name);
    return data;
  }

  function unknownQuery(query) {
    return new error('Unknown browser query `' + query + '`. ' + 'Maybe you are using old Browserslist or made typo in query.');
  }

  function filterAndroid(list, versions, context) {
    if (context.mobileToDesktop) return list;
    var released = browserslist.data.android.released;
    var last = released[released.length - 1];
    var diff = last - ANDROID_EVERGREEN_FIRST - versions;

    if (diff > 0) {
      return list.slice(-1);
    } else {
      return list.slice(diff - 1);
    }
  }

  function resolve$2(queries, context) {
    if (Array.isArray(queries)) {
      queries = flatten$1(queries.map(parse$6));
    } else {
      queries = parse$6(queries);
    }

    return queries.reduce(function (result, query, index) {
      var selection = query.queryString;
      var isExclude = selection.indexOf('not ') === 0;

      if (isExclude) {
        if (index === 0) {
          throw new error('Write any browsers query (for instance, `defaults`) ' + 'before `' + selection + '`');
        }

        selection = selection.slice(4);
      }

      for (var i = 0; i < QUERIES.length; i++) {
        var type = QUERIES[i];
        var match = selection.match(type.regexp);

        if (match) {
          var args = [context].concat(match.slice(1));
          var array = type.select.apply(browserslist, args).map(function (j) {
            var parts = j.split(' ');

            if (parts[1] === '0') {
              return parts[0] + ' ' + byName(parts[0], context).versions[0];
            } else {
              return j;
            }
          });

          switch (query.type) {
            case QUERY_AND:
              if (isExclude) {
                return result.filter(function (j) {
                  return array.indexOf(j) === -1;
                });
              } else {
                return result.filter(function (j) {
                  return array.indexOf(j) !== -1;
                });
              }

            case QUERY_OR:
            default:
              if (isExclude) {
                var filter = {};
                array.forEach(function (j) {
                  filter[j] = true;
                });
                return result.filter(function (j) {
                  return !filter[j];
                });
              }

              return result.concat(array);
          }
        }
      }

      throw unknownQuery(selection);
    }, []);
  }

  var cache$2 = {};

  function browserslist(queries, opts) {
    if (typeof opts === 'undefined') opts = {};

    if (typeof opts.path === 'undefined') {
      opts.path = fs$1.resolve ? fs$1.resolve('.') : '.';
    }

    if (typeof queries === 'undefined' || queries === null) {
      var config = browserslist.loadConfig(opts);

      if (config) {
        queries = config;
      } else {
        queries = browserslist.defaults;
      }
    }

    if (!(typeof queries === 'string' || Array.isArray(queries))) {
      throw new error('Browser queries must be an array or string. Got ' + typeof queries + '.');
    }

    var context = {
      ignoreUnknownVersions: opts.ignoreUnknownVersions,
      dangerousExtend: opts.dangerousExtend,
      mobileToDesktop: opts.mobileToDesktop,
      path: opts.path,
      env: opts.env
    };
    browser$2.oldDataWarning(browserslist.data);
    var stats = browser$2.getStat(opts, browserslist.data);

    if (stats) {
      context.customUsage = {};

      for (var browser in stats) {
        fillUsage(context.customUsage, browser, stats[browser]);
      }
    }

    var cacheKey = JSON.stringify([queries, context]);
    if (cache$2[cacheKey]) return cache$2[cacheKey];
    var result = uniq(resolve$2(queries, context)).sort(function (name1, name2) {
      name1 = name1.split(' ');
      name2 = name2.split(' ');

      if (name1[0] === name2[0]) {
        var version1 = name1[1].split('-')[0];
        var version2 = name2[1].split('-')[0];
        return compareSemver(version2.split('.'), version1.split('.'));
      } else {
        return compare$5(name1[0], name2[0]);
      }
    });

    if (!browser$6.env.BROWSERSLIST_DISABLE_CACHE) {
      cache$2[cacheKey] = result;
    }

    return result;
  }

  function parse$6(queries) {
    var qs = [];

    do {
      queries = doMatch(queries, qs);
    } while (queries);

    return qs;
  }

  function doMatch(string, qs) {
    var or = /^(?:,\s*|\s+or\s+)(.*)/i;
    var and = /^\s+and\s+(.*)/i;
    return find(string, function (parsed, n, max) {
      if (and.test(parsed)) {
        qs.unshift({
          type: QUERY_AND,
          queryString: parsed.match(and)[1]
        });
        return true;
      } else if (or.test(parsed)) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.match(or)[1]
        });
        return true;
      } else if (n === max) {
        qs.unshift({
          type: QUERY_OR,
          queryString: parsed.trim()
        });
        return true;
      }

      return false;
    });
  }

  function find(string, predicate) {
    for (var n = 1, max = string.length; n <= max; n++) {
      var parsed = string.substr(-n, n);

      if (predicate(parsed, n, max)) {
        return string.slice(0, -n);
      }
    }

    return '';
  }

  function flatten$1(array) {
    if (!Array.isArray(array)) return [array];
    return array.reduce(function (a, b) {
      return a.concat(flatten$1(b));
    }, []);
  }

  browserslist.cache = {};
  browserslist.data = {};
  browserslist.usage = {
    global: {},
    custom: null
  };
  browserslist.defaults = ['> 0.5%', 'last 2 versions', 'Firefox ESR', 'not dead'];
  browserslist.aliases = {
    fx: 'firefox',
    ff: 'firefox',
    ios: 'ios_saf',
    explorer: 'ie',
    blackberry: 'bb',
    explorermobile: 'ie_mob',
    operamini: 'op_mini',
    operamobile: 'op_mob',
    chromeandroid: 'and_chr',
    firefoxandroid: 'and_ff',
    ucandroid: 'and_uc',
    qqandroid: 'and_qq'
  };
  browserslist.desktopNames = {
    and_chr: 'chrome',
    and_ff: 'firefox',
    ie_mob: 'ie',
    op_mob: 'opera',
    android: 'chrome'
  };
  browserslist.versionAliases = {};
  browserslist.clearCaches = browser$2.clearCaches;
  browserslist.parseConfig = browser$2.parseConfig;
  browserslist.readConfig = browser$2.readConfig;
  browserslist.findConfig = browser$2.findConfig;
  browserslist.loadConfig = browser$2.loadConfig;

  browserslist.coverage = function (browsers, stats) {
    var data;

    if (typeof stats === 'undefined') {
      data = browserslist.usage.global;
    } else if (stats === 'my stats') {
      var opts = {};
      opts.path = fs$1.resolve ? fs$1.resolve('.') : '.';
      var customStats = browser$2.getStat(opts);

      if (!customStats) {
        throw new error('Custom usage statistics was not provided');
      }

      data = {};

      for (var browser in customStats) {
        fillUsage(data, browser, customStats[browser]);
      }
    } else if (typeof stats === 'string') {
      if (stats.length > 2) {
        stats = stats.toLowerCase();
      } else {
        stats = stats.toUpperCase();
      }

      browser$2.loadCountry(browserslist.usage, stats, browserslist.data);
      data = browserslist.usage[stats];
    } else {
      if ('dataByBrowser' in stats) {
        stats = stats.dataByBrowser;
      }

      data = {};

      for (var name in stats) {
        for (var version in stats[name]) {
          data[name + ' ' + version] = stats[name][version];
        }
      }
    }

    return browsers.reduce(function (all, i) {
      var usage = data[i];

      if (usage === undefined) {
        usage = data[i.replace(/ \S+$/, ' 0')];
      }

      return all + (usage || 0);
    }, 0);
  };

  function nodeQuery(context, version) {
    var nodeReleases = jsReleases.filter(function (i) {
      return i.name === 'nodejs';
    });
    var matched = nodeReleases.filter(function (i) {
      return isVersionsMatch(i.version, version);
    });

    if (matched.length === 0) {
      if (context.ignoreUnknownVersions) {
        return [];
      } else {
        throw new error('Unknown version ' + version + ' of Node.js');
      }
    }

    return ['node ' + matched[matched.length - 1].version];
  }

  function sinceQuery(context, year, month, date) {
    year = parseInt(year);
    month = parseInt(month || '01') - 1;
    date = parseInt(date || '01');
    return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context);
  }

  function coverQuery(context, coverage, statMode) {
    coverage = parseFloat(coverage);
    var usage = browserslist.usage.global;

    if (statMode) {
      if (statMode.match(/^my\s+stats$/)) {
        if (!context.customUsage) {
          throw new error('Custom usage statistics was not provided');
        }

        usage = context.customUsage;
      } else {
        var place;

        if (statMode.length === 2) {
          place = statMode.toUpperCase();
        } else {
          place = statMode.toLowerCase();
        }

        browser$2.loadCountry(browserslist.usage, place, browserslist.data);
        usage = browserslist.usage[place];
      }
    }

    var versions = Object.keys(usage).sort(function (a, b) {
      return usage[b] - usage[a];
    });
    var coveraged = 0;
    var result = [];
    var version;

    for (var i = 0; i <= versions.length; i++) {
      version = versions[i];
      if (usage[version] === 0) break;
      coveraged += usage[version];
      result.push(version);
      if (coveraged >= coverage) break;
    }

    return result;
  }

  var QUERIES = [{
    regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = getMajorVersions(data.released, versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+versions?$/i,
    select: function select(context, versions) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.released.slice(-versions);
        list = list.map(nameMapper(data.name));

        if (data.name === 'android') {
          list = filterAndroid(list, versions, context);
        }

        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
    select: function select(context, versions$1) {
      var validVersions = getMajorVersions(Object.keys(versions), versions$1);
      return validVersions.map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var validVersions = getMajorVersions(data.released, versions);
      var list = validVersions.map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
    select: function select(context, versions$1) {
      return Object.keys(versions).slice(-versions$1).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
    select: function select(context, versions, name) {
      var data = checkName(name, context);
      var list = data.released.slice(-versions).map(nameMapper(data.name));

      if (data.name === 'android') {
        list = filterAndroid(list, versions, context);
      }

      return list;
    }
  }, {
    regexp: /^unreleased\s+versions$/i,
    select: function select(context) {
      return Object.keys(agents).reduce(function (selected, name) {
        var data = byName(name, context);
        if (!data) return selected;
        var list = data.versions.filter(function (v) {
          return data.released.indexOf(v) === -1;
        });
        list = list.map(nameMapper(data.name));
        return selected.concat(list);
      }, []);
    }
  }, {
    regexp: /^unreleased\s+electron\s+versions?$/i,
    select: function select() {
      return [];
    }
  }, {
    regexp: /^unreleased\s+(\w+)\s+versions?$/i,
    select: function select(context, name) {
      var data = checkName(name, context);
      return data.versions.filter(function (v) {
        return data.released.indexOf(v) === -1;
      }).map(nameMapper(data.name));
    }
  }, {
    regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
    select: function select(context, years) {
      return filterByYear(Date.now() - YEAR * years, context);
    }
  }, {
    regexp: /^since (\d+)$/i,
    select: sinceQuery
  }, {
    regexp: /^since (\d+)-(\d+)$/i,
    select: sinceQuery
  }, {
    regexp: /^since (\d+)-(\d+)-(\d+)$/i,
    select: sinceQuery
  }, {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);
      var usage = browserslist.usage.global;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
    select: function select(context, sign, popularity) {
      popularity = parseFloat(popularity);

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
    select: function select(context, sign, popularity, name) {
      popularity = parseFloat(popularity);
      var stats = browser$2.loadStat(context, name, browserslist.data);

      if (stats) {
        context.customUsage = {};

        for (var browser in stats) {
          fillUsage(context.customUsage, browser, stats[browser]);
        }
      }

      if (!context.customUsage) {
        throw new error('Custom usage statistics was not provided');
      }

      var usage = context.customUsage;
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
    select: function select(context, sign, popularity, place) {
      popularity = parseFloat(popularity);

      if (place.length === 2) {
        place = place.toUpperCase();
      } else {
        place = place.toLowerCase();
      }

      browser$2.loadCountry(browserslist.usage, place, browserslist.data);
      var usage = browserslist.usage[place];
      return Object.keys(usage).reduce(function (result, version) {
        if (sign === '>') {
          if (usage[version] > popularity) {
            result.push(version);
          }
        } else if (sign === '<') {
          if (usage[version] < popularity) {
            result.push(version);
          }
        } else if (sign === '<=') {
          if (usage[version] <= popularity) {
            result.push(version);
          }
        } else if (usage[version] >= popularity) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/,
    select: coverQuery
  }, {
    regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/,
    select: coverQuery
  }, {
    regexp: /^supports\s+([\w-]+)$/,
    select: function select(context, feature) {
      browser$2.loadFeature(browserslist.cache, feature);
      var features = browserslist.cache[feature];
      return Object.keys(features).reduce(function (result, version) {
        var flags = features[version];

        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {
          result.push(version);
        }

        return result;
      }, []);
    }
  }, {
    regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var fromToUse = normalizeElectron(from);
      var toToUse = normalizeElectron(to);

      if (!versions[fromToUse]) {
        throw new error('Unknown version ' + from + ' of electron');
      }

      if (!versions[toToUse]) {
        throw new error('Unknown version ' + to + ' of electron');
      }

      from = parseFloat(from);
      to = parseFloat(to);
      return Object.keys(versions).filter(function (i) {
        var parsed = parseFloat(i);
        return parsed >= from && parsed <= to;
      }).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, from, to) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      return nodeVersions.filter(semverFilterLoose('>=', from)).filter(semverFilterLoose('<=', to)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
    select: function select(context, name, from, to) {
      var data = checkName(name, context);
      from = parseFloat(normalizeVersion(data, from) || from);
      to = parseFloat(normalizeVersion(data, to) || to);

      function filter(v) {
        var parsed = parseFloat(v);
        return parsed >= from && parsed <= to;
      }

      return data.released.filter(filter).map(nameMapper(data.name));
    }
  }, {
    regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var versionToUse = normalizeElectron(version);
      return Object.keys(versions).filter(generateFilter(sign, versionToUse)).map(function (i) {
        return 'chrome ' + versions[i];
      });
    }
  }, {
    regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
    select: function select(context, sign, version) {
      var nodeVersions = jsReleases.filter(function (i) {
        return i.name === 'nodejs';
      }).map(function (i) {
        return i.version;
      });
      return nodeVersions.filter(generateSemverFilter(sign, version)).map(function (v) {
        return 'node ' + v;
      });
    }
  }, {
    regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
    select: function select(context, name, sign, version) {
      var data = checkName(name, context);
      var alias = browserslist.versionAliases[data.name][version];

      if (alias) {
        version = alias;
      }

      return data.released.filter(generateFilter(sign, version)).map(function (v) {
        return data.name + ' ' + v;
      });
    }
  }, {
    regexp: /^(firefox|ff|fx)\s+esr$/i,
    select: function select() {
      return ['firefox 78'];
    }
  }, {
    regexp: /(operamini|op_mini)\s+all/i,
    select: function select() {
      return ['op_mini all'];
    }
  }, {
    regexp: /^electron\s+([\d.]+)$/i,
    select: function select(context, version) {
      var versionToUse = normalizeElectron(version);
      var chrome = versions[versionToUse];

      if (!chrome) {
        throw new error('Unknown version ' + version + ' of electron');
      }

      return ['chrome ' + chrome];
    }
  }, {
    regexp: /^node\s+(\d+)$/i,
    select: nodeQuery
  }, {
    regexp: /^node\s+(\d+\.\d+)$/i,
    select: nodeQuery
  }, {
    regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
    select: nodeQuery
  }, {
    regexp: /^current\s+node$/i,
    select: function select(context) {
      return [browser$2.currentNode(resolve$2, context)];
    }
  }, {
    regexp: /^maintained\s+node\s+versions$/i,
    select: function select(context) {
      var now = Date.now();
      var queries = Object.keys(jsEOL).filter(function (key) {
        return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
      }).map(function (key) {
        return 'node ' + key.slice(1);
      });
      return resolve$2(queries, context);
    }
  }, {
    regexp: /^phantomjs\s+1.9$/i,
    select: function select() {
      return ['safari 5'];
    }
  }, {
    regexp: /^phantomjs\s+2.1$/i,
    select: function select() {
      return ['safari 6'];
    }
  }, {
    regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
    select: function select(context, name, version) {
      if (/^tp$/i.test(version)) version = 'TP';
      var data = checkName(name, context);
      var alias = normalizeVersion(data, version);

      if (alias) {
        version = alias;
      } else {
        if (version.indexOf('.') === -1) {
          alias = version + '.0';
        } else {
          alias = version.replace(/\.0$/, '');
        }

        alias = normalizeVersion(data, alias);

        if (alias) {
          version = alias;
        } else if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new error('Unknown version ' + version + ' of ' + name);
        }
      }

      return [data.name + ' ' + version];
    }
  }, {
    regexp: /^browserslist config$/i,
    select: function select(context) {
      return browserslist(undefined, context);
    }
  }, {
    regexp: /^extends (.+)$/i,
    select: function select(context, name) {
      return resolve$2(browser$2.loadQueries(context, name), context);
    }
  }, {
    regexp: /^defaults$/i,
    select: function select(context) {
      return resolve$2(browserslist.defaults, context);
    }
  }, {
    regexp: /^dead$/i,
    select: function select(context) {
      var dead = ['ie <= 10', 'ie_mob <= 11', 'bb <= 10', 'op_mob <= 12.1', 'samsung 4'];
      return resolve$2(dead, context);
    }
  }, {
    regexp: /^(\w+)$/i,
    select: function select(context, name) {
      if (byName(name, context)) {
        throw new error('Specify versions in Browserslist query for browser ' + name);
      } else {
        throw unknownQuery(name);
      }
    }
  }];

  (function () {
    for (var name in agents) {
      var browser = agents[name];
      browserslist.data[name] = {
        name: name,
        versions: normalize(agents[name].versions),
        released: normalize(agents[name].versions.slice(0, -3)),
        releaseDate: agents[name].release_date
      };
      fillUsage(browserslist.usage.global, name, browser.usage_global);
      browserslist.versionAliases[name] = {};

      for (var i = 0; i < browser.versions.length; i++) {
        var full = browser.versions[i];
        if (!full) continue;

        if (full.indexOf('-') !== -1) {
          var interval = full.split('-');

          for (var j = 0; j < interval.length; j++) {
            browserslist.versionAliases[name][interval[j]] = full;
          }
        }
      }
    }

    browserslist.versionAliases.op_mob['59'] = '58';
  })();

  var browserslist_1 = browserslist;

  var min = Math.min;

  function levenshtein(a, b) {
    var t = [],
        u = [],
        i,
        j;
    var m = a.length,
        n = b.length;

    if (!m) {
      return n;
    }

    if (!n) {
      return m;
    }

    for (j = 0; j <= n; j++) {
      t[j] = j;
    }

    for (i = 1; i <= m; i++) {
      for (u = [i], j = 1; j <= n; j++) {
        u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min(t[j - 1], t[j], u[j - 1]) + 1;
      }

      t = u;
    }

    return u[n];
  }

  function findSuggestion(str, arr) {
    var distances = arr.map(function (el) {
      return levenshtein(el, str);
    });
    return arr[distances.indexOf(min.apply(void 0, _toConsumableArray(distances)))];
  }

  var OptionValidator = function () {
    function OptionValidator(descriptor) {
      this.descriptor = descriptor;
    }

    var _proto = OptionValidator.prototype;

    _proto.validateTopLevelOptions = function validateTopLevelOptions(options, TopLevelOptionShape) {
      var validOptionNames = Object.keys(TopLevelOptionShape);

      for (var _i = 0, _Object$keys = Object.keys(options); _i < _Object$keys.length; _i++) {
        var option = _Object$keys[_i];

        if (!validOptionNames.includes(option)) {
          throw new Error(this.formatMessage("'" + option + "' is not a valid top-level option.\n- Did you mean '" + findSuggestion(option, validOptionNames) + "'?"));
        }
      }
    };

    _proto.validateBooleanOption = function validateBooleanOption(name, value, defaultValue) {
      if (value === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value === "boolean", "'" + name + "' option must be a boolean.");
      }

      return value;
    };

    _proto.validateStringOption = function validateStringOption(name, value, defaultValue) {
      if (value === undefined) {
        return defaultValue;
      } else {
        this.invariant(typeof value === "string", "'" + name + "' option must be a string.");
      }

      return value;
    };

    _proto.invariant = function invariant(condition, message) {
      if (!condition) {
        throw new Error(this.formatMessage(message));
      }
    };

    _proto.formatMessage = function formatMessage(message) {
      return this.descriptor + ": " + message;
    };

    return OptionValidator;
  }();

  var require$$0$7 = {
  	"es6.module": {
  	chrome: "61",
  	and_chr: "61",
  	edge: "16",
  	firefox: "60",
  	and_ff: "60",
  	node: "13.2.0",
  	opera: "48",
  	op_mob: "48",
  	safari: "10.1",
  	ios: "10.3",
  	samsung: "8.2",
  	android: "61",
  	electron: "2.0",
  	ios_saf: "10.3"
  }
  };

  var nativeModules = require$$0$7;

  var SEMVER_SPEC_VERSION$2 = '2.0.0';
  var MAX_LENGTH$8 = 256;
  var MAX_SAFE_INTEGER$5 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH$2 = 16;
  var constants$2 = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$2,
    MAX_LENGTH: MAX_LENGTH$8,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$5,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$2
  };

  var debug$4 = typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1$2 = debug$4;

  var re_1$2 = createCommonjsModule(function (module, exports) {
    var MAX_SAFE_COMPONENT_LENGTH = constants$2.MAX_SAFE_COMPONENT_LENGTH;
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;

    var createToken = function createToken(name, value, isGlobal) {
      var index = R++;
      debug_1$2(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
    createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
    createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
    createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
    createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
    createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
    createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
    createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
    createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
    createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
    createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
    createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
    createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
    createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
    createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
    createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
    createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
    createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
    createToken('STAR', '(<|>)?=?\\s*\\*');
    createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
  }, "/$$rollup_base$$/packages/babel-helper-compilation-targets/node_modules/semver/node_modules/semver-BABEL_8_BREAKING-true/internal");

  var opts$1 = ['includePrerelease', 'loose', 'rtl'];

  var parseOptions$1 = function parseOptions(options) {
    return !options ? {} : typeof options !== 'object' ? {
      loose: true
    } : opts$1.filter(function (k) {
      return options[k];
    }).reduce(function (options, k) {
      options[k] = true;
      return options;
    }, {});
  };

  var parseOptions_1$1 = parseOptions$1;

  var numeric$2 = /^[0-9]+$/;

  var compareIdentifiers$5 = function compareIdentifiers(a, b) {
    var anum = numeric$2.test(a);
    var bnum = numeric$2.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers$2 = function rcompareIdentifiers(a, b) {
    return compareIdentifiers$5(b, a);
  };

  var identifiers$2 = {
    compareIdentifiers: compareIdentifiers$5,
    rcompareIdentifiers: rcompareIdentifiers$2
  };

  var MAX_LENGTH$7 = constants$2.MAX_LENGTH,
      MAX_SAFE_INTEGER$4 = constants$2.MAX_SAFE_INTEGER;
  var re$c = re_1$2.re,
      t$j = re_1$2.t;
  var compareIdentifiers$4 = identifiers$2.compareIdentifiers;

  var SemVer$2 = function () {
    function SemVer(version, options) {
      options = parseOptions_1$1(options);

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$7) {
        throw new TypeError("version is longer than " + MAX_LENGTH$7 + " characters");
      }

      debug_1$2('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re$c[t$j.LOOSE] : re$c[t$j.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER$4 || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER$4 || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER$4 || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER$4) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1$2('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers$4(this.major, other.major) || compareIdentifiers$4(this.minor, other.minor) || compareIdentifiers$4(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1$2('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$4(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1$2('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$4(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$9 = SemVer$2;

  var MAX_LENGTH$6 = constants$2.MAX_LENGTH;
  var re$b = re_1$2.re,
      t$i = re_1$2.t;

  var parse$5 = function parse(version, options) {
    options = parseOptions_1$1(options);

    if (version instanceof semver$9) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH$6) {
      return null;
    }

    var r = options.loose ? re$b[t$i.LOOSE] : re$b[t$i.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$9(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1$2 = parse$5;

  var valid$3 = function valid(version, options) {
    var v = parse_1$2(version, options);
    return v ? v.version : null;
  };

  var valid_1$1 = valid$3;

  var clean$1 = function clean(version, options) {
    var s = parse_1$2(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  };

  var clean_1$1 = clean$1;

  var inc$1 = function inc(version, release, options, identifier) {
    if (typeof options === 'string') {
      identifier = options;
      options = undefined;
    }

    try {
      return new semver$9(version, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };

  var inc_1$1 = inc$1;

  var compare$4 = function compare(a, b, loose) {
    return new semver$9(a, loose).compare(new semver$9(b, loose));
  };

  var compare_1$2 = compare$4;

  var eq$2 = function eq(a, b, loose) {
    return compare_1$2(a, b, loose) === 0;
  };

  var eq_1$2 = eq$2;

  var diff$1 = function diff(version1, version2) {
    if (eq_1$2(version1, version2)) {
      return null;
    } else {
      var v1 = parse_1$2(version1);
      var v2 = parse_1$2(version2);
      var hasPre = v1.prerelease.length || v2.prerelease.length;
      var prefix = hasPre ? 'pre' : '';
      var defaultResult = hasPre ? 'prerelease' : '';

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  };

  var diff_1$1 = diff$1;

  var major$1 = function major(a, loose) {
    return new semver$9(a, loose).major;
  };

  var major_1$1 = major$1;

  var minor$1 = function minor(a, loose) {
    return new semver$9(a, loose).minor;
  };

  var minor_1$1 = minor$1;

  var patch$1 = function patch(a, loose) {
    return new semver$9(a, loose).patch;
  };

  var patch_1$1 = patch$1;

  var prerelease$1 = function prerelease(version, options) {
    var parsed = parse_1$2(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };

  var prerelease_1$1 = prerelease$1;

  var rcompare$1 = function rcompare(a, b, loose) {
    return compare_1$2(b, a, loose);
  };

  var rcompare_1$1 = rcompare$1;

  var compareLoose$1 = function compareLoose(a, b) {
    return compare_1$2(a, b, true);
  };

  var compareLoose_1$1 = compareLoose$1;

  var compareBuild$1 = function compareBuild(a, b, loose) {
    var versionA = new semver$9(a, loose);
    var versionB = new semver$9(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };

  var compareBuild_1$1 = compareBuild$1;

  var sort$1 = function sort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1$1(a, b, loose);
    });
  };

  var sort_1$1 = sort$1;

  var rsort$1 = function rsort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1$1(b, a, loose);
    });
  };

  var rsort_1$1 = rsort$1;

  var gt$2 = function gt(a, b, loose) {
    return compare_1$2(a, b, loose) > 0;
  };

  var gt_1$2 = gt$2;

  var lt$2 = function lt(a, b, loose) {
    return compare_1$2(a, b, loose) < 0;
  };

  var lt_1$2 = lt$2;

  var neq$2 = function neq(a, b, loose) {
    return compare_1$2(a, b, loose) !== 0;
  };

  var neq_1$2 = neq$2;

  var gte$2 = function gte(a, b, loose) {
    return compare_1$2(a, b, loose) >= 0;
  };

  var gte_1$2 = gte$2;

  var lte$2 = function lte(a, b, loose) {
    return compare_1$2(a, b, loose) <= 0;
  };

  var lte_1$2 = lte$2;

  var cmp$2 = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1$2(a, b, loose);

      case '!=':
        return neq_1$2(a, b, loose);

      case '>':
        return gt_1$2(a, b, loose);

      case '>=':
        return gte_1$2(a, b, loose);

      case '<':
        return lt_1$2(a, b, loose);

      case '<=':
        return lte_1$2(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1$2 = cmp$2;

  var re$a = re_1$2.re,
      t$h = re_1$2.t;

  var coerce$2 = function coerce(version, options) {
    if (version instanceof semver$9) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re$a[t$h.COERCE]);
    } else {
      var next;

      while ((next = re$a[t$h.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re$a[t$h.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re$a[t$h.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1$2(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1$2 = coerce$2;

  var iterator$1 = function iterator(Yallist) {
    Yallist.prototype[Symbol.iterator] = regenerator.mark(function _callee() {
      var walker;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              walker = this.head;

            case 1:
              if (!walker) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return walker.value;

            case 4:
              walker = walker.next;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    });
  };

  var yallist$1 = Yallist$1;
  Yallist$1.Node = Node$1;
  Yallist$1.create = Yallist$1;

  function Yallist$1(list) {
    var self = this;

    if (!(self instanceof Yallist$1)) {
      self = new Yallist$1();
    }

    self.tail = null;
    self.head = null;
    self.length = 0;

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }

    return self;
  }

  Yallist$1.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }

    var next = node.next;
    var prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };

  Yallist$1.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var head = this.head;
    node.list = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length++;
  };

  Yallist$1.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var tail = this.tail;
    node.list = this;
    node.prev = tail;

    if (tail) {
      tail.next = node;
    }

    this.tail = node;

    if (!this.head) {
      this.head = node;
    }

    this.length++;
  };

  Yallist$1.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push$2(this, arguments[i]);
    }

    return this.length;
  };

  Yallist$1.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift$1(this, arguments[i]);
    }

    return this.length;
  };

  Yallist$1.prototype.pop = function () {
    if (!this.tail) {
      return undefined;
    }

    var res = this.tail.value;
    this.tail = this.tail.prev;

    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }

    this.length--;
    return res;
  };

  Yallist$1.prototype.shift = function () {
    if (!this.head) {
      return undefined;
    }

    var res = this.head.value;
    this.head = this.head.next;

    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }

    this.length--;
    return res;
  };

  Yallist$1.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };

  Yallist$1.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };

  Yallist$1.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist$1.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist$1.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();

    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }

    return res;
  };

  Yallist$1.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist$1();

    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }

    return res;
  };

  Yallist$1.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }

    return acc;
  };

  Yallist$1.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }

    return acc;
  };

  Yallist$1.prototype.toArray = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }

    return arr;
  };

  Yallist$1.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }

    return arr;
  };

  Yallist$1.prototype.slice = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist$1();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }

    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist$1.prototype.sliceReverse = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist$1();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }

    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist$1.prototype.splice = function (start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }

    if (start < 0) {
      start = this.length + start;
    }

    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }

    var ret = [];

    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }

    if (walker === null) {
      walker = this.tail;
    }

    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }

    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      walker = insert$1(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
    }

    return ret;
  };

  Yallist$1.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;

    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }

    this.head = tail;
    this.tail = head;
    return this;
  };

  function insert$1(self, node, value) {
    var inserted = node === self.head ? new Node$1(value, null, node, self) : new Node$1(value, node, node.next, self);

    if (inserted.next === null) {
      self.tail = inserted;
    }

    if (inserted.prev === null) {
      self.head = inserted;
    }

    self.length++;
    return inserted;
  }

  function push$2(self, item) {
    self.tail = new Node$1(item, self.tail, null, self);

    if (!self.head) {
      self.head = self.tail;
    }

    self.length++;
  }

  function unshift$1(self, item) {
    self.head = new Node$1(item, null, self.head, self);

    if (!self.tail) {
      self.tail = self.head;
    }

    self.length++;
  }

  function Node$1(value, prev, next, list) {
    if (!(this instanceof Node$1)) {
      return new Node$1(value, prev, next, list);
    }

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

  try {
    iterator$1(Yallist$1);
  } catch (er) {}

  var MAX$1 = Symbol('max');
  var LENGTH$1 = Symbol('length');
  var LENGTH_CALCULATOR$1 = Symbol('lengthCalculator');
  var ALLOW_STALE$1 = Symbol('allowStale');
  var MAX_AGE$1 = Symbol('maxAge');
  var DISPOSE$1 = Symbol('dispose');
  var NO_DISPOSE_ON_SET$1 = Symbol('noDisposeOnSet');
  var LRU_LIST$1 = Symbol('lruList');
  var CACHE$1 = Symbol('cache');
  var UPDATE_AGE_ON_GET$1 = Symbol('updateAgeOnGet');

  var naiveLength$1 = function naiveLength() {
    return 1;
  };

  var LRUCache$1 = function () {
    function LRUCache(options) {
      if (typeof options === 'number') options = {
        max: options
      };
      if (!options) options = {};
      if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
      this[MAX$1] = options.max || Infinity;
      var lc = options.length || naiveLength$1;
      this[LENGTH_CALCULATOR$1] = typeof lc !== 'function' ? naiveLength$1 : lc;
      this[ALLOW_STALE$1] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
      this[MAX_AGE$1] = options.maxAge || 0;
      this[DISPOSE$1] = options.dispose;
      this[NO_DISPOSE_ON_SET$1] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET$1] = options.updateAgeOnGet || false;
      this.reset();
    }

    var _proto = LRUCache.prototype;

    _proto.rforEach = function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST$1].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep$1(this, fn, walker, thisp);
        walker = prev;
      }
    };

    _proto.forEach = function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST$1].head; walker !== null;) {
        var next = walker.next;
        forEachStep$1(this, fn, walker, thisp);
        walker = next;
      }
    };

    _proto.keys = function keys() {
      return this[LRU_LIST$1].toArray().map(function (k) {
        return k.key;
      });
    };

    _proto.values = function values() {
      return this[LRU_LIST$1].toArray().map(function (k) {
        return k.value;
      });
    };

    _proto.reset = function reset() {
      var _this = this;

      if (this[DISPOSE$1] && this[LRU_LIST$1] && this[LRU_LIST$1].length) {
        this[LRU_LIST$1].forEach(function (hit) {
          return _this[DISPOSE$1](hit.key, hit.value);
        });
      }

      this[CACHE$1] = new Map();
      this[LRU_LIST$1] = new yallist$1();
      this[LENGTH$1] = 0;
    };

    _proto.dump = function dump() {
      var _this2 = this;

      return this[LRU_LIST$1].map(function (hit) {
        return isStale$1(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    };

    _proto.dumpLru = function dumpLru() {
      return this[LRU_LIST$1];
    };

    _proto.set = function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE$1];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR$1](value, key);

      if (this[CACHE$1].has(key)) {
        if (len > this[MAX$1]) {
          _del$1(this, this[CACHE$1].get(key));

          return false;
        }

        var node = this[CACHE$1].get(key);
        var item = node.value;

        if (this[DISPOSE$1]) {
          if (!this[NO_DISPOSE_ON_SET$1]) this[DISPOSE$1](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH$1] += len - item.length;
        item.length = len;
        this.get(key);
        trim$1(this);
        return true;
      }

      var hit = new Entry$2(key, value, len, now, maxAge);

      if (hit.length > this[MAX$1]) {
        if (this[DISPOSE$1]) this[DISPOSE$1](key, value);
        return false;
      }

      this[LENGTH$1] += hit.length;
      this[LRU_LIST$1].unshift(hit);
      this[CACHE$1].set(key, this[LRU_LIST$1].head);
      trim$1(this);
      return true;
    };

    _proto.has = function has(key) {
      if (!this[CACHE$1].has(key)) return false;
      var hit = this[CACHE$1].get(key).value;
      return !isStale$1(this, hit);
    };

    _proto.get = function get(key) {
      return _get$1(this, key, true);
    };

    _proto.peek = function peek(key) {
      return _get$1(this, key, false);
    };

    _proto.pop = function pop() {
      var node = this[LRU_LIST$1].tail;
      if (!node) return null;

      _del$1(this, node);

      return node.value;
    };

    _proto.del = function del(key) {
      _del$1(this, this[CACHE$1].get(key));
    };

    _proto.load = function load(arr) {
      this.reset();
      var now = Date.now();

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now;

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };

    _proto.prune = function prune() {
      var _this3 = this;

      this[CACHE$1].forEach(function (value, key) {
        return _get$1(_this3, key, false);
      });
    };

    _createClass(LRUCache, [{
      key: "max",
      get: function get() {
        return this[MAX$1];
      },
      set: function set(mL) {
        if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
        this[MAX$1] = mL || Infinity;
        trim$1(this);
      }
    }, {
      key: "allowStale",
      get: function get() {
        return this[ALLOW_STALE$1];
      },
      set: function set(allowStale) {
        this[ALLOW_STALE$1] = !!allowStale;
      }
    }, {
      key: "maxAge",
      get: function get() {
        return this[MAX_AGE$1];
      },
      set: function set(mA) {
        if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
        this[MAX_AGE$1] = mA;
        trim$1(this);
      }
    }, {
      key: "lengthCalculator",
      get: function get() {
        return this[LENGTH_CALCULATOR$1];
      },
      set: function set(lC) {
        var _this4 = this;

        if (typeof lC !== 'function') lC = naiveLength$1;

        if (lC !== this[LENGTH_CALCULATOR$1]) {
          this[LENGTH_CALCULATOR$1] = lC;
          this[LENGTH$1] = 0;
          this[LRU_LIST$1].forEach(function (hit) {
            hit.length = _this4[LENGTH_CALCULATOR$1](hit.value, hit.key);
            _this4[LENGTH$1] += hit.length;
          });
        }

        trim$1(this);
      }
    }, {
      key: "length",
      get: function get() {
        return this[LENGTH$1];
      }
    }, {
      key: "itemCount",
      get: function get() {
        return this[LRU_LIST$1].length;
      }
    }]);

    return LRUCache;
  }();

  var _get$1 = function _get(self, key, doUse) {
    var node = self[CACHE$1].get(key);

    if (node) {
      var hit = node.value;

      if (isStale$1(self, hit)) {
        _del$1(self, node);

        if (!self[ALLOW_STALE$1]) return undefined;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET$1]) node.value.now = Date.now();
          self[LRU_LIST$1].unshiftNode(node);
        }
      }

      return hit.value;
    }
  };

  var isStale$1 = function isStale(self, hit) {
    if (!hit || !hit.maxAge && !self[MAX_AGE$1]) return false;
    var diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE$1] && diff > self[MAX_AGE$1];
  };

  var trim$1 = function trim(self) {
    if (self[LENGTH$1] > self[MAX$1]) {
      for (var walker = self[LRU_LIST$1].tail; self[LENGTH$1] > self[MAX$1] && walker !== null;) {
        var prev = walker.prev;

        _del$1(self, walker);

        walker = prev;
      }
    }
  };

  var _del$1 = function _del(self, node) {
    if (node) {
      var hit = node.value;
      if (self[DISPOSE$1]) self[DISPOSE$1](hit.key, hit.value);
      self[LENGTH$1] -= hit.length;
      self[CACHE$1]["delete"](hit.key);
      self[LRU_LIST$1].removeNode(node);
    }
  };

  var Entry$2 = function Entry(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  };

  var forEachStep$1 = function forEachStep(self, fn, node, thisp) {
    var hit = node.value;

    if (isStale$1(self, hit)) {
      _del$1(self, node);

      if (!self[ALLOW_STALE$1]) hit = undefined;
    }

    if (hit) fn.call(thisp, hit.value, hit.key, self);
  };

  var lruCache$1 = LRUCache$1;

  var Range$1 = function () {
    function Range(range, options) {
      var _this = this;

      options = parseOptions_1$1(options);

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof comparator$1) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return _this.parseRange(range.trim());
      }).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }

      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter(function (c) {
          return !isNullSet$1(c[0]);
        });
        if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
          for (var _iterator = _createForOfIteratorHelperLoose(this.set), _step; !(_step = _iterator()).done;) {
            var c = _step.value;

            if (c.length === 1 && isAny$1(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }

      this.format();
    }

    var _proto = Range.prototype;

    _proto.format = function format() {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    _proto.toString = function toString() {
      return this.range;
    };

    _proto.parseRange = function parseRange(range) {
      var _this2 = this;

      range = range.trim();
      var memoOpts = Object.keys(this.options).join(',');
      var memoKey = "parseRange:" + memoOpts + ":" + range;
      var cached = cache$1.get(memoKey);
      if (cached) return cached;
      var loose = this.options.loose;
      var hr = loose ? re$9[t$g.HYPHENRANGELOOSE] : re$9[t$g.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace$1(this.options.includePrerelease));
      debug_1$2('hyphen replace', range);
      range = range.replace(re$9[t$g.COMPARATORTRIM], comparatorTrimReplace$1);
      debug_1$2('comparator trim', range, re$9[t$g.COMPARATORTRIM]);
      range = range.replace(re$9[t$g.TILDETRIM], tildeTrimReplace$1);
      range = range.replace(re$9[t$g.CARETTRIM], caretTrimReplace$1);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re$9[t$g.COMPARATORLOOSE] : re$9[t$g.COMPARATOR];
      var rangeList = range.split(' ').map(function (comp) {
        return parseComparator$1(comp, _this2.options);
      }).join(' ').split(/\s+/).map(function (comp) {
        return replaceGTE0$1(comp, _this2.options);
      }).filter(this.options.loose ? function (comp) {
        return !!comp.match(compRe);
      } : function () {
        return true;
      }).map(function (comp) {
        return new comparator$1(comp, _this2.options);
      });
      rangeList.length;
      var rangeMap = new Map();

      for (var _iterator2 = _createForOfIteratorHelperLoose(rangeList), _step2; !(_step2 = _iterator2()).done;) {
        var comp = _step2.value;
        if (isNullSet$1(comp)) return [comp];
        rangeMap.set(comp.value, comp);
      }

      if (rangeMap.size > 1 && rangeMap.has('')) rangeMap["delete"]('');

      var result = _toConsumableArray(rangeMap.values());

      cache$1.set(memoKey, result);
      return result;
    };

    _proto.intersects = function intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable$1(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable$1(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    _proto.test = function test(version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$9(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet$1(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    return Range;
  }();

  var range$1 = Range$1;
  var cache$1 = new lruCache$1({
    max: 1000
  });
  var re$9 = re_1$2.re,
      t$g = re_1$2.t,
      comparatorTrimReplace$1 = re_1$2.comparatorTrimReplace,
      tildeTrimReplace$1 = re_1$2.tildeTrimReplace,
      caretTrimReplace$1 = re_1$2.caretTrimReplace;

  var isNullSet$1 = function isNullSet(c) {
    return c.value === '<0.0.0-0';
  };

  var isAny$1 = function isAny(c) {
    return c.value === '';
  };

  var isSatisfiable$1 = function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }

    return result;
  };

  var parseComparator$1 = function parseComparator(comp, options) {
    debug_1$2('comp', comp, options);
    comp = replaceCarets$1(comp, options);
    debug_1$2('caret', comp);
    comp = replaceTildes$1(comp, options);
    debug_1$2('tildes', comp);
    comp = replaceXRanges$1(comp, options);
    debug_1$2('xrange', comp);
    comp = replaceStars$1(comp, options);
    debug_1$2('stars', comp);
    return comp;
  };

  var isX$1 = function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  };

  var replaceTildes$1 = function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde$1(comp, options);
    }).join(' ');
  };

  var replaceTilde$1 = function replaceTilde(comp, options) {
    var r = options.loose ? re$9[t$g.TILDELOOSE] : re$9[t$g.TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$2('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX$1(M)) {
        ret = '';
      } else if (isX$1(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0-0";
      } else if (isX$1(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0-0";
      } else if (pr) {
        debug_1$2('replaceTilde pr', pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$2('tilde return', ret);
      return ret;
    });
  };

  var replaceCarets$1 = function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret$1(comp, options);
    }).join(' ');
  };

  var replaceCaret$1 = function replaceCaret(comp, options) {
    debug_1$2('caret', comp, options);
    var r = options.loose ? re$9[t$g.CARETLOOSE] : re$9[t$g.CARET];
    var z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$2('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX$1(M)) {
        ret = '';
      } else if (isX$1(m)) {
        ret = ">=" + M + ".0.0" + z + " <" + (+M + 1) + ".0.0-0";
      } else if (isX$1(p)) {
        if (M === '0') {
          ret = ">=" + M + "." + m + ".0" + z + " <" + M + "." + (+m + 1) + ".0-0";
        } else {
          ret = ">=" + M + "." + m + ".0" + z + " <" + (+M + 1) + ".0.0-0";
        }
      } else if (pr) {
        debug_1$2('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0-0";
        }
      } else {
        debug_1$2('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0-0";
        }
      }

      debug_1$2('caret return', ret);
      return ret;
    });
  };

  var replaceXRanges$1 = function replaceXRanges(comp, options) {
    debug_1$2('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange$1(comp, options);
    }).join(' ');
  };

  var replaceXRange$1 = function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re$9[t$g.XRANGELOOSE] : re$9[t$g.XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug_1$2('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX$1(M);
      var xm = xM || isX$1(m);
      var xp = xm || isX$1(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      pr = options.includePrerelease ? '-0' : '';

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0-0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        if (gtlt === '<') pr = '-0';
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0-0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$2('xRange return', ret);
      return ret;
    });
  };

  var replaceStars$1 = function replaceStars(comp, options) {
    debug_1$2('replaceStars', comp, options);
    return comp.trim().replace(re$9[t$g.STAR], '');
  };

  var replaceGTE0$1 = function replaceGTE0(comp, options) {
    debug_1$2('replaceGTE0', comp, options);
    return comp.trim().replace(re$9[options.includePrerelease ? t$g.GTE0PRE : t$g.GTE0], '');
  };

  var hyphenReplace$1 = function hyphenReplace(incPr) {
    return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX$1(fM)) {
        from = '';
      } else if (isX$1(fm)) {
        from = ">=" + fM + ".0.0" + (incPr ? '-0' : '');
      } else if (isX$1(fp)) {
        from = ">=" + fM + "." + fm + ".0" + (incPr ? '-0' : '');
      } else if (fpr) {
        from = ">=" + from;
      } else {
        from = ">=" + from + (incPr ? '-0' : '');
      }

      if (isX$1(tM)) {
        to = '';
      } else if (isX$1(tm)) {
        to = "<" + (+tM + 1) + ".0.0-0";
      } else if (isX$1(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0-0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else if (incPr) {
        to = "<" + tM + "." + tm + "." + (+tp + 1) + "-0";
      } else {
        to = "<=" + to;
      }

      return (from + " " + to).trim();
    };
  };

  var testSet$1 = function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set.length; _i++) {
        debug_1$2(set[_i].semver);

        if (set[_i].semver === comparator$1.ANY) {
          continue;
        }

        if (set[_i].semver.prerelease.length > 0) {
          var allowed = set[_i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  };

  var ANY$5 = Symbol('SemVer ANY');

  var Comparator$1 = function () {
    function Comparator(comp, options) {
      options = parseOptions_1$1(options);

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      debug_1$2('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY$5) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug_1$2('comp', this);
    }

    var _proto = Comparator.prototype;

    _proto.parse = function parse(comp) {
      var r = this.options.loose ? re$8[t$f.COMPARATORLOOSE] : re$8[t$f.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY$5;
      } else {
        this.semver = new semver$9(m[2], this.options.loose);
      }
    };

    _proto.toString = function toString() {
      return this.value;
    };

    _proto.test = function test(version) {
      debug_1$2('Comparator.test', version, this.options.loose);

      if (this.semver === ANY$5 || version === ANY$5) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$9(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp_1$2(version, this.operator, this.semver, this.options);
    };

    _proto.intersects = function intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        return new range$1(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        return new range$1(this.value, options).test(comp.semver);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp_1$2(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp_1$2(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    _createClass(Comparator, null, [{
      key: "ANY",
      get: function get() {
        return ANY$5;
      }
    }]);

    return Comparator;
  }();

  var comparator$1 = Comparator$1;
  var re$8 = re_1$2.re,
      t$f = re_1$2.t;

  var satisfies$1 = function satisfies(version, range, options) {
    try {
      range = new range$1(range, options);
    } catch (er) {
      return false;
    }

    return range.test(version);
  };

  var satisfies_1$1 = satisfies$1;

  var toComparators$1 = function toComparators(range, options) {
    return new range$1(range, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  };

  var toComparators_1$1 = toComparators$1;

  var maxSatisfying$1 = function maxSatisfying(versions, range, options) {
    var max = null;
    var maxSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range$1(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new semver$9(max, options);
        }
      }
    });
    return max;
  };

  var maxSatisfying_1$1 = maxSatisfying$1;

  var minSatisfying$1 = function minSatisfying(versions, range, options) {
    var min = null;
    var minSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range$1(range, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new semver$9(min, options);
        }
      }
    });
    return min;
  };

  var minSatisfying_1$1 = minSatisfying$1;

  var minVersion$1 = function minVersion(range, loose) {
    range = new range$1(range, loose);
    var minver = new semver$9('0.0.0');

    if (range.test(minver)) {
      return minver;
    }

    minver = new semver$9('0.0.0-0');

    if (range.test(minver)) {
      return minver;
    }

    minver = null;

    var _loop = function _loop(i) {
      var comparators = range.set[i];
      var setMin = null;
      comparators.forEach(function (comparator) {
        var compver = new semver$9(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!setMin || gt_1$2(compver, setMin)) {
              setMin = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
      if (setMin && (!minver || gt_1$2(minver, setMin))) minver = setMin;
    };

    for (var i = 0; i < range.set.length; ++i) {
      _loop(i);
    }

    if (minver && range.test(minver)) {
      return minver;
    }

    return null;
  };

  var minVersion_1$1 = minVersion$1;

  var validRange$1 = function validRange(range, options) {
    try {
      return new range$1(range, options).range || '*';
    } catch (er) {
      return null;
    }
  };

  var valid$2 = validRange$1;

  var ANY$4 = comparator$1.ANY;

  var outside$1 = function outside(version, range, hilo, options) {
    version = new semver$9(version, options);
    range = new range$1(range, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt_1$2;
        ltefn = lte_1$2;
        ltfn = lt_1$2;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt_1$2;
        ltefn = gte_1$2;
        ltfn = gt_1$2;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies_1$1(version, range, options)) {
      return false;
    }

    var _loop = function _loop(i) {
      var comparators = range.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator) {
        if (comparator.semver === ANY$4) {
          comparator = new comparator$1('>=0.0.0');
        }

        high = high || comparator;
        low = low || comparator;

        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return {
          v: false
        };
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return {
          v: false
        };
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return {
          v: false
        };
      }
    };

    for (var i = 0; i < range.set.length; ++i) {
      var _ret = _loop(i);

      if (typeof _ret === "object") return _ret.v;
    }

    return true;
  };

  var outside_1$1 = outside$1;

  var gtr$1 = function gtr(version, range, options) {
    return outside_1$1(version, range, '>', options);
  };

  var gtr_1$1 = gtr$1;

  var ltr$1 = function ltr(version, range, options) {
    return outside_1$1(version, range, '<', options);
  };

  var ltr_1$1 = ltr$1;

  var intersects$1 = function intersects(r1, r2, options) {
    r1 = new range$1(r1, options);
    r2 = new range$1(r2, options);
    return r1.intersects(r2);
  };

  var intersects_1$1 = intersects$1;

  var simplify$1 = function simplify(versions, range, options) {
    var set = [];
    var min = null;
    var prev = null;
    var v = versions.sort(function (a, b) {
      return compare_1$2(a, b, options);
    });

    for (var _iterator = _createForOfIteratorHelperLoose(v), _step; !(_step = _iterator()).done;) {
      var version = _step.value;
      var included = satisfies_1$1(version, range, options);

      if (included) {
        prev = version;
        if (!min) min = version;
      } else {
        if (prev) {
          set.push([min, prev]);
        }

        prev = null;
        min = null;
      }
    }

    if (min) set.push([min, null]);
    var ranges = [];

    for (var _i = 0, _set = set; _i < _set.length; _i++) {
      var _set$_i = _slicedToArray$2(_set[_i], 2),
          _min = _set$_i[0],
          max = _set$_i[1];

      if (_min === max) ranges.push(_min);else if (!max && _min === v[0]) ranges.push('*');else if (!max) ranges.push(">=" + _min);else if (_min === v[0]) ranges.push("<=" + max);else ranges.push(_min + " - " + max);
    }

    var simplified = ranges.join(' || ');
    var original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };

  var ANY$3 = comparator$1.ANY;

  var subset$1 = function subset(sub, dom, options) {
    if (sub === dom) return true;
    sub = new range$1(sub, options);
    dom = new range$1(dom, options);
    var sawNonNull = false;

    OUTER: for (var _iterator = _createForOfIteratorHelperLoose(sub.set), _step; !(_step = _iterator()).done;) {
      var simpleSub = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(dom.set), _step2; !(_step2 = _iterator2()).done;) {
        var simpleDom = _step2.value;
        var isSub = simpleSubset$1(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) continue OUTER;
      }

      if (sawNonNull) return false;
    }

    return true;
  };

  var simpleSubset$1 = function simpleSubset(sub, dom, options) {
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === ANY$3) return dom.length === 1 && dom[0].semver === ANY$3;
    var eqSet = new Set();
    var gt, lt;

    for (var _iterator3 = _createForOfIteratorHelperLoose(sub), _step3; !(_step3 = _iterator3()).done;) {
      var c = _step3.value;
      if (c.operator === '>' || c.operator === '>=') gt = higherGT$1(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = lowerLT$1(lt, c, options);else eqSet.add(c.semver);
    }

    if (eqSet.size > 1) return null;
    var gtltComp;

    if (gt && lt) {
      gtltComp = compare_1$2(gt.semver, lt.semver, options);
      if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;
    }

    for (var _iterator4 = _createForOfIteratorHelperLoose(eqSet), _step4; !(_step4 = _iterator4()).done;) {
      var eq = _step4.value;
      if (gt && !satisfies_1$1(eq, String(gt), options)) return null;
      if (lt && !satisfies_1$1(eq, String(lt), options)) return null;

      for (var _iterator6 = _createForOfIteratorHelperLoose(dom), _step6; !(_step6 = _iterator6()).done;) {
        var _c = _step6.value;
        if (!satisfies_1$1(eq, String(_c), options)) return false;
      }

      return true;
    }

    var higher, lower;
    var hasDomLT, hasDomGT;

    for (var _iterator5 = _createForOfIteratorHelperLoose(dom), _step5; !(_step5 = _iterator5()).done;) {
      var _c2 = _step5.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

      if (gt) {
        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT$1(gt, _c2, options);
          if (higher === _c2 && higher !== gt) return false;
        } else if (gt.operator === '>=' && !satisfies_1$1(gt.semver, String(_c2), options)) return false;
      }

      if (lt) {
        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT$1(lt, _c2, options);
          if (lower === _c2 && lower !== lt) return false;
        } else if (lt.operator === '<=' && !satisfies_1$1(lt.semver, String(_c2), options)) return false;
      }

      if (!_c2.operator && (lt || gt) && gtltComp !== 0) return false;
    }

    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    return true;
  };

  var higherGT$1 = function higherGT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$2(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
  };

  var lowerLT$1 = function lowerLT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$2(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
  };

  var subset_1$1 = subset$1;

  ({
    re: re_1$2.re,
    src: re_1$2.src,
    tokens: re_1$2.t,
    SEMVER_SPEC_VERSION: constants$2.SEMVER_SPEC_VERSION,
    SemVer: semver$9,
    compareIdentifiers: identifiers$2.compareIdentifiers,
    rcompareIdentifiers: identifiers$2.rcompareIdentifiers,
    parse: parse_1$2,
    valid: valid_1$1,
    clean: clean_1$1,
    inc: inc_1$1,
    diff: diff_1$1,
    major: major_1$1,
    minor: minor_1$1,
    patch: patch_1$1,
    prerelease: prerelease_1$1,
    compare: compare_1$2,
    rcompare: rcompare_1$1,
    compareLoose: compareLoose_1$1,
    compareBuild: compareBuild_1$1,
    sort: sort_1$1,
    rsort: rsort_1$1,
    gt: gt_1$2,
    lt: lt_1$2,
    eq: eq_1$2,
    neq: neq_1$2,
    gte: gte_1$2,
    lte: lte_1$2,
    cmp: cmp_1$2,
    coerce: coerce_1$2,
    Comparator: comparator$1,
    Range: range$1,
    satisfies: satisfies_1$1,
    toComparators: toComparators_1$1,
    maxSatisfying: maxSatisfying_1$1,
    minSatisfying: minSatisfying_1$1,
    minVersion: minVersion_1$1,
    validRange: valid$2,
    outside: outside_1$1,
    gtr: gtr_1$1,
    ltr: ltr_1$1,
    intersects: intersects_1$1,
    simplifyRange: simplify$1,
    subset: subset_1$1
  });

  var semver$8 = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  }, "/$$rollup_base$$/packages/babel-helper-compilation-targets/node_modules/semver/node_modules/semver-BABEL_8_BREAKING-false");

  var semver$7 = semver$8;

  var unreleasedLabels = {
    safari: "tp"
  };
  var browserNameMap = {
    and_chr: "chrome",
    and_ff: "firefox",
    android: "android",
    chrome: "chrome",
    edge: "edge",
    firefox: "firefox",
    ie: "ie",
    ie_mob: "ie",
    ios_saf: "ios",
    node: "node",
    op_mob: "opera",
    opera: "opera",
    safari: "safari",
    samsung: "samsung"
  };

  var versionRegExp = /^(\d+|\d+.\d+)$/;
  var v$3 = new OptionValidator("@babel/helper-compilation-targets");
  function semverMin(first, second) {
    return first && semver$7.lt(first, second) ? first : second;
  }
  function semverify(version) {
    if (typeof version === "string" && semver$7.valid(version)) {
      return version;
    }

    v$3.invariant(typeof version === "number" || typeof version === "string" && versionRegExp.test(version), "'" + version + "' is not a valid version");
    var split = version.toString().split(".");

    while (split.length < 3) {
      split.push("0");
    }

    return split.join(".");
  }
  function isUnreleasedVersion(version, env) {
    var unreleasedLabel = unreleasedLabels[env];
    return !!unreleasedLabel && unreleasedLabel === version.toString().toLowerCase();
  }
  function getLowestUnreleased(a, b, env) {
    var unreleasedLabel = unreleasedLabels[env];
    var hasUnreleased = [a, b].some(function (item) {
      return item === unreleasedLabel;
    });

    if (hasUnreleased) {
      return a === hasUnreleased ? b : a || b;
    }

    return semverMin(a, b);
  }
  function getHighestUnreleased(a, b, env) {
    return getLowestUnreleased(a, b, env) === a ? b : a;
  }
  function getLowestImplementedVersion(plugin, environment) {
    var result = plugin[environment];

    if (!result && environment === "android") {
      return plugin.chrome;
    }

    return result;
  }

  var TargetNames = {
    node: "node",
    chrome: "chrome",
    opera: "opera",
    edge: "edge",
    firefox: "firefox",
    safari: "safari",
    ie: "ie",
    ios: "ios",
    android: "android",
    electron: "electron",
    samsung: "samsung"
  };

  function prettifyVersion(version) {
    if (typeof version !== "string") {
      return version;
    }

    var parts = [semver$7.major(version)];
    var minor = semver$7.minor(version);
    var patch = semver$7.patch(version);

    if (minor || patch) {
      parts.push(minor);
    }

    if (patch) {
      parts.push(patch);
    }

    return parts.join(".");
  }
  function prettifyTargets(targets) {
    return Object.keys(targets).reduce(function (results, target) {
      var value = targets[target];
      var unreleasedLabel = unreleasedLabels[target];

      if (typeof value === "string" && unreleasedLabel !== value) {
        value = prettifyVersion(value);
      }

      results[target] = value;
      return results;
    }, {});
  }

  function getInclusionReasons(item, targetVersions, list) {
    var minVersions = list[item] || {};
    return Object.keys(targetVersions).reduce(function (result, env) {
      var minVersion = getLowestImplementedVersion(minVersions, env);
      var targetVersion = targetVersions[env];

      if (!minVersion) {
        result[env] = prettifyVersion(targetVersion);
      } else {
        var minIsUnreleased = isUnreleasedVersion(minVersion, env);
        var targetIsUnreleased = isUnreleasedVersion(targetVersion, env);

        if (!targetIsUnreleased && (minIsUnreleased || semver$7.lt(targetVersion.toString(), semverify(minVersion)))) {
          result[env] = prettifyVersion(targetVersion);
        }
      }

      return result;
    }, {});
  }

  var require$$0$6 = {
  	"proposal-class-static-block": {
  	chrome: "91",
  	electron: "13.0"
  },
  	"proposal-private-property-in-object": {
  	chrome: "91",
  	firefox: "90",
  	electron: "13.0"
  },
  	"proposal-class-properties": {
  	chrome: "74",
  	opera: "62",
  	edge: "79",
  	firefox: "90",
  	safari: "14.1",
  	node: "12",
  	samsung: "11",
  	electron: "6.0"
  },
  	"proposal-private-methods": {
  	chrome: "84",
  	opera: "70",
  	edge: "84",
  	firefox: "90",
  	safari: "15",
  	node: "14.6",
  	electron: "10.0"
  },
  	"proposal-numeric-separator": {
  	chrome: "75",
  	opera: "62",
  	edge: "79",
  	firefox: "70",
  	safari: "13",
  	node: "12.5",
  	ios: "13",
  	samsung: "11",
  	electron: "6.0"
  },
  	"proposal-logical-assignment-operators": {
  	chrome: "85",
  	opera: "71",
  	edge: "85",
  	firefox: "79",
  	safari: "14",
  	node: "15",
  	ios: "14",
  	electron: "10.0"
  },
  	"proposal-nullish-coalescing-operator": {
  	chrome: "80",
  	opera: "67",
  	edge: "80",
  	firefox: "72",
  	safari: "13.1",
  	node: "14",
  	ios: "13.4",
  	samsung: "13",
  	electron: "8.0"
  },
  	"proposal-optional-chaining": {
  	firefox: "74",
  	safari: "13.1",
  	ios: "13.4"
  },
  	"proposal-json-strings": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "62",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"proposal-optional-catch-binding": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "58",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "18",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"proposal-async-generator-functions": {
  	chrome: "63",
  	opera: "50",
  	edge: "79",
  	firefox: "57",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"proposal-object-rest-spread": {
  	chrome: "60",
  	opera: "47",
  	edge: "79",
  	firefox: "55",
  	safari: "11.1",
  	node: "8.3",
  	ios: "11.3",
  	samsung: "8",
  	electron: "2.0"
  },
  	"transform-dotall-regex": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "8.10",
  	ios: "11.3",
  	samsung: "8",
  	electron: "3.0"
  },
  	"proposal-unicode-property-regex": {
  	chrome: "64",
  	opera: "51",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-named-capturing-groups-regex": {
  	chrome: "64",
  	opera: "51",
  	edge: "79",
  	firefox: "78",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "9",
  	electron: "3.0"
  },
  	"transform-async-to-generator": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "11",
  	node: "7.6",
  	ios: "11",
  	samsung: "6",
  	electron: "1.6"
  },
  	"transform-exponentiation-operator": {
  	chrome: "52",
  	opera: "39",
  	edge: "14",
  	firefox: "52",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.3"
  },
  	"transform-template-literals": {
  	chrome: "41",
  	opera: "28",
  	edge: "13",
  	firefox: "34",
  	safari: "13",
  	node: "4",
  	ios: "13",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"transform-literals": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "53",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-arrow-functions": {
  	chrome: "47",
  	opera: "34",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-block-scoped-functions": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "46",
  	safari: "10",
  	node: "4",
  	ie: "11",
  	ios: "10",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"transform-classes": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-object-super": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-shorthand-properties": {
  	chrome: "43",
  	opera: "30",
  	edge: "12",
  	firefox: "33",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.27"
  },
  	"transform-duplicate-keys": {
  	chrome: "42",
  	opera: "29",
  	edge: "12",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.25"
  },
  	"transform-computed-properties": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "34",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-for-of": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-sticky-regex": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "3",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-unicode-escapes": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "53",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"transform-unicode-regex": {
  	chrome: "50",
  	opera: "37",
  	edge: "13",
  	firefox: "46",
  	safari: "12",
  	node: "6",
  	ios: "12",
  	samsung: "5",
  	electron: "1.1"
  },
  	"transform-spread": {
  	chrome: "46",
  	opera: "33",
  	edge: "13",
  	firefox: "45",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-destructuring": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-block-scoping": {
  	chrome: "49",
  	opera: "36",
  	edge: "14",
  	firefox: "51",
  	safari: "11",
  	node: "6",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-typeof-symbol": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"transform-new-target": {
  	chrome: "46",
  	opera: "33",
  	edge: "14",
  	firefox: "41",
  	safari: "10",
  	node: "5",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"transform-regenerator": {
  	chrome: "50",
  	opera: "37",
  	edge: "13",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"transform-member-expression-literals": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "2",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"transform-property-literals": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "2",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"transform-reserved-words": {
  	chrome: "13",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4.4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"proposal-export-namespace-from": {
  	chrome: "72",
  	and_chr: "72",
  	edge: "79",
  	firefox: "80",
  	and_ff: "80",
  	node: "13.2",
  	opera: "60",
  	op_mob: "51",
  	samsung: "11.0",
  	android: "72",
  	electron: "5.0"
  }
  };

  var plugins = require$$0$6;

  function targetsSupported(target, support) {
    var targetEnvironments = Object.keys(target);

    if (targetEnvironments.length === 0) {
      return false;
    }

    var unsupportedEnvironments = targetEnvironments.filter(function (environment) {
      var lowestImplementedVersion = getLowestImplementedVersion(support, environment);

      if (!lowestImplementedVersion) {
        return true;
      }

      var lowestTargetedVersion = target[environment];

      if (isUnreleasedVersion(lowestTargetedVersion, environment)) {
        return false;
      }

      if (isUnreleasedVersion(lowestImplementedVersion, environment)) {
        return true;
      }

      if (!semver$7.valid(lowestTargetedVersion.toString())) {
        throw new Error("Invalid version passed for target \"" + environment + "\": \"" + lowestTargetedVersion + "\". " + "Versions must be in semver format (major.minor.patch)");
      }

      return semver$7.gt(semverify(lowestImplementedVersion), lowestTargetedVersion.toString());
    });
    return unsupportedEnvironments.length === 0;
  }
  function isRequired(name, targets, _temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$compatData = _ref.compatData,
        compatData = _ref$compatData === void 0 ? plugins : _ref$compatData,
        includes = _ref.includes,
        excludes = _ref.excludes;

    if (excludes != null && excludes.has(name)) return false;
    if (includes != null && includes.has(name)) return true;
    return !targetsSupported(targets, compatData[name]);
  }
  function filterItems(list, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
    var result = new Set();
    var options = {
      compatData: list,
      includes: includes,
      excludes: excludes
    };

    for (var item in list) {
      if (isRequired(item, targets, options)) {
        result.add(item);
      } else if (pluginSyntaxMap) {
        var shippedProposalsSyntax = pluginSyntaxMap.get(item);

        if (shippedProposalsSyntax) {
          result.add(shippedProposalsSyntax);
        }
      }
    }

    if (defaultIncludes) {
      defaultIncludes.forEach(function (item) {
        return !excludes.has(item) && result.add(item);
      });
    }

    if (defaultExcludes) {
      defaultExcludes.forEach(function (item) {
        return !includes.has(item) && result["delete"](item);
      });
    }

    return result;
  }

  var ESM_SUPPORT = nativeModules["es6.module"];
  var v$2 = new OptionValidator("@babel/helper-compilation-targets");

  function validateTargetNames(targets) {
    var validTargets = Object.keys(TargetNames);

    for (var _i = 0, _Object$keys = Object.keys(targets); _i < _Object$keys.length; _i++) {
      var target = _Object$keys[_i];

      if (!(target in TargetNames)) {
        throw new Error(v$2.formatMessage("'" + target + "' is not a valid target\n- Did you mean '" + findSuggestion(target, validTargets) + "'?"));
      }
    }

    return targets;
  }

  function isBrowsersQueryValid(browsers) {
    return typeof browsers === "string" || Array.isArray(browsers) && browsers.every(function (b) {
      return typeof b === "string";
    });
  }

  function validateBrowsers(browsers) {
    v$2.invariant(browsers === undefined || isBrowsersQueryValid(browsers), "'" + String(browsers) + "' is not a valid browserslist query");
    return browsers;
  }

  function getLowestVersions(browsers) {
    return browsers.reduce(function (all, browser) {
      var _browser$split = browser.split(" "),
          _browser$split2 = _slicedToArray$2(_browser$split, 2),
          browserName = _browser$split2[0],
          browserVersion = _browser$split2[1];

      var normalizedBrowserName = browserNameMap[browserName];

      if (!normalizedBrowserName) {
        return all;
      }

      try {
        var splitVersion = browserVersion.split("-")[0].toLowerCase();
        var isSplitUnreleased = isUnreleasedVersion(splitVersion, browserName);

        if (!all[normalizedBrowserName]) {
          all[normalizedBrowserName] = isSplitUnreleased ? splitVersion : semverify(splitVersion);
          return all;
        }

        var version = all[normalizedBrowserName];
        var isUnreleased = isUnreleasedVersion(version, browserName);

        if (isUnreleased && isSplitUnreleased) {
          all[normalizedBrowserName] = getLowestUnreleased(version, splitVersion, browserName);
        } else if (isUnreleased) {
          all[normalizedBrowserName] = semverify(splitVersion);
        } else if (!isUnreleased && !isSplitUnreleased) {
          var parsedBrowserVersion = semverify(splitVersion);
          all[normalizedBrowserName] = semverMin(version, parsedBrowserVersion);
        }
      } catch (e) {}

      return all;
    }, {});
  }

  function outputDecimalWarning(decimalTargets) {
    if (!decimalTargets.length) {
      return;
    }

    console.warn("Warning, the following targets are using a decimal version:\n");
    decimalTargets.forEach(function (_ref) {
      var target = _ref.target,
          value = _ref.value;
      return console.warn("  " + target + ": " + value);
    });
    console.warn("\nWe recommend using a string for minor/patch versions to avoid numbers like 6.10\ngetting parsed as 6.1, which can lead to unexpected behavior.\n");
  }

  function semverifyTarget(target, value) {
    try {
      return semverify(value);
    } catch (error) {
      throw new Error(v$2.formatMessage("'" + value + "' is not a valid value for 'targets." + target + "'."));
    }
  }

  var targetParserMap = {
    __default: function __default(target, value) {
      var version = isUnreleasedVersion(value, target) ? value.toLowerCase() : semverifyTarget(target, value);
      return [target, version];
    },
    node: function node(target, value) {
      var parsed = value === true || value === "current" ? browser$6.versions.node : semverifyTarget(target, value);
      return [target, parsed];
    }
  };

  function generateTargets(inputTargets) {
    var input = Object.assign({}, inputTargets);
    delete input.esmodules;
    delete input.browsers;
    return input;
  }

  function resolveTargets$1(queries) {
    var resolved = browserslist_1(queries, {
      mobileToDesktop: true
    });
    return getLowestVersions(resolved);
  }

  function getTargets$2(inputTargets, options) {
    var _browsers;

    if (inputTargets === void 0) {
      inputTargets = {};
    }

    if (options === void 0) {
      options = {};
    }

    var _inputTargets = inputTargets,
        browsers = _inputTargets.browsers,
        esmodules = _inputTargets.esmodules;
    var _options = options,
        _options$configPath = _options.configPath,
        configPath = _options$configPath === void 0 ? "." : _options$configPath;
    validateBrowsers(browsers);
    var input = generateTargets(inputTargets);
    var targets = validateTargetNames(input);
    var shouldParseBrowsers = !!browsers;
    var hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
    var shouldSearchForConfig = !options.ignoreBrowserslistConfig && !hasTargets;

    if (!browsers && shouldSearchForConfig) {
      browsers = browserslist_1.loadConfig({
        config: options.configFile,
        path: configPath,
        env: options.browserslistEnv
      });

      if (browsers == null) {
        {
          browsers = [];
        }
      }
    }

    if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
      browsers = Object.keys(ESM_SUPPORT).map(function (browser) {
        return browser + " >= " + ESM_SUPPORT[browser];
      }).join(", ");
      esmodules = false;
    }

    if (browsers) {
      var queryBrowsers = resolveTargets$1(browsers);

      if (esmodules === "intersect") {
        for (var _i2 = 0, _Object$keys2 = Object.keys(queryBrowsers); _i2 < _Object$keys2.length; _i2++) {
          var browser = _Object$keys2[_i2];
          var version = queryBrowsers[browser];

          if (ESM_SUPPORT[browser]) {
            queryBrowsers[browser] = getHighestUnreleased(version, semverify(ESM_SUPPORT[browser]), browser);
          } else {
            delete queryBrowsers[browser];
          }
        }
      }

      targets = Object.assign(queryBrowsers, targets);
    }

    var result = {};
    var decimalWarnings = [];

    for (var _iterator = _createForOfIteratorHelperLoose(Object.keys(targets).sort()), _step; !(_step = _iterator()).done;) {
      var _targetParserMap$targ;

      var target = _step.value;
      var value = targets[target];

      if (typeof value === "number" && value % 1 !== 0) {
        decimalWarnings.push({
          target: target,
          value: value
        });
      }

      var parser = (_targetParserMap$targ = targetParserMap[target]) != null ? _targetParserMap$targ : targetParserMap.__default;

      var _parser = parser(target, value),
          _parser2 = _slicedToArray$2(_parser, 2),
          parsedTarget = _parser2[0],
          parsedValue = _parser2[1];

      if (parsedValue) {
        result[parsedTarget] = parsedValue;
      }
    }

    outputDecimalWarning(decimalWarnings);
    return result;
  }

  function resolveBrowserslistConfigFile(browserslistConfigFile, configFilePath) {
    return undefined;
  }
  function resolveTargets(options, root) {
    var targets = options.targets;

    if (typeof targets === "string" || Array.isArray(targets)) {
      targets = {
        browsers: targets
      };
    }

    if (targets && targets.esmodules) {
      targets = Object.assign({}, targets, {
        esmodules: "intersect"
      });
    }

    return getTargets$2(targets, {
      ignoreBrowserslistConfig: true,
      browserslistEnv: options.browserslistEnv
    });
  }

  var _marked$7 = regenerator.mark(handlerOf),
      _marked2$3 = regenerator.mark(createPresetDescriptors),
      _marked3$1 = regenerator.mark(createPluginDescriptors),
      _marked4$1 = regenerator.mark(createDescriptors),
      _marked5$1 = regenerator.mark(createDescriptor);

  function isEqualDescriptor(a, b) {
    return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && (a.file && a.file.request) === (b.file && b.file.request) && (a.file && a.file.resolved) === (b.file && b.file.resolved);
  }

  function handlerOf(value) {
    return regenerator.wrap(function handlerOf$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", value);

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$7);
  }

  function optionsWithResolvedBrowserslistConfigFile(options, dirname) {
    if (typeof options.browserslistConfigFile === "string") {
      options.browserslistConfigFile = resolveBrowserslistConfigFile(options.browserslistConfigFile);
    }

    return options;
  }

  function createCachedDescriptors(dirname, options, alias) {
    var plugins = options.plugins,
        presets = options.presets,
        passPerPreset = options.passPerPreset;
    return {
      options: optionsWithResolvedBrowserslistConfigFile(options),
      plugins: plugins ? function () {
        return createCachedPluginDescriptors(plugins, dirname)(alias);
      } : function () {
        return handlerOf([]);
      },
      presets: presets ? function () {
        return createCachedPresetDescriptors(presets, dirname)(alias)(!!passPerPreset);
      } : function () {
        return handlerOf([]);
      }
    };
  }
  function createUncachedDescriptors(dirname, options, alias) {
    var _plugins;

    var _presets;

    return {
      options: optionsWithResolvedBrowserslistConfigFile(options),
      plugins: regenerator.mark(function plugins() {
        return regenerator.wrap(function plugins$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (_plugins) {
                  _context2.next = 3;
                  break;
                }

                return _context2.delegateYield(createPluginDescriptors(options.plugins || [], dirname, alias), "t0", 2);

              case 2:
                _plugins = _context2.t0;

              case 3:
                return _context2.abrupt("return", _plugins);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, plugins);
      }),
      presets: regenerator.mark(function presets() {
        return regenerator.wrap(function presets$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (_presets) {
                  _context3.next = 3;
                  break;
                }

                return _context3.delegateYield(createPresetDescriptors(options.presets || [], dirname, alias, !!options.passPerPreset), "t0", 2);

              case 2:
                _presets = _context3.t0;

              case 3:
                return _context3.abrupt("return", _presets);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, presets);
      })
    };
  }
  var PRESET_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPresetDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCacheSync(function (alias) {
      return makeStrongCache(regenerator.mark(function _callee(passPerPreset) {
        var descriptors;
        return regenerator.wrap(function _callee$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.delegateYield(createPresetDescriptors(items, dirname, alias, passPerPreset), "t0", 1);

              case 1:
                descriptors = _context4.t0;
                return _context4.abrupt("return", descriptors.map(function (desc) {
                  return loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc);
                }));

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee);
      }));
    });
  });
  var PLUGIN_DESCRIPTOR_CACHE = new WeakMap();
  var createCachedPluginDescriptors = makeWeakCacheSync(function (items, cache) {
    var dirname = cache.using(function (dir) {
      return dir;
    });
    return makeStrongCache(regenerator.mark(function _callee2(alias) {
      var descriptors;
      return regenerator.wrap(function _callee2$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.delegateYield(createPluginDescriptors(items, dirname, alias), "t0", 1);

            case 1:
              descriptors = _context5.t0;
              return _context5.abrupt("return", descriptors.map(function (desc) {
                return loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc);
              }));

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee2);
    }));
  });
  var DEFAULT_OPTIONS = {};

  function loadCachedDescriptor(cache, desc) {
    var value = desc.value,
        _desc$options = desc.options,
        options = _desc$options === void 0 ? DEFAULT_OPTIONS : _desc$options;
    if (options === false) return desc;
    var cacheByOptions = cache.get(value);

    if (!cacheByOptions) {
      cacheByOptions = new WeakMap();
      cache.set(value, cacheByOptions);
    }

    var possibilities = cacheByOptions.get(options);

    if (!possibilities) {
      possibilities = [];
      cacheByOptions.set(options, possibilities);
    }

    if (possibilities.indexOf(desc) === -1) {
      var matches = possibilities.filter(function (possibility) {
        return isEqualDescriptor(possibility, desc);
      });

      if (matches.length > 0) {
        return matches[0];
      }

      possibilities.push(desc);
    }

    return desc;
  }

  function createPresetDescriptors(items, dirname, alias, passPerPreset) {
    return regenerator.wrap(function createPresetDescriptors$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            return _context6.delegateYield(createDescriptors("preset", items, dirname, alias, passPerPreset), "t0", 1);

          case 1:
            return _context6.abrupt("return", _context6.t0);

          case 2:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked2$3);
  }

  function createPluginDescriptors(items, dirname, alias) {
    return regenerator.wrap(function createPluginDescriptors$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            return _context7.delegateYield(createDescriptors("plugin", items, dirname, alias), "t0", 1);

          case 1:
            return _context7.abrupt("return", _context7.t0);

          case 2:
          case "end":
            return _context7.stop();
        }
      }
    }, _marked3$1);
  }

  function createDescriptors(type, items, dirname, alias, ownPass) {
    var descriptors;
    return regenerator.wrap(function createDescriptors$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            return _context8.delegateYield(gensync.all(items.map(function (item, index) {
              return createDescriptor(item, dirname, {
                type: type,
                alias: alias + "$" + index,
                ownPass: !!ownPass
              });
            })), "t0", 1);

          case 1:
            descriptors = _context8.t0;
            assertNoDuplicates(descriptors);
            return _context8.abrupt("return", descriptors);

          case 4:
          case "end":
            return _context8.stop();
        }
      }
    }, _marked4$1);
  }

  function createDescriptor(pair, dirname, _ref) {
    var type, alias, ownPass, desc, name, options, value, _value, _value2, _value3, _value4, file, filepath, resolver, request, _yield$resolver;

    return regenerator.wrap(function createDescriptor$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            type = _ref.type, alias = _ref.alias, ownPass = _ref.ownPass;
            desc = getItemDescriptor(pair);

            if (!desc) {
              _context9.next = 4;
              break;
            }

            return _context9.abrupt("return", desc);

          case 4:
            value = pair;

            if (Array.isArray(value)) {
              if (value.length === 3) {
                _value = value;
                _value2 = _slicedToArray$2(_value, 3);
                value = _value2[0];
                options = _value2[1];
                name = _value2[2];
              } else {
                _value3 = value;
                _value4 = _slicedToArray$2(_value3, 2);
                value = _value4[0];
                options = _value4[1];
              }
            }

            file = undefined;
            filepath = null;

            if (!(typeof value === "string")) {
              _context9.next = 18;
              break;
            }

            if (!(typeof type !== "string")) {
              _context9.next = 11;
              break;
            }

            throw new Error("To resolve a string-based item, the type of item must be given");

          case 11:
            resolver = type === "plugin" ? loadPlugin : loadPreset;
            request = value;
            return _context9.delegateYield(resolver(value, dirname), "t0", 14);

          case 14:
            _yield$resolver = _context9.t0;
            filepath = _yield$resolver.filepath;
            value = _yield$resolver.value;
            file = {
              request: request,
              resolved: filepath
            };

          case 18:
            if (value) {
              _context9.next = 20;
              break;
            }

            throw new Error("Unexpected falsy value: " + String(value));

          case 20:
            if (!(typeof value === "object" && value.__esModule)) {
              _context9.next = 26;
              break;
            }

            if (!value["default"]) {
              _context9.next = 25;
              break;
            }

            value = value["default"];
            _context9.next = 26;
            break;

          case 25:
            throw new Error("Must export a default export when using ES6 modules.");

          case 26:
            if (!(typeof value !== "object" && typeof value !== "function")) {
              _context9.next = 28;
              break;
            }

            throw new Error("Unsupported format: " + typeof value + ". Expected an object or a function.");

          case 28:
            if (!(filepath !== null && typeof value === "object" && value)) {
              _context9.next = 30;
              break;
            }

            throw new Error("Plugin/Preset files are not allowed to export objects, only functions. In " + filepath);

          case 30:
            return _context9.abrupt("return", {
              name: name,
              alias: filepath || alias,
              value: value,
              options: options,
              dirname: dirname,
              ownPass: ownPass,
              file: file
            });

          case 31:
          case "end":
            return _context9.stop();
        }
      }
    }, _marked5$1);
  }

  function assertNoDuplicates(items) {
    var map = new Map();

    var _loop = function _loop() {
      var item = _step.value;
      if (typeof item.value !== "function") return "continue";
      var nameMap = map.get(item.value);

      if (!nameMap) {
        nameMap = new Set();
        map.set(item.value, nameMap);
      }

      if (nameMap.has(item.name)) {
        var conflicts = items.filter(function (i) {
          return i.value === item.value;
        });
        throw new Error(["Duplicate plugin/preset detected.", "If you'd like to use two separate instances of a plugin,", "they need separate names, e.g.", "", "  plugins: [", "    ['some-plugin', {}],", "    ['some-plugin', {}, 'some unique name'],", "  ]", "", "Duplicates detected are:", "" + JSON.stringify(conflicts, null, 2)].join("\n"));
      }

      nameMap.add(item.name);
    };

    for (var _iterator = _createForOfIteratorHelperLoose(items), _step; !(_step = _iterator()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  }

  var _marked$6 = regenerator.mark(createConfigItem$1);
  function createItemFromDescriptor(desc) {
    return new ConfigItem(desc);
  }
  function createConfigItem$1(value, _temp) {
    var _ref, _ref$dirname, dirname, type, descriptor;

    return regenerator.wrap(function createConfigItem$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _ref = _temp === void 0 ? {} : _temp, _ref$dirname = _ref.dirname, dirname = _ref$dirname === void 0 ? "." : _ref$dirname, type = _ref.type;
            return _context.delegateYield(createDescriptor(value, path$1.resolve(dirname), {
              type: type,
              alias: "programmatic item"
            }), "t0", 2);

          case 2:
            descriptor = _context.t0;
            return _context.abrupt("return", createItemFromDescriptor(descriptor));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$6);
  }
  function getItemDescriptor(item) {
    if (item != null && item[CONFIG_ITEM_BRAND]) {
      return item._descriptor;
    }

    return undefined;
  }
  var CONFIG_ITEM_BRAND = Symbol["for"]("@babel/core@7 - ConfigItem");

  var ConfigItem = function ConfigItem(descriptor) {
    this._descriptor = void 0;
    this[CONFIG_ITEM_BRAND] = true;
    this.value = void 0;
    this.options = void 0;
    this.dirname = void 0;
    this.name = void 0;
    this.file = void 0;
    this._descriptor = descriptor;
    Object.defineProperty(this, "_descriptor", {
      enumerable: false
    });
    Object.defineProperty(this, CONFIG_ITEM_BRAND, {
      enumerable: false
    });
    this.value = this._descriptor.value;
    this.options = this._descriptor.options;
    this.dirname = this._descriptor.dirname;
    this.name = this._descriptor.name;
    this.file = this._descriptor.file ? {
      request: this._descriptor.file.request,
      resolved: this._descriptor.file.resolved
    } : undefined;
    Object.freeze(this);
  };

  Object.freeze(ConfigItem.prototype);

  var s = 1000;
  var m$1 = s * 60;
  var h = m$1 * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;

  var ms = function ms(val, options) {
    options = options || {};
    var type = typeof val;

    if (type === 'string' && val.length > 0) {
      return parse$4(val);
    } else if (type === 'number' && isFinite(val)) {
      return options["long"] ? fmtLong(val) : fmtShort(val);
    }

    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
  };

  function parse$4(str) {
    str = String(str);

    if (str.length > 100) {
      return;
    }

    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

    if (!match) {
      return;
    }

    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();

    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;

      case 'weeks':
      case 'week':
      case 'w':
        return n * w;

      case 'days':
      case 'day':
      case 'd':
        return n * d;

      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;

      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m$1;

      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;

      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;

      default:
        return undefined;
    }
  }

  function fmtShort(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }

    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }

    if (msAbs >= m$1) {
      return Math.round(ms / m$1) + 'm';
    }

    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }

    return ms + 'ms';
  }

  function fmtLong(ms) {
    var msAbs = Math.abs(ms);

    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }

    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }

    if (msAbs >= m$1) {
      return plural(ms, msAbs, m$1, 'minute');
    }

    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }

    return ms + ' ms';
  }

  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }

  function setup(env) {
    createDebug.debug = createDebug;
    createDebug["default"] = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = ms;
    createDebug.destroy = destroy;
    Object.keys(env).forEach(function (key) {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};

    function selectColor(namespace) {
      var hash = 0;

      for (var i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }

      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }

    createDebug.selectColor = selectColor;

    function createDebug(namespace) {
      var prevTime;
      var enableOverride = null;
      var namespacesCache;
      var enabledCache;

      function debug() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (!debug.enabled) {
          return;
        }

        var self = debug;
        var curr = Number(new Date());
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);

        if (typeof args[0] !== 'string') {
          args.unshift('%O');
        }

        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
          if (match === '%%') {
            return '%';
          }

          index++;
          var formatter = createDebug.formatters[format];

          if (typeof formatter === 'function') {
            var val = args[index];
            match = formatter.call(self, val);
            args.splice(index, 1);
            index--;
          }

          return match;
        });
        createDebug.formatArgs.call(self, args);
        var logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: function get() {
          if (enableOverride !== null) {
            return enableOverride;
          }

          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }

          return enabledCache;
        },
        set: function set(v) {
          enableOverride = v;
        }
      });

      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }

      return debug;
    }

    function extend(namespace, delimiter) {
      var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }

    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      var i;
      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }

        namespaces = split[i].replace(/\*/g, '.*?');

        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    function disable() {
      var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
        return '-' + namespace;
      }))).join(',');
      createDebug.enable('');
      return namespaces;
    }

    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }

      var i;
      var len;

      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }

      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }

      return false;
    }

    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
    }

    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }

      return val;
    }

    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }

    createDebug.enable(createDebug.load());
    return createDebug;
  }

  var common = setup;

  var browser$1 = createCommonjsModule(function (module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();

    exports.destroy = function () {
      var warned = false;
      return function () {
        if (!warned) {
          warned = true;
          console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
      };
    }();

    exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];

    function useColors() {
      if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
        return true;
      }

      if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }

      return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }

    function formatArgs(args) {
      args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function (match) {
        if (match === '%%') {
          return;
        }

        index++;

        if (match === '%c') {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }

    exports.log = console.debug || console.log || function () {};

    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {}
    }

    function load() {
      var r;

      try {
        r = exports.storage.getItem('debug');
      } catch (error) {}

      if (!r && typeof browser$6 !== 'undefined' && 'env' in browser$6) {
        r = browser$6.env.DEBUG;
      }

      return r;
    }

    function localstorage() {
      try {
        return localStorage;
      } catch (error) {}
    }

    module.exports = common(exports);
    var formatters = module.exports.formatters;

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };
  }, "/$$rollup_base$$/packages/babel-core/node_modules/debug/src");

  var removed = {
    auxiliaryComment: {
      message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
    },
    blacklist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    breakConfig: {
      message: "This is not a necessary option in Babel 6"
    },
    experimental: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    externalHelpers: {
      message: "Use the `external-helpers` plugin instead. " + "Check out http://babeljs.io/docs/plugins/external-helpers/"
    },
    extra: {
      message: ""
    },
    jsxPragma: {
      message: "use the `pragma` option in the `react-jsx` plugin. " + "Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
    },
    loose: {
      message: "Specify the `loose` option for the relevant plugin you are using " + "or use a preset that sets the option."
    },
    metadataUsedHelpers: {
      message: "Not required anymore as this is enabled by default"
    },
    modules: {
      message: "Use the corresponding module transform plugin in the `plugins` option. " + "Check out http://babeljs.io/docs/plugins/#modules"
    },
    nonStandard: {
      message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. " + "Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
    },
    optional: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    sourceMapName: {
      message: "The `sourceMapName` option has been removed because it makes more sense for the " + "tooling that calls Babel to assign `map.file` themselves."
    },
    stage: {
      message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
    },
    whitelist: {
      message: "Put the specific transforms you want in the `plugins` option"
    },
    resolveModuleSource: {
      version: 6,
      message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
    },
    metadata: {
      version: 6,
      message: "Generated plugin metadata is always included in the output result"
    },
    sourceMapTarget: {
      version: 6,
      message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling " + "that calls Babel to assign `map.file` themselves."
    }
  };

  function msg(loc) {
    switch (loc.type) {
      case "root":
        return "";

      case "env":
        return msg(loc.parent) + ".env[\"" + loc.name + "\"]";

      case "overrides":
        return msg(loc.parent) + ".overrides[" + loc.index + "]";

      case "option":
        return msg(loc.parent) + "." + loc.name;

      case "access":
        return msg(loc.parent) + "[" + JSON.stringify(loc.name) + "]";

      default:
        throw new Error("Assertion failure: Unknown type " + loc.type);
    }
  }
  function access(loc, name) {
    return {
      type: "access",
      name: name,
      parent: loc
    };
  }
  function assertRootMode(loc, value) {
    if (value !== undefined && value !== "root" && value !== "upward" && value !== "upward-optional") {
      throw new Error(msg(loc) + " must be a \"root\", \"upward\", \"upward-optional\" or undefined");
    }

    return value;
  }
  function assertSourceMaps(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "inline" && value !== "both") {
      throw new Error(msg(loc) + " must be a boolean, \"inline\", \"both\", or undefined");
    }

    return value;
  }
  function assertCompact(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && value !== "auto") {
      throw new Error(msg(loc) + " must be a boolean, \"auto\", or undefined");
    }

    return value;
  }
  function assertSourceType(loc, value) {
    if (value !== undefined && value !== "module" && value !== "script" && value !== "unambiguous") {
      throw new Error(msg(loc) + " must be \"module\", \"script\", \"unambiguous\", or undefined");
    }

    return value;
  }
  function assertCallerMetadata(loc, value) {
    var obj = assertObject(loc, value);

    if (obj) {
      if (typeof obj.name !== "string") {
        throw new Error(msg(loc) + " set but does not contain \"name\" property string");
      }

      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];
        var propLoc = access(loc, prop);
        var _value = obj[prop];

        if (_value != null && typeof _value !== "boolean" && typeof _value !== "string" && typeof _value !== "number") {
          throw new Error(msg(propLoc) + " must be null, undefined, a boolean, a string, or a number.");
        }
      }
    }

    return value;
  }
  function assertInputSourceMap(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && (typeof value !== "object" || !value)) {
      throw new Error(msg(loc) + " must be a boolean, object, or undefined");
    }

    return value;
  }
  function assertString(loc, value) {
    if (value !== undefined && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a string, or undefined");
    }

    return value;
  }
  function assertFunction(loc, value) {
    if (value !== undefined && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a function, or undefined");
    }

    return value;
  }
  function assertBoolean(loc, value) {
    if (value !== undefined && typeof value !== "boolean") {
      throw new Error(msg(loc) + " must be a boolean, or undefined");
    }

    return value;
  }
  function assertObject(loc, value) {
    if (value !== undefined && (typeof value !== "object" || Array.isArray(value) || !value)) {
      throw new Error(msg(loc) + " must be an object, or undefined");
    }

    return value;
  }
  function assertArray(loc, value) {
    if (value != null && !Array.isArray(value)) {
      throw new Error(msg(loc) + " must be an array, or undefined");
    }

    return value;
  }
  function assertIgnoreList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertIgnoreItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertIgnoreItem(loc, value) {
    if (typeof value !== "string" && typeof value !== "function" && !(value instanceof RegExp)) {
      throw new Error(msg(loc) + " must be an array of string/Function/RegExp values, or undefined");
    }

    return value;
  }

  function assertConfigApplicableTest(loc, value) {
    if (value === undefined) return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a string/Function/RegExp, or an array of those");
    }

    return value;
  }

  function checkValidTest(value) {
    return typeof value === "string" || typeof value === "function" || value instanceof RegExp;
  }

  function assertConfigFileSearch(loc, value) {
    if (value !== undefined && typeof value !== "boolean" && typeof value !== "string") {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string, " + ("got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertBabelrcSearch(loc, value) {
    if (value === undefined || typeof value === "boolean") return value;

    if (Array.isArray(value)) {
      value.forEach(function (item, i) {
        if (!checkValidTest(item)) {
          throw new Error(msg(access(loc, i)) + " must be a string/Function/RegExp.");
        }
      });
    } else if (!checkValidTest(value)) {
      throw new Error(msg(loc) + " must be a undefined, a boolean, a string/Function/RegExp " + ("or an array of those, got " + JSON.stringify(value)));
    }

    return value;
  }
  function assertPluginList(loc, value) {
    var arr = assertArray(loc, value);

    if (arr) {
      arr.forEach(function (item, i) {
        return assertPluginItem(access(loc, i), item);
      });
    }

    return arr;
  }

  function assertPluginItem(loc, value) {
    if (Array.isArray(value)) {
      if (value.length === 0) {
        throw new Error(msg(loc) + " must include an object");
      }

      if (value.length > 3) {
        throw new Error(msg(loc) + " may only be a two-tuple or three-tuple");
      }

      assertPluginTarget(access(loc, 0), value[0]);

      if (value.length > 1) {
        var opts = value[1];

        if (opts !== undefined && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
          throw new Error(msg(access(loc, 1)) + " must be an object, false, or undefined");
        }
      }

      if (value.length === 3) {
        var _name = value[2];

        if (_name !== undefined && typeof _name !== "string") {
          throw new Error(msg(access(loc, 2)) + " must be a string, or undefined");
        }
      }
    } else {
      assertPluginTarget(loc, value);
    }

    return value;
  }

  function assertPluginTarget(loc, value) {
    if ((typeof value !== "object" || !value) && typeof value !== "string" && typeof value !== "function") {
      throw new Error(msg(loc) + " must be a string, object, function");
    }

    return value;
  }

  function assertTargets(loc, value) {
    if (isBrowsersQueryValid(value)) return value;

    if (typeof value !== "object" || !value || Array.isArray(value)) {
      throw new Error(msg(loc) + " must be a string, an array of strings or an object");
    }

    var browsersLoc = access(loc, "browsers");
    var esmodulesLoc = access(loc, "esmodules");
    assertBrowsersList(browsersLoc, value.browsers);
    assertBoolean(esmodulesLoc, value.esmodules);

    for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
      var _key = _Object$keys2[_i2];
      var val = value[_key];
      var subLoc = access(loc, _key);
      if (_key === "esmodules") assertBoolean(subLoc, val);else if (_key === "browsers") assertBrowsersList(subLoc, val);else if (!Object.hasOwnProperty.call(TargetNames, _key)) {
        var validTargets = Object.keys(TargetNames).join(", ");
        throw new Error(msg(subLoc) + " is not a valid target. Supported targets are " + validTargets);
      } else assertBrowserVersion(subLoc, val);
    }

    return value;
  }

  function assertBrowsersList(loc, value) {
    if (value !== undefined && !isBrowsersQueryValid(value)) {
      throw new Error(msg(loc) + " must be undefined, a string or an array of strings");
    }
  }

  function assertBrowserVersion(loc, value) {
    if (typeof value === "number" && Math.round(value) === value) return;
    if (typeof value === "string") return;
    throw new Error(msg(loc) + " must be a string or an integer number");
  }

  function assertAssumptions(loc, value) {
    if (value === undefined) return;

    if (typeof value !== "object" || value === null) {
      throw new Error(msg(loc) + " must be an object or undefined.");
    }

    var root = loc;

    do {
      root = root.parent;
    } while (root.type !== "root");

    var inPreset = root.source === "preset";

    for (var _i3 = 0, _Object$keys3 = Object.keys(value); _i3 < _Object$keys3.length; _i3++) {
      var _name2 = _Object$keys3[_i3];
      var subLoc = access(loc, _name2);

      if (!assumptionsNames.has(_name2)) {
        throw new Error(msg(subLoc) + " is not a supported assumption.");
      }

      if (typeof value[_name2] !== "boolean") {
        throw new Error(msg(subLoc) + " must be a boolean.");
      }

      if (inPreset && value[_name2] === false) {
        throw new Error(msg(subLoc) + " cannot be set to 'false' inside presets.");
      }
    }

    return value;
  }

  var ROOT_VALIDATORS = {
    cwd: assertString,
    root: assertString,
    rootMode: assertRootMode,
    configFile: assertConfigFileSearch,
    caller: assertCallerMetadata,
    filename: assertString,
    filenameRelative: assertString,
    code: assertBoolean,
    ast: assertBoolean,
    cloneInputAst: assertBoolean,
    envName: assertString
  };
  var BABELRC_VALIDATORS = {
    babelrc: assertBoolean,
    babelrcRoots: assertBabelrcSearch
  };
  var NONPRESET_VALIDATORS = {
    "extends": assertString,
    ignore: assertIgnoreList,
    only: assertIgnoreList,
    targets: assertTargets,
    browserslistConfigFile: assertConfigFileSearch,
    browserslistEnv: assertString
  };
  var COMMON_VALIDATORS = {
    inputSourceMap: assertInputSourceMap,
    presets: assertPluginList,
    plugins: assertPluginList,
    passPerPreset: assertBoolean,
    assumptions: assertAssumptions,
    env: assertEnvSet,
    overrides: assertOverridesList,
    test: assertConfigApplicableTest,
    include: assertConfigApplicableTest,
    exclude: assertConfigApplicableTest,
    retainLines: assertBoolean,
    comments: assertBoolean,
    shouldPrintComment: assertFunction,
    compact: assertCompact,
    minified: assertBoolean,
    auxiliaryCommentBefore: assertString,
    auxiliaryCommentAfter: assertString,
    sourceType: assertSourceType,
    wrapPluginVisitorMethod: assertFunction,
    highlightCode: assertBoolean,
    sourceMaps: assertSourceMaps,
    sourceMap: assertSourceMaps,
    sourceFileName: assertString,
    sourceRoot: assertString,
    parserOpts: assertObject,
    generatorOpts: assertObject
  };
  {
    Object.assign(COMMON_VALIDATORS, {
      getModuleId: assertFunction,
      moduleRoot: assertString,
      moduleIds: assertBoolean,
      moduleId: assertString
    });
  }
  var assumptionsNames = new Set(["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noNewArrows", "objectRestNoSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"]);

  function getSource(loc) {
    return loc.type === "root" ? loc.source : getSource(loc.parent);
  }

  function validate(type, opts) {
    return validateNested({
      type: "root",
      source: type
    }, opts);
  }

  function validateNested(loc, opts) {
    var type = getSource(loc);
    assertNoDuplicateSourcemap(opts);
    Object.keys(opts).forEach(function (key) {
      var optLoc = {
        type: "option",
        name: key,
        parent: loc
      };

      if (type === "preset" && NONPRESET_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is not allowed in preset options");
      }

      if (type !== "arguments" && ROOT_VALIDATORS[key]) {
        throw new Error(msg(optLoc) + " is only allowed in root programmatic options");
      }

      if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
        if (type === "babelrcfile" || type === "extendsfile") {
          throw new Error(msg(optLoc) + " is not allowed in .babelrc or \"extends\"ed files, only in root programmatic options, " + "or babel.config.js/config file options");
        }

        throw new Error(msg(optLoc) + " is only allowed in root programmatic options, or babel.config.js/config file options");
      }

      var validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
      validator(optLoc, opts[key]);
    });
    return opts;
  }

  function throwUnknownError(loc) {
    var key = loc.name;

    if (removed[key]) {
      var _removed$key = removed[key],
          message = _removed$key.message,
          _removed$key$version = _removed$key.version,
          version = _removed$key$version === void 0 ? 5 : _removed$key$version;
      throw new Error("Using removed Babel " + version + " option: " + msg(loc) + " - " + message);
    } else {
      var unknownOptErr = new Error("Unknown option: " + msg(loc) + ". Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.");
      unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
      throw unknownOptErr;
    }
  }

  function has$a(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function assertNoDuplicateSourcemap(opts) {
    if (has$a(opts, "sourceMap") && has$a(opts, "sourceMaps")) {
      throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
    }
  }

  function assertEnvSet(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside of another .env block");
    }

    var parent = loc.parent;
    var obj = assertObject(loc, value);

    if (obj) {
      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {
        var envName = _Object$keys[_i];
        var env = assertObject(access(loc, envName), obj[envName]);
        if (!env) continue;
        var envLoc = {
          type: "env",
          name: envName,
          parent: parent
        };
        validateNested(envLoc, env);
      }
    }

    return obj;
  }

  function assertOverridesList(loc, value) {
    if (loc.parent.type === "env") {
      throw new Error(msg(loc) + " is not allowed inside an .env block");
    }

    if (loc.parent.type === "overrides") {
      throw new Error(msg(loc) + " is not allowed inside an .overrides block");
    }

    var parent = loc.parent;
    var arr = assertArray(loc, value);

    if (arr) {
      for (var _iterator = _createForOfIteratorHelperLoose(arr.entries()), _step; !(_step = _iterator()).done;) {
        var _step$value = _slicedToArray$2(_step.value, 2),
            index = _step$value[0],
            item = _step$value[1];

        var objLoc = access(loc, index);
        var env = assertObject(objLoc, item);
        if (!env) throw new Error(msg(objLoc) + " must be an object");
        var overridesLoc = {
          type: "overrides",
          index: index,
          parent: parent
        };
        validateNested(overridesLoc, env);
      }
    }

    return arr;
  }

  function checkNoUnwrappedItemOptionPairs(items, index, type, e) {
    if (index === 0) return;
    var lastItem = items[index - 1];
    var thisItem = items[index];

    if (lastItem.file && lastItem.options === undefined && typeof thisItem.value === "object") {
      e.message += "\n- Maybe you meant to use\n" + ("\"" + type + "\": [\n  [\"" + lastItem.file.request + "\", " + JSON.stringify(thisItem.value, undefined, 2) + "]\n]\n") + ("To be a valid " + type + ", its name and options should be wrapped in a pair of brackets");
    }
  }

  var sep = "\\" + path$1.sep;
  var endSep = "(?:" + sep + "|$)";
  var substitution = "[^" + sep + "]+";
  var starPat = "(?:" + substitution + sep + ")";
  var starPatLast = "(?:" + substitution + endSep + ")";
  var starStarPat = starPat + "*?";
  var starStarPatLast = starPat + "*?" + starPatLast + "?";

  function escapeRegExp(string) {
    return string.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
  }

  function pathToPattern(pattern, dirname) {
    var parts = path$1.resolve(dirname, pattern).split(path$1.sep);
    return new RegExp(["^"].concat(_toConsumableArray(parts.map(function (part, i) {
      var last = i === parts.length - 1;
      if (part === "**") return last ? starStarPatLast : starStarPat;
      if (part === "*") return last ? starPatLast : starPat;

      if (part.indexOf("*.") === 0) {
        return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep);
      }

      return escapeRegExp(part) + (last ? endSep : sep);
    }))).join(""));
  }

  var ChainFormatter = {
    Programmatic: 0,
    Config: 1
  };
  var Formatter = {
    title: function title(type, callerName, filepath) {
      var title = "";

      if (type === ChainFormatter.Programmatic) {
        title = "programmatic options";

        if (callerName) {
          title += " from " + callerName;
        }
      } else {
        title = "config " + filepath;
      }

      return title;
    },
    loc: function loc(index, envName) {
      var loc = "";

      if (index != null) {
        loc += ".overrides[" + index + "]";
      }

      if (envName != null) {
        loc += ".env[\"" + envName + "\"]";
      }

      return loc;
    },
    optionsAndDescriptors: regenerator.mark(function optionsAndDescriptors(opt) {
      var content, pluginDescriptors, presetDescriptors;
      return regenerator.wrap(function optionsAndDescriptors$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              content = Object.assign({}, opt.options);
              delete content.overrides;
              delete content.env;
              _context.t0 = _toConsumableArray;
              return _context.delegateYield(opt.plugins(), "t1", 5);

            case 5:
              _context.t2 = _context.t1;
              pluginDescriptors = (0, _context.t0)(_context.t2);

              if (pluginDescriptors.length) {
                content.plugins = pluginDescriptors.map(function (d) {
                  return descriptorToConfig(d);
                });
              }

              _context.t3 = _toConsumableArray;
              return _context.delegateYield(opt.presets(), "t4", 10);

            case 10:
              _context.t5 = _context.t4;
              presetDescriptors = (0, _context.t3)(_context.t5);

              if (presetDescriptors.length) {
                content.presets = _toConsumableArray(presetDescriptors).map(function (d) {
                  return descriptorToConfig(d);
                });
              }

              return _context.abrupt("return", JSON.stringify(content, undefined, 2));

            case 14:
            case "end":
              return _context.stop();
          }
        }
      }, optionsAndDescriptors);
    })
  };

  function descriptorToConfig(d) {
    var _d$file;

    var name = (_d$file = d.file) == null ? void 0 : _d$file.request;

    if (name == null) {
      if (typeof d.value === "object") {
        name = d.value;
      } else if (typeof d.value === "function") {
        name = "[Function: " + d.value.toString().substr(0, 50) + " ... ]";
      }
    }

    if (name == null) {
      name = "[Unknown]";
    }

    if (d.options === undefined) {
      return name;
    } else if (d.name == null) {
      return [name, d.options];
    } else {
      return [name, d.options, d.name];
    }
  }

  var ConfigPrinter = function () {
    function ConfigPrinter() {
      this._stack = [];
    }

    var _proto = ConfigPrinter.prototype;

    _proto.configure = function configure(enabled, type, _ref) {
      var _this = this;

      var callerName = _ref.callerName,
          filepath = _ref.filepath;
      if (!enabled) return function () {};
      return function (content, index, envName) {
        _this._stack.push({
          type: type,
          callerName: callerName,
          filepath: filepath,
          content: content,
          index: index,
          envName: envName
        });
      };
    };

    ConfigPrinter.format = regenerator.mark(function format(config) {
      var title, loc, content;
      return regenerator.wrap(function format$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              title = Formatter.title(config.type, config.callerName, config.filepath);
              loc = Formatter.loc(config.index, config.envName);
              if (loc) title += " " + loc;
              return _context2.delegateYield(Formatter.optionsAndDescriptors(config.content), "t0", 4);

            case 4:
              content = _context2.t0;
              return _context2.abrupt("return", title + "\n" + content);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, format);
    });
    _proto.output = regenerator.mark(function output() {
      var configs;
      return regenerator.wrap(function output$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(this._stack.length === 0)) {
                _context3.next = 2;
                break;
              }

              return _context3.abrupt("return", "");

            case 2:
              return _context3.delegateYield(gensync.all(this._stack.map(function (s) {
                return ConfigPrinter.format(s);
              })), "t0", 3);

            case 3:
              configs = _context3.t0;
              return _context3.abrupt("return", configs.join("\n\n"));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, output, this);
    });
    return ConfigPrinter;
  }();

  var _marked$5 = regenerator.mark(buildPresetChain),
      _marked2$2 = regenerator.mark(buildRootChain),
      _marked3 = regenerator.mark(loadFileChain),
      _marked4 = regenerator.mark(mergeExtendsChain),
      _marked5 = regenerator.mark(mergeChainOpts);
  var debug$3 = browser$1("babel:config:config-chain");
  function buildPresetChain(arg, context) {
    var chain;
    return regenerator.wrap(function buildPresetChain$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(buildPresetChainWalker(arg, context), "t0", 1);

          case 1:
            chain = _context.t0;

            if (chain) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.abrupt("return", {
              plugins: dedupDescriptors(chain.plugins),
              presets: dedupDescriptors(chain.presets),
              options: chain.options.map(function (o) {
                return normalizeOptions$5(o);
              }),
              files: new Set()
            });

          case 5:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$5);
  }
  var buildPresetChainWalker = makeChainWalker({
    root: function root(preset) {
      return loadPresetDescriptors(preset);
    },
    env: function env(preset, envName) {
      return loadPresetEnvDescriptors(preset)(envName);
    },
    overrides: function overrides(preset, index) {
      return loadPresetOverridesDescriptors(preset)(index);
    },
    overridesEnv: function overridesEnv(preset, index, envName) {
      return loadPresetOverridesEnvDescriptors(preset)(index)(envName);
    },
    createLogger: function createLogger() {
      return function () {};
    }
  });
  var loadPresetDescriptors = makeWeakCacheSync(function (preset) {
    return buildRootDescriptors(preset, preset.alias, createUncachedDescriptors);
  });
  var loadPresetEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(preset, preset.alias, createUncachedDescriptors, envName);
    });
  });
  var loadPresetOverridesDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(preset, preset.alias, createUncachedDescriptors, index);
    });
  });
  var loadPresetOverridesEnvDescriptors = makeWeakCacheSync(function (preset) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(preset, preset.alias, createUncachedDescriptors, index, envName);
      });
    });
  });
  function buildRootChain(opts, context) {
    var configReport, babelRcReport, programmaticLogger, programmaticChain, programmaticReport, configFile, babelrc, babelrcRoots, babelrcRootsDirectory, configFileChain, configFileLogger, validatedFile, result, ignoreFile, babelrcFile, isIgnored, fileChain, pkgData, _yield$findRelativeCo, _validatedFile, babelrcLogger, _result, chain;

    return regenerator.wrap(function buildRootChain$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            programmaticLogger = new ConfigPrinter();
            return _context2.delegateYield(loadProgrammaticChain({
              options: opts,
              dirname: context.cwd
            }, context, undefined, programmaticLogger), "t0", 2);

          case 2:
            programmaticChain = _context2.t0;

            if (programmaticChain) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", null);

          case 5:
            return _context2.delegateYield(programmaticLogger.output(), "t1", 6);

          case 6:
            programmaticReport = _context2.t1;

            if (!(typeof opts.configFile === "string")) {
              _context2.next = 12;
              break;
            }

            return _context2.delegateYield(loadConfig$1(opts.configFile, context.cwd, context.envName, context.caller), "t2", 9);

          case 9:
            configFile = _context2.t2;
            _context2.next = 15;
            break;

          case 12:
            if (!(opts.configFile !== false)) {
              _context2.next = 15;
              break;
            }

            return _context2.delegateYield(findRootConfig(context.root, context.envName, context.caller), "t3", 14);

          case 14:
            configFile = _context2.t3;

          case 15:
            babelrc = opts.babelrc, babelrcRoots = opts.babelrcRoots;
            babelrcRootsDirectory = context.cwd;
            configFileChain = emptyChain();
            configFileLogger = new ConfigPrinter();

            if (!configFile) {
              _context2.next = 30;
              break;
            }

            validatedFile = validateConfigFile(configFile);
            return _context2.delegateYield(loadFileChain(validatedFile, context, undefined, configFileLogger), "t4", 22);

          case 22:
            result = _context2.t4;

            if (result) {
              _context2.next = 25;
              break;
            }

            return _context2.abrupt("return", null);

          case 25:
            return _context2.delegateYield(configFileLogger.output(), "t5", 26);

          case 26:
            configReport = _context2.t5;

            if (babelrc === undefined) {
              babelrc = validatedFile.options.babelrc;
            }

            if (babelrcRoots === undefined) {
              babelrcRootsDirectory = validatedFile.dirname;
              babelrcRoots = validatedFile.options.babelrcRoots;
            }

            mergeChain(configFileChain, result);

          case 30:
            isIgnored = false;
            fileChain = emptyChain();

            if (!((babelrc === true || babelrc === undefined) && typeof context.filename === "string")) {
              _context2.next = 55;
              break;
            }

            return _context2.delegateYield(findPackageData(context.filename), "t6", 34);

          case 34:
            pkgData = _context2.t6;

            if (!(pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory))) {
              _context2.next = 55;
              break;
            }

            return _context2.delegateYield(findRelativeConfig(pkgData, context.envName, context.caller), "t7", 37);

          case 37:
            _yield$findRelativeCo = _context2.t7;
            ignoreFile = _yield$findRelativeCo.ignore;
            babelrcFile = _yield$findRelativeCo.config;

            if (ignoreFile) {
              fileChain.files.add(ignoreFile.filepath);
            }

            if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
              isIgnored = true;
            }

            if (!(babelrcFile && !isIgnored)) {
              _context2.next = 54;
              break;
            }

            _validatedFile = validateBabelrcFile(babelrcFile);
            babelrcLogger = new ConfigPrinter();
            return _context2.delegateYield(loadFileChain(_validatedFile, context, undefined, babelrcLogger), "t8", 46);

          case 46:
            _result = _context2.t8;

            if (_result) {
              _context2.next = 51;
              break;
            }

            isIgnored = true;
            _context2.next = 54;
            break;

          case 51:
            return _context2.delegateYield(babelrcLogger.output(), "t9", 52);

          case 52:
            babelRcReport = _context2.t9;
            mergeChain(fileChain, _result);

          case 54:
            if (babelrcFile && isIgnored) {
              fileChain.files.add(babelrcFile.filepath);
            }

          case 55:
            if (context.showConfig) {
              console.log("Babel configs on \"" + context.filename + "\" (ascending priority):\n" + [configReport, babelRcReport, programmaticReport].filter(function (x) {
                return !!x;
              }).join("\n\n") + "\n-----End Babel configs-----");
            }

            chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
            return _context2.abrupt("return", {
              plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
              presets: isIgnored ? [] : dedupDescriptors(chain.presets),
              options: isIgnored ? [] : chain.options.map(function (o) {
                return normalizeOptions$5(o);
              }),
              fileHandling: isIgnored ? "ignored" : "transpile",
              ignore: ignoreFile || undefined,
              babelrc: babelrcFile || undefined,
              config: configFile || undefined,
              files: chain.files
            });

          case 58:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2$2);
  }

  function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
    if (typeof babelrcRoots === "boolean") return babelrcRoots;
    var absoluteRoot = context.root;

    if (babelrcRoots === undefined) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    var babelrcPatterns = babelrcRoots;

    if (!Array.isArray(babelrcPatterns)) {
      babelrcPatterns = [babelrcPatterns];
    }

    babelrcPatterns = babelrcPatterns.map(function (pat) {
      return typeof pat === "string" ? path$1.resolve(babelrcRootsDirectory, pat) : pat;
    });

    if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
      return pkgData.directories.indexOf(absoluteRoot) !== -1;
    }

    return babelrcPatterns.some(function (pat) {
      if (typeof pat === "string") {
        pat = pathToPattern(pat, babelrcRootsDirectory);
      }

      return pkgData.directories.some(function (directory) {
        return matchPattern(pat, babelrcRootsDirectory, directory, context);
      });
    });
  }

  var validateConfigFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate("configfile", file.options)
    };
  });
  var validateBabelrcFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate("babelrcfile", file.options)
    };
  });
  var validateExtendFile = makeWeakCacheSync(function (file) {
    return {
      filepath: file.filepath,
      dirname: file.dirname,
      options: validate("extendsfile", file.options)
    };
  });
  var loadProgrammaticChain = makeChainWalker({
    root: function root(input) {
      return buildRootDescriptors(input, "base", createCachedDescriptors);
    },
    env: function env(input, envName) {
      return buildEnvDescriptors(input, "base", createCachedDescriptors, envName);
    },
    overrides: function overrides(input, index) {
      return buildOverrideDescriptors(input, "base", createCachedDescriptors, index);
    },
    overridesEnv: function overridesEnv(input, index, envName) {
      return buildOverrideEnvDescriptors(input, "base", createCachedDescriptors, index, envName);
    },
    createLogger: function createLogger(input, context, baseLogger) {
      return buildProgrammaticLogger(input, context, baseLogger);
    }
  });
  var loadFileChainWalker = makeChainWalker({
    root: function root(file) {
      return loadFileDescriptors(file);
    },
    env: function env(file, envName) {
      return loadFileEnvDescriptors(file)(envName);
    },
    overrides: function overrides(file, index) {
      return loadFileOverridesDescriptors(file)(index);
    },
    overridesEnv: function overridesEnv(file, index, envName) {
      return loadFileOverridesEnvDescriptors(file)(index)(envName);
    },
    createLogger: function createLogger(file, context, baseLogger) {
      return buildFileLogger(file.filepath, context, baseLogger);
    }
  });

  function loadFileChain(input, context, files, baseLogger) {
    var chain;
    return regenerator.wrap(function loadFileChain$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.delegateYield(loadFileChainWalker(input, context, files, baseLogger), "t0", 1);

          case 1:
            chain = _context3.t0;

            if (chain) {
              chain.files.add(input.filepath);
            }

            return _context3.abrupt("return", chain);

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _marked3);
  }

  var loadFileDescriptors = makeWeakCacheSync(function (file) {
    return buildRootDescriptors(file, file.filepath, createUncachedDescriptors);
  });
  var loadFileEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (envName) {
      return buildEnvDescriptors(file, file.filepath, createUncachedDescriptors, envName);
    });
  });
  var loadFileOverridesDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return buildOverrideDescriptors(file, file.filepath, createUncachedDescriptors, index);
    });
  });
  var loadFileOverridesEnvDescriptors = makeWeakCacheSync(function (file) {
    return makeStrongCacheSync(function (index) {
      return makeStrongCacheSync(function (envName) {
        return buildOverrideEnvDescriptors(file, file.filepath, createUncachedDescriptors, index, envName);
      });
    });
  });

  function buildFileLogger(filepath, context, baseLogger) {
    if (!baseLogger) {
      return function () {};
    }

    return baseLogger.configure(context.showConfig, ChainFormatter.Config, {
      filepath: filepath
    });
  }

  function buildRootDescriptors(_ref, alias, descriptors) {
    var dirname = _ref.dirname,
        options = _ref.options;
    return descriptors(dirname, options, alias);
  }

  function buildProgrammaticLogger(_, context, baseLogger) {
    var _context$caller;

    if (!baseLogger) {
      return function () {};
    }

    return baseLogger.configure(context.showConfig, ChainFormatter.Programmatic, {
      callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
    });
  }

  function buildEnvDescriptors(_ref2, alias, descriptors, envName) {
    var dirname = _ref2.dirname,
        options = _ref2.options;
    var opts = options.env && options.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".env[\"" + envName + "\"]") : null;
  }

  function buildOverrideDescriptors(_ref3, alias, descriptors, index) {
    var dirname = _ref3.dirname,
        options = _ref3.options;
    var opts = options.overrides && options.overrides[index];
    if (!opts) throw new Error("Assertion failure - missing override");
    return descriptors(dirname, opts, alias + ".overrides[" + index + "]");
  }

  function buildOverrideEnvDescriptors(_ref4, alias, descriptors, index, envName) {
    var dirname = _ref4.dirname,
        options = _ref4.options;
    var override = options.overrides && options.overrides[index];
    if (!override) throw new Error("Assertion failure - missing override");
    var opts = override.env && override.env[envName];
    return opts ? descriptors(dirname, opts, alias + ".overrides[" + index + "].env[\"" + envName + "\"]") : null;
  }

  function makeChainWalker(_ref5) {
    var root = _ref5.root,
        env = _ref5.env,
        overrides = _ref5.overrides,
        overridesEnv = _ref5.overridesEnv,
        createLogger = _ref5.createLogger;
    return regenerator.mark(function _callee(input, context, files, baseLogger) {
      var dirname, flattenedConfigs, rootOpts, envOpts, chain, logger, _i, _flattenedConfigs, _flattenedConfigs$_i, config, _index, envName;

      return regenerator.wrap(function _callee$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (files === void 0) {
                files = new Set();
              }

              dirname = input.dirname;
              flattenedConfigs = [];
              rootOpts = root(input);

              if (configIsApplicable(rootOpts, dirname, context)) {
                flattenedConfigs.push({
                  config: rootOpts,
                  envName: undefined,
                  index: undefined
                });
                envOpts = env(input, context.envName);

                if (envOpts && configIsApplicable(envOpts, dirname, context)) {
                  flattenedConfigs.push({
                    config: envOpts,
                    envName: context.envName,
                    index: undefined
                  });
                }

                (rootOpts.options.overrides || []).forEach(function (_, index) {
                  var overrideOps = overrides(input, index);

                  if (configIsApplicable(overrideOps, dirname, context)) {
                    flattenedConfigs.push({
                      config: overrideOps,
                      index: index,
                      envName: undefined
                    });
                    var overrideEnvOpts = overridesEnv(input, index, context.envName);

                    if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname, context)) {
                      flattenedConfigs.push({
                        config: overrideEnvOpts,
                        index: index,
                        envName: context.envName
                      });
                    }
                  }
                });
              }

              if (!flattenedConfigs.some(function (_ref6) {
                var _ref6$config$options = _ref6.config.options,
                    ignore = _ref6$config$options.ignore,
                    only = _ref6$config$options.only;
                return shouldIgnore(context, ignore, only, dirname);
              })) {
                _context4.next = 7;
                break;
              }

              return _context4.abrupt("return", null);

            case 7:
              chain = emptyChain();
              logger = createLogger(input, context, baseLogger);
              _i = 0, _flattenedConfigs = flattenedConfigs;

            case 10:
              if (!(_i < _flattenedConfigs.length)) {
                _context4.next = 20;
                break;
              }

              _flattenedConfigs$_i = _flattenedConfigs[_i], config = _flattenedConfigs$_i.config, _index = _flattenedConfigs$_i.index, envName = _flattenedConfigs$_i.envName;
              return _context4.delegateYield(mergeExtendsChain(chain, config.options, dirname, context, files, baseLogger), "t0", 13);

            case 13:
              if (_context4.t0) {
                _context4.next = 15;
                break;
              }

              return _context4.abrupt("return", null);

            case 15:
              logger(config, _index, envName);
              return _context4.delegateYield(mergeChainOpts(chain, config), "t1", 17);

            case 17:
              _i++;
              _context4.next = 10;
              break;

            case 20:
              return _context4.abrupt("return", chain);

            case 21:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee);
    });
  }

  function mergeExtendsChain(chain, opts, dirname, context, files, baseLogger) {
    var file, fileChain;
    return regenerator.wrap(function mergeExtendsChain$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (!(opts["extends"] === undefined)) {
              _context5.next = 2;
              break;
            }

            return _context5.abrupt("return", true);

          case 2:
            return _context5.delegateYield(loadConfig$1(opts["extends"], dirname, context.envName, context.caller), "t0", 3);

          case 3:
            file = _context5.t0;

            if (!files.has(file)) {
              _context5.next = 6;
              break;
            }

            throw new Error("Configuration cycle detected loading " + file.filepath + ".\n" + "File already loaded following the config chain:\n" + Array.from(files, function (file) {
              return " - " + file.filepath;
            }).join("\n"));

          case 6:
            files.add(file);
            return _context5.delegateYield(loadFileChain(validateExtendFile(file), context, files, baseLogger), "t1", 8);

          case 8:
            fileChain = _context5.t1;
            files["delete"](file);

            if (fileChain) {
              _context5.next = 12;
              break;
            }

            return _context5.abrupt("return", false);

          case 12:
            mergeChain(chain, fileChain);
            return _context5.abrupt("return", true);

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _marked4);
  }

  function mergeChain(target, source) {
    var _target$options, _target$plugins, _target$presets;

    (_target$options = target.options).push.apply(_target$options, _toConsumableArray(source.options));

    (_target$plugins = target.plugins).push.apply(_target$plugins, _toConsumableArray(source.plugins));

    (_target$presets = target.presets).push.apply(_target$presets, _toConsumableArray(source.presets));

    for (var _iterator = _createForOfIteratorHelperLoose(source.files), _step; !(_step = _iterator()).done;) {
      var file = _step.value;
      target.files.add(file);
    }

    return target;
  }

  function mergeChainOpts(target, _ref7) {
    var _target$plugins2, _target$presets2;

    var options, plugins, presets;
    return regenerator.wrap(function mergeChainOpts$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            options = _ref7.options, plugins = _ref7.plugins, presets = _ref7.presets;
            target.options.push(options);
            _context6.t0 = (_target$plugins2 = target.plugins).push;
            _context6.t1 = _target$plugins2;
            _context6.t2 = _toConsumableArray;
            return _context6.delegateYield(plugins(), "t3", 6);

          case 6:
            _context6.t4 = _context6.t3;
            _context6.t5 = (0, _context6.t2)(_context6.t4);

            _context6.t0.apply.call(_context6.t0, _context6.t1, _context6.t5);

            _context6.t6 = (_target$presets2 = target.presets).push;
            _context6.t7 = _target$presets2;
            _context6.t8 = _toConsumableArray;
            return _context6.delegateYield(presets(), "t9", 13);

          case 13:
            _context6.t10 = _context6.t9;
            _context6.t11 = (0, _context6.t8)(_context6.t10);

            _context6.t6.apply.call(_context6.t6, _context6.t7, _context6.t11);

            return _context6.abrupt("return", target);

          case 17:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked5);
  }

  function emptyChain() {
    return {
      options: [],
      presets: [],
      plugins: [],
      files: new Set()
    };
  }

  function normalizeOptions$5(opts) {
    var options = Object.assign({}, opts);
    delete options["extends"];
    delete options.env;
    delete options.overrides;
    delete options.plugins;
    delete options.presets;
    delete options.passPerPreset;
    delete options.ignore;
    delete options.only;
    delete options.test;
    delete options.include;
    delete options.exclude;

    if (Object.prototype.hasOwnProperty.call(options, "sourceMap")) {
      options.sourceMaps = options.sourceMap;
      delete options.sourceMap;
    }

    return options;
  }

  function dedupDescriptors(items) {
    var map = new Map();
    var descriptors = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(items), _step2; !(_step2 = _iterator2()).done;) {
      var item = _step2.value;

      if (typeof item.value === "function") {
        var fnKey = item.value;
        var nameMap = map.get(fnKey);

        if (!nameMap) {
          nameMap = new Map();
          map.set(fnKey, nameMap);
        }

        var desc = nameMap.get(item.name);

        if (!desc) {
          desc = {
            value: item
          };
          descriptors.push(desc);
          if (!item.ownPass) nameMap.set(item.name, desc);
        } else {
          desc.value = item;
        }
      } else {
        descriptors.push({
          value: item
        });
      }
    }

    return descriptors.reduce(function (acc, desc) {
      acc.push(desc.value);
      return acc;
    }, []);
  }

  function configIsApplicable(_ref8, dirname, context) {
    var options = _ref8.options;
    return (options.test === undefined || configFieldIsApplicable(context, options.test, dirname)) && (options.include === undefined || configFieldIsApplicable(context, options.include, dirname)) && (options.exclude === undefined || !configFieldIsApplicable(context, options.exclude, dirname));
  }

  function configFieldIsApplicable(context, test, dirname) {
    var patterns = Array.isArray(test) ? test : [test];
    return matchesPatterns(context, patterns, dirname);
  }

  function shouldIgnore(context, ignore, only, dirname) {
    if (ignore && matchesPatterns(context, ignore, dirname)) {
      var _context$filename;

      var message = "No config is applied to \"" + ((_context$filename = context.filename) != null ? _context$filename : "(unknown)") + "\" because it matches one of `ignore: " + JSON.stringify(ignore) + "` from \"" + dirname + "\"";
      debug$3(message);

      if (context.showConfig) {
        console.log(message);
      }

      return true;
    }

    if (only && !matchesPatterns(context, only, dirname)) {
      var _context$filename2;

      var _message = "No config is applied to \"" + ((_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)") + "\" because it fails to match one of `only: " + JSON.stringify(only) + "` from \"" + dirname + "\"";

      debug$3(_message);

      if (context.showConfig) {
        console.log(_message);
      }

      return true;
    }

    return false;
  }

  function matchesPatterns(context, patterns, dirname) {
    return patterns.some(function (pattern) {
      return matchPattern(pattern, dirname, context.filename, context);
    });
  }

  function matchPattern(pattern, dirname, pathToTest, context) {
    if (typeof pattern === "function") {
      return !!pattern(pathToTest, {
        dirname: dirname,
        envName: context.envName,
        caller: context.caller
      });
    }

    if (typeof pathToTest !== "string") {
      throw new Error("Configuration contains string/RegExp pattern, but no filename was passed to Babel");
    }

    if (typeof pattern === "string") {
      pattern = pathToPattern(pattern, dirname);
    }

    return pattern.test(pathToTest);
  }

  var VALIDATORS = {
    name: assertString,
    manipulateOptions: assertFunction,
    pre: assertFunction,
    post: assertFunction,
    inherits: assertFunction,
    visitor: assertVisitorMap,
    parserOverride: assertFunction,
    generatorOverride: assertFunction
  };

  function assertVisitorMap(loc, value) {
    var obj = assertObject(loc, value);

    if (obj) {
      Object.keys(obj).forEach(function (prop) {
        return assertVisitorHandler(prop, obj[prop]);
      });

      if (obj.enter || obj.exit) {
        throw new Error(msg(loc) + " cannot contain catch-all \"enter\" or \"exit\" handlers. Please target individual nodes.");
      }
    }

    return obj;
  }

  function assertVisitorHandler(key, value) {
    if (value && typeof value === "object") {
      Object.keys(value).forEach(function (handler) {
        if (handler !== "enter" && handler !== "exit") {
          throw new Error(".visitor[\"" + key + "\"] may only have .enter and/or .exit handlers.");
        }
      });
    } else if (typeof value !== "function") {
      throw new Error(".visitor[\"" + key + "\"] must be a function");
    }

    return value;
  }

  function validatePluginObject(obj) {
    var rootPath = {
      type: "root",
      source: "plugin"
    };
    Object.keys(obj).forEach(function (key) {
      var validator = VALIDATORS[key];

      if (validator) {
        var optLoc = {
          type: "option",
          name: key,
          parent: rootPath
        };
        validator(optLoc, obj[key]);
      } else {
        var invalidPluginPropertyError = new Error("." + key + " is not a valid Plugin property");
        invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
        throw invalidPluginPropertyError;
      }
    });
    return obj;
  }

  function makeConfigAPI(cache) {
    var env = function env(value) {
      return cache.using(function (data) {
        if (typeof value === "undefined") return data.envName;

        if (typeof value === "function") {
          return assertSimpleType(value(data.envName));
        }

        if (!Array.isArray(value)) value = [value];
        return value.some(function (entry) {
          if (typeof entry !== "string") {
            throw new Error("Unexpected non-string value");
          }

          return entry === data.envName;
        });
      });
    };

    var caller = function caller(cb) {
      return cache.using(function (data) {
        return assertSimpleType(cb(data.caller));
      });
    };

    return {
      version: version$3,
      cache: cache.simple(),
      env: env,
      async: function async() {
        return false;
      },
      caller: caller,
      assertVersion: assertVersion
    };
  }
  function makePresetAPI(cache) {
    var targets = function targets() {
      return JSON.parse(cache.using(function (data) {
        return JSON.stringify(data.targets);
      }));
    };

    return Object.assign({}, makeConfigAPI(cache), {
      targets: targets
    });
  }
  function makePluginAPI(cache) {
    var assumption = function assumption(name) {
      return cache.using(function (data) {
        return data.assumptions[name];
      });
    };

    return Object.assign({}, makePresetAPI(cache), {
      assumption: assumption
    });
  }

  function assertVersion(range) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    if (semver$a.satisfies(version$3, range)) return;
    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version$3 + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version$3,
      range: range
    });
  }

  var _excluded$2 = ["showIgnoredFiles"];

  var _marked$4 = regenerator.mark(loadPrivatePartialConfig);

  function resolveRootMode(rootDir, rootMode) {
    switch (rootMode) {
      case "root":
        return rootDir;

      case "upward-optional":
        {
          var upwardRootDir = findConfigUpwards();
          return upwardRootDir === null ? rootDir : upwardRootDir;
        }

      case "upward":
        {
          var _upwardRootDir = findConfigUpwards();

          if (_upwardRootDir !== null) return _upwardRootDir;
          throw Object.assign(new Error("Babel was run with rootMode:\"upward\" but a root could not " + ("be found when searching upward from \"" + rootDir + "\".\n") + "One of the following config files must be in the directory tree: " + ("\"" + ROOT_CONFIG_FILENAMES.join(", ") + "\".")), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: rootDir
          });
        }

      default:
        throw new Error("Assertion failure - unknown rootMode value.");
    }
  }

  function loadPrivatePartialConfig(inputOpts) {
    var args, _args$envName, envName, _args$cwd, cwd, _args$root, rootDir, _args$rootMode, rootMode, caller, _args$cloneInputAst, cloneInputAst, absoluteCwd, absoluteRootDir, filename, showConfigPath, context, configChain, merged, options;

    return regenerator.wrap(function loadPrivatePartialConfig$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts)))) {
              _context.next = 2;
              break;
            }

            throw new Error("Babel options must be an object, null, or undefined");

          case 2:
            args = inputOpts ? validate("arguments", inputOpts) : {};
            _args$envName = args.envName, envName = _args$envName === void 0 ? getEnv() : _args$envName, _args$cwd = args.cwd, cwd = _args$cwd === void 0 ? "." : _args$cwd, _args$root = args.root, rootDir = _args$root === void 0 ? "." : _args$root, _args$rootMode = args.rootMode, rootMode = _args$rootMode === void 0 ? "root" : _args$rootMode, caller = args.caller, _args$cloneInputAst = args.cloneInputAst, cloneInputAst = _args$cloneInputAst === void 0 ? true : _args$cloneInputAst;
            absoluteCwd = path$1.resolve(cwd);
            absoluteRootDir = resolveRootMode(path$1.resolve(absoluteCwd, rootDir), rootMode);
            filename = typeof args.filename === "string" ? path$1.resolve(cwd, args.filename) : undefined;
            return _context.delegateYield(resolveShowConfigPath(), "t0", 8);

          case 8:
            showConfigPath = _context.t0;
            context = {
              filename: filename,
              cwd: absoluteCwd,
              root: absoluteRootDir,
              envName: envName,
              caller: caller,
              showConfig: showConfigPath === filename
            };
            return _context.delegateYield(buildRootChain(args, context), "t1", 11);

          case 11:
            configChain = _context.t1;

            if (configChain) {
              _context.next = 14;
              break;
            }

            return _context.abrupt("return", null);

          case 14:
            merged = {
              assumptions: {}
            };
            configChain.options.forEach(function (opts) {
              mergeOptions(merged, opts);
            });
            options = Object.assign({}, merged, {
              targets: resolveTargets(merged),
              cloneInputAst: cloneInputAst,
              babelrc: false,
              configFile: false,
              browserslistConfigFile: false,
              passPerPreset: false,
              envName: context.envName,
              cwd: context.cwd,
              root: context.root,
              rootMode: "root",
              filename: typeof context.filename === "string" ? context.filename : undefined,
              plugins: configChain.plugins.map(function (descriptor) {
                return createItemFromDescriptor(descriptor);
              }),
              presets: configChain.presets.map(function (descriptor) {
                return createItemFromDescriptor(descriptor);
              })
            });
            return _context.abrupt("return", {
              options: options,
              context: context,
              fileHandling: configChain.fileHandling,
              ignore: configChain.ignore,
              babelrc: configChain.babelrc,
              config: configChain.config,
              files: configChain.files
            });

          case 18:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$4);
  }
  var loadPartialConfig$1 = gensync(regenerator.mark(function _callee(opts) {
    var showIgnoredFiles, _opts, result, options, babelrc, ignore, config, fileHandling, files;

    return regenerator.wrap(function _callee$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            showIgnoredFiles = false;

            if (typeof opts === "object" && opts !== null && !Array.isArray(opts)) {
              _opts = opts;
              showIgnoredFiles = _opts.showIgnoredFiles;
              opts = _objectWithoutPropertiesLoose(_opts, _excluded$2);
            }

            return _context2.delegateYield(loadPrivatePartialConfig(opts), "t0", 3);

          case 3:
            result = _context2.t0;

            if (result) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", null);

          case 6:
            options = result.options, babelrc = result.babelrc, ignore = result.ignore, config = result.config, fileHandling = result.fileHandling, files = result.files;

            if (!(fileHandling === "ignored" && !showIgnoredFiles)) {
              _context2.next = 9;
              break;
            }

            return _context2.abrupt("return", null);

          case 9:
            (options.plugins || []).forEach(function (item) {
              if (item.value instanceof Plugin$1) {
                throw new Error("Passing cached plugin instances is not supported in " + "babel.loadPartialConfig()");
              }
            });
            return _context2.abrupt("return", new PartialConfig(options, babelrc ? babelrc.filepath : undefined, ignore ? ignore.filepath : undefined, config ? config.filepath : undefined, fileHandling, files));

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee);
  }));

  var PartialConfig = function () {
    function PartialConfig(options, babelrc, ignore, config, fileHandling, files) {
      this.options = void 0;
      this.babelrc = void 0;
      this.babelignore = void 0;
      this.config = void 0;
      this.fileHandling = void 0;
      this.files = void 0;
      this.options = options;
      this.babelignore = ignore;
      this.babelrc = babelrc;
      this.config = config;
      this.fileHandling = fileHandling;
      this.files = files;
      Object.freeze(this);
    }

    var _proto = PartialConfig.prototype;

    _proto.hasFilesystemConfig = function hasFilesystemConfig() {
      return this.babelrc !== undefined || this.config !== undefined;
    };

    return PartialConfig;
  }();

  Object.freeze(PartialConfig.prototype);

  var _marked$3 = regenerator.mark(loadPluginDescriptor),
      _marked2$1 = regenerator.mark(loadPresetDescriptor);
  var loadConfig = gensync(regenerator.mark(function loadFullConfig(inputOpts) {
    var _opts$assumptions;

    var result, options, context, fileHandling, optionDefaults, plugins, presets, presetContext, toDescriptor, presetsDescriptors, initialPluginsDescriptors, pluginDescriptorsByPass, passes, ignored, opts, pluginContext;
    return regenerator.wrap(function loadFullConfig$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.delegateYield(loadPrivatePartialConfig(inputOpts), "t0", 1);

          case 1:
            result = _context3.t0;

            if (result) {
              _context3.next = 4;
              break;
            }

            return _context3.abrupt("return", null);

          case 4:
            options = result.options, context = result.context, fileHandling = result.fileHandling;

            if (!(fileHandling === "ignored")) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", null);

          case 7:
            optionDefaults = {};
            plugins = options.plugins, presets = options.presets;

            if (!(!plugins || !presets)) {
              _context3.next = 11;
              break;
            }

            throw new Error("Assertion failure - plugins and presets exist");

          case 11:
            presetContext = Object.assign({}, context, {
              targets: options.targets
            });

            toDescriptor = function toDescriptor(item) {
              var desc = getItemDescriptor(item);

              if (!desc) {
                throw new Error("Assertion failure - must be config item");
              }

              return desc;
            };

            presetsDescriptors = presets.map(toDescriptor);
            initialPluginsDescriptors = plugins.map(toDescriptor);
            pluginDescriptorsByPass = [[]];
            passes = [];
            return _context3.delegateYield(enhanceError(context, regenerator.mark(function recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
              var presets, i, descriptor, _iterator, _step, _step$value, preset, pass, _ignored;

              return regenerator.wrap(function recursePresetDescriptors$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      presets = [];
                      i = 0;

                    case 2:
                      if (!(i < rawPresets.length)) {
                        _context.next = 30;
                        break;
                      }

                      descriptor = rawPresets[i];

                      if (!(descriptor.options !== false)) {
                        _context.next = 27;
                        break;
                      }

                      _context.prev = 5;

                      if (!descriptor.ownPass) {
                        _context.next = 15;
                        break;
                      }

                      _context.t0 = presets;
                      return _context.delegateYield(loadPresetDescriptor(descriptor, presetContext), "t1", 9);

                    case 9:
                      _context.t2 = _context.t1;
                      _context.t3 = [];
                      _context.t4 = {
                        preset: _context.t2,
                        pass: _context.t3
                      };

                      _context.t0.push.call(_context.t0, _context.t4);

                      _context.next = 21;
                      break;

                    case 15:
                      _context.t5 = presets;
                      return _context.delegateYield(loadPresetDescriptor(descriptor, presetContext), "t6", 17);

                    case 17:
                      _context.t7 = _context.t6;
                      _context.t8 = pluginDescriptorsPass;
                      _context.t9 = {
                        preset: _context.t7,
                        pass: _context.t8
                      };

                      _context.t5.unshift.call(_context.t5, _context.t9);

                    case 21:
                      _context.next = 27;
                      break;

                    case 23:
                      _context.prev = 23;
                      _context.t10 = _context["catch"](5);

                      if (_context.t10.code === "BABEL_UNKNOWN_OPTION") {
                        checkNoUnwrappedItemOptionPairs(rawPresets, i, "preset", _context.t10);
                      }

                      throw _context.t10;

                    case 27:
                      i++;
                      _context.next = 2;
                      break;

                    case 30:
                      if (!(presets.length > 0)) {
                        _context.next = 45;
                        break;
                      }

                      pluginDescriptorsByPass.splice.apply(pluginDescriptorsByPass, [1, 0].concat(_toConsumableArray(presets.map(function (o) {
                        return o.pass;
                      }).filter(function (p) {
                        return p !== pluginDescriptorsPass;
                      }))));
                      _iterator = _createForOfIteratorHelperLoose(presets);

                    case 33:
                      if ((_step = _iterator()).done) {
                        _context.next = 45;
                        break;
                      }

                      _step$value = _step.value, preset = _step$value.preset, pass = _step$value.pass;

                      if (preset) {
                        _context.next = 37;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 37:
                      pass.push.apply(pass, _toConsumableArray(preset.plugins));
                      return _context.delegateYield(recursePresetDescriptors(preset.presets, pass), "t11", 39);

                    case 39:
                      _ignored = _context.t11;

                      if (!_ignored) {
                        _context.next = 42;
                        break;
                      }

                      return _context.abrupt("return", true);

                    case 42:
                      preset.options.forEach(function (opts) {
                        mergeOptions(optionDefaults, opts);
                      });

                    case 43:
                      _context.next = 33;
                      break;

                    case 45:
                    case "end":
                      return _context.stop();
                  }
                }
              }, recursePresetDescriptors, null, [[5, 23]]);
            }))(presetsDescriptors, pluginDescriptorsByPass[0]), "t1", 18);

          case 18:
            ignored = _context3.t1;

            if (!ignored) {
              _context3.next = 21;
              break;
            }

            return _context3.abrupt("return", null);

          case 21:
            opts = optionDefaults;
            mergeOptions(opts, options);
            pluginContext = Object.assign({}, presetContext, {
              assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
            });
            return _context3.delegateYield(enhanceError(context, regenerator.mark(function loadPluginDescriptors() {
              var _pluginDescriptorsByP;

              var _iterator2, _step2, descs, pass, i, descriptor;

              return regenerator.wrap(function loadPluginDescriptors$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      (_pluginDescriptorsByP = pluginDescriptorsByPass[0]).unshift.apply(_pluginDescriptorsByP, _toConsumableArray(initialPluginsDescriptors));

                      _iterator2 = _createForOfIteratorHelperLoose(pluginDescriptorsByPass);

                    case 2:
                      if ((_step2 = _iterator2()).done) {
                        _context2.next = 26;
                        break;
                      }

                      descs = _step2.value;
                      pass = [];
                      passes.push(pass);
                      i = 0;

                    case 7:
                      if (!(i < descs.length)) {
                        _context2.next = 24;
                        break;
                      }

                      descriptor = descs[i];

                      if (!(descriptor.options !== false)) {
                        _context2.next = 21;
                        break;
                      }

                      _context2.prev = 10;
                      _context2.t0 = pass;
                      return _context2.delegateYield(loadPluginDescriptor(descriptor, pluginContext), "t1", 13);

                    case 13:
                      _context2.t2 = _context2.t1;

                      _context2.t0.push.call(_context2.t0, _context2.t2);

                      _context2.next = 21;
                      break;

                    case 17:
                      _context2.prev = 17;
                      _context2.t3 = _context2["catch"](10);

                      if (_context2.t3.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                        checkNoUnwrappedItemOptionPairs(descs, i, "plugin", _context2.t3);
                      }

                      throw _context2.t3;

                    case 21:
                      i++;
                      _context2.next = 7;
                      break;

                    case 24:
                      _context2.next = 2;
                      break;

                    case 26:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, loadPluginDescriptors, null, [[10, 17]]);
            }))(), "t2", 25);

          case 25:
            opts.plugins = passes[0];
            opts.presets = passes.slice(1).filter(function (plugins) {
              return plugins.length > 0;
            }).map(function (plugins) {
              return {
                plugins: plugins
              };
            });
            opts.passPerPreset = opts.presets.length > 0;
            return _context3.abrupt("return", {
              options: opts,
              passes: passes
            });

          case 29:
          case "end":
            return _context3.stop();
        }
      }
    }, loadFullConfig);
  }));

  function enhanceError(context, fn) {
    return regenerator.mark(function _callee(arg1, arg2) {
      return regenerator.wrap(function _callee$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              return _context4.delegateYield(fn(arg1, arg2), "t0", 2);

            case 2:
              return _context4.abrupt("return", _context4.t0);

            case 5:
              _context4.prev = 5;
              _context4.t1 = _context4["catch"](0);

              if (!/^\[BABEL\]/.test(_context4.t1.message)) {
                _context4.t1.message = "[BABEL] " + (context.filename || "unknown") + ": " + _context4.t1.message;
              }

              throw _context4.t1;

            case 9:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee, null, [[0, 5]]);
    });
  }

  var makeDescriptorLoader = function makeDescriptorLoader(apiFactory) {
    return makeWeakCache(regenerator.mark(function _callee2(_ref, cache) {
      var value, options, dirname, alias, item, factory, api;
      return regenerator.wrap(function _callee2$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              value = _ref.value, options = _ref.options, dirname = _ref.dirname, alias = _ref.alias;

              if (!(options === false)) {
                _context5.next = 3;
                break;
              }

              throw new Error("Assertion failure");

            case 3:
              options = options || {};
              item = value;

              if (!(typeof value === "function")) {
                _context5.next = 17;
                break;
              }

              factory = maybeAsync(value, "You appear to be using an async plugin/preset, but Babel has been called synchronously");
              api = Object.assign({}, babel, apiFactory(cache));
              _context5.prev = 8;
              return _context5.delegateYield(factory(api, options, dirname), "t0", 10);

            case 10:
              item = _context5.t0;
              _context5.next = 17;
              break;

            case 13:
              _context5.prev = 13;
              _context5.t1 = _context5["catch"](8);

              if (alias) {
                _context5.t1.message += " (While processing: " + JSON.stringify(alias) + ")";
              }

              throw _context5.t1;

            case 17:
              if (!(!item || typeof item !== "object")) {
                _context5.next = 19;
                break;
              }

              throw new Error("Plugin/Preset did not return an object.");

            case 19:
              if (!isThenable$1(item)) {
                _context5.next = 22;
                break;
              }

              return _context5.delegateYield([], "t2", 21);

            case 21:
              throw new Error("You appear to be using a promise as a plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version. " + "As an alternative, you can prefix the promise with \"await\". " + ("(While processing: " + JSON.stringify(alias) + ")"));

            case 22:
              return _context5.abrupt("return", {
                value: item,
                options: options,
                dirname: dirname,
                alias: alias
              });

            case 23:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee2, null, [[8, 13]]);
    }));
  };

  var pluginDescriptorLoader = makeDescriptorLoader(makePluginAPI);
  var presetDescriptorLoader = makeDescriptorLoader(makePresetAPI);

  function loadPluginDescriptor(descriptor, context) {
    return regenerator.wrap(function loadPluginDescriptor$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!(descriptor.value instanceof Plugin$1)) {
              _context6.next = 4;
              break;
            }

            if (!descriptor.options) {
              _context6.next = 3;
              break;
            }

            throw new Error("Passed options to an existing Plugin instance will not work.");

          case 3:
            return _context6.abrupt("return", descriptor.value);

          case 4:
            _context6.t0 = instantiatePlugin;
            return _context6.delegateYield(pluginDescriptorLoader(descriptor, context), "t1", 6);

          case 6:
            _context6.t2 = _context6.t1;
            _context6.t3 = context;
            return _context6.delegateYield((0, _context6.t0)(_context6.t2, _context6.t3), "t4", 9);

          case 9:
            return _context6.abrupt("return", _context6.t4);

          case 10:
          case "end":
            return _context6.stop();
        }
      }
    }, _marked$3);
  }

  var instantiatePlugin = makeWeakCache(regenerator.mark(function _callee3(_ref2, cache) {
    var value, options, dirname, alias, pluginObj, plugin, inheritsDescriptor, inherits;
    return regenerator.wrap(function _callee3$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            value = _ref2.value, options = _ref2.options, dirname = _ref2.dirname, alias = _ref2.alias;
            pluginObj = validatePluginObject(value);
            plugin = Object.assign({}, pluginObj);

            if (plugin.visitor) {
              plugin.visitor = traverse.explode(Object.assign({}, plugin.visitor));
            }

            if (!plugin.inherits) {
              _context7.next = 12;
              break;
            }

            inheritsDescriptor = {
              name: undefined,
              alias: alias + "$inherits",
              value: plugin.inherits,
              options: options,
              dirname: dirname
            };
            return _context7.delegateYield(forwardAsync(loadPluginDescriptor, function (run) {
              return cache.invalidate(function (data) {
                return run(inheritsDescriptor, data);
              });
            }), "t0", 7);

          case 7:
            inherits = _context7.t0;
            plugin.pre = chain(inherits.pre, plugin.pre);
            plugin.post = chain(inherits.post, plugin.post);
            plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);
            plugin.visitor = traverse.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);

          case 12:
            return _context7.abrupt("return", new Plugin$1(plugin, options, alias));

          case 13:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee3);
  }));

  var validateIfOptionNeedsFilename = function validateIfOptionNeedsFilename(options, descriptor) {
    if (options.test || options.include || options.exclude) {
      var formattedPresetName = descriptor.name ? "\"" + descriptor.name + "\"" : "/* your preset */";
      throw new Error(["Preset " + formattedPresetName + " requires a filename to be set when babel is called directly,", "```", "babel.transform(code, { filename: 'file.ts', presets: [" + formattedPresetName + "] });", "```", "See https://babeljs.io/docs/en/options#filename for more information."].join("\n"));
    }
  };

  var validatePreset = function validatePreset(preset, context, descriptor) {
    if (!context.filename) {
      var options = preset.options;
      validateIfOptionNeedsFilename(options, descriptor);

      if (options.overrides) {
        options.overrides.forEach(function (overrideOptions) {
          return validateIfOptionNeedsFilename(overrideOptions, descriptor);
        });
      }
    }
  };

  function loadPresetDescriptor(descriptor, context) {
    var preset;
    return regenerator.wrap(function loadPresetDescriptor$(_context8) {
      while (1) {
        switch (_context8.prev = _context8.next) {
          case 0:
            _context8.t0 = instantiatePreset;
            return _context8.delegateYield(presetDescriptorLoader(descriptor, context), "t1", 2);

          case 2:
            _context8.t2 = _context8.t1;
            preset = (0, _context8.t0)(_context8.t2);
            validatePreset(preset, context, descriptor);
            return _context8.delegateYield(buildPresetChain(preset, context), "t3", 6);

          case 6:
            return _context8.abrupt("return", _context8.t3);

          case 7:
          case "end":
            return _context8.stop();
        }
      }
    }, _marked2$1);
  }

  var instantiatePreset = makeWeakCacheSync(function (_ref3) {
    var value = _ref3.value,
        dirname = _ref3.dirname,
        alias = _ref3.alias;
    return {
      options: validate("preset", value),
      alias: alias,
      dirname: dirname
    };
  });

  function chain(a, b) {
    var fns = [a, b].filter(Boolean);
    if (fns.length <= 1) return fns[0];
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(fns), _step3; !(_step3 = _iterator3()).done;) {
        var fn = _step3.value;
        fn.apply(this, args);
      }
    };
  }

  var loadOptionsRunner = gensync(regenerator.mark(function _callee(opts) {
    var _config$options;

    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig(opts), "t0", 1);

          case 1:
            config = _context.t0;
            return _context.abrupt("return", (_config$options = config == null ? void 0 : config.options) != null ? _config$options : null);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var createConfigItemRunner = gensync(createConfigItem$1);

  var maybeErrback = function maybeErrback(runner) {
    return function (opts, callback) {
      if (callback === undefined && typeof opts === "function") {
        callback = opts;
        opts = undefined;
      }

      return callback ? runner.errback(opts, callback) : runner.sync(opts);
    };
  };

  var loadPartialConfig = maybeErrback(loadPartialConfig$1);
  var loadPartialConfigSync = loadPartialConfig$1.sync;
  var loadPartialConfigAsync = loadPartialConfig$1.async;
  var loadOptions = maybeErrback(loadOptionsRunner);
  var loadOptionsSync = loadOptionsRunner.sync;
  var loadOptionsAsync = loadOptionsRunner.async;
  var createConfigItemSync = createConfigItemRunner.sync;
  var createConfigItemAsync = createConfigItemRunner.async;
  function createConfigItem(target, options, callback) {
    if (callback !== undefined) {
      return createConfigItemRunner.errback(target, options, callback);
    } else if (typeof options === "function") {
      return createConfigItemRunner.errback(target, undefined, callback);
    } else {
      return createConfigItemRunner.sync(target, options);
    }
  }

  var PluginPass = function () {
    function PluginPass(file, key, options) {
      this._map = new Map();
      this.key = void 0;
      this.file = void 0;
      this.opts = void 0;
      this.cwd = void 0;
      this.filename = void 0;
      this.key = key;
      this.file = file;
      this.opts = options || {};
      this.cwd = file.opts.cwd;
      this.filename = file.opts.filename;
    }

    var _proto = PluginPass.prototype;

    _proto.set = function set(key, val) {
      this._map.set(key, val);
    };

    _proto.get = function get(key) {
      return this._map.get(key);
    };

    _proto.availableHelper = function availableHelper(name, versionRange) {
      return this.file.availableHelper(name, versionRange);
    };

    _proto.addHelper = function addHelper(name) {
      return this.file.addHelper(name);
    };

    _proto.addImport = function addImport() {
      return this.file.addImport();
    };

    _proto.buildCodeFrameError = function buildCodeFrameError(node, msg, _Error) {
      return this.file.buildCodeFrameError(node, msg, _Error);
    };

    return PluginPass;
  }();
  {
    PluginPass.prototype.getModuleName = function getModuleName() {
      return this.file.getModuleName();
    };
  }

  var LOADED_PLUGIN;
  function loadBlockHoistPlugin() {
    if (!LOADED_PLUGIN) {
      LOADED_PLUGIN = new Plugin$1(Object.assign({}, blockHoistPlugin, {
        visitor: traverse.explode(blockHoistPlugin.visitor)
      }), {});
    }

    return LOADED_PLUGIN;
  }

  function priority(bodyNode) {
    var priority = bodyNode == null ? void 0 : bodyNode._blockHoist;
    if (priority == null) return 1;
    if (priority === true) return 2;
    return priority;
  }

  function stableSort(body) {
    var buckets = Object.create(null);

    for (var i = 0; i < body.length; i++) {
      var n = body[i];
      var p = priority(n);
      var bucket = buckets[p] || (buckets[p] = []);
      bucket.push(n);
    }

    var keys = Object.keys(buckets).map(function (k) {
      return +k;
    }).sort(function (a, b) {
      return b - a;
    });
    var index = 0;

    for (var _iterator = _createForOfIteratorHelperLoose(keys), _step; !(_step = _iterator()).done;) {
      var key = _step.value;
      var _bucket = buckets[key];

      for (var _iterator2 = _createForOfIteratorHelperLoose(_bucket), _step2; !(_step2 = _iterator2()).done;) {
        var _n = _step2.value;
        body[index++] = _n;
      }
    }

    return body;
  }

  var blockHoistPlugin = {
    name: "internal.blockHoist",
    visitor: {
      Block: {
        exit: function exit(_ref) {
          var node = _ref.node;
          var body = node.body;
          var max = Math.pow(2, 30) - 1;
          var hasChange = false;

          for (var i = 0; i < body.length; i++) {
            var n = body[i];
            var p = priority(n);

            if (p > max) {
              hasChange = true;
              break;
            }

            max = p;
          }

          if (!hasChange) return;
          node.body = stableSort(body.slice());
        }
      }
    }
  };

  function normalizeOptions$4(config) {
    var _config$options = config.options,
        filename = _config$options.filename,
        cwd = _config$options.cwd,
        _config$options$filen = _config$options.filenameRelative,
        filenameRelative = _config$options$filen === void 0 ? typeof filename === "string" ? path$1.relative(cwd, filename) : "unknown" : _config$options$filen,
        _config$options$sourc = _config$options.sourceType,
        sourceType = _config$options$sourc === void 0 ? "module" : _config$options$sourc,
        inputSourceMap = _config$options.inputSourceMap,
        _config$options$sourc2 = _config$options.sourceMaps,
        sourceMaps = _config$options$sourc2 === void 0 ? !!inputSourceMap : _config$options$sourc2,
        _config$options$sourc3 = _config$options.sourceRoot,
        sourceRoot = _config$options$sourc3 === void 0 ? config.options.moduleRoot : _config$options$sourc3,
        _config$options$sourc4 = _config$options.sourceFileName,
        sourceFileName = _config$options$sourc4 === void 0 ? path$1.basename(filenameRelative) : _config$options$sourc4,
        _config$options$comme = _config$options.comments,
        comments = _config$options$comme === void 0 ? true : _config$options$comme,
        _config$options$compa = _config$options.compact,
        compact = _config$options$compa === void 0 ? "auto" : _config$options$compa;
    var opts = config.options;
    var options = Object.assign({}, opts, {
      parserOpts: Object.assign({
        sourceType: path$1.extname(filenameRelative) === ".mjs" ? "module" : sourceType,
        sourceFileName: filename,
        plugins: []
      }, opts.parserOpts),
      generatorOpts: Object.assign({
        filename: filename,
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        retainLines: opts.retainLines,
        comments: comments,
        shouldPrintComment: opts.shouldPrintComment,
        compact: compact,
        minified: opts.minified,
        sourceMaps: sourceMaps,
        sourceRoot: sourceRoot,
        sourceFileName: sourceFileName
      }, opts.generatorOpts)
    });

    for (var _iterator = _createForOfIteratorHelperLoose(config.passes), _step; !(_step = _iterator()).done;) {
      var plugins = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
        var plugin = _step2.value;

        if (plugin.manipulateOptions) {
          plugin.manipulateOptions(options, options.parserOpts);
        }
      }
    }

    return options;
  }

  var fs = {};

  var safeBuffer = createCommonjsModule(function (module, exports) {
    var Buffer = buffer.Buffer;

    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }

    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }

    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }

      return Buffer(arg, encodingOrOffset, length);
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      var buf = Buffer(size);

      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }

      return buf;
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return Buffer(size);
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return buffer.SlowBuffer(size);
    };
  }, "/$$rollup_base$$/packages/babel-core/node_modules/convert-source-map/node_modules/safe-buffer");

  var path = /*@__PURE__*/getAugmentedNamespace(path$2);

  var convertSourceMap = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, 'commentRegex', {
      get: function getCommentRegex() {
        return /^\s*\/(?:\/|\*)[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/mg;
      }
    });
    Object.defineProperty(exports, 'mapFileCommentRegex', {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+sourceMappingURL=([^\s'"`]+?)[ \t]*$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^\*]+?)[ \t]*(?:\*\/){1}[ \t]*$)/mg;
      }
    });

    function decodeBase64(base64) {
      return safeBuffer.Buffer.from(base64, 'base64').toString();
    }

    function stripComment(sm) {
      return sm.split(',').pop();
    }

    function readFromFileMap(sm, dir) {
      var r = exports.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      var filepath = path.resolve(dir, filename);

      try {
        return fs$1.readFileSync(filepath, 'utf8');
      } catch (e) {
        throw new Error('An error occurred while trying to read the map file at ' + filepath + '\n' + e);
      }
    }

    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);
      if (opts.hasComment) sm = stripComment(sm);
      if (opts.isEncoded) sm = decodeBase64(sm);
      if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);
      this.sourcemap = sm;
    }

    Converter.prototype.toJSON = function (space) {
      return JSON.stringify(this.sourcemap, null, space);
    };

    Converter.prototype.toBase64 = function () {
      var json = this.toJSON();
      return safeBuffer.Buffer.from(json, 'utf8').toString('base64');
    };

    Converter.prototype.toComment = function (options) {
      var base64 = this.toBase64();
      var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };

    Converter.prototype.toObject = function () {
      return JSON.parse(this.toJSON());
    };

    Converter.prototype.addProperty = function (key, value) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value);
    };

    Converter.prototype.setProperty = function (key, value) {
      this.sourcemap[key] = value;
      return this;
    };

    Converter.prototype.getProperty = function (key) {
      return this.sourcemap[key];
    };

    exports.fromObject = function (obj) {
      return new Converter(obj);
    };

    exports.fromJSON = function (json) {
      return new Converter(json, {
        isJSON: true
      });
    };

    exports.fromBase64 = function (base64) {
      return new Converter(base64, {
        isEncoded: true
      });
    };

    exports.fromComment = function (comment) {
      comment = comment.replace(/^\/\*/g, '//').replace(/\*\/$/g, '');
      return new Converter(comment, {
        isEncoded: true,
        hasComment: true
      });
    };

    exports.fromMapFileComment = function (comment, dir) {
      return new Converter(comment, {
        commentFileDir: dir,
        isFileComment: true,
        isJSON: true
      });
    };

    exports.fromSource = function (content) {
      var m = content.match(exports.commentRegex);
      return m ? exports.fromComment(m.pop()) : null;
    };

    exports.fromMapFileSource = function (content, dir) {
      var m = content.match(exports.mapFileCommentRegex);
      return m ? exports.fromMapFileComment(m.pop(), dir) : null;
    };

    exports.removeComments = function (src) {
      return src.replace(exports.commentRegex, '');
    };

    exports.removeMapFileComments = function (src) {
      return src.replace(exports.mapFileCommentRegex, '');
    };

    exports.generateMapFileComment = function (file, options) {
      var data = 'sourceMappingURL=' + file;
      return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;
    };
  }, "/$$rollup_base$$/packages/babel-core/node_modules/convert-source-map");

  var pluginNameMap = {
    asyncDoExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-async-do-expressions",
        url: "https://git.io/JYer8"
      }
    },
    classProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://git.io/vb4SL"
      }
    },
    classPrivateProperties: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-class-properties",
        url: "https://git.io/vb4SL"
      }
    },
    classPrivateMethods: {
      syntax: {
        name: "@babel/plugin-syntax-class-properties",
        url: "https://git.io/vb4yQ"
      },
      transform: {
        name: "@babel/plugin-proposal-private-methods",
        url: "https://git.io/JvpRG"
      }
    },
    classStaticBlock: {
      syntax: {
        name: "@babel/plugin-syntax-class-static-block",
        url: "https://git.io/JTLB6"
      },
      transform: {
        name: "@babel/plugin-proposal-class-static-block",
        url: "https://git.io/JTLBP"
      }
    },
    decimal: {
      syntax: {
        name: "@babel/plugin-syntax-decimal",
        url: "https://git.io/JfKOH"
      }
    },
    decorators: {
      syntax: {
        name: "@babel/plugin-syntax-decorators",
        url: "https://git.io/vb4y9"
      },
      transform: {
        name: "@babel/plugin-proposal-decorators",
        url: "https://git.io/vb4ST"
      }
    },
    doExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-do-expressions",
        url: "https://git.io/vb4yh"
      },
      transform: {
        name: "@babel/plugin-proposal-do-expressions",
        url: "https://git.io/vb4S3"
      }
    },
    dynamicImport: {
      syntax: {
        name: "@babel/plugin-syntax-dynamic-import",
        url: "https://git.io/vb4Sv"
      }
    },
    exportDefaultFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-default-from",
        url: "https://git.io/vb4SO"
      },
      transform: {
        name: "@babel/plugin-proposal-export-default-from",
        url: "https://git.io/vb4yH"
      }
    },
    exportNamespaceFrom: {
      syntax: {
        name: "@babel/plugin-syntax-export-namespace-from",
        url: "https://git.io/vb4Sf"
      },
      transform: {
        name: "@babel/plugin-proposal-export-namespace-from",
        url: "https://git.io/vb4SG"
      }
    },
    flow: {
      syntax: {
        name: "@babel/plugin-syntax-flow",
        url: "https://git.io/vb4yb"
      },
      transform: {
        name: "@babel/preset-flow",
        url: "https://git.io/JfeDn"
      }
    },
    functionBind: {
      syntax: {
        name: "@babel/plugin-syntax-function-bind",
        url: "https://git.io/vb4y7"
      },
      transform: {
        name: "@babel/plugin-proposal-function-bind",
        url: "https://git.io/vb4St"
      }
    },
    functionSent: {
      syntax: {
        name: "@babel/plugin-syntax-function-sent",
        url: "https://git.io/vb4yN"
      },
      transform: {
        name: "@babel/plugin-proposal-function-sent",
        url: "https://git.io/vb4SZ"
      }
    },
    importMeta: {
      syntax: {
        name: "@babel/plugin-syntax-import-meta",
        url: "https://git.io/vbKK6"
      }
    },
    jsx: {
      syntax: {
        name: "@babel/plugin-syntax-jsx",
        url: "https://git.io/vb4yA"
      },
      transform: {
        name: "@babel/preset-react",
        url: "https://git.io/JfeDR"
      }
    },
    importAssertions: {
      syntax: {
        name: "@babel/plugin-syntax-import-assertions",
        url: "https://git.io/JUbkv"
      }
    },
    moduleStringNames: {
      syntax: {
        name: "@babel/plugin-syntax-module-string-names",
        url: "https://git.io/JTL8G"
      }
    },
    numericSeparator: {
      syntax: {
        name: "@babel/plugin-syntax-numeric-separator",
        url: "https://git.io/vb4Sq"
      },
      transform: {
        name: "@babel/plugin-proposal-numeric-separator",
        url: "https://git.io/vb4yS"
      }
    },
    optionalChaining: {
      syntax: {
        name: "@babel/plugin-syntax-optional-chaining",
        url: "https://git.io/vb4Sc"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-chaining",
        url: "https://git.io/vb4Sk"
      }
    },
    pipelineOperator: {
      syntax: {
        name: "@babel/plugin-syntax-pipeline-operator",
        url: "https://git.io/vb4yj"
      },
      transform: {
        name: "@babel/plugin-proposal-pipeline-operator",
        url: "https://git.io/vb4SU"
      }
    },
    privateIn: {
      syntax: {
        name: "@babel/plugin-syntax-private-property-in-object",
        url: "https://git.io/JfK3q"
      },
      transform: {
        name: "@babel/plugin-proposal-private-property-in-object",
        url: "https://git.io/JfK3O"
      }
    },
    recordAndTuple: {
      syntax: {
        name: "@babel/plugin-syntax-record-and-tuple",
        url: "https://git.io/JvKp3"
      }
    },
    throwExpressions: {
      syntax: {
        name: "@babel/plugin-syntax-throw-expressions",
        url: "https://git.io/vb4SJ"
      },
      transform: {
        name: "@babel/plugin-proposal-throw-expressions",
        url: "https://git.io/vb4yF"
      }
    },
    typescript: {
      syntax: {
        name: "@babel/plugin-syntax-typescript",
        url: "https://git.io/vb4SC"
      },
      transform: {
        name: "@babel/preset-typescript",
        url: "https://git.io/JfeDz"
      }
    },
    asyncGenerators: {
      syntax: {
        name: "@babel/plugin-syntax-async-generators",
        url: "https://git.io/vb4SY"
      },
      transform: {
        name: "@babel/plugin-proposal-async-generator-functions",
        url: "https://git.io/vb4yp"
      }
    },
    logicalAssignment: {
      syntax: {
        name: "@babel/plugin-syntax-logical-assignment-operators",
        url: "https://git.io/vAlBp"
      },
      transform: {
        name: "@babel/plugin-proposal-logical-assignment-operators",
        url: "https://git.io/vAlRe"
      }
    },
    nullishCoalescingOperator: {
      syntax: {
        name: "@babel/plugin-syntax-nullish-coalescing-operator",
        url: "https://git.io/vb4yx"
      },
      transform: {
        name: "@babel/plugin-proposal-nullish-coalescing-operator",
        url: "https://git.io/vb4Se"
      }
    },
    objectRestSpread: {
      syntax: {
        name: "@babel/plugin-syntax-object-rest-spread",
        url: "https://git.io/vb4y5"
      },
      transform: {
        name: "@babel/plugin-proposal-object-rest-spread",
        url: "https://git.io/vb4Ss"
      }
    },
    optionalCatchBinding: {
      syntax: {
        name: "@babel/plugin-syntax-optional-catch-binding",
        url: "https://git.io/vb4Sn"
      },
      transform: {
        name: "@babel/plugin-proposal-optional-catch-binding",
        url: "https://git.io/vb4SI"
      }
    }
  };
  pluginNameMap.privateIn.syntax = pluginNameMap.privateIn.transform;

  var getNameURLCombination = function getNameURLCombination(_ref) {
    var name = _ref.name,
        url = _ref.url;
    return name + " (" + url + ")";
  };

  function generateMissingPluginMessage(missingPluginName, loc, codeFrame) {
    var helpMessage = "Support for the experimental syntax '" + missingPluginName + "' isn't currently enabled " + ("(" + loc.line + ":" + (loc.column + 1) + "):\n\n") + codeFrame;
    var pluginInfo = pluginNameMap[missingPluginName];

    if (pluginInfo) {
      var syntaxPlugin = pluginInfo.syntax,
          transformPlugin = pluginInfo.transform;

      if (syntaxPlugin) {
        var syntaxPluginInfo = getNameURLCombination(syntaxPlugin);

        if (transformPlugin) {
          var transformPluginInfo = getNameURLCombination(transformPlugin);
          var sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
          helpMessage += "\n\nAdd " + transformPluginInfo + " to the '" + sectionType + "' section of your Babel config to enable transformation.\nIf you want to leave it as-is, add " + syntaxPluginInfo + " to the 'plugins' section to enable parsing.";
        } else {
          helpMessage += "\n\nAdd " + syntaxPluginInfo + " to the 'plugins' section of your Babel config " + "to enable parsing.";
        }
      }
    }

    return helpMessage;
  }

  var _marked$2 = regenerator.mark(parser$1);
  function parser$1(pluginPasses, _ref, code) {
    var parserOpts, _ref$highlightCode, highlightCode, _ref$filename, filename, results, _iterator, _step, plugins, _iterator2, _step2, plugin, parserOverride, ast, loc, missingPlugin, codeFrame;

    return regenerator.wrap(function parser$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            parserOpts = _ref.parserOpts, _ref$highlightCode = _ref.highlightCode, highlightCode = _ref$highlightCode === void 0 ? true : _ref$highlightCode, _ref$filename = _ref.filename, filename = _ref$filename === void 0 ? "unknown" : _ref$filename;
            _context.prev = 1;
            results = [];

            for (_iterator = _createForOfIteratorHelperLoose(pluginPasses); !(_step = _iterator()).done;) {
              plugins = _step.value;

              for (_iterator2 = _createForOfIteratorHelperLoose(plugins); !(_step2 = _iterator2()).done;) {
                plugin = _step2.value;
                parserOverride = plugin.parserOverride;

                if (parserOverride) {
                  ast = parserOverride(code, parserOpts, parse$8);
                  if (ast !== undefined) results.push(ast);
                }
              }
            }

            if (!(results.length === 0)) {
              _context.next = 8;
              break;
            }

            return _context.abrupt("return", parse$8(code, parserOpts));

          case 8:
            if (!(results.length === 1)) {
              _context.next = 13;
              break;
            }

            return _context.delegateYield([], "t0", 10);

          case 10:
            if (!(typeof results[0].then === "function")) {
              _context.next = 12;
              break;
            }

            throw new Error("You appear to be using an async parser plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 12:
            return _context.abrupt("return", results[0]);

          case 13:
            throw new Error("More than one plugin attempted to override parsing.");

          case 16:
            _context.prev = 16;
            _context.t1 = _context["catch"](1);

            if (_context.t1.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
              _context.t1.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module " + "or sourceType:unambiguous in your Babel config for this file.";
            }

            loc = _context.t1.loc, missingPlugin = _context.t1.missingPlugin;

            if (loc) {
              codeFrame = codeFrameColumns(code, {
                start: {
                  line: loc.line,
                  column: loc.column + 1
                }
              }, {
                highlightCode: highlightCode
              });

              if (missingPlugin) {
                _context.t1.message = filename + ": " + generateMissingPluginMessage(missingPlugin[0], loc, codeFrame);
              } else {
                _context.t1.message = filename + ": " + _context.t1.message + "\n\n" + codeFrame;
              }

              _context.t1.code = "BABEL_PARSE_ERROR";
            }

            throw _context.t1;

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$2, null, [[1, 16]]);
  }

  var serialized = "$$ babel internal serialized type" + Math.random();

  function serialize(key, value) {
    var _ref;

    if (typeof value !== "bigint") return value;
    return _ref = {}, _ref[serialized] = "BigInt", _ref.value = value.toString(), _ref;
  }

  function revive(key, value) {
    if (!value || typeof value !== "object") return value;
    if (value[serialized] !== "BigInt") return value;
    return BigInt(value.value);
  }

  function cloneDeep (value) {
    return JSON.parse(JSON.stringify(value, serialize), revive);
  }

  var _marked$1 = regenerator.mark(normalizeFile);
  var debug$2 = browser$1("babel:transform:file");
  var LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;
  function normalizeFile(pluginPasses, options, code, ast) {
    var inputMap, lastComment, _lastComment, match, inputMapContent;

    return regenerator.wrap(function normalizeFile$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            code = "" + (code || "");

            if (!ast) {
              _context.next = 11;
              break;
            }

            if (!(ast.type === "Program")) {
              _context.next = 6;
              break;
            }

            ast = file(ast, [], []);
            _context.next = 8;
            break;

          case 6:
            if (!(ast.type !== "File")) {
              _context.next = 8;
              break;
            }

            throw new Error("AST root must be a Program or File node");

          case 8:
            if (options.cloneInputAst) {
              ast = cloneDeep(ast);
            }

            _context.next = 13;
            break;

          case 11:
            return _context.delegateYield(parser$1(pluginPasses, options, code), "t0", 12);

          case 12:
            ast = _context.t0;

          case 13:
            inputMap = null;

            if (options.inputSourceMap !== false) {
              if (typeof options.inputSourceMap === "object") {
                inputMap = convertSourceMap.fromObject(options.inputSourceMap);
              }

              if (!inputMap) {
                lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);

                if (lastComment) {
                  try {
                    inputMap = convertSourceMap.fromComment(lastComment);
                  } catch (err) {
                    debug$2("discarding unknown inline input sourcemap", err);
                  }
                }
              }

              if (!inputMap) {
                _lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);

                if (typeof options.filename === "string" && _lastComment) {
                  try {
                    match = EXTERNAL_SOURCEMAP_REGEX.exec(_lastComment);
                    inputMapContent = fs.readFileSync(path$1.resolve(path$1.dirname(options.filename), match[1]));

                    if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {
                      debug$2("skip merging input map > 1 MB");
                    } else {
                      inputMap = convertSourceMap.fromJSON(inputMapContent);
                    }
                  } catch (err) {
                    debug$2("discarding unknown file input sourcemap", err);
                  }
                } else if (_lastComment) {
                  debug$2("discarding un-loadable file input sourcemap");
                }
              }
            }

            return _context.abrupt("return", new File(options, {
              code: code,
              ast: ast,
              inputMap: inputMap
            }));

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _marked$1);
  }
  var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,(?:.*)$/;
  var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;

  function extractCommentsFromList(regex, comments, lastComment) {
    if (comments) {
      comments = comments.filter(function (_ref) {
        var value = _ref.value;

        if (regex.test(value)) {
          lastComment = value;
          return false;
        }

        return true;
      });
    }

    return [comments, lastComment];
  }

  function extractComments(regex, ast) {
    var lastComment = null;
    traverseFast(ast, function (node) {
      var _extractCommentsFromL = extractCommentsFromList(regex, node.leadingComments, lastComment);

      var _extractCommentsFromL2 = _slicedToArray$2(_extractCommentsFromL, 2);

      node.leadingComments = _extractCommentsFromL2[0];
      lastComment = _extractCommentsFromL2[1];

      var _extractCommentsFromL3 = extractCommentsFromList(regex, node.innerComments, lastComment);

      var _extractCommentsFromL4 = _slicedToArray$2(_extractCommentsFromL3, 2);

      node.innerComments = _extractCommentsFromL4[0];
      lastComment = _extractCommentsFromL4[1];

      var _extractCommentsFromL5 = extractCommentsFromList(regex, node.trailingComments, lastComment);

      var _extractCommentsFromL6 = _slicedToArray$2(_extractCommentsFromL5, 2);

      node.trailingComments = _extractCommentsFromL6[0];
      lastComment = _extractCommentsFromL6[1];
    });
    return lastComment;
  }

  var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

  var encode$1 = function encode(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }

    throw new TypeError("Must be between 0 and 63: " + number);
  };

  var decode$1 = function decode(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;

    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }

    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }

    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }

    if (charCode == plus) {
      return 62;
    }

    if (charCode == slash) {
      return 63;
    }

    return -1;
  };

  var base64 = {
    encode: encode$1,
    decode: decode$1
  };

  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;

  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }

  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }

  var encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);

    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;

      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }

      encoded += base64.encode(digit);
    } while (vlq > 0);

    return encoded;
  };

  var decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;

    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }

      digit = base64.decode(aStr.charCodeAt(aIndex++));

      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }

      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);

    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };

  var base64Vlq = {
    encode: encode,
    decode: decode
  };

  var util$4 = createCommonjsModule(function (module, exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }

    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;

    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);

      if (!match) {
        return null;
      }

      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }

    exports.urlParse = urlParse;

    function urlGenerate(aParsedUrl) {
      var url = '';

      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }

      url += '//';

      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }

      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }

      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }

      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }

      return url;
    }

    exports.urlGenerate = urlGenerate;

    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);

      if (url) {
        if (!url.path) {
          return aPath;
        }

        path = url.path;
      }

      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);

      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];

        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }

      path = parts.join('/');

      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }

      if (url) {
        url.path = path;
        return urlGenerate(url);
      }

      return path;
    }

    exports.normalize = normalize;

    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      if (aPath === "") {
        aPath = ".";
      }

      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);

      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }

      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }

        return urlGenerate(aPathUrl);
      }

      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }

      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }

      var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }

      return joined;
    }

    exports.join = join;

    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
    };

    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }

      aRoot = aRoot.replace(/\/$/, '');
      var level = 0;

      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");

        if (index < 0) {
          return aPath;
        }

        aRoot = aRoot.slice(0, index);

        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }

        ++level;
      }

      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }

    exports.relative = relative;

    var supportsNullProto = function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }();

    function identity(s) {
      return s;
    }

    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }

      return aStr;
    }

    exports.toSetString = supportsNullProto ? identity : toSetString;

    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }

      return aStr;
    }

    exports.fromSetString = supportsNullProto ? identity : fromSetString;

    function isProtoString(s) {
      if (!s) {
        return false;
      }

      var length = s.length;

      if (length < 9) {
          return false;
        }

      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }

      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
            return false;
          }
      }

      return true;
    }

    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByOriginalPositions = compareByOriginalPositions;

    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }

      cmp = mappingA.source - mappingB.source;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return mappingA.name - mappingB.name;
    }

    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }

      if (aStr1 > aStr2) {
        return 1;
      }

      return -1;
    }

    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.generatedColumn - mappingB.generatedColumn;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = strcmp(mappingA.source, mappingB.source);

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalLine - mappingB.originalLine;

      if (cmp !== 0) {
        return cmp;
      }

      cmp = mappingA.originalColumn - mappingB.originalColumn;

      if (cmp !== 0) {
        return cmp;
      }

      return strcmp(mappingA.name, mappingB.name);
    }

    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
  }, "/$$rollup_base$$/packages/babel-core/node_modules/source-map/lib");

  var has$9 = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";

  function ArraySet$2() {
    this._array = [];
    this._set = hasNativeMap ? new Map() : Object.create(null);
  }

  ArraySet$2.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet$2();

    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }

    return set;
  };

  ArraySet$2.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };

  ArraySet$2.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util$4.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has$9.call(this._set, sStr);
    var idx = this._array.length;

    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }

    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };

  ArraySet$2.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util$4.toSetString(aStr);
      return has$9.call(this._set, sStr);
    }
  };

  ArraySet$2.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);

      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util$4.toSetString(aStr);

      if (has$9.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }

    throw new Error('"' + aStr + '" is not in the set.');
  };

  ArraySet$2.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }

    throw new Error('No element indexed by ' + aIdx);
  };

  ArraySet$2.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };

  var ArraySet_1 = ArraySet$2;
  var arraySet = {
    ArraySet: ArraySet_1
  };

  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util$4.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }

  function MappingList$1() {
    this._array = [];
    this._sorted = true;
    this._last = {
      generatedLine: -1,
      generatedColumn: 0
    };
  }

  MappingList$1.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

  MappingList$1.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;

      this._array.push(aMapping);
    } else {
      this._sorted = false;

      this._array.push(aMapping);
    }
  };

  MappingList$1.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util$4.compareByGeneratedPositionsInflated);

      this._sorted = true;
    }

    return this._array;
  };

  var MappingList_1 = MappingList$1;
  var mappingList = {
    MappingList: MappingList_1
  };

  var ArraySet$1 = arraySet.ArraySet;
  var MappingList = mappingList.MappingList;

  function SourceMapGenerator$2(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }

    this._file = util$4.getArg(aArgs, 'file', null);
    this._sourceRoot = util$4.getArg(aArgs, 'sourceRoot', null);
    this._skipValidation = util$4.getArg(aArgs, 'skipValidation', false);
    this._sources = new ArraySet$1();
    this._names = new ArraySet$1();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }

  SourceMapGenerator$2.prototype._version = 3;

  SourceMapGenerator$2.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator$2({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;

        if (sourceRoot != null) {
          newMapping.source = util$4.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

  SourceMapGenerator$2.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util$4.getArg(aArgs, 'generated');
    var original = util$4.getArg(aArgs, 'original', null);
    var source = util$4.getArg(aArgs, 'source', null);
    var name = util$4.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);

      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);

      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

  SourceMapGenerator$2.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;

    if (this._sourceRoot != null) {
      source = util$4.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }

      this._sourcesContents[util$4.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util$4.toSetString(source)];

      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

  SourceMapGenerator$2.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;

    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
      }

      sourceFile = aSourceMapConsumer.file;
    }

    var sourceRoot = this._sourceRoot;

    if (sourceRoot != null) {
      sourceFile = util$4.relative(sourceRoot, sourceFile);
    }

    var newSources = new ArraySet$1();
    var newNames = new ArraySet$1();

    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });

        if (original.source != null) {
          mapping.source = original.source;

          if (aSourceMapPath != null) {
            mapping.source = util$4.join(aSourceMapPath, mapping.source);
          }

          if (sourceRoot != null) {
            mapping.source = util$4.relative(sourceRoot, mapping.source);
          }

          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;

          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;

      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;

      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }
    }, this);

    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util$4.join(aSourceMapPath, sourceFile);
        }

        if (sourceRoot != null) {
          sourceFile = util$4.relative(sourceRoot, sourceFile);
        }

        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

  SourceMapGenerator$2.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
      throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

  SourceMapGenerator$2.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();

    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = '';

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;

        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util$4.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }

          next += ',';
        }
      }

      next += base64Vlq.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64Vlq.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64Vlq.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64Vlq.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64Vlq.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

  SourceMapGenerator$2.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }

      if (aSourceRoot != null) {
        source = util$4.relative(aSourceRoot, source);
      }

      var key = util$4.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };

  SourceMapGenerator$2.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };

    if (this._file != null) {
      map.file = this._file;
    }

    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }

    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

  SourceMapGenerator$2.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

  var SourceMapGenerator_1 = SourceMapGenerator$2;
  var sourceMapGenerator = {
    SourceMapGenerator: SourceMapGenerator_1
  };

  var binarySearch = createCommonjsModule(function (module, exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;

    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);

      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }

        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }

    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }

      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

      if (index < 0) {
        return -1;
      }

      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }

        --index;
      }

      return index;
    };
  }, "/$$rollup_base$$/packages/babel-core/node_modules/source-map/lib");

  function swap(ary, x, y) {
    var temp = ary[x];
    ary[x] = ary[y];
    ary[y] = temp;
  }

  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }

  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];

      for (var j = p; j < r; j++) {
        if (comparator(ary[j], pivot) <= 0) {
          i += 1;
          swap(ary, i, j);
        }
      }

      swap(ary, i + 1, j);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }

  var quickSort_1 = function quickSort_1(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };

  var quickSort$1 = {
    quickSort: quickSort_1
  };

  var ArraySet = arraySet.ArraySet;
  var quickSort = quickSort$1.quickSort;

  function SourceMapConsumer$1(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap) : new BasicSourceMapConsumer(sourceMap);
  }

  SourceMapConsumer$1.fromSourceMap = function (aSourceMap) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
  };

  SourceMapConsumer$1.prototype._version = 3;
  SourceMapConsumer$1.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_generatedMappings', {
    get: function get() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__generatedMappings;
    }
  });
  SourceMapConsumer$1.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer$1.prototype, '_originalMappings', {
    get: function get() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }

      return this.__originalMappings;
    }
  });

  SourceMapConsumer$1.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
    var c = aStr.charAt(index);
    return c === ";" || c === ",";
  };

  SourceMapConsumer$1.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };

  SourceMapConsumer$1.GENERATED_ORDER = 1;
  SourceMapConsumer$1.ORIGINAL_ORDER = 2;
  SourceMapConsumer$1.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer$1.LEAST_UPPER_BOUND = 2;

  SourceMapConsumer$1.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context = aContext || null;
    var order = aOrder || SourceMapConsumer$1.GENERATED_ORDER;
    var mappings;

    switch (order) {
      case SourceMapConsumer$1.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;

      case SourceMapConsumer$1.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;

      default:
        throw new Error("Unknown order of iteration.");
    }

    var sourceRoot = this.sourceRoot;
    mappings.map(function (mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);

      if (source != null && sourceRoot != null) {
        source = util$4.join(sourceRoot, source);
      }

      return {
        source: source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context);
  };

  SourceMapConsumer$1.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util$4.getArg(aArgs, 'line');
    var needle = {
      source: util$4.getArg(aArgs, 'source'),
      originalLine: line,
      originalColumn: util$4.getArg(aArgs, 'column', 0)
    };

    if (this.sourceRoot != null) {
      needle.source = util$4.relative(this.sourceRoot, needle.source);
    }

    if (!this._sources.has(needle.source)) {
      return [];
    }

    needle.source = this._sources.indexOf(needle.source);
    var mappings = [];

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$4.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (aArgs.column === undefined) {
        var originalLine = mapping.originalLine;

        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util$4.getArg(mapping, 'generatedLine', null),
            column: util$4.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$4.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      } else {
        var originalColumn = mapping.originalColumn;

        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util$4.getArg(mapping, 'generatedLine', null),
            column: util$4.getArg(mapping, 'generatedColumn', null),
            lastColumn: util$4.getArg(mapping, 'lastGeneratedColumn', null)
          });
          mapping = this._originalMappings[++index];
        }
      }
    }

    return mappings;
  };

  var SourceMapConsumer_1 = SourceMapConsumer$1;

  function BasicSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$4.getArg(sourceMap, 'version');
    var sources = util$4.getArg(sourceMap, 'sources');
    var names = util$4.getArg(sourceMap, 'names', []);
    var sourceRoot = util$4.getArg(sourceMap, 'sourceRoot', null);
    var sourcesContent = util$4.getArg(sourceMap, 'sourcesContent', null);
    var mappings = util$4.getArg(sourceMap, 'mappings');
    var file = util$4.getArg(sourceMap, 'file', null);

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    sources = sources.map(String).map(util$4.normalize).map(function (source) {
      return sourceRoot && util$4.isAbsolute(sourceRoot) && util$4.isAbsolute(source) ? util$4.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this.file = file;
  }

  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer$1;

  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
    smc.file = aSourceMap._file;

    var generatedMappings = aSourceMap._mappings.toArray().slice();

    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];

    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;

      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;

        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }

        destOriginalMappings.push(destMapping);
      }

      destGeneratedMappings.push(destMapping);
    }

    quickSort(smc.__originalMappings, util$4.compareByOriginalPositions);
    return smc;
  };

  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      return this._sources.toArray().map(function (s) {
        return this.sourceRoot != null ? util$4.join(this.sourceRoot, s) : s;
      }, this);
    }
  });

  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }

  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str, segment, end, value;

    while (index < length) {
      if (aStr.charAt(index) === ';') {
        generatedLine++;
        index++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index) === ',') {
        index++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;

        for (end = index; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }

        str = aStr.slice(index, end);
        segment = cachedSegments[str];

        if (segment) {
          index += str.length;
        } else {
          segment = [];

          while (index < end) {
            base64Vlq.decode(aStr, index, temp);
            value = temp.value;
            index = temp.rest;
            segment.push(value);
          }

          if (segment.length === 2) {
            throw new Error('Found a source, but no line and column');
          }

          if (segment.length === 3) {
            throw new Error('Found a source and line, but no column');
          }

          cachedSegments[str] = segment;
        }

        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;

        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;

          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }

        generatedMappings.push(mapping);

        if (typeof mapping.originalLine === 'number') {
          originalMappings.push(mapping);
        }
      }
    }

    quickSort(generatedMappings, util$4.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort(originalMappings, util$4.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };

  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
    }

    if (aNeedle[aColumnName] < 0) {
      throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
    }

    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
  };

  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index = 0; index < this._generatedMappings.length; ++index) {
      var mapping = this._generatedMappings[index];

      if (index + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index + 1];

        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }

      mapping.lastGeneratedColumn = Infinity;
    }
  };

  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$4.getArg(aArgs, 'line'),
      generatedColumn: util$4.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util$4.compareByGeneratedPositionsDeflated, util$4.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._generatedMappings[index];

      if (mapping.generatedLine === needle.generatedLine) {
        var source = util$4.getArg(mapping, 'source', null);

        if (source !== null) {
          source = this._sources.at(source);

          if (this.sourceRoot != null) {
            source = util$4.join(this.sourceRoot, source);
          }
        }

        var name = util$4.getArg(mapping, 'name', null);

        if (name !== null) {
          name = this._names.at(name);
        }

        return {
          source: source,
          line: util$4.getArg(mapping, 'originalLine', null),
          column: util$4.getArg(mapping, 'originalColumn', null),
          name: name
        };
      }
    }

    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };

  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }

    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
      return sc == null;
    });
  };

  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }

    if (this.sourceRoot != null) {
      aSource = util$4.relative(this.sourceRoot, aSource);
    }

    if (this._sources.has(aSource)) {
      return this.sourcesContent[this._sources.indexOf(aSource)];
    }

    var url;

    if (this.sourceRoot != null && (url = util$4.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");

      if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }

      if ((!url.path || url.path == "/") && this._sources.has("/" + aSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util$4.getArg(aArgs, 'source');

    if (this.sourceRoot != null) {
      source = util$4.relative(this.sourceRoot, source);
    }

    if (!this._sources.has(source)) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }

    source = this._sources.indexOf(source);
    var needle = {
      source: source,
      originalLine: util$4.getArg(aArgs, 'line'),
      originalColumn: util$4.getArg(aArgs, 'column')
    };

    var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util$4.compareByOriginalPositions, util$4.getArg(aArgs, 'bias', SourceMapConsumer$1.GREATEST_LOWER_BOUND));

    if (index >= 0) {
      var mapping = this._originalMappings[index];

      if (mapping.source === needle.source) {
        return {
          line: util$4.getArg(mapping, 'generatedLine', null),
          column: util$4.getArg(mapping, 'generatedColumn', null),
          lastColumn: util$4.getArg(mapping, 'lastGeneratedColumn', null)
        };
      }
    }

    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };

  var BasicSourceMapConsumer_1 = BasicSourceMapConsumer;

  function IndexedSourceMapConsumer(aSourceMap) {
    var sourceMap = aSourceMap;

    if (typeof aSourceMap === 'string') {
      sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
    }

    var version = util$4.getArg(sourceMap, 'version');
    var sections = util$4.getArg(sourceMap, 'sections');

    if (version != this._version) {
      throw new Error('Unsupported version: ' + version);
    }

    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function (s) {
      if (s.url) {
        throw new Error('Support for url field in sections not implemented.');
      }

      var offset = util$4.getArg(s, 'offset');
      var offsetLine = util$4.getArg(offset, 'line');
      var offsetColumn = util$4.getArg(offset, 'column');

      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error('Section offsets must be ordered and non-overlapping.');
      }

      lastOffset = offset;
      return {
        generatedOffset: {
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer$1(util$4.getArg(s, 'map'))
      };
    });
  }

  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer$1.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer$1;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
    get: function get() {
      var sources = [];

      for (var i = 0; i < this._sections.length; i++) {
        for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
          sources.push(this._sections[i].consumer.sources[j]);
        }
      }

      return sources;
    }
  });

  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util$4.getArg(aArgs, 'line'),
      generatedColumn: util$4.getArg(aArgs, 'column')
    };
    var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
      var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

      if (cmp) {
        return cmp;
      }

      return needle.generatedColumn - section.generatedOffset.generatedColumn;
    });
    var section = this._sections[sectionIndex];

    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }

    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };

  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function (s) {
      return s.consumer.hasContentsOfAllSources();
    });
  };

  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);

      if (content) {
        return content;
      }
    }

    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };

  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];

      if (section.consumer.sources.indexOf(util$4.getArg(aArgs, 'source')) === -1) {
        continue;
      }

      var generatedPosition = section.consumer.generatedPositionFor(aArgs);

      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }

    return {
      line: null,
      column: null
    };
  };

  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];

    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;

      for (var j = 0; j < sectionMappings.length; j++) {
        var mapping = sectionMappings[j];

        var source = section.consumer._sources.at(mapping.source);

        if (section.consumer.sourceRoot !== null) {
          source = util$4.join(section.consumer.sourceRoot, source);
        }

        this._sources.add(source);

        source = this._sources.indexOf(source);

        var name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
        var adjustedMapping = {
          source: source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name
        };

        this.__generatedMappings.push(adjustedMapping);

        if (typeof adjustedMapping.originalLine === 'number') {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }

    quickSort(this.__generatedMappings, util$4.compareByGeneratedPositionsDeflated);
    quickSort(this.__originalMappings, util$4.compareByOriginalPositions);
  };

  var IndexedSourceMapConsumer_1 = IndexedSourceMapConsumer;
  var sourceMapConsumer = {
    SourceMapConsumer: SourceMapConsumer_1,
    BasicSourceMapConsumer: BasicSourceMapConsumer_1,
    IndexedSourceMapConsumer: IndexedSourceMapConsumer_1
  };

  var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
  var REGEX_NEWLINE = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";

  function SourceNode$1(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }

  SourceNode$1.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node = new SourceNode$1();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
    var remainingLinesIndex = 0;

    var shiftNextLine = function shiftNextLine() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;

      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
      }
    };

    var lastGeneratedLine = 1,
        lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function (mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex];
          var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code);
          lastMapping = mapping;
          return;
        }
      }

      while (lastGeneratedLine < mapping.generatedLine) {
        node.add(shiftNextLine());
        lastGeneratedLine++;
      }

      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex];
        node.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }

      lastMapping = mapping;
    }, this);

    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }

      node.add(remainingLines.splice(remainingLinesIndex).join(""));
    }

    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);

      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util$4.join(aRelativePath, sourceFile);
        }

        node.setSourceContent(sourceFile, content);
      }
    });
    return node;

    function addMappingWithCode(mapping, code) {
      if (mapping === null || mapping.source === undefined) {
        node.add(code);
      } else {
        var source = aRelativePath ? util$4.join(aRelativePath, mapping.source) : mapping.source;
        node.add(new SourceNode$1(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
      }
    }
  };

  SourceNode$1.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function (chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode$1.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
    }

    return this;
  };

  SourceNode$1.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;

    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];

      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== '') {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };

  SourceNode$1.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;

    if (len > 0) {
      newChildren = [];

      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }

      newChildren.push(this.children[i]);
      this.children = newChildren;
    }

    return this;
  };

  SourceNode$1.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];

    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === 'string') {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push(''.replace(aPattern, aReplacement));
    }

    return this;
  };

  SourceNode$1.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util$4.toSetString(aSourceFile)] = aSourceContent;
  };

  SourceNode$1.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }

    var sources = Object.keys(this.sourceContents);

    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util$4.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };

  SourceNode$1.prototype.toString = function SourceNode_toString() {
    var str = "";
    this.walk(function (chunk) {
      str += chunk;
    });
    return str;
  };

  SourceNode$1.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map = new SourceMapGenerator$1(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function (chunk, original) {
      generated.code += chunk;

      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }

        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }

      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;

          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function (sourceFile, sourceContent) {
      map.setSourceContent(sourceFile, sourceContent);
    });
    return {
      code: generated.code,
      map: map
    };
  };

  var SourceNode_1 = SourceNode$1;
  var sourceNode = {
    SourceNode: SourceNode_1
  };

  var SourceMapGenerator = sourceMapGenerator.SourceMapGenerator;
  var SourceMapConsumer = sourceMapConsumer.SourceMapConsumer;
  var SourceNode = sourceNode.SourceNode;
  var sourceMap = {
    SourceMapGenerator: SourceMapGenerator,
    SourceMapConsumer: SourceMapConsumer,
    SourceNode: SourceNode
  };

  function mergeSourceMap(inputMap, map) {
    var input = buildMappingData(inputMap);
    var output = buildMappingData(map);
    var mergedGenerator = new sourceMap.SourceMapGenerator();

    for (var _iterator = _createForOfIteratorHelperLoose(input.sources), _step; !(_step = _iterator()).done;) {
      var source = _step.value.source;

      if (typeof source.content === "string") {
        mergedGenerator.setSourceContent(source.path, source.content);
      }
    }

    if (output.sources.length === 1) {
      var defaultSource = output.sources[0];
      var insertedMappings = new Map();
      eachInputGeneratedRange(input, function (generated, original, source) {
        eachOverlappingGeneratedOutputRange(defaultSource, generated, function (item) {
          var key = makeMappingKey(item);
          if (insertedMappings.has(key)) return;
          insertedMappings.set(key, item);
          mergedGenerator.addMapping({
            source: source.path,
            original: {
              line: original.line,
              column: original.columnStart
            },
            generated: {
              line: item.line,
              column: item.columnStart
            },
            name: original.name
          });
        });
      });

      for (var _iterator2 = _createForOfIteratorHelperLoose(insertedMappings.values()), _step2; !(_step2 = _iterator2()).done;) {
        var _item = _step2.value;

        if (_item.columnEnd === Infinity) {
          continue;
        }

        var clearItem = {
          line: _item.line,
          columnStart: _item.columnEnd
        };
        var key = makeMappingKey(clearItem);

        if (insertedMappings.has(key)) {
          continue;
        }

        mergedGenerator.addMapping({
          generated: {
            line: clearItem.line,
            column: clearItem.columnStart
          }
        });
      }
    }

    var result = mergedGenerator.toJSON();

    if (typeof input.sourceRoot === "string") {
      result.sourceRoot = input.sourceRoot;
    }

    return result;
  }

  function makeMappingKey(item) {
    return item.line + "/" + item.columnStart;
  }

  function eachOverlappingGeneratedOutputRange(outputFile, inputGeneratedRange, callback) {
    var overlappingOriginal = filterApplicableOriginalRanges(outputFile, inputGeneratedRange);

    for (var _iterator3 = _createForOfIteratorHelperLoose(overlappingOriginal), _step3; !(_step3 = _iterator3()).done;) {
      var generated = _step3.value.generated;

      for (var _iterator4 = _createForOfIteratorHelperLoose(generated), _step4; !(_step4 = _iterator4()).done;) {
        var _item2 = _step4.value;
        callback(_item2);
      }
    }
  }

  function filterApplicableOriginalRanges(_ref, _ref2) {
    var mappings = _ref.mappings;
    var line = _ref2.line,
        columnStart = _ref2.columnStart,
        columnEnd = _ref2.columnEnd;
    return filterSortedArray(mappings, function (_ref3) {
      var outOriginal = _ref3.original;
      if (line > outOriginal.line) return -1;
      if (line < outOriginal.line) return 1;
      if (columnStart >= outOriginal.columnEnd) return -1;
      if (columnEnd <= outOriginal.columnStart) return 1;
      return 0;
    });
  }

  function eachInputGeneratedRange(map, callback) {
    for (var _iterator5 = _createForOfIteratorHelperLoose(map.sources), _step5; !(_step5 = _iterator5()).done;) {
      var _step5$value = _step5.value,
          source = _step5$value.source,
          mappings = _step5$value.mappings;

      for (var _iterator6 = _createForOfIteratorHelperLoose(mappings), _step6; !(_step6 = _iterator6()).done;) {
        var _step6$value = _step6.value,
            original = _step6$value.original,
            generated = _step6$value.generated;

        for (var _iterator7 = _createForOfIteratorHelperLoose(generated), _step7; !(_step7 = _iterator7()).done;) {
          var _item3 = _step7.value;
          callback(_item3, original, source);
        }
      }
    }
  }

  function buildMappingData(map) {
    var consumer = new sourceMap.SourceMapConsumer(Object.assign({}, map, {
      sourceRoot: null
    }));
    var sources = new Map();
    var mappings = new Map();
    var last = null;
    consumer.computeColumnSpans();
    consumer.eachMapping(function (m) {
      if (m.originalLine === null) return;
      var source = sources.get(m.source);

      if (!source) {
        source = {
          path: m.source,
          content: consumer.sourceContentFor(m.source, true)
        };
        sources.set(m.source, source);
      }

      var sourceData = mappings.get(source);

      if (!sourceData) {
        sourceData = {
          source: source,
          mappings: []
        };
        mappings.set(source, sourceData);
      }

      var obj = {
        line: m.originalLine,
        columnStart: m.originalColumn,
        columnEnd: Infinity,
        name: m.name
      };

      if (last && last.source === source && last.mapping.line === m.originalLine) {
        last.mapping.columnEnd = m.originalColumn;
      }

      last = {
        source: source,
        mapping: obj
      };
      sourceData.mappings.push({
        original: obj,
        generated: consumer.allGeneratedPositionsFor({
          source: m.source,
          line: m.originalLine,
          column: m.originalColumn
        }).map(function (item) {
          return {
            line: item.line,
            columnStart: item.column,
            columnEnd: item.lastColumn + 1
          };
        })
      });
    }, null, sourceMap.SourceMapConsumer.ORIGINAL_ORDER);
    return {
      file: map.file,
      sourceRoot: map.sourceRoot,
      sources: Array.from(mappings.values())
    };
  }

  function findInsertionLocation(array, callback) {
    var left = 0;
    var right = array.length;

    while (left < right) {
      var mid = Math.floor((left + right) / 2);
      var _item4 = array[mid];
      var result = callback(_item4);

      if (result === 0) {
        left = mid;
        break;
      }

      if (result >= 0) {
        right = mid;
      } else {
        left = mid + 1;
      }
    }

    var i = left;

    if (i < array.length) {
      while (i >= 0 && callback(array[i]) >= 0) {
        i--;
      }

      return i + 1;
    }

    return i;
  }

  function filterSortedArray(array, callback) {
    var start = findInsertionLocation(array, callback);
    var results = [];

    for (var i = start; i < array.length && callback(array[i]) === 0; i++) {
      results.push(array[i]);
    }

    return results;
  }

  function generateCode(pluginPasses, file) {
    var opts = file.opts,
        ast = file.ast,
        code = file.code,
        inputMap = file.inputMap;
    var results = [];

    for (var _iterator = _createForOfIteratorHelperLoose(pluginPasses), _step; !(_step = _iterator()).done;) {
      var plugins = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(plugins), _step2; !(_step2 = _iterator2()).done;) {
        var plugin = _step2.value;
        var generatorOverride = plugin.generatorOverride;

        if (generatorOverride) {
          var _result2 = generatorOverride(ast, opts.generatorOpts, code, generate$1);

          if (_result2 !== undefined) results.push(_result2);
        }
      }
    }

    var result;

    if (results.length === 0) {
      result = generate$1(ast, opts.generatorOpts, code);
    } else if (results.length === 1) {
      result = results[0];

      if (typeof result.then === "function") {
        throw new Error("You appear to be using an async codegen plugin, " + "which your current version of Babel does not support. " + "If you're using a published plugin, " + "you may need to upgrade your @babel/core version.");
      }
    } else {
      throw new Error("More than one plugin attempted to override codegen.");
    }

    var _result = result,
        outputCode = _result.code,
        outputMap = _result.map;

    if (outputMap && inputMap) {
      outputMap = mergeSourceMap(inputMap.toObject(), outputMap);
    }

    if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
      outputCode += "\n" + convertSourceMap.fromObject(outputMap).toComment();
    }

    if (opts.sourceMaps === "inline") {
      outputMap = null;
    }

    return {
      outputCode: outputCode,
      outputMap: outputMap
    };
  }

  var _marked = regenerator.mark(run$1),
      _marked2 = regenerator.mark(transformFile$1);
  function run$1(config, code, ast) {
    var file, opts, _opts$filename, outputCode, outputMap, _generateCode, _opts$filename2;

    return regenerator.wrap(function run$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(normalizeFile(config.passes, normalizeOptions$4(config), code, ast), "t0", 1);

          case 1:
            file = _context.t0;
            opts = file.opts;
            _context.prev = 3;
            return _context.delegateYield(transformFile$1(file, config.passes), "t1", 5);

          case 5:
            _context.next = 12;
            break;

          case 7:
            _context.prev = 7;
            _context.t2 = _context["catch"](3);
            _context.t2.message = ((_opts$filename = opts.filename) != null ? _opts$filename : "unknown") + ": " + _context.t2.message;

            if (!_context.t2.code) {
              _context.t2.code = "BABEL_TRANSFORM_ERROR";
            }

            throw _context.t2;

          case 12:
            _context.prev = 12;

            if (opts.code !== false) {
              _generateCode = generateCode(config.passes, file);
              outputCode = _generateCode.outputCode;
              outputMap = _generateCode.outputMap;
            }

            _context.next = 21;
            break;

          case 16:
            _context.prev = 16;
            _context.t3 = _context["catch"](12);
            _context.t3.message = ((_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown") + ": " + _context.t3.message;

            if (!_context.t3.code) {
              _context.t3.code = "BABEL_GENERATE_ERROR";
            }

            throw _context.t3;

          case 21:
            return _context.abrupt("return", {
              metadata: file.metadata,
              options: opts,
              ast: opts.ast === true ? file.ast : null,
              code: outputCode === undefined ? null : outputCode,
              map: outputMap === undefined ? null : outputMap,
              sourceType: file.ast.program.sourceType
            });

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _marked, null, [[3, 7], [12, 16]]);
  }

  function transformFile$1(file, pluginPasses) {
    var _iterator, _step, pluginPairs, passPairs, passes, visitors, _iterator2, _step2, _plugin2, _pass2, _i, _passPairs, _passPairs$_i, plugin, pass, fn, result, visitor, _i2, _passPairs2, _passPairs2$_i, _plugin, _pass, _fn, _result;

    return regenerator.wrap(function transformFile$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator = _createForOfIteratorHelperLoose(pluginPasses);

          case 1:
            if ((_step = _iterator()).done) {
              _context2.next = 35;
              break;
            }

            pluginPairs = _step.value;
            passPairs = [];
            passes = [];
            visitors = [];

            for (_iterator2 = _createForOfIteratorHelperLoose(pluginPairs.concat([loadBlockHoistPlugin()])); !(_step2 = _iterator2()).done;) {
              _plugin2 = _step2.value;
              _pass2 = new PluginPass(file, _plugin2.key, _plugin2.options);
              passPairs.push([_plugin2, _pass2]);
              passes.push(_pass2);
              visitors.push(_plugin2.visitor);
            }

            _i = 0, _passPairs = passPairs;

          case 8:
            if (!(_i < _passPairs.length)) {
              _context2.next = 19;
              break;
            }

            _passPairs$_i = _slicedToArray$2(_passPairs[_i], 2), plugin = _passPairs$_i[0], pass = _passPairs$_i[1];
            fn = plugin.pre;

            if (!fn) {
              _context2.next = 16;
              break;
            }

            result = fn.call(pass, file);
            return _context2.delegateYield([], "t0", 14);

          case 14:
            if (!isThenable(result)) {
              _context2.next = 16;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .pre, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 16:
            _i++;
            _context2.next = 8;
            break;

          case 19:
            visitor = traverse.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
            traverse(file.ast, visitor, file.scope);
            _i2 = 0, _passPairs2 = passPairs;

          case 22:
            if (!(_i2 < _passPairs2.length)) {
              _context2.next = 33;
              break;
            }

            _passPairs2$_i = _slicedToArray$2(_passPairs2[_i2], 2), _plugin = _passPairs2$_i[0], _pass = _passPairs2$_i[1];
            _fn = _plugin.post;

            if (!_fn) {
              _context2.next = 30;
              break;
            }

            _result = _fn.call(_pass, file);
            return _context2.delegateYield([], "t1", 28);

          case 28:
            if (!isThenable(_result)) {
              _context2.next = 30;
              break;
            }

            throw new Error("You appear to be using an plugin with an async .post, " + "which your current version of Babel does not support. " + "If you're using a published plugin, you may need to upgrade " + "your @babel/core version.");

          case 30:
            _i2++;
            _context2.next = 22;
            break;

          case 33:
            _context2.next = 1;
            break;

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked2);
  }

  function isThenable(val) {
    return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
  }

  var transformRunner = gensync(regenerator.mark(function transform(code, opts) {
    var config;
    return regenerator.wrap(function transform$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(run$1(config, code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, transform);
  }));
  var transform$2 = function transform(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return transformRunner.sync(code, opts);
    transformRunner.errback(code, opts, callback);
  };
  var transformSync = transformRunner.sync;
  var transformAsync = transformRunner.async;

  var transformFile = function transformFile(filename, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
    }

    callback(new Error("Transforming files is not supported in browsers"), null);
  };
  function transformFileSync() {
    throw new Error("Transforming files is not supported in browsers");
  }
  function transformFileAsync() {
    return Promise.reject(new Error("Transforming files is not supported in browsers"));
  }

  var transformFromAstRunner = gensync(regenerator.mark(function _callee(ast, code, opts) {
    var config;
    return regenerator.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            if (ast) {
              _context.next = 6;
              break;
            }

            throw new Error("No AST given");

          case 6:
            return _context.delegateYield(run$1(config, code, ast), "t1", 7);

          case 7:
            return _context.abrupt("return", _context.t1);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  var transformFromAst$1 = function transformFromAst(ast, code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) {
      return transformFromAstRunner.sync(ast, code, opts);
    }

    transformFromAstRunner.errback(ast, code, opts, callback);
  };
  var transformFromAstSync = transformFromAstRunner.sync;
  var transformFromAstAsync = transformFromAstRunner.async;

  var parseRunner = gensync(regenerator.mark(function parse(code, opts) {
    var config;
    return regenerator.wrap(function parse$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.delegateYield(loadConfig(opts), "t0", 1);

          case 1:
            config = _context.t0;

            if (!(config === null)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", null);

          case 4:
            return _context.delegateYield(parser$1(config.passes, normalizeOptions$4(config), code), "t1", 5);

          case 5:
            return _context.abrupt("return", _context.t1);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, parse);
  }));
  var parse$3 = function parse(code, opts, callback) {
    if (typeof opts === "function") {
      callback = opts;
      opts = undefined;
    }

    if (callback === undefined) return parseRunner.sync(code, opts);
    parseRunner.errback(code, opts, callback);
  };
  var parseSync = parseRunner.sync;
  var parseAsync = parseRunner.async;

  var version$3 = "7.14.6";
  var DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
  var OptionManager = function () {
    function OptionManager() {}

    var _proto = OptionManager.prototype;

    _proto.init = function init(opts) {
      return loadOptions(opts);
    };

    return OptionManager;
  }();
  function Plugin(alias) {
    throw new Error("The (" + alias + ") Babel 5 plugin is being run with an unsupported Babel version.");
  }

  function declare(builder) {
    return function (api, options, dirname) {
      var _clonedApi2;

      var clonedApi;

      for (var _i = 0, _Object$keys = Object.keys(apiPolyfills); _i < _Object$keys.length; _i++) {
        var _clonedApi;

        var name = _Object$keys[_i];
        if (api[name]) continue;
        clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api);
        clonedApi[name] = apiPolyfills[name](clonedApi);
      }

      return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
    };
  }
  var apiPolyfills = {
    assertVersion: function assertVersion(api) {
      return function (range) {
        throwVersionError(range, api.version);
      };
    },
    targets: function targets() {
      return function () {
        return {};
      };
    },
    assumption: function assumption() {
      return function () {};
    }
  };

  function copyApiObject(api) {
    var proto = null;

    if (typeof api.version === "string" && /^7\./.test(api.version)) {
      proto = Object.getPrototypeOf(api);

      if (proto && (!has$8(proto, "version") || !has$8(proto, "transform") || !has$8(proto, "template") || !has$8(proto, "types"))) {
        proto = null;
      }
    }

    return Object.assign({}, proto, api);
  }

  function has$8(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }

  function throwVersionError(range, version) {
    if (typeof range === "number") {
      if (!Number.isInteger(range)) {
        throw new Error("Expected string or integer value.");
      }

      range = "^" + range + ".0.0-0";
    }

    if (typeof range !== "string") {
      throw new Error("Expected string or integer value.");
    }

    var limit = Error.stackTraceLimit;

    if (typeof limit === "number" && limit < 25) {
      Error.stackTraceLimit = 25;
    }

    var err;

    if (version.slice(0, 2) === "7.") {
      err = new Error("Requires Babel \"^7.0.0-beta.41\", but was loaded with \"" + version + "\". " + "You'll need to update your @babel/core version.");
    } else {
      err = new Error("Requires Babel \"" + range + "\", but was loaded with \"" + version + "\". " + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + "the first entry that doesn't mention \"@babel/core\" or \"babel-core\" " + "to see what is calling Babel.");
    }

    if (typeof limit === "number") {
      Error.stackTraceLimit = limit;
    }

    throw Object.assign(err, {
      code: "BABEL_VERSION_UNSUPPORTED",
      version: version,
      range: range
    });
  }

  var src = /*#__PURE__*/Object.freeze({
    __proto__: null,
    declare: declare
  });

  var externalHelpers = declare(function (api, options) {
    api.assertVersion(7);
    var _options$helperVersio = options.helperVersion,
        helperVersion = _options$helperVersio === void 0 ? "7.0.0-beta.0" : _options$helperVersio,
        _options$whitelist = options.whitelist,
        whitelist = _options$whitelist === void 0 ? false : _options$whitelist;

    if (whitelist !== false && (!Array.isArray(whitelist) || whitelist.some(function (w) {
      return typeof w !== "string";
    }))) {
      throw new Error(".whitelist must be undefined, false, or an array of strings");
    }

    var helperWhitelist = whitelist ? new Set(whitelist) : null;
    return {
      name: "external-helpers",
      pre: function pre(file) {
        file.set("helperGenerator", function (name) {
          if (file.availableHelper && !file.availableHelper(name, helperVersion)) {
            return;
          }

          if (helperWhitelist && !helperWhitelist.has(name)) return;
          return memberExpression(identifier("babelHelpers"), identifier(name));
        });
      }
    };
  });

  var _helperPluginUtils = /*@__PURE__*/getAugmentedNamespace(src);

  var lib$q = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-async-generators/lib");

  var lib$p = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-class-properties",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-class-properties/lib");

  var _syntaxClassStaticBlock = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-class-static-block",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classStaticBlock");
      }
    };
  });

  var syntaxDecimal = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-decimal",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("decimal");
      }
    };
  });

  var syntaxDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The '@babel/plugin-syntax-decorators' plugin requires a" + " 'decoratorsBeforeExport' option, whose value must be a boolean." + " If you want to use the legacy decorators semantics, you can set" + " the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    return {
      name: "syntax-decorators",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(legacy ? "decorators-legacy" : ["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
      }
    };
  });

  var syntaxDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-do-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("doExpressions");
      }
    };
  });

  var syntaxExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-export-default-from",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("exportDefaultFrom");
      }
    };
  });

  var syntaxFlow = declare(function (api, options) {
    api.assertVersion(7);
    var all = options.all,
        enums = options.enums;

    if (typeof all !== "boolean" && typeof all !== "undefined") {
      throw new Error(".all must be a boolean, or undefined");
    }

    if (typeof enums !== "boolean" && typeof enums !== "undefined") {
      throw new Error(".enums must be a boolean, or undefined");
    }

    return {
      name: "syntax-flow",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push(["flow", {
          all: all,
          enums: enums
        }]);
      }
    };
  });

  var syntaxFunctionBind = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-bind",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionBind");
      }
    };
  });

  var syntaxFunctionSent = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-function-sent",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("functionSent");
      }
    };
  });

  var syntaxModuleBlocks = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-module-blocks",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("moduleBlocks");
      }
    };
  });

  var lib$o = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-import-meta",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("importMeta");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-import-meta/lib");

  var syntaxJsx = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-jsx",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        if (parserOpts.plugins.some(function (p) {
          return (Array.isArray(p) ? p[0] : p) === "typescript";
        })) {
          return;
        }

        parserOpts.plugins.push("jsx");
      }
    };
  });

  var syntaxImportAssertions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-import-assertions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(["importAssertions"]);
      }
    };
  });

  var lib$n = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

  var lib$m = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-standalone/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

  var proposals = ["minimal", "smart", "fsharp"];
  var syntaxPipelineOperator = declare(function (api, _ref) {
    var proposal = _ref.proposal;
    api.assertVersion(7);

    if (typeof proposal !== "string" || !proposals.includes(proposal)) {
      throw new Error("The pipeline operator plugin requires a 'proposal' option." + "'proposal' must be one of: " + proposals.join(", ") + ". More details: https://babeljs.io/docs/en/next/babel-plugin-proposal-pipeline-operator");
    }

    return {
      name: "syntax-pipeline-operator",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push(["pipelineOperator", {
          proposal: proposal
        }]);
      }
    };
  });

  var syntaxRecordAndTuple = declare(function (api, options) {
    api.assertVersion(7);
    return {
      name: "syntax-record-and-tuple",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        opts.generatorOpts.recordAndTupleSyntaxType = options.syntaxType;
        parserOpts.plugins.push(["recordAndTuple", {
          syntaxType: options.syntaxType
        }]);
      }
    };
  });

  var _syntaxTopLevelAwait = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-top-level-await",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("topLevelAwait");
      }
    };
  });

  function removePlugin(plugins, name) {
    var indices = [];
    plugins.forEach(function (plugin, i) {
      var n = Array.isArray(plugin) ? plugin[0] : plugin;

      if (n === name) {
        indices.unshift(i);
      }
    });

    for (var _i = 0, _indices = indices; _i < _indices.length; _i++) {
      var i = _indices[_i];
      plugins.splice(i, 1);
    }
  }

  var syntaxTypescript = declare(function (api, _ref) {
    var isTSX = _ref.isTSX;
    api.assertVersion(7);
    return {
      name: "syntax-typescript",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        var plugins = parserOpts.plugins;
        removePlugin(plugins, "flow");
        removePlugin(plugins, "jsx");
        parserOpts.plugins.push("typescript", "classProperties");
        {
          parserOpts.plugins.push("objectRestSpread");
        }

        if (isTSX) {
          parserOpts.plugins.push("jsx");
        }
      }
    };
  });

  var buildAnonymousExpressionWrapper = template$2.expression("\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n");
  var buildNamedExpressionWrapper = template$2.expression("\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n");
  var buildDeclarationWrapper = template$2("\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n");

  function classOrObjectMethod(path, callId) {
    var node = path.node;
    var body = node.body;
    var container = functionExpression(null, [], blockStatement(body.body), true);
    body.body = [returnStatement(callExpression(callExpression(callId, [container]), []))];
    node.async = false;
    node.generator = false;
    path.get("body.body.0.argument.callee.arguments.0").unwrapFunctionEnvironment();
  }

  function plainFunction(path, callId, noNewArrows) {
    var node = path.node;
    var isDeclaration = path.isFunctionDeclaration();
    var functionId = node.id;
    var wrapper = isDeclaration ? buildDeclarationWrapper : functionId ? buildNamedExpressionWrapper : buildAnonymousExpressionWrapper;

    if (path.isArrowFunctionExpression()) {
      path.arrowFunctionToExpression({
        noNewArrows: noNewArrows
      });
    }

    node.id = null;

    if (isDeclaration) {
      node.type = "FunctionExpression";
    }

    var built = callExpression(callId, [node]);
    var container = wrapper({
      NAME: functionId || null,
      REF: path.scope.generateUidIdentifier(functionId ? functionId.name : "ref"),
      FUNCTION: built,
      PARAMS: node.params.reduce(function (acc, param) {
        acc.done = acc.done || isAssignmentPattern(param) || isRestElement(param);

        if (!acc.done) {
          acc.params.push(path.scope.generateUidIdentifier("x"));
        }

        return acc;
      }, {
        params: [],
        done: false
      }).params
    });

    if (isDeclaration) {
      path.replaceWith(container[0]);
      path.insertAfter(container[1]);
    } else {
      var retFunction = container.callee.body.body[1].argument;

      if (!functionId) {
        nameFunction({
          node: retFunction,
          parent: path.parent,
          scope: path.scope
        });
      }

      if (!retFunction || retFunction.id || node.params.length) {
        path.replaceWith(container);
      } else {
        path.replaceWith(built);
      }
    }
  }

  function wrapFunction(path, callId, noNewArrows) {
    if (noNewArrows === void 0) {
      noNewArrows = true;
    }

    if (path.isMethod()) {
      classOrObjectMethod(path, callId);
    } else {
      plainFunction(path, callId, noNewArrows);
    }
  }

  var PURE_ANNOTATION = "#__PURE__";

  var isPureAnnotated = function isPureAnnotated(_ref) {
    var leadingComments = _ref.leadingComments;
    return !!leadingComments && leadingComments.some(function (comment) {
      return /[@#]__PURE__/.test(comment.value);
    });
  };

  function annotateAsPure(pathOrNode) {
    var node = pathOrNode["node"] || pathOrNode;

    if (isPureAnnotated(node)) {
      return;
    }

    addComment$1(node, "leading", PURE_ANNOTATION);
  }

  var awaitVisitor$1 = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path, _ref) {
      var wrapAwait = _ref.wrapAwait;
      var argument = path.get("argument");

      if (path.parentPath.isYieldExpression()) {
        path.replaceWith(argument.node);
        return;
      }

      path.replaceWith(yieldExpression(wrapAwait ? callExpression(cloneNode(wrapAwait), [argument.node]) : argument.node));
    }
  };
  function remapAsyncToGenerator (path, helpers, noNewArrows) {
    path.traverse(awaitVisitor$1, {
      wrapAwait: helpers.wrapAwait
    });
    var isIIFE = checkIsIIFE(path);
    path.node.async = false;
    path.node.generator = true;
    wrapFunction(path, cloneNode(helpers.wrapAsync), noNewArrows);
    var isProperty = path.isObjectMethod() || path.isClassMethod() || path.parentPath.isObjectProperty() || path.parentPath.isClassProperty();

    if (!isProperty && !isIIFE && path.isExpression()) {
      annotateAsPure(path);
    }

    function checkIsIIFE(path) {
      if (path.parentPath.isCallExpression({
        callee: path.node
      })) {
        return true;
      }

      var parentPath = path.parentPath;

      if (parentPath.isMemberExpression() && isIdentifier(parentPath.node.property, {
        name: "bind"
      })) {
        var bindCall = parentPath.parentPath;
        return bindCall.isCallExpression() && bindCall.node.arguments.length === 1 && isThisExpression(bindCall.node.arguments[0]) && bindCall.parentPath.isCallExpression({
          callee: bindCall.node
        });
      }

      return false;
    }
  }

  var lib$l = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-async-generator-functions/node_modules/@babel/plugin-syntax-async-generators/lib");

  var buildForAwait = template$2("\n  async function wrapper() {\n    var ITERATOR_COMPLETION = true;\n    var ITERATOR_HAD_ERROR_KEY = false;\n    var ITERATOR_ERROR_KEY;\n    try {\n      for (\n        var ITERATOR_KEY = GET_ITERATOR(OBJECT), STEP_KEY, STEP_VALUE;\n        (\n          STEP_KEY = await ITERATOR_KEY.next(),\n          ITERATOR_COMPLETION = STEP_KEY.done,\n          STEP_VALUE = await STEP_KEY.value,\n          !ITERATOR_COMPLETION\n        );\n        ITERATOR_COMPLETION = true) {\n      }\n    } catch (err) {\n      ITERATOR_HAD_ERROR_KEY = true;\n      ITERATOR_ERROR_KEY = err;\n    } finally {\n      try {\n        if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n          await ITERATOR_KEY.return();\n        }\n      } finally {\n        if (ITERATOR_HAD_ERROR_KEY) {\n          throw ITERATOR_ERROR_KEY;\n        }\n      }\n    }\n  }\n");
  function rewriteForAwait (path, _ref) {
    var getAsyncIterator = _ref.getAsyncIterator;
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var stepKey = scope.generateUidIdentifier("step");
    var stepValue = scope.generateUidIdentifier("value");
    var left = node.left;
    var declar;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = expressionStatement(assignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
    }

    var template = buildForAwait({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      GET_ITERATOR: getAsyncIterator,
      OBJECT: node.right,
      STEP_VALUE: cloneNode(stepValue),
      STEP_KEY: stepKey
    });
    template = template.body.body;
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      node: template,
      declar: declar,
      loop: loop
    };
  }

  var _proposalAsyncGeneratorFunctions = declare(function (api) {
    api.assertVersion(7);
    var yieldStarVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(_ref, state) {
        var node = _ref.node;
        if (!node.delegate) return;
        var callee = state.addHelper("asyncGeneratorDelegate");
        node.argument = callExpression(callee, [callExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
      }
    };
    var forAwaitVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      ForOfStatement: function ForOfStatement(path, _ref2) {
        var file = _ref2.file;
        var node = path.node;
        if (!node["await"]) return;
        var build = rewriteForAwait(path, {
          getAsyncIterator: file.addHelper("asyncIterator")
        });
        var declar = build.declar,
            loop = build.loop;
        var block = loop.body;
        path.ensureBlock();

        if (declar) {
          block.body.push(declar);
        }

        block.body = block.body.concat(node.body.body);
        inherits(loop, node);
        inherits(loop.body, node.body);

        if (build.replaceParent) {
          path.parentPath.replaceWithMultiple(build.node);
        } else {
          path.replaceWithMultiple(build.node);
        }
      }
    };
    var visitor = {
      Function: function Function(path, state) {
        if (!path.node.async) return;
        path.traverse(forAwaitVisitor, state);
        if (!path.node.generator) return;
        path.traverse(yieldStarVisitor, state);
        remapAsyncToGenerator(path, {
          wrapAsync: state.addHelper("wrapAsyncGenerator"),
          wrapAwait: state.addHelper("awaitAsyncGenerator")
        });
      }
    };
    return {
      name: "proposal-async-generator-functions",
      inherits: lib$l["default"],
      visitor: {
        Program: function Program(path, state) {
          path.traverse(visitor, state);
        }
      }
    };
  });

  function assertFieldTransformed(path) {
    if (path.node.declare) {
      throw path.buildCodeFrameError("TypeScript 'declare' fields must first be transformed by " + "@babel/plugin-transform-typescript.\n" + "If you have already enabled that plugin (or '@babel/preset-typescript'), make sure " + "that it runs before any plugin related to additional class features:\n" + " - @babel/plugin-proposal-class-properties\n" + " - @babel/plugin-proposal-private-methods\n" + " - @babel/plugin-proposal-decorators");
    }
  }

  var _templateObject$j, _templateObject2$9, _templateObject3$8, _templateObject4$4, _templateObject5$2, _templateObject6$2, _templateObject7$1, _templateObject8, _templateObject9, _templateObject10, _templateObject11, _templateObject12, _templateObject13, _templateObject14, _templateObject15, _templateObject16;
  function buildPrivateNamesMap(props) {
    var privateNamesMap = new Map();

    for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
      var prop = _step.value;
      var isPrivate = prop.isPrivate();
      var isMethod = !prop.isProperty();
      var isInstance = !prop.node["static"];

      if (isPrivate) {
        var name = prop.node.key.id.name;
        var update = privateNamesMap.has(name) ? privateNamesMap.get(name) : {
          id: prop.scope.generateUidIdentifier(name),
          "static": !isInstance,
          method: isMethod
        };

        if (prop.node.kind === "get") {
          update.getId = prop.scope.generateUidIdentifier("get_" + name);
        } else if (prop.node.kind === "set") {
          update.setId = prop.scope.generateUidIdentifier("set_" + name);
        } else if (prop.node.kind === "method") {
          update.methodId = prop.scope.generateUidIdentifier(name);
        }

        privateNamesMap.set(name, update);
      }
    }

    return privateNamesMap;
  }
  function buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties, state) {
    var initNodes = [];

    for (var _iterator2 = _createForOfIteratorHelperLoose(privateNamesMap), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _slicedToArray$2(_step2.value, 2),
          name = _step2$value[0],
          value = _step2$value[1];

      var isStatic = value["static"],
          isMethod = value.method,
          getId = value.getId,
          setId = value.setId;
      var isAccessor = getId || setId;
      var id = cloneNode(value.id);
      var init = void 0;

      if (privateFieldsAsProperties) {
        init = callExpression(state.addHelper("classPrivateFieldLooseKey"), [stringLiteral(name)]);
      } else if (!isStatic) {
        init = newExpression(identifier(!isMethod || isAccessor ? "WeakMap" : "WeakSet"), []);
      }

      if (init) {
        annotateAsPure(init);
        initNodes.push(template$2.statement.ast(_templateObject$j || (_templateObject$j = _taggedTemplateLiteralLoose(["var ", " = ", ""])), id, init));
      }
    }

    return initNodes;
  }

  function privateNameVisitorFactory(visitor) {
    var privateNameVisitor = Object.assign({}, visitor, {
      Class: function Class(path) {
        var privateNamesMap = this.privateNamesMap;
        var body = path.get("body.body");
        var visiblePrivateNames = new Map(privateNamesMap);
        var redeclared = [];

        for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
          var prop = _step3.value;
          if (!prop.isPrivate()) continue;
          var name = prop.node.key.id.name;
          visiblePrivateNames["delete"](name);
          redeclared.push(name);
        }

        if (!redeclared.length) {
          return;
        }

        path.get("body").traverse(nestedVisitor, Object.assign({}, this, {
          redeclared: redeclared
        }));
        path.traverse(privateNameVisitor, Object.assign({}, this, {
          privateNamesMap: visiblePrivateNames
        }));
        path.skipKey("body");
      }
    });
    var nestedVisitor = traverse.visitors.merge([Object.assign({}, visitor), environmentVisitor]);
    return privateNameVisitor;
  }

  var privateNameVisitor = privateNameVisitorFactory({
    PrivateName: function PrivateName(path, _ref) {
      var noDocumentAll = _ref.noDocumentAll;
      var privateNamesMap = this.privateNamesMap,
          redeclared = this.redeclared;
      var node = path.node,
          parentPath = path.parentPath;

      if (!parentPath.isMemberExpression({
        property: node
      }) && !parentPath.isOptionalMemberExpression({
        property: node
      })) {
        return;
      }

      var name = node.id.name;
      if (!privateNamesMap.has(name)) return;
      if (redeclared && redeclared.includes(name)) return;
      this.handle(parentPath, noDocumentAll);
    }
  });
  var privateInVisitor = privateNameVisitorFactory({
    BinaryExpression: function BinaryExpression(path) {
      var _path$node = path.node,
          operator = _path$node.operator,
          left = _path$node.left,
          right = _path$node.right;
      if (operator !== "in") return;
      if (!path.get("left").isPrivateName()) return;
      var privateFieldsAsProperties = this.privateFieldsAsProperties,
          privateNamesMap = this.privateNamesMap,
          redeclared = this.redeclared;
      var name = left.id.name;
      if (!privateNamesMap.has(name)) return;
      if (redeclared && redeclared.includes(name)) return;

      if (privateFieldsAsProperties) {
        var _privateNamesMap$get = privateNamesMap.get(name),
            _id = _privateNamesMap$get.id;

        path.replaceWith(template$2.expression.ast(_templateObject2$9 || (_templateObject2$9 = _taggedTemplateLiteralLoose(["\n        Object.prototype.hasOwnProperty.call(", ", ", ")\n      "])), right, cloneNode(_id)));
        return;
      }

      var _privateNamesMap$get2 = privateNamesMap.get(name),
          id = _privateNamesMap$get2.id,
          isStatic = _privateNamesMap$get2["static"];

      if (isStatic) {
        path.replaceWith(template$2.expression.ast(_templateObject3$8 || (_templateObject3$8 = _taggedTemplateLiteralLoose(["", " === ", ""])), right, this.classRef));
        return;
      }

      path.replaceWith(template$2.expression.ast(_templateObject4$4 || (_templateObject4$4 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), cloneNode(id), right));
    }
  });
  var privateNameHandlerSpec = {
    memoise: function memoise(member, count) {
      var scope = member.scope;
      var object = member.node.object;
      var memo = scope.maybeGenerateMemoised(object);

      if (!memo) {
        return;
      }

      this.memoiser.set(object, memo, count);
    },
    receiver: function receiver(member) {
      var object = member.node.object;

      if (this.memoiser.has(object)) {
        return cloneNode(this.memoiser.get(object));
      }

      return cloneNode(object);
    },
    get: function get(member) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get3 = privateNamesMap.get(name),
          id = _privateNamesMap$get3.id,
          isStatic = _privateNamesMap$get3["static"],
          isMethod = _privateNamesMap$get3.method,
          methodId = _privateNamesMap$get3.methodId,
          getId = _privateNamesMap$get3.getId,
          setId = _privateNamesMap$get3.setId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodGet" : "classStaticPrivateFieldSpecGet";
        return callExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id)]);
      }

      if (isMethod) {
        if (isAccessor) {
          if (!getId && setId) {
            if (file.availableHelper("writeOnlyError")) {
              return sequenceExpression([this.receiver(member), callExpression(file.addHelper("writeOnlyError"), [stringLiteral("#" + name)])]);
            }

            console.warn("@babel/helpers is outdated, update it to silence this warning.");
          }

          return callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
        }

        return callExpression(file.addHelper("classPrivateMethodGet"), [this.receiver(member), cloneNode(id), cloneNode(methodId)]);
      }

      return callExpression(file.addHelper("classPrivateFieldGet"), [this.receiver(member), cloneNode(id)]);
    },
    boundGet: function boundGet(member) {
      this.memoise(member, 1);
      return callExpression(memberExpression(this.get(member), identifier("bind")), [this.receiver(member)]);
    },
    set: function set(member, value) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get4 = privateNamesMap.get(name),
          id = _privateNamesMap$get4.id,
          isStatic = _privateNamesMap$get4["static"],
          isMethod = _privateNamesMap$get4.method,
          setId = _privateNamesMap$get4.setId,
          getId = _privateNamesMap$get4.getId;

      var isAccessor = getId || setId;

      if (isStatic) {
        var helperName = isMethod && !isAccessor ? "classStaticPrivateMethodSet" : "classStaticPrivateFieldSpecSet";
        return callExpression(file.addHelper(helperName), [this.receiver(member), cloneNode(classRef), cloneNode(id), value]);
      }

      if (isMethod) {
        if (setId) {
          return callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
        }

        return sequenceExpression([this.receiver(member), value, callExpression(file.addHelper("readOnlyError"), [stringLiteral("#" + name)])]);
      }

      return callExpression(file.addHelper("classPrivateFieldSet"), [this.receiver(member), cloneNode(id), value]);
    },
    destructureSet: function destructureSet(member) {
      var classRef = this.classRef,
          privateNamesMap = this.privateNamesMap,
          file = this.file;
      var name = member.node.property.id.name;

      var _privateNamesMap$get5 = privateNamesMap.get(name),
          id = _privateNamesMap$get5.id,
          isStatic = _privateNamesMap$get5["static"];

      if (isStatic) {
        try {
          var helper = file.addHelper("classStaticPrivateFieldDestructureSet");
        } catch (_unused) {
          throw new Error("Babel can not transpile `[C.#p] = [0]` with @babel/helpers < 7.13.10, \n" + "please update @babel/helpers to the latest version.");
        }

        return memberExpression(callExpression(helper, [this.receiver(member), cloneNode(classRef), cloneNode(id)]), identifier("value"));
      }

      return memberExpression(callExpression(file.addHelper("classPrivateFieldDestructureSet"), [this.receiver(member), cloneNode(id)]), identifier("value"));
    },
    call: function call(member, args) {
      this.memoise(member, 1);
      return optimiseCallExpression(this.get(member), this.receiver(member), args, false);
    },
    optionalCall: function optionalCall(member, args) {
      this.memoise(member, 1);
      return optimiseCallExpression(this.get(member), this.receiver(member), args, true);
    }
  };
  var privateNameHandlerLoose = {
    get: function get(member) {
      var privateNamesMap = this.privateNamesMap,
          file = this.file;
      var object = member.node.object;
      var name = member.node.property.id.name;
      return template$2.expression(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteralLoose(["BASE(REF, PROP)[PROP]"])))({
        BASE: file.addHelper("classPrivateFieldLooseBase"),
        REF: cloneNode(object),
        PROP: cloneNode(privateNamesMap.get(name).id)
      });
    },
    boundGet: function boundGet(member) {
      return callExpression(memberExpression(this.get(member), identifier("bind")), [cloneNode(member.node.object)]);
    },
    simpleSet: function simpleSet(member) {
      return this.get(member);
    },
    destructureSet: function destructureSet(member) {
      return this.get(member);
    },
    call: function call(member, args) {
      return callExpression(this.get(member), args);
    },
    optionalCall: function optionalCall(member, args) {
      return optionalCallExpression(this.get(member), args, true);
    }
  };
  function transformPrivateNamesUsage(ref, path, privateNamesMap, _ref2, state) {
    var privateFieldsAsProperties = _ref2.privateFieldsAsProperties,
        noDocumentAll = _ref2.noDocumentAll;
    if (!privateNamesMap.size) return;
    var body = path.get("body");
    var handler = privateFieldsAsProperties ? privateNameHandlerLoose : privateNameHandlerSpec;
    memberExpressionToFunctions(body, privateNameVisitor, Object.assign({
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state
    }, handler, {
      noDocumentAll: noDocumentAll
    }));
    body.traverse(privateInVisitor, {
      privateNamesMap: privateNamesMap,
      classRef: ref,
      file: state,
      privateFieldsAsProperties: privateFieldsAsProperties
    });
  }

  function buildPrivateFieldInitLoose(ref, prop, privateNamesMap) {
    var _privateNamesMap$get6 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get6.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template$2.statement.ast(_templateObject6$2 || (_templateObject6$2 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    });\n  "])), ref, cloneNode(id), value);
  }

  function buildPrivateInstanceFieldInitSpec(ref, prop, privateNamesMap) {
    var _privateNamesMap$get7 = privateNamesMap.get(prop.node.key.id.name),
        id = _privateNamesMap$get7.id;

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template$2.statement.ast(_templateObject7$1 || (_templateObject7$1 = _taggedTemplateLiteralLoose(["", ".set(", ", {\n    // configurable is always false for private elements\n    // enumerable is always false for private elements\n    writable: true,\n    value: ", ",\n  })"])), cloneNode(id), ref, value);
  }

  function buildPrivateStaticFieldInitSpec(prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    var isAccessor = getId || setId;
    if (!prop.isProperty() && (initAdded || !isAccessor)) return;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template$2.statement.ast(_templateObject8 || (_templateObject8 = _taggedTemplateLiteralLoose(["\n      var ", " = {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      }\n    "])), cloneNode(id), getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return template$2.statement.ast(_templateObject9 || (_templateObject9 = _taggedTemplateLiteralLoose(["\n    var ", " = {\n      // configurable is false by default\n      // enumerable is false by default\n      writable: true,\n      value: ", "\n    };\n  "])), cloneNode(id), value);
  }

  function buildPrivateMethodInitLoose(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var methodId = privateName.methodId,
        id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;

    if (methodId) {
      return template$2.statement.ast(_templateObject10 || (_templateObject10 = _taggedTemplateLiteralLoose(["\n        Object.defineProperty(", ", ", ", {\n          // configurable is false by default\n          // enumerable is false by default\n          // writable is false by default\n          value: ", "\n        });\n      "])), ref, id, methodId.name);
    }

    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template$2.statement.ast(_templateObject11 || (_templateObject11 = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      });\n    "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }
  }

  function buildPrivateInstanceMethodInitSpec(ref, prop, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template$2.statement.ast(_templateObject12 || (_templateObject12 = _taggedTemplateLiteralLoose(["\n      ", ".set(", ", {\n        get: ", ",\n        set: ", "\n      });\n    "])), id, ref, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template$2.statement.ast(_templateObject13 || (_templateObject13 = _taggedTemplateLiteralLoose(["", ".add(", ")"])), id, ref);
  }

  function buildPublicFieldInitLoose(ref, prop) {
    var _prop$node = prop.node,
        key = _prop$node.key,
        computed = _prop$node.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return expressionStatement(assignmentExpression("=", memberExpression(ref, key, computed || isLiteral(key)), value));
  }

  function buildPublicFieldInitSpec(ref, prop, state) {
    var _prop$node2 = prop.node,
        key = _prop$node2.key,
        computed = _prop$node2.computed;
    var value = prop.node.value || prop.scope.buildUndefinedNode();
    return expressionStatement(callExpression(state.addHelper("defineProperty"), [ref, computed || isLiteral(key) ? key : stringLiteral(key.name), value]));
  }

  function buildPrivateStaticMethodInitLoose(ref, prop, state, privateNamesMap) {
    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        initAdded = privateName.initAdded;
    if (initAdded) return;
    var isAccessor = getId || setId;

    if (isAccessor) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        initAdded: true
      }));
      return template$2.statement.ast(_templateObject14 || (_templateObject14 = _taggedTemplateLiteralLoose(["\n      Object.defineProperty(", ", ", ", {\n        // configurable is false by default\n        // enumerable is false by default\n        // writable is false by default\n        get: ", ",\n        set: ", "\n      })\n    "])), ref, id, getId ? getId.name : prop.scope.buildUndefinedNode(), setId ? setId.name : prop.scope.buildUndefinedNode());
    }

    return template$2.statement.ast(_templateObject15 || (_templateObject15 = _taggedTemplateLiteralLoose(["\n    Object.defineProperty(", ", ", ", {\n      // configurable is false by default\n      // enumerable is false by default\n      // writable is false by default\n      value: ", "\n    });\n  "])), ref, id, methodId.name);
  }

  function buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties) {
    if (privateFieldsAsProperties === void 0) {
      privateFieldsAsProperties = false;
    }

    var privateName = privateNamesMap.get(prop.node.key.id.name);
    var id = privateName.id,
        methodId = privateName.methodId,
        getId = privateName.getId,
        setId = privateName.setId,
        getterDeclared = privateName.getterDeclared,
        setterDeclared = privateName.setterDeclared,
        isStatic = privateName["static"];
    var _prop$node3 = prop.node,
        params = _prop$node3.params,
        body = _prop$node3.body,
        generator = _prop$node3.generator,
        async = _prop$node3.async;
    var isGetter = getId && !getterDeclared && params.length === 0;
    var isSetter = setId && !setterDeclared && params.length > 0;
    var declId = methodId;

    if (isGetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        getterDeclared: true
      }));
      declId = getId;
    } else if (isSetter) {
      privateNamesMap.set(prop.node.key.id.name, Object.assign({}, privateName, {
        setterDeclared: true
      }));
      declId = setId;
    } else if (isStatic && !privateFieldsAsProperties) {
      declId = id;
    }

    return functionDeclaration(cloneNode(declId), params, body, generator, async);
  }

  var thisContextVisitor = traverse.visitors.merge([{
    ThisExpression: function ThisExpression(path, state) {
      state.needsClassRef = true;
      path.replaceWith(cloneNode(state.classRef));
    }
  }, environmentVisitor]);
  var innerReferencesVisitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (path.scope.bindingIdentifierEquals(path.node.name, state.innerBinding)) {
        state.needsClassRef = true;
        path.node.name = state.classRef.name;
      }
    }
  };

  function replaceThisContext(path, ref, getSuperRef, file, isStaticBlock, constantSuper, innerBindingRef) {
    var _state$classRef;

    var state = {
      classRef: ref,
      needsClassRef: false,
      innerBinding: innerBindingRef
    };
    var replacer = new ReplaceSupers({
      methodPath: path,
      constantSuper: constantSuper,
      file: file,
      refToPreserve: ref,
      getSuperRef: getSuperRef,
      getObjectRef: function getObjectRef() {
        state.needsClassRef = true;
        return isStaticBlock || path.node["static"] ? ref : memberExpression(ref, identifier("prototype"));
      }
    });
    replacer.replace();

    if (isStaticBlock || path.isProperty()) {
      path.traverse(thisContextVisitor, state);
    }

    if ((_state$classRef = state.classRef) != null && _state$classRef.name && state.classRef.name !== (innerBindingRef == null ? void 0 : innerBindingRef.name)) {
      path.traverse(innerReferencesVisitor, state);
    }

    return state.needsClassRef;
  }

  function buildFieldsInitNodes(ref, superRef, props, privateNamesMap, state, setPublicClassFields, privateFieldsAsProperties, constantSuper, innerBindingRef) {
    var needsClassRef = false;
    var injectSuperRef;
    var staticNodes = [];
    var instanceNodes = [];
    var pureStaticNodes = [];
    var getSuperRef = isIdentifier(superRef) ? function () {
      return superRef;
    } : function () {
      var _injectSuperRef;

      (_injectSuperRef = injectSuperRef) != null ? _injectSuperRef : injectSuperRef = props[0].scope.generateUidIdentifierBasedOnNode(superRef);
      return injectSuperRef;
    };

    for (var _iterator4 = _createForOfIteratorHelperLoose(props), _step4; !(_step4 = _iterator4()).done;) {
      var prop = _step4.value;
      assertFieldTransformed(prop);
      var isStatic = prop.node["static"];
      var isInstance = !isStatic;
      var isPrivate = prop.isPrivate();
      var isPublic = !isPrivate;
      var isField = prop.isProperty();
      var isMethod = !isField;
      var isStaticBlock = prop.isStaticBlock == null ? void 0 : prop.isStaticBlock();

      if (isStatic || isMethod && isPrivate || isStaticBlock) {
        var replaced = replaceThisContext(prop, ref, getSuperRef, state, isStaticBlock, constantSuper, innerBindingRef);
        needsClassRef = needsClassRef || replaced;
      }

      switch (true) {
        case isStaticBlock:
          staticNodes.push(template$2.statement.ast(_templateObject16 || (_templateObject16 = _taggedTemplateLiteralLoose(["(() => ", ")()"])), blockStatement(prop.node.body)));
          break;

        case isStatic && isPrivate && isField && privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.push(buildPrivateFieldInitLoose(cloneNode(ref), prop, privateNamesMap));
          break;

        case isStatic && isPrivate && isField && !privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.push(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          break;

        case isStatic && isPublic && isField && setPublicClassFields:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitLoose(cloneNode(ref), prop));
          break;

        case isStatic && isPublic && isField && !setPublicClassFields:
          needsClassRef = true;
          staticNodes.push(buildPublicFieldInitSpec(cloneNode(ref), prop, state));
          break;

        case isInstance && isPrivate && isField && privateFieldsAsProperties:
          instanceNodes.push(buildPrivateFieldInitLoose(thisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isField && !privateFieldsAsProperties:
          instanceNodes.push(buildPrivateInstanceFieldInitSpec(thisExpression(), prop, privateNamesMap));
          break;

        case isInstance && isPrivate && isMethod && privateFieldsAsProperties:
          instanceNodes.unshift(buildPrivateMethodInitLoose(thisExpression(), prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isInstance && isPrivate && isMethod && !privateFieldsAsProperties:
          instanceNodes.unshift(buildPrivateInstanceMethodInitSpec(thisExpression(), prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isStatic && isPrivate && isMethod && !privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.unshift(buildPrivateStaticFieldInitSpec(prop, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isStatic && isPrivate && isMethod && privateFieldsAsProperties:
          needsClassRef = true;
          staticNodes.unshift(buildPrivateStaticMethodInitLoose(cloneNode(ref), prop, state, privateNamesMap));
          pureStaticNodes.push(buildPrivateMethodDeclaration(prop, privateNamesMap, privateFieldsAsProperties));
          break;

        case isInstance && isPublic && isField && setPublicClassFields:
          instanceNodes.push(buildPublicFieldInitLoose(thisExpression(), prop));
          break;

        case isInstance && isPublic && isField && !setPublicClassFields:
          instanceNodes.push(buildPublicFieldInitSpec(thisExpression(), prop, state));
          break;

        default:
          throw new Error("Unreachable.");
      }
    }

    return {
      staticNodes: staticNodes.filter(Boolean),
      instanceNodes: instanceNodes.filter(Boolean),
      pureStaticNodes: pureStaticNodes.filter(Boolean),
      wrapClass: function wrapClass(path) {
        for (var _iterator5 = _createForOfIteratorHelperLoose(props), _step5; !(_step5 = _iterator5()).done;) {
          var prop = _step5.value;
          prop.remove();
        }

        if (injectSuperRef) {
          path.scope.push({
            id: cloneNode(injectSuperRef)
          });
          path.set("superClass", assignmentExpression("=", injectSuperRef, path.node.superClass));
        }

        if (!needsClassRef) return path;

        if (path.isClassExpression()) {
          path.scope.push({
            id: ref
          });
          path.replaceWith(assignmentExpression("=", cloneNode(ref), path.node));
        } else if (!path.node.id) {
          path.node.id = ref;
        }

        return path;
      }
    };
  }

  var _templateObject$i, _templateObject2$8, _templateObject3$7, _templateObject4$3;
  function hasOwnDecorators(node) {
    return !!(node.decorators && node.decorators.length);
  }
  function hasDecorators(node) {
    return hasOwnDecorators(node) || node.body.body.some(hasOwnDecorators);
  }

  function prop(key, value) {
    if (!value) return null;
    return objectProperty(identifier(key), value);
  }

  function method(key, body) {
    return objectMethod("method", identifier(key), [], blockStatement(body));
  }

  function takeDecorators(node) {
    var result;

    if (node.decorators && node.decorators.length > 0) {
      result = arrayExpression(node.decorators.map(function (decorator) {
        return decorator.expression;
      }));
    }

    node.decorators = undefined;
    return result;
  }

  function getKey(node) {
    if (node.computed) {
      return node.key;
    } else if (isIdentifier(node.key)) {
      return stringLiteral(node.key.name);
    } else {
      return stringLiteral(String(node.key.value));
    }
  }

  function extractElementDescriptor(classRef, superRef, path) {
    var node = path.node,
        scope = path.scope;
    var isMethod = path.isClassMethod();

    if (path.isPrivate()) {
      throw path.buildCodeFrameError("Private " + (isMethod ? "methods" : "fields") + " in decorated classes are not supported yet.");
    }

    new ReplaceSupers({
      methodPath: path,
      objectRef: classRef,
      superRef: superRef,
      file: this,
      refToPreserve: classRef
    }).replace();
    var properties = [prop("kind", stringLiteral(isMethod ? node.kind : "field")), prop("decorators", takeDecorators(node)), prop("static", node["static"] && booleanLiteral(true)), prop("key", getKey(node))].filter(Boolean);

    if (isMethod) {
      var id = node.computed ? null : node.key;
      toExpression(node);
      properties.push(prop("value", nameFunction({
        node: node,
        id: id,
        scope: scope
      }) || node));
    } else if (node.value) {
      properties.push(method("value", template$2.statements.ast(_templateObject$i || (_templateObject$i = _taggedTemplateLiteralLoose(["return ", ""])), node.value)));
    } else {
      properties.push(prop("value", scope.buildUndefinedNode()));
    }

    path.remove();
    return objectExpression(properties);
  }

  function addDecorateHelper(file) {
    try {
      return file.addHelper("decorate");
    } catch (err) {
      if (err.code === "BABEL_HELPER_UNKNOWN") {
        err.message += "\n  '@babel/plugin-transform-decorators' in non-legacy mode" + " requires '@babel/core' version ^7.0.2 and you appear to be using" + " an older version.";
      }

      throw err;
    }
  }

  function buildDecoratedClass(ref, path, elements, file) {
    var node = path.node,
        scope = path.scope;
    var initializeId = scope.generateUidIdentifier("initialize");
    var isDeclaration = node.id && path.isDeclaration();
    var isStrict = path.isInStrictMode();
    var superClass = node.superClass;
    node.type = "ClassDeclaration";
    if (!node.id) node.id = cloneNode(ref);
    var superId;

    if (superClass) {
      superId = scope.generateUidIdentifierBasedOnNode(node.superClass, "super");
      node.superClass = superId;
    }

    var classDecorators = takeDecorators(node);
    var definitions = arrayExpression(elements.filter(function (element) {
      return !element.node["abstract"];
    }).map(extractElementDescriptor.bind(file, node.id, superId)));
    var wrapperCall = template$2.expression.ast(_templateObject2$8 || (_templateObject2$8 = _taggedTemplateLiteralLoose(["\n    ", "(\n      ", ",\n      function (", ", ", ") {\n        ", "\n        return { F: ", ", d: ", " };\n      },\n      ", "\n    )\n  "])), addDecorateHelper(file), classDecorators || nullLiteral(), initializeId, superClass ? cloneNode(superId) : null, node, cloneNode(node.id), definitions, superClass);

    if (!isStrict) {
      wrapperCall.arguments[1].body.directives.push(directive(directiveLiteral("use strict")));
    }

    var replacement = wrapperCall;
    var classPathDesc = "arguments.1.body.body.0";

    if (isDeclaration) {
      replacement = template$2.statement.ast(_templateObject3$7 || (_templateObject3$7 = _taggedTemplateLiteralLoose(["let ", " = ", ""])), ref, wrapperCall);
      classPathDesc = "declarations.0.init." + classPathDesc;
    }

    return {
      instanceNodes: [template$2.statement.ast(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteralLoose(["", "(this)"])), cloneNode(initializeId))],
      wrapClass: function wrapClass(path) {
        path.replaceWith(replacement);
        return path.get(classPathDesc);
      }
    };
  }

  var _templateObject$h;
  var findBareSupers = traverse.visitors.merge([{
    Super: function Super(path) {
      var node = path.node,
          parentPath = path.parentPath;

      if (parentPath.isCallExpression({
        callee: node
      })) {
        this.push(parentPath);
      }
    }
  }, environmentVisitor]);
  var referenceVisitor = {
    "TSTypeAnnotation|TypeAnnotation": function TSTypeAnnotationTypeAnnotation(path) {
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path) {
      if (this.scope.hasOwnBinding(path.node.name)) {
        this.scope.rename(path.node.name);
        path.skip();
      }
    }
  };

  function handleClassTDZ(path, state) {
    if (state.classBinding && state.classBinding === path.scope.getBinding(path.node.name)) {
      var classNameTDZError = state.file.addHelper("classNameTDZError");
      var throwNode = callExpression(classNameTDZError, [stringLiteral(path.node.name)]);
      path.replaceWith(sequenceExpression([throwNode, path.node]));
      path.skip();
    }
  }

  var classFieldDefinitionEvaluationTDZVisitor = {
    ReferencedIdentifier: handleClassTDZ
  };
  function injectInitialization(path, constructor, nodes, renamer) {
    if (!nodes.length) return;
    var isDerived = !!path.node.superClass;

    if (!constructor) {
      var newConstructor = classMethod("constructor", identifier("constructor"), [], blockStatement([]));

      if (isDerived) {
        newConstructor.params = [restElement(identifier("args"))];
        newConstructor.body.body.push(template$2.statement.ast(_templateObject$h || (_templateObject$h = _taggedTemplateLiteralLoose(["super(...args)"]))));
      }

      var _path$get$unshiftCont = path.get("body").unshiftContainer("body", newConstructor);

      var _path$get$unshiftCont2 = _slicedToArray$2(_path$get$unshiftCont, 1);

      constructor = _path$get$unshiftCont2[0];
    }

    if (renamer) {
      renamer(referenceVisitor, {
        scope: constructor.scope
      });
    }

    if (isDerived) {
      var bareSupers = [];
      constructor.traverse(findBareSupers, bareSupers);
      var isFirst = true;

      for (var _i = 0, _bareSupers = bareSupers; _i < _bareSupers.length; _i++) {
        var bareSuper = _bareSupers[_i];

        if (isFirst) {
          bareSuper.insertAfter(nodes);
          isFirst = false;
        } else {
          bareSuper.insertAfter(nodes.map(function (n) {
            return cloneNode(n);
          }));
        }
      }
    } else {
      constructor.get("body").unshiftContainer("body", nodes);
    }
  }
  function extractComputedKeys(ref, path, computedPaths, file) {
    var declarations = [];
    var state = {
      classBinding: path.node.id && path.scope.getBinding(path.node.id.name),
      file: file
    };

    for (var _iterator = _createForOfIteratorHelperLoose(computedPaths), _step; !(_step = _iterator()).done;) {
      var computedPath = _step.value;
      var computedKey = computedPath.get("key");

      if (computedKey.isReferencedIdentifier()) {
        handleClassTDZ(computedKey, state);
      } else {
        computedKey.traverse(classFieldDefinitionEvaluationTDZVisitor, state);
      }

      var computedNode = computedPath.node;

      if (!computedKey.isConstantExpression()) {
        var ident = path.scope.generateUidIdentifierBasedOnNode(computedNode.key);
        path.scope.push({
          id: ident,
          kind: "let"
        });
        declarations.push(expressionStatement(assignmentExpression("=", cloneNode(ident), computedNode.key)));
        computedNode.key = cloneNode(ident);
      }
    }

    return declarations;
  }

  var FEATURES$1 = Object.freeze({
    fields: 1 << 1,
    privateMethods: 1 << 2,
    decorators: 1 << 3,
    privateIn: 1 << 4,
    staticBlocks: 1 << 5
  });
  var featuresSameLoose = new Map([[FEATURES$1.fields, "@babel/plugin-proposal-class-properties"], [FEATURES$1.privateMethods, "@babel/plugin-proposal-private-methods"], [FEATURES$1.privateIn, "@babel/plugin-proposal-private-property-in-object"]]);
  var featuresKey$1 = "@babel/plugin-class-features/featuresKey";
  var looseKey = "@babel/plugin-class-features/looseKey";
  var looseLowPriorityKey = "@babel/plugin-class-features/looseLowPriorityKey/#__internal__@babel/preset-env__please-overwrite-loose-instead-of-throwing";
  function enableFeature$1(file, feature, loose) {
    if (!hasFeature$1(file, feature) || canIgnoreLoose(file, feature)) {
      file.set(featuresKey$1, file.get(featuresKey$1) | feature);

      if (loose === "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, true);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else if (loose === "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error") {
        setLoose(file, feature, false);
        file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) | feature);
      } else {
        setLoose(file, feature, loose);
      }
    }

    var resolvedLoose;
    var higherPriorityPluginName;

    for (var _iterator = _createForOfIteratorHelperLoose(featuresSameLoose), _step; !(_step = _iterator()).done;) {
      var _step$value = _slicedToArray$2(_step.value, 2),
          _mask = _step$value[0],
          _name = _step$value[1];

      if (!hasFeature$1(file, _mask)) continue;

      var _loose = isLoose(file, _mask);

      if (canIgnoreLoose(file, _mask)) {
        continue;
      } else if (resolvedLoose === !_loose) {
        throw new Error("'loose' mode configuration must be the same for @babel/plugin-proposal-class-properties, " + "@babel/plugin-proposal-private-methods and " + "@babel/plugin-proposal-private-property-in-object (when they are enabled).");
      } else {
        resolvedLoose = _loose;
        higherPriorityPluginName = _name;
      }
    }

    if (resolvedLoose !== undefined) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(featuresSameLoose), _step2; !(_step2 = _iterator2()).done;) {
        var _step2$value = _slicedToArray$2(_step2.value, 2),
            mask = _step2$value[0],
            name = _step2$value[1];

        if (hasFeature$1(file, mask) && isLoose(file, mask) !== resolvedLoose) {
          setLoose(file, mask, resolvedLoose);
          console.warn("Though the \"loose\" option was set to \"" + !resolvedLoose + "\" in your @babel/preset-env " + ("config, it will not be used for " + name + " since the \"loose\" mode option was set to ") + ("\"" + resolvedLoose + "\" for " + higherPriorityPluginName + ".\nThe \"loose\" option must be the ") + "same for @babel/plugin-proposal-class-properties, @babel/plugin-proposal-private-methods " + "and @babel/plugin-proposal-private-property-in-object (when they are enabled): you can " + "silence this warning by explicitly adding\n" + ("\t[\"" + name + "\", { \"loose\": " + resolvedLoose + " }]\n") + "to the \"plugins\" section of your Babel config.");
        }
      }
    }
  }

  function hasFeature$1(file, feature) {
    return !!(file.get(featuresKey$1) & feature);
  }

  function isLoose(file, feature) {
    return !!(file.get(looseKey) & feature);
  }

  function setLoose(file, feature, loose) {
    if (loose) file.set(looseKey, file.get(looseKey) | feature);else file.set(looseKey, file.get(looseKey) & ~feature);
    file.set(looseLowPriorityKey, file.get(looseLowPriorityKey) & ~feature);
  }

  function canIgnoreLoose(file, feature) {
    return !!(file.get(looseLowPriorityKey) & feature);
  }

  function verifyUsedFeatures(path, file) {
    if (hasOwnDecorators(path.node)) {
      if (!hasFeature$1(file, FEATURES$1.decorators)) {
        throw path.buildCodeFrameError("Decorators are not enabled." + "\nIf you are using " + '["@babel/plugin-proposal-decorators", { "legacy": true }], ' + 'make sure it comes *before* "@babel/plugin-proposal-class-properties" ' + "and enable loose mode, like so:\n" + '\t["@babel/plugin-proposal-decorators", { "legacy": true }]\n' + '\t["@babel/plugin-proposal-class-properties", { "loose": true }]');
      }

      if (path.isPrivate()) {
        throw path.buildCodeFrameError("Private " + (path.isClassMethod() ? "methods" : "fields") + " in decorated classes are not supported yet.");
      }
    }

    if (path.isPrivateMethod != null && path.isPrivateMethod()) {
      if (!hasFeature$1(file, FEATURES$1.privateMethods)) {
        throw path.buildCodeFrameError("Class private methods are not enabled.");
      }
    }

    if (path.isPrivateName() && path.parentPath.isBinaryExpression({
      operator: "in",
      left: path.node
    })) {
      if (!hasFeature$1(file, FEATURES$1.privateIn)) {
        throw path.buildCodeFrameError("Private property in checks are not enabled.");
      }
    }

    if (path.isProperty()) {
      if (!hasFeature$1(file, FEATURES$1.fields)) {
        throw path.buildCodeFrameError("Class fields are not enabled.");
      }
    }

    if (path.isStaticBlock != null && path.isStaticBlock()) {
      if (!hasFeature$1(file, FEATURES$1.staticBlocks)) {
        throw path.buildCodeFrameError("Static class blocks are not enabled. " + "Please add `@babel/plugin-proposal-class-static-block` to your configuration.");
      }
    }
  }

  var version$2 = "7.14.6".split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey$1 = "@babel/plugin-class-features/version";
  function createClassFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        loose = _ref.loose,
        manipulateOptions = _ref.manipulateOptions,
        _ref$api = _ref.api,
        api = _ref$api === void 0 ? {
      assumption: function assumption() {}
    } : _ref$api;
    var setPublicClassFields = api.assumption("setPublicClassFields");
    var privateFieldsAsProperties = api.assumption("privateFieldsAsProperties");
    var constantSuper = api.assumption("constantSuper");
    var noDocumentAll = api.assumption("noDocumentAll");

    if (loose === true) {
      var explicit = [];

      if (setPublicClassFields !== undefined) {
        explicit.push("\"setPublicClassFields\"");
      }

      if (privateFieldsAsProperties !== undefined) {
        explicit.push("\"privateFieldsAsProperties\"");
      }

      if (explicit.length !== 0) {
        console.warn("[" + name + "]: You are using the \"loose: true\" option and you are" + (" explicitly setting a value for the " + explicit.join(" and ")) + (" assumption" + (explicit.length > 1 ? "s" : "") + ". The \"loose\" option") + " can cause incompatibilities with the other class features" + " plugins, so it's recommended that you replace it with the" + " following top-level option:\n" + "\t\"assumptions\": {\n" + "\t\t\"setPublicClassFields\": true,\n" + "\t\t\"privateFieldsAsProperties\": true\n" + "\t}");
      }
    }

    return {
      name: name,
      manipulateOptions: manipulateOptions,
      pre: function pre() {
        enableFeature$1(this.file, feature, loose);

        if (!this.file.get(versionKey$1) || this.file.get(versionKey$1) < version$2) {
          this.file.set(versionKey$1, version$2);
        }
      },
      visitor: {
        Class: function Class(path, state) {
          if (this.file.get(versionKey$1) !== version$2) return;
          verifyUsedFeatures(path, this.file);
          var loose = isLoose(this.file, feature);
          var constructor;
          var isDecorated = hasOwnDecorators(path.node);
          var props = [];
          var elements = [];
          var computedPaths = [];
          var privateNames = new Set();
          var body = path.get("body");

          for (var _iterator = _createForOfIteratorHelperLoose(body.get("body")), _step; !(_step = _iterator()).done;) {
            var _path = _step.value;
            verifyUsedFeatures(_path, this.file);

            if (_path.node.computed) {
              computedPaths.push(_path);
            }

            if (_path.isPrivate()) {
              var _name = _path.node.key.id.name;
              var getName = "get " + _name;
              var setName = "set " + _name;

              if (_path.node.kind === "get") {
                if (privateNames.has(getName) || privateNames.has(_name) && !privateNames.has(setName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(getName).add(_name);
              } else if (_path.node.kind === "set") {
                if (privateNames.has(setName) || privateNames.has(_name) && !privateNames.has(getName)) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(setName).add(_name);
              } else {
                if (privateNames.has(_name) && !privateNames.has(getName) && !privateNames.has(setName) || privateNames.has(_name) && (privateNames.has(getName) || privateNames.has(setName))) {
                  throw _path.buildCodeFrameError("Duplicate private field");
                }

                privateNames.add(_name);
              }
            }

            if (_path.isClassMethod({
              kind: "constructor"
            })) {
              constructor = _path;
            } else {
              elements.push(_path);

              if (_path.isProperty() || _path.isPrivate() || _path.isStaticBlock != null && _path.isStaticBlock()) {
                props.push(_path);
              }
            }

            if (!isDecorated) isDecorated = hasOwnDecorators(_path.node);
          }

          if (!props.length && !isDecorated) return;
          var innerBinding = path.node.id;
          var ref;

          if (!innerBinding || path.isClassExpression()) {
            nameFunction(path);
            ref = path.scope.generateUidIdentifier("class");
          } else {
            ref = cloneNode(path.node.id);
          }

          var privateNamesMap = buildPrivateNamesMap(props);
          var privateNamesNodes = buildPrivateNamesNodes(privateNamesMap, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, state);
          transformPrivateNamesUsage(ref, path, privateNamesMap, {
            privateFieldsAsProperties: privateFieldsAsProperties != null ? privateFieldsAsProperties : loose,
            noDocumentAll: noDocumentAll
          }, state);
          var keysNodes, staticNodes, pureStaticNodes, instanceNodes, wrapClass;

          if (isDecorated) {
            staticNodes = pureStaticNodes = keysNodes = [];

            var _buildDecoratedClass = buildDecoratedClass(ref, path, elements, this.file);

            instanceNodes = _buildDecoratedClass.instanceNodes;
            wrapClass = _buildDecoratedClass.wrapClass;
          } else {
            keysNodes = extractComputedKeys(ref, path, computedPaths, this.file);

            var _buildFieldsInitNodes = buildFieldsInitNodes(ref, path.node.superClass, props, privateNamesMap, state, setPublicClassFields != null ? setPublicClassFields : loose, privateFieldsAsProperties != null ? privateFieldsAsProperties : loose, constantSuper != null ? constantSuper : loose, innerBinding);

            staticNodes = _buildFieldsInitNodes.staticNodes;
            pureStaticNodes = _buildFieldsInitNodes.pureStaticNodes;
            instanceNodes = _buildFieldsInitNodes.instanceNodes;
            wrapClass = _buildFieldsInitNodes.wrapClass;
          }

          if (instanceNodes.length > 0) {
            injectInitialization(path, constructor, instanceNodes, function (referenceVisitor, state) {
              if (isDecorated) return;

              for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
                var prop = _step2.value;
                if (prop.node["static"]) continue;
                prop.traverse(referenceVisitor, state);
              }
            });
          }

          path = wrapClass(path);
          path.insertBefore([].concat(_toConsumableArray(privateNamesNodes), _toConsumableArray(keysNodes)));

          if (staticNodes.length > 0) {
            path.insertAfter(staticNodes);
          }

          if (pureStaticNodes.length > 0) {
            path.find(function (parent) {
              return parent.isStatement() || parent.isDeclaration();
            }).insertAfter(pureStaticNodes);
          }
        },
        PrivateName: function PrivateName(path) {
          if (this.file.get(versionKey$1) !== version$2 || path.parentPath.isPrivate({
            key: path.node
          })) {
            return;
          }

          throw path.buildCodeFrameError("Unknown PrivateName \"" + path + "\"");
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (this.file.get(versionKey$1) !== version$2) return;
          var decl = path.get("declaration");

          if (decl.isClassDeclaration() && hasDecorators(decl.node)) {
            if (decl.node.id) {
              splitExportDeclaration(path);
            } else {
              decl.node.type = "ClassExpression";
            }
          }
        }
      }
    };
  }

  var _proposalClassProperties = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-class-properties",
      api: api,
      feature: FEATURES$1.fields,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classProperties", "classPrivateProperties");
      }
    });
  });

  var _templateObject$g;

  function generateUid(scope, denyList) {
    var name = "";
    var uid;
    var i = 1;

    do {
      uid = scope._generateUid(name, i);
      i++;
    } while (denyList.has(uid));

    return uid;
  }

  var _proposalClassStaticBlock = declare(function (_ref) {
    var t = _ref.types,
        template = _ref.template,
        assertVersion = _ref.assertVersion;
    assertVersion("^7.12.0");
    return {
      name: "proposal-class-static-block",
      inherits: _syntaxClassStaticBlock,
      pre: function pre() {
        enableFeature$1(this.file, FEATURES$1.staticBlocks, false);
      },
      visitor: {
        ClassBody: function ClassBody(classBody) {
          var scope = classBody.scope;
          var privateNames = new Set();
          var body = classBody.get("body");

          for (var _iterator = _createForOfIteratorHelperLoose(body), _step; !(_step = _iterator()).done;) {
            var path = _step.value;

            if (path.isPrivate()) {
              privateNames.add(path.get("key.id").node.name);
            }
          }

          for (var _iterator2 = _createForOfIteratorHelperLoose(body), _step2; !(_step2 = _iterator2()).done;) {
            var _path = _step2.value;
            if (!_path.isStaticBlock()) continue;
            var staticBlockPrivateId = generateUid(scope, privateNames);
            privateNames.add(staticBlockPrivateId);
            var staticBlockRef = t.privateName(t.identifier(staticBlockPrivateId));

            _path.replaceWith(t.classPrivateProperty(staticBlockRef, template.expression.ast(_templateObject$g || (_templateObject$g = _taggedTemplateLiteralLoose(["(() => { ", " })()"])), _path.node.body), [], true));
          }
        }
      }
    };
  });

  var buildClassDecorator = template$2("\n  DECORATOR(CLASS_REF = INNER) || CLASS_REF;\n");
  var buildClassPrototype = template$2("\n  CLASS_REF.prototype;\n");
  var buildGetDescriptor = template$2("\n    Object.getOwnPropertyDescriptor(TARGET, PROPERTY);\n");
  var buildGetObjectInitializer = template$2("\n    (TEMP = Object.getOwnPropertyDescriptor(TARGET, PROPERTY), (TEMP = TEMP ? TEMP.value : undefined), {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        initializer: function(){\n            return TEMP;\n        }\n    })\n");
  var WARNING_CALLS = new WeakSet();

  function applyEnsureOrdering(path) {
    var decorators = (path.isClass() ? [path].concat(path.get("body.body")) : path.get("properties")).reduce(function (acc, prop) {
      return acc.concat(prop.node.decorators || []);
    }, []);
    var identDecorators = decorators.filter(function (decorator) {
      return !isIdentifier(decorator.expression);
    });
    if (identDecorators.length === 0) return;
    return sequenceExpression(identDecorators.map(function (decorator) {
      var expression = decorator.expression;
      var id = decorator.expression = path.scope.generateDeclaredUidIdentifier("dec");
      return assignmentExpression("=", id, expression);
    }).concat([path.node]));
  }

  function applyClassDecorators(classPath) {
    if (!hasClassDecorators(classPath.node)) return;
    var decorators = classPath.node.decorators || [];
    classPath.node.decorators = null;
    var name = classPath.scope.generateDeclaredUidIdentifier("class");
    return decorators.map(function (dec) {
      return dec.expression;
    }).reverse().reduce(function (acc, decorator) {
      return buildClassDecorator({
        CLASS_REF: cloneNode(name),
        DECORATOR: cloneNode(decorator),
        INNER: acc
      }).expression;
    }, classPath.node);
  }

  function hasClassDecorators(classNode) {
    return !!(classNode.decorators && classNode.decorators.length);
  }

  function applyMethodDecorators(path, state) {
    if (!hasMethodDecorators(path.node.body.body)) return;
    return applyTargetDecorators(path, state, path.node.body.body);
  }

  function hasMethodDecorators(body) {
    return body.some(function (node) {
      var _node$decorators;

      return (_node$decorators = node.decorators) == null ? void 0 : _node$decorators.length;
    });
  }

  function applyObjectDecorators(path, state) {
    if (!hasMethodDecorators(path.node.properties)) return;
    return applyTargetDecorators(path, state, path.node.properties);
  }

  function applyTargetDecorators(path, state, decoratedProps) {
    var name = path.scope.generateDeclaredUidIdentifier(path.isClass() ? "class" : "obj");
    var exprs = decoratedProps.reduce(function (acc, node) {
      var decorators = node.decorators || [];
      node.decorators = null;
      if (decorators.length === 0) return acc;

      if (node.computed) {
        throw path.buildCodeFrameError("Computed method/property decorators are not yet supported.");
      }

      var property = isLiteral(node.key) ? node.key : stringLiteral(node.key.name);
      var target = path.isClass() && !node["static"] ? buildClassPrototype({
        CLASS_REF: name
      }).expression : name;

      if (isClassProperty(node, {
        "static": false
      })) {
        var descriptor = path.scope.generateDeclaredUidIdentifier("descriptor");
        var initializer = node.value ? functionExpression(null, [], blockStatement([returnStatement(node.value)])) : nullLiteral();
        node.value = callExpression(state.addHelper("initializerWarningHelper"), [descriptor, thisExpression()]);
        WARNING_CALLS.add(node.value);
        acc = acc.concat([assignmentExpression("=", cloneNode(descriptor), callExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), arrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), objectExpression([objectProperty(identifier("configurable"), booleanLiteral(true)), objectProperty(identifier("enumerable"), booleanLiteral(true)), objectProperty(identifier("writable"), booleanLiteral(true)), objectProperty(identifier("initializer"), initializer)])]))]);
      } else {
        acc = acc.concat(callExpression(state.addHelper("applyDecoratedDescriptor"), [cloneNode(target), cloneNode(property), arrayExpression(decorators.map(function (dec) {
          return cloneNode(dec.expression);
        })), isObjectProperty(node) || isClassProperty(node, {
          "static": true
        }) ? buildGetObjectInitializer({
          TEMP: path.scope.generateDeclaredUidIdentifier("init"),
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression : buildGetDescriptor({
          TARGET: cloneNode(target),
          PROPERTY: cloneNode(property)
        }).expression, cloneNode(target)]));
      }

      return acc;
    }, []);
    return sequenceExpression([assignmentExpression("=", cloneNode(name), path.node), sequenceExpression(exprs), cloneNode(name)]);
  }

  function decoratedClassToExpression(_ref) {
    var node = _ref.node,
        scope = _ref.scope;

    if (!hasClassDecorators(node) && !hasMethodDecorators(node.body.body)) {
      return;
    }

    var ref = node.id ? cloneNode(node.id) : scope.generateUidIdentifier("class");
    return variableDeclaration("let", [variableDeclarator(ref, toExpression(node))]);
  }

  var legacyVisitor = {
    ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
      var decl = path.get("declaration");
      if (!decl.isClassDeclaration()) return;
      var replacement = decoratedClassToExpression(decl);

      if (replacement) {
        var _path$replaceWithMult = path.replaceWithMultiple([replacement, exportNamedDeclaration(null, [exportSpecifier(cloneNode(replacement.declarations[0].id), identifier("default"))])]),
            _path$replaceWithMult2 = _slicedToArray$2(_path$replaceWithMult, 1),
            varDeclPath = _path$replaceWithMult2[0];

        if (!decl.node.id) {
          path.scope.registerDeclaration(varDeclPath);
        }
      }
    },
    ClassDeclaration: function ClassDeclaration(path) {
      var replacement = decoratedClassToExpression(path);

      if (replacement) {
        path.replaceWith(replacement);
      }
    },
    ClassExpression: function ClassExpression(path, state) {
      var decoratedClass = applyEnsureOrdering(path) || applyClassDecorators(path) || applyMethodDecorators(path, state);
      if (decoratedClass) path.replaceWith(decoratedClass);
    },
    ObjectExpression: function ObjectExpression(path, state) {
      var decoratedObject = applyEnsureOrdering(path) || applyObjectDecorators(path, state);
      if (decoratedObject) path.replaceWith(decoratedObject);
    },
    AssignmentExpression: function AssignmentExpression(path, state) {
      if (!WARNING_CALLS.has(path.node.right)) return;
      path.replaceWith(callExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("left.object").node), stringLiteral(path.get("left.property").node.name || path.get("left.property").node.value), cloneNode(path.get("right.arguments")[0].node), cloneNode(path.get("right.arguments")[1].node)]));
    },
    CallExpression: function CallExpression(path, state) {
      if (path.node.arguments.length !== 3) return;
      if (!WARNING_CALLS.has(path.node.arguments[2])) return;

      if (path.node.callee.name !== state.addHelper("defineProperty").name) {
        return;
      }

      path.replaceWith(callExpression(state.addHelper("initializerDefineProperty"), [cloneNode(path.get("arguments")[0].node), cloneNode(path.get("arguments")[1].node), cloneNode(path.get("arguments.2.arguments")[0].node), cloneNode(path.get("arguments.2.arguments")[1].node)]));
    }
  };

  var proposalDecorators = declare(function (api, options) {
    api.assertVersion(7);
    var _options$legacy = options.legacy,
        legacy = _options$legacy === void 0 ? false : _options$legacy;

    if (typeof legacy !== "boolean") {
      throw new Error("'legacy' must be a boolean.");
    }

    var decoratorsBeforeExport = options.decoratorsBeforeExport;

    if (decoratorsBeforeExport === undefined) {
      if (!legacy) {
        throw new Error("The decorators plugin requires a 'decoratorsBeforeExport' option," + " whose value must be a boolean. If you want to use the legacy" + " decorators semantics, you can set the 'legacy: true' option.");
      }
    } else {
      if (legacy) {
        throw new Error("'decoratorsBeforeExport' can't be used with legacy decorators.");
      }

      if (typeof decoratorsBeforeExport !== "boolean") {
        throw new Error("'decoratorsBeforeExport' must be a boolean.");
      }
    }

    if (legacy) {
      return {
        name: "proposal-decorators",
        inherits: syntaxDecorators,
        manipulateOptions: function manipulateOptions(_ref) {
          var generatorOpts = _ref.generatorOpts;
          generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
        },
        visitor: legacyVisitor
      };
    }

    return createClassFeaturePlugin({
      name: "proposal-decorators",
      api: api,
      feature: FEATURES$1.decorators,
      manipulateOptions: function manipulateOptions(_ref2) {
        var generatorOpts = _ref2.generatorOpts,
            parserOpts = _ref2.parserOpts;
        parserOpts.plugins.push(["decorators", {
          decoratorsBeforeExport: decoratorsBeforeExport
        }]);
        generatorOpts.decoratorsBeforeExport = decoratorsBeforeExport;
      }
    });
  });

  var proposalDoExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-do-expressions",
      inherits: syntaxDoExpressions,
      visitor: {
        DoExpression: {
          exit: function exit(path) {
            var node = path.node;

            if (node.async) {
              return;
            }

            var body = node.body.body;

            if (body.length) {
              path.replaceExpressionWithStatements(body);
            } else {
              path.replaceWith(path.scope.buildUndefinedNode());
            }
          }
        }
      }
    };
  });

  var lib$k = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-dynamic-import",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("dynamicImport");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-dynamic-import/node_modules/@babel/plugin-syntax-dynamic-import/lib");

  var SUPPORTED_MODULES = ["commonjs", "amd", "systemjs"];
  var MODULES_NOT_FOUND = "@babel/plugin-proposal-dynamic-import depends on a modules\ntransform plugin. Supported plugins are:\n - @babel/plugin-transform-modules-commonjs ^7.4.0\n - @babel/plugin-transform-modules-amd ^7.4.0\n - @babel/plugin-transform-modules-systemjs ^7.4.0\n\nIf you are using Webpack or Rollup and thus don't want\nBabel to transpile your imports and exports, you can use\nthe @babel/plugin-syntax-dynamic-import plugin and let your\nbundler handle dynamic imports.\n";
  var _proposalDynamicImport = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-dynamic-import",
      inherits: lib$k["default"],
      pre: function pre() {
        this.file.set("@babel/plugin-proposal-dynamic-import", "7.14.5");
      },
      visitor: {
        Program: function Program() {
          var modules = this.file.get("@babel/plugin-transform-modules-*");

          if (!SUPPORTED_MODULES.includes(modules)) {
            throw new Error(MODULES_NOT_FOUND);
          }
        }
      }
    };
  });

  var proposalExportDefaultFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-default-from",
      inherits: syntaxExportDefaultFrom,
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          if (!isExportDefaultSpecifier(specifiers[0])) return;
          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier(exported.name);
          var nodes = [importDeclaration([importDefaultSpecifier(uid)], cloneNode(node.source)), exportNamedDeclaration(null, [exportSpecifier(cloneNode(uid), exported)])];

          if (specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              _path$replaceWithMult2 = _slicedToArray$2(_path$replaceWithMult, 1),
              importDeclaration$1 = _path$replaceWithMult2[0];

          path.scope.registerDeclaration(importDeclaration$1);
        }
      }
    };
  });

  var lib$j = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-export-namespace-from",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportNamespaceFrom");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-export-namespace-from/node_modules/@babel/plugin-syntax-export-namespace-from/lib");

  var _proposalExportNamespaceFrom = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-export-namespace-from",
      inherits: lib$j["default"],
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var _exported$name;

          var node = path.node,
              scope = path.scope;
          var specifiers = node.specifiers;
          var index = isExportDefaultSpecifier(specifiers[0]) ? 1 : 0;
          if (!isExportNamespaceSpecifier(specifiers[index])) return;
          var nodes = [];

          if (index === 1) {
            nodes.push(exportNamedDeclaration(null, [specifiers.shift()], node.source));
          }

          var specifier = specifiers.shift();
          var exported = specifier.exported;
          var uid = scope.generateUidIdentifier((_exported$name = exported.name) != null ? _exported$name : exported.value);
          nodes.push(importDeclaration([importNamespaceSpecifier(uid)], cloneNode(node.source)), exportNamedDeclaration(null, [exportSpecifier(cloneNode(uid), exported)]));

          if (node.specifiers.length >= 1) {
            nodes.push(node);
          }

          var _path$replaceWithMult = path.replaceWithMultiple(nodes),
              _path$replaceWithMult2 = _slicedToArray$2(_path$replaceWithMult, 1),
              importDeclaration$1 = _path$replaceWithMult2[0];

          path.scope.registerDeclaration(importDeclaration$1);
        }
      }
    };
  });

  var proposalFunctionBind = declare(function (api) {
    api.assertVersion(7);

    function getTempId(scope) {
      var id = scope.path.getData("functionBind");
      if (id) return cloneNode(id);
      id = scope.generateDeclaredUidIdentifier("context");
      return scope.path.setData("functionBind", id);
    }

    function getStaticContext(bind, scope) {
      var object = bind.object || bind.callee.object;
      return scope.isStatic(object) && (isSuper(object) ? thisExpression() : object);
    }

    function inferBindContext(bind, scope) {
      var staticContext = getStaticContext(bind, scope);
      if (staticContext) return cloneNode(staticContext);
      var tempId = getTempId(scope);

      if (bind.object) {
        bind.callee = sequenceExpression([assignmentExpression("=", tempId, bind.object), bind.callee]);
      } else {
        bind.callee.object = assignmentExpression("=", tempId, bind.callee.object);
      }

      return cloneNode(tempId);
    }

    return {
      name: "proposal-function-bind",
      inherits: syntaxFunctionBind,
      visitor: {
        CallExpression: function CallExpression(_ref) {
          var node = _ref.node,
              scope = _ref.scope;
          var bind = node.callee;
          if (!isBindExpression(bind)) return;
          var context = inferBindContext(bind, scope);
          node.callee = memberExpression(bind.callee, identifier("call"));
          node.arguments.unshift(context);
        },
        BindExpression: function BindExpression(path) {
          var node = path.node,
              scope = path.scope;
          var context = inferBindContext(node, scope);
          path.replaceWith(callExpression(memberExpression(node.callee, identifier("bind")), [context]));
        }
      }
    };
  });

  var proposalFunctionSent = declare(function (api) {
    api.assertVersion(7);

    var isFunctionSent = function isFunctionSent(node) {
      return isIdentifier(node.meta, {
        name: "function"
      }) && isIdentifier(node.property, {
        name: "sent"
      });
    };

    var hasBeenReplaced = function hasBeenReplaced(node, sentId) {
      return isAssignmentExpression(node) && isIdentifier(node.left, {
        name: sentId
      });
    };

    var yieldVisitor = {
      Function: function Function(path) {
        path.skip();
      },
      YieldExpression: function YieldExpression(path) {
        if (!hasBeenReplaced(path.parent, this.sentId)) {
          path.replaceWith(assignmentExpression("=", identifier(this.sentId), path.node));
        }
      },
      MetaProperty: function MetaProperty(path) {
        if (isFunctionSent(path.node)) {
          path.replaceWith(identifier(this.sentId));
        }
      }
    };
    return {
      name: "proposal-function-sent",
      inherits: syntaxFunctionSent,
      visitor: {
        MetaProperty: function MetaProperty(path, state) {
          if (!isFunctionSent(path.node)) return;
          var fnPath = path.getFunctionParent();

          if (!fnPath.node.generator) {
            throw new Error("Parent generator function not found");
          }

          var sentId = path.scope.generateUid("function.sent");
          fnPath.traverse(yieldVisitor, {
            sentId: sentId
          });
          fnPath.node.body.body.unshift(variableDeclaration("let", [variableDeclarator(identifier(sentId), yieldExpression())]));
          wrapFunction(fnPath, state.addHelper("skipFirstGeneratorNext"));
        }
      }
    };
  });

  var lib$i = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-json-strings",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsonStrings");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-json-strings/node_modules/@babel/plugin-syntax-json-strings/lib");

  var _proposalJsonStrings = declare(function (api) {
    api.assertVersion(7);
    var regex = /(\\*)([\u2028\u2029])/g;

    function replace(match, escapes, separator) {
      var isEscaped = escapes.length % 2 === 1;
      if (isEscaped) return match;
      return escapes + "\\u" + separator.charCodeAt(0).toString(16);
    }

    return {
      name: "proposal-json-strings",
      inherits: lib$i["default"],
      visitor: {
        "DirectiveLiteral|StringLiteral": function DirectiveLiteralStringLiteral(_ref) {
          var node = _ref.node;
          var extra = node.extra;
          if (!(extra != null && extra.raw)) return;
          extra.raw = extra.raw.replace(regex, replace);
        }
      }
    };
  });

  var lib$h = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-logical-assignment-operators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("logicalAssignment");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-logical-assignment-operators/node_modules/@babel/plugin-syntax-logical-assignment-operators/lib");

  var _proposalLogicalAssignmentOperators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-logical-assignment-operators",
      inherits: lib$h["default"],
      visitor: {
        AssignmentExpression: function AssignmentExpression(path) {
          var node = path.node,
              scope = path.scope;
          var operator = node.operator,
              left = node.left,
              right = node.right;
          var operatorTrunc = operator.slice(0, -1);

          if (!LOGICAL_OPERATORS.includes(operatorTrunc)) {
            return;
          }

          var lhs = cloneNode(left);

          if (isMemberExpression(left)) {
            var object = left.object,
                property = left.property,
                computed = left.computed;
            var memo = scope.maybeGenerateMemoised(object);

            if (memo) {
              left.object = memo;
              lhs.object = assignmentExpression("=", cloneNode(memo), object);
            }

            if (computed) {
              var _memo = scope.maybeGenerateMemoised(property);

              if (_memo) {
                left.property = _memo;
                lhs.property = assignmentExpression("=", cloneNode(_memo), property);
              }
            }
          }

          path.replaceWith(logicalExpression(operatorTrunc, lhs, assignmentExpression("=", left, right)));
        }
      }
    };
  });

  var lib$g = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-nullish-coalescing-operator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-nullish-coalescing-operator/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib");

  var _templateObject$f;
  var _proposalNullishCoalescingOperator = declare(function (api, _ref) {
    var _api$assumption;

    var _ref$loose = _ref.loose,
        loose = _ref$loose === void 0 ? false : _ref$loose;
    api.assertVersion(7);
    var noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
    return {
      name: "proposal-nullish-coalescing-operator",
      inherits: lib$g["default"],
      visitor: {
        LogicalExpression: function LogicalExpression(path) {
          var node = path.node,
              scope = path.scope;

          if (node.operator !== "??") {
            return;
          }

          var ref;
          var assignment;

          if (scope.isStatic(node.left)) {
            ref = node.left;
            assignment = cloneNode(node.left);
          } else if (scope.path.isPattern()) {
            path.replaceWith(template$2.ast(_templateObject$f || (_templateObject$f = _taggedTemplateLiteralLoose(["(() => ", ")()"])), path.node));
            return;
          } else {
            ref = scope.generateUidIdentifierBasedOnNode(node.left);
            scope.push({
              id: cloneNode(ref)
            });
            assignment = assignmentExpression("=", ref, node.left);
          }

          path.replaceWith(conditionalExpression(noDocumentAll ? binaryExpression("!=", assignment, nullLiteral()) : logicalExpression("&&", binaryExpression("!==", assignment, nullLiteral()), binaryExpression("!==", cloneNode(ref), scope.buildUndefinedNode())), cloneNode(ref), node.right));
        }
      }
    };
  });

  var lib$f = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-numeric-separator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("numericSeparator");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-numeric-separator/node_modules/@babel/plugin-syntax-numeric-separator/lib");

  function remover(_ref) {
    var _extra$raw;

    var node = _ref.node;
    var extra = node.extra;

    if (extra != null && (_extra$raw = extra.raw) != null && _extra$raw.includes("_")) {
      extra.raw = extra.raw.replace(/_/g, "");
    }
  }

  var _proposalNumericSeparator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-numeric-separator",
      inherits: lib$f["default"],
      visitor: {
        NumericLiteral: remover,
        BigIntLiteral: remover
      }
    };
  });

  var lib$e = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-object-rest-spread/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

  var buildDefaultParam = template$2("\n  let VARIABLE_NAME =\n    arguments.length > ARGUMENT_KEY && arguments[ARGUMENT_KEY] !== undefined ?\n      arguments[ARGUMENT_KEY]\n    :\n      DEFAULT_VALUE;\n");
  var buildLooseDefaultParam = template$2("\n  if (ASSIGNMENT_IDENTIFIER === UNDEFINED) {\n    ASSIGNMENT_IDENTIFIER = DEFAULT_VALUE;\n  }\n");
  var buildLooseDestructuredDefaultParam = template$2("\n  let ASSIGNMENT_IDENTIFIER = PARAMETER_NAME === UNDEFINED ? DEFAULT_VALUE : PARAMETER_NAME ;\n");
  var buildSafeArgumentsAccess = template$2("\n  let $0 = arguments.length > $1 ? arguments[$1] : undefined;\n");
  var iifeVisitor = {
    "ReferencedIdentifier|BindingIdentifier": function ReferencedIdentifierBindingIdentifier(path, state) {
      var scope = path.scope,
          node = path.node;
      var name = node.name;

      if (name === "eval" || scope.getBinding(name) === state.scope.parent.getBinding(name) && state.scope.hasOwnBinding(name)) {
        state.needsOuterBinding = true;
        path.stop();
      }
    },
    "TypeAnnotation|TSTypeAnnotation|TypeParameterDeclaration|TSTypeParameterDeclaration": function TypeAnnotationTSTypeAnnotationTypeParameterDeclarationTSTypeParameterDeclaration(path) {
      return path.skip();
    }
  };
  function convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement) {
    var params = path.get("params");
    var isSimpleParameterList = params.every(function (param) {
      return param.isIdentifier();
    });
    if (isSimpleParameterList) return false;
    var node = path.node,
        scope = path.scope;
    var state = {
      stop: false,
      needsOuterBinding: false,
      scope: scope
    };
    var body = [];
    var shadowedParams = new Set();

    for (var _iterator = _createForOfIteratorHelperLoose(params), _step; !(_step = _iterator()).done;) {
      var _param2 = _step.value;

      for (var _i = 0, _Object$keys = Object.keys(_param2.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
        var _scope$bindings$name;

        var name = _Object$keys[_i];
        var constantViolations = (_scope$bindings$name = scope.bindings[name]) == null ? void 0 : _scope$bindings$name.constantViolations;

        if (constantViolations) {
          for (var _iterator4 = _createForOfIteratorHelperLoose(constantViolations), _step4; !(_step4 = _iterator4()).done;) {
            var redeclarator = _step4.value;
            var _node = redeclarator.node;

            switch (_node.type) {
              case "VariableDeclarator":
                {
                  if (_node.init === null) {
                    var declaration = redeclarator.parentPath;

                    if (!declaration.parentPath.isFor() || declaration.parentPath.get("body") === declaration) {
                      redeclarator.remove();
                      break;
                    }
                  }

                  shadowedParams.add(name);
                  break;
                }

              case "FunctionDeclaration":
                shadowedParams.add(name);
                break;
            }
          }
        }
      }
    }

    if (shadowedParams.size === 0) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(params), _step2; !(_step2 = _iterator2()).done;) {
        var param = _step2.value;
        if (!param.isIdentifier()) param.traverse(iifeVisitor, state);
        if (state.needsOuterBinding) break;
      }
    }

    var firstOptionalIndex = null;

    for (var i = 0; i < params.length; i++) {
      var _param = params[i];

      if (shouldTransformParam && !shouldTransformParam(i)) {
        continue;
      }

      var transformedRestNodes = [];

      if (replaceRestElement) {
        replaceRestElement(_param.parentPath, _param, transformedRestNodes);
      }

      var paramIsAssignmentPattern = _param.isAssignmentPattern();

      if (paramIsAssignmentPattern && (ignoreFunctionLength || node.kind === "set")) {
        var left = _param.get("left");

        var right = _param.get("right");

        var undefinedNode = scope.buildUndefinedNode();

        if (left.isIdentifier()) {
          body.push(buildLooseDefaultParam({
            ASSIGNMENT_IDENTIFIER: cloneNode(left.node),
            DEFAULT_VALUE: right.node,
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(left.node);
        } else if (left.isObjectPattern() || left.isArrayPattern()) {
          var paramName = scope.generateUidIdentifier();
          body.push(buildLooseDestructuredDefaultParam({
            ASSIGNMENT_IDENTIFIER: left.node,
            DEFAULT_VALUE: right.node,
            PARAMETER_NAME: cloneNode(paramName),
            UNDEFINED: undefinedNode
          }));

          _param.replaceWith(paramName);
        }
      } else if (paramIsAssignmentPattern) {
        if (firstOptionalIndex === null) firstOptionalIndex = i;

        var _left = _param.get("left");

        var _right = _param.get("right");

        var defNode = buildDefaultParam({
          VARIABLE_NAME: _left.node,
          DEFAULT_VALUE: _right.node,
          ARGUMENT_KEY: numericLiteral(i)
        });
        body.push(defNode);
      } else if (firstOptionalIndex !== null) {
        var _defNode = buildSafeArgumentsAccess([_param.node, numericLiteral(i)]);

        body.push(_defNode);
      } else if (_param.isObjectPattern() || _param.isArrayPattern()) {
        var uid = path.scope.generateUidIdentifier("ref");

        var _defNode2 = variableDeclaration("let", [variableDeclarator(_param.node, uid)]);

        body.push(_defNode2);

        _param.replaceWith(cloneNode(uid));
      }

      if (transformedRestNodes) {
        for (var _iterator3 = _createForOfIteratorHelperLoose(transformedRestNodes), _step3; !(_step3 = _iterator3()).done;) {
          var transformedNode = _step3.value;
          body.push(transformedNode);
        }
      }
    }

    if (firstOptionalIndex !== null) {
      node.params = node.params.slice(0, firstOptionalIndex);
    }

    path.ensureBlock();

    if (state.needsOuterBinding || shadowedParams.size > 0) {
      body.push(buildScopeIIFE(shadowedParams, path.get("body").node));
      path.set("body", blockStatement(body));
      var bodyPath = path.get("body.body");
      var arrowPath = bodyPath[bodyPath.length - 1].get("argument.callee");
      arrowPath.arrowFunctionToExpression();
      arrowPath.node.generator = path.node.generator;
      arrowPath.node.async = path.node.async;
      path.node.generator = false;
    } else {
      path.get("body").unshiftContainer("body", body);
    }

    return true;
  }

  function buildScopeIIFE(shadowedParams, body) {
    var args = [];
    var params = [];

    for (var _iterator5 = _createForOfIteratorHelperLoose(shadowedParams), _step5; !(_step5 = _iterator5()).done;) {
      var name = _step5.value;
      args.push(identifier(name));
      params.push(identifier(name));
    }

    return returnStatement(callExpression(arrowFunctionExpression(params, body), args));
  }

  var buildRest = template$2("\n  for (var LEN = ARGUMENTS.length,\n           ARRAY = new Array(ARRAY_LEN),\n           KEY = START;\n       KEY < LEN;\n       KEY++) {\n    ARRAY[ARRAY_KEY] = ARGUMENTS[KEY];\n  }\n");
  var restIndex = template$2("\n  (INDEX < OFFSET || ARGUMENTS.length <= INDEX) ? undefined : ARGUMENTS[INDEX]\n");
  var restIndexImpure = template$2("\n  REF = INDEX, (REF < OFFSET || ARGUMENTS.length <= REF) ? undefined : ARGUMENTS[REF]\n");
  var restLength = template$2("\n  ARGUMENTS.length <= OFFSET ? 0 : ARGUMENTS.length - OFFSET\n");

  function referencesRest(path, state) {
    if (path.node.name === state.name) {
      return path.scope.bindingIdentifierEquals(state.name, state.outerBinding);
    }

    return false;
  }

  var memberExpressionOptimisationVisitor = {
    Scope: function Scope(path, state) {
      if (!path.scope.bindingIdentifierEquals(state.name, state.outerBinding)) {
        path.skip();
      }
    },
    Flow: function Flow(path) {
      if (path.isTypeCastExpression()) return;
      path.skip();
    },
    Function: function Function(path, state) {
      var oldNoOptimise = state.noOptimise;
      state.noOptimise = true;
      path.traverse(memberExpressionOptimisationVisitor, state);
      state.noOptimise = oldNoOptimise;
      path.skip();
    },
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var node = path.node;

      if (node.name === "arguments") {
        state.deopted = true;
      }

      if (!referencesRest(path, state)) return;

      if (state.noOptimise) {
        state.deopted = true;
      } else {
        var parentPath = path.parentPath;

        if (parentPath.listKey === "params" && parentPath.key < state.offset) {
          return;
        }

        if (parentPath.isMemberExpression({
          object: node
        })) {
          var grandparentPath = parentPath.parentPath;
          var argsOptEligible = !state.deopted && !(grandparentPath.isAssignmentExpression() && parentPath.node === grandparentPath.node.left || grandparentPath.isLVal() || grandparentPath.isForXStatement() || grandparentPath.isUpdateExpression() || grandparentPath.isUnaryExpression({
            operator: "delete"
          }) || (grandparentPath.isCallExpression() || grandparentPath.isNewExpression()) && parentPath.node === grandparentPath.node.callee);

          if (argsOptEligible) {
            if (parentPath.node.computed) {
              if (parentPath.get("property").isBaseType("number")) {
                state.candidates.push({
                  cause: "indexGetter",
                  path: path
                });
                return;
              }
            } else if (parentPath.node.property.name === "length") {
              state.candidates.push({
                cause: "lengthGetter",
                path: path
              });
              return;
            }
          }
        }

        if (state.offset === 0 && parentPath.isSpreadElement()) {
          var call = parentPath.parentPath;

          if (call.isCallExpression() && call.node.arguments.length === 1) {
            state.candidates.push({
              cause: "argSpread",
              path: path
            });
            return;
          }
        }

        state.references.push(path);
      }
    },
    BindingIdentifier: function BindingIdentifier(path, state) {
      if (referencesRest(path, state)) {
        state.deopted = true;
      }
    }
  };

  function getParamsCount(node) {
    var count = node.params.length;

    if (count > 0 && isIdentifier(node.params[0], {
      name: "this"
    })) {
      count -= 1;
    }

    return count;
  }

  function hasRest(node) {
    var length = node.params.length;
    return length > 0 && isRestElement(node.params[length - 1]);
  }

  function optimiseIndexGetter(path, argsId, offset) {
    var offsetLiteral = numericLiteral(offset);
    var index;

    if (isNumericLiteral(path.parent.property)) {
      index = numericLiteral(path.parent.property.value + offset);
    } else if (offset === 0) {
      index = path.parent.property;
    } else {
      index = binaryExpression("+", path.parent.property, cloneNode(offsetLiteral));
    }

    var scope = path.scope;

    if (!scope.isPure(index)) {
      var temp = scope.generateUidIdentifierBasedOnNode(index);
      scope.push({
        id: temp,
        kind: "var"
      });
      path.parentPath.replaceWith(restIndexImpure({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index,
        REF: cloneNode(temp)
      }));
    } else {
      var parentPath = path.parentPath;
      parentPath.replaceWith(restIndex({
        ARGUMENTS: argsId,
        OFFSET: offsetLiteral,
        INDEX: index
      }));
      var offsetTestPath = parentPath.get("test").get("left");
      var valRes = offsetTestPath.evaluate();

      if (valRes.confident) {
        if (valRes.value === true) {
          parentPath.replaceWith(parentPath.scope.buildUndefinedNode());
        } else {
          parentPath.get("test").replaceWith(parentPath.get("test").get("right"));
        }
      }
    }
  }

  function optimiseLengthGetter(path, argsId, offset) {
    if (offset) {
      path.parentPath.replaceWith(restLength({
        ARGUMENTS: argsId,
        OFFSET: numericLiteral(offset)
      }));
    } else {
      path.replaceWith(argsId);
    }
  }

  function convertFunctionRest(path) {
    var node = path.node,
        scope = path.scope;
    if (!hasRest(node)) return false;
    var rest = node.params.pop().argument;
    var argsId = identifier("arguments");

    if (isPattern(rest)) {
      var pattern = rest;
      rest = scope.generateUidIdentifier("ref");
      var declar = variableDeclaration("let", [variableDeclarator(pattern, rest)]);
      node.body.body.unshift(declar);
    }

    var paramsCount = getParamsCount(node);
    var state = {
      references: [],
      offset: paramsCount,
      argumentsNode: argsId,
      outerBinding: scope.getBindingIdentifier(rest.name),
      candidates: [],
      name: rest.name,
      deopted: false
    };
    path.traverse(memberExpressionOptimisationVisitor, state);

    if (!state.deopted && !state.references.length) {
      for (var _i = 0, _arr = state.candidates; _i < _arr.length; _i++) {
        var _arr$_i = _arr[_i],
            _path = _arr$_i.path,
            cause = _arr$_i.cause;
        var clonedArgsId = cloneNode(argsId);

        switch (cause) {
          case "indexGetter":
            optimiseIndexGetter(_path, clonedArgsId, state.offset);
            break;

          case "lengthGetter":
            optimiseLengthGetter(_path, clonedArgsId, state.offset);
            break;

          default:
            _path.replaceWith(clonedArgsId);

        }
      }

      return true;
    }

    state.references = state.references.concat(state.candidates.map(function (_ref) {
      var path = _ref.path;
      return path;
    }));
    var start = numericLiteral(paramsCount);
    var key = scope.generateUidIdentifier("key");
    var len = scope.generateUidIdentifier("len");
    var arrKey, arrLen;

    if (paramsCount) {
      arrKey = binaryExpression("-", cloneNode(key), cloneNode(start));
      arrLen = conditionalExpression(binaryExpression(">", cloneNode(len), cloneNode(start)), binaryExpression("-", cloneNode(len), cloneNode(start)), numericLiteral(0));
    } else {
      arrKey = identifier(key.name);
      arrLen = identifier(len.name);
    }

    var loop = buildRest({
      ARGUMENTS: argsId,
      ARRAY_KEY: arrKey,
      ARRAY_LEN: arrLen,
      START: start,
      ARRAY: rest,
      KEY: key,
      LEN: len
    });

    if (state.deopted) {
      node.body.body.unshift(loop);
    } else {
      var target = path.getEarliestCommonAncestorFrom(state.references).getStatementParent();
      target.findParent(function (path) {
        if (path.isLoop()) {
          target = path;
        } else {
          return path.isFunction();
        }
      });
      target.insertBefore(loop);
    }

    return true;
  }

  var _transformParameters = declare(function (api, options) {
    var _api$assumption;

    api.assertVersion(7);
    var ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : options.loose;
    var noNewArrows = api.assumption("noNewArrows");
    return {
      name: "transform-parameters",
      visitor: {
        Function: function Function(path) {
          if (path.isArrowFunctionExpression() && path.get("params").some(function (param) {
            return param.isRestElement() || param.isAssignmentPattern();
          })) {
            path.arrowFunctionToExpression({
              noNewArrows: noNewArrows
            });
          }

          var convertedRest = convertFunctionRest(path);
          var convertedParams = convertFunctionParams(path, ignoreFunctionLength);

          if (convertedRest || convertedParams) {
            path.scope.crawl();
          }
        }
      }
    };
  });

  var require$$0$5 = {
  	"es6.array.copy-within": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "32",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.every": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.fill": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "31",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.filter": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.array.find": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.find-index": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "4",
  	ios: "8",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es7.array.flat-map": {
  	chrome: "69",
  	opera: "56",
  	edge: "79",
  	firefox: "62",
  	safari: "12",
  	node: "11",
  	ios: "12",
  	samsung: "10",
  	electron: "4.0"
  },
  	"es6.array.for-each": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.from": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "36",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.array.includes": {
  	chrome: "47",
  	opera: "34",
  	edge: "14",
  	firefox: "43",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"es6.array.index-of": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.is-array": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.iterator": {
  	chrome: "66",
  	opera: "53",
  	edge: "12",
  	firefox: "60",
  	safari: "9",
  	node: "10",
  	ios: "9",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es6.array.last-index-of": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.map": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.array.of": {
  	chrome: "45",
  	opera: "32",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "5",
  	electron: "0.31"
  },
  	"es6.array.reduce": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.reduce-right": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.slice": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.array.some": {
  	chrome: "5",
  	opera: "10.10",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.array.sort": {
  	chrome: "63",
  	opera: "50",
  	edge: "12",
  	firefox: "5",
  	safari: "12",
  	node: "10",
  	ie: "9",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.array.species": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.date.now": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-iso-string": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3.5",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-json": {
  	chrome: "5",
  	opera: "12.10",
  	edge: "12",
  	firefox: "4",
  	safari: "10",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "10",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.date.to-primitive": {
  	chrome: "47",
  	opera: "34",
  	edge: "15",
  	firefox: "44",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.36"
  },
  	"es6.date.to-string": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "2",
  	safari: "3.1",
  	node: "0.10",
  	ie: "10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.function.bind": {
  	chrome: "7",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.function.has-instance": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "50",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.function.name": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "14",
  	firefox: "2",
  	safari: "4",
  	node: "0.10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.map": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.math.acosh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.asinh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.atanh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.cbrt": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.clz32": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.cosh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.expm1": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.fround": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "26",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.hypot": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "27",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.imul": {
  	chrome: "30",
  	opera: "17",
  	edge: "12",
  	firefox: "23",
  	safari: "7",
  	node: "0.12",
  	android: "4.4",
  	ios: "7",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.math.log1p": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.log10": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.log2": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.sign": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.sinh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.tanh": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.math.trunc": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "25",
  	safari: "7.1",
  	node: "0.12",
  	ios: "8",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.number.constructor": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.number.epsilon": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.is-finite": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "16",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.number.is-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "16",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.is-nan": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "15",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.number.is-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "32",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.max-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.min-safe-integer": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.parse-float": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.number.parse-int": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "25",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es6.object.assign": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "36",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.object.create": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.object.define-getter": {
  	chrome: "62",
  	opera: "49",
  	edge: "16",
  	firefox: "48",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es7.object.define-setter": {
  	chrome: "62",
  	opera: "49",
  	edge: "16",
  	firefox: "48",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.object.define-property": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "5.1",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.object.define-properties": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "4",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.object.entries": {
  	chrome: "54",
  	opera: "41",
  	edge: "14",
  	firefox: "47",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.object.freeze": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.get-own-property-descriptor": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es7.object.get-own-property-descriptors": {
  	chrome: "54",
  	opera: "41",
  	edge: "15",
  	firefox: "50",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.object.get-own-property-names": {
  	chrome: "40",
  	opera: "27",
  	edge: "12",
  	firefox: "33",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.object.get-prototype-of": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es7.object.lookup-getter": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "36",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es7.object.lookup-setter": {
  	chrome: "62",
  	opera: "49",
  	edge: "79",
  	firefox: "36",
  	safari: "9",
  	node: "8.10",
  	ios: "9",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.object.prevent-extensions": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.to-string": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "51",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es6.object.is": {
  	chrome: "19",
  	opera: "15",
  	edge: "12",
  	firefox: "22",
  	safari: "9",
  	node: "0.12",
  	android: "4.1",
  	ios: "9",
  	samsung: "1.5",
  	electron: "0.20"
  },
  	"es6.object.is-frozen": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.is-sealed": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.is-extensible": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.keys": {
  	chrome: "40",
  	opera: "27",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.object.seal": {
  	chrome: "44",
  	opera: "31",
  	edge: "12",
  	firefox: "35",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "4",
  	electron: "0.30"
  },
  	"es6.object.set-prototype-of": {
  	chrome: "34",
  	opera: "21",
  	edge: "12",
  	firefox: "31",
  	safari: "9",
  	node: "0.12",
  	ie: "11",
  	ios: "9",
  	samsung: "2",
  	electron: "0.20"
  },
  	"es7.object.values": {
  	chrome: "54",
  	opera: "41",
  	edge: "14",
  	firefox: "47",
  	safari: "10.1",
  	node: "7",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.4"
  },
  	"es6.promise": {
  	chrome: "51",
  	opera: "38",
  	edge: "14",
  	firefox: "45",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.promise.finally": {
  	chrome: "63",
  	opera: "50",
  	edge: "18",
  	firefox: "58",
  	safari: "11.1",
  	node: "10",
  	ios: "11.3",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.reflect.apply": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.construct": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.define-property": {
  	chrome: "49",
  	opera: "36",
  	edge: "13",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.delete-property": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get-own-property-descriptor": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.get-prototype-of": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.has": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.is-extensible": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.own-keys": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.prevent-extensions": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.set": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.reflect.set-prototype-of": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "42",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.regexp.constructor": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "40",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.flags": {
  	chrome: "49",
  	opera: "36",
  	edge: "79",
  	firefox: "37",
  	safari: "9",
  	node: "6",
  	ios: "9",
  	samsung: "5",
  	electron: "0.37"
  },
  	"es6.regexp.match": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.replace": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.split": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.search": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "49",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.regexp.to-string": {
  	chrome: "50",
  	opera: "37",
  	edge: "79",
  	firefox: "39",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "1.1"
  },
  	"es6.set": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.symbol": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "51",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es7.symbol.async-iterator": {
  	chrome: "63",
  	opera: "50",
  	edge: "79",
  	firefox: "57",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "8",
  	electron: "3.0"
  },
  	"es6.string.anchor": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.big": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.blink": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.bold": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.code-point-at": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.ends-with": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.fixed": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.fontcolor": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.fontsize": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.from-code-point": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.includes": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "40",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.italics": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.iterator": {
  	chrome: "38",
  	opera: "25",
  	edge: "12",
  	firefox: "36",
  	safari: "9",
  	node: "0.12",
  	ios: "9",
  	samsung: "3",
  	electron: "0.20"
  },
  	"es6.string.link": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.string.pad-start": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "48",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es7.string.pad-end": {
  	chrome: "57",
  	opera: "44",
  	edge: "15",
  	firefox: "48",
  	safari: "10",
  	node: "8",
  	ios: "10",
  	samsung: "7",
  	electron: "1.7"
  },
  	"es6.string.raw": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.repeat": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "24",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.small": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.starts-with": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "29",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"es6.string.strike": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.sub": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.sup": {
  	chrome: "5",
  	opera: "15",
  	edge: "12",
  	firefox: "17",
  	safari: "6",
  	node: "0.10",
  	android: "4",
  	ios: "7",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.string.trim": {
  	chrome: "5",
  	opera: "10.50",
  	edge: "12",
  	firefox: "3.5",
  	safari: "4",
  	node: "0.10",
  	ie: "9",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es7.string.trim-left": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "61",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es7.string.trim-right": {
  	chrome: "66",
  	opera: "53",
  	edge: "79",
  	firefox: "61",
  	safari: "12",
  	node: "10",
  	ios: "12",
  	samsung: "9",
  	electron: "3.0"
  },
  	"es6.typed.array-buffer": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.data-view": {
  	chrome: "5",
  	opera: "12",
  	edge: "12",
  	firefox: "15",
  	safari: "5.1",
  	node: "0.10",
  	ie: "10",
  	android: "4",
  	ios: "6",
  	phantom: "2",
  	samsung: "1",
  	electron: "0.20"
  },
  	"es6.typed.int8-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint8-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint8-clamped-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.int16-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint16-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.int32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.uint32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.float32-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.typed.float64-array": {
  	chrome: "51",
  	opera: "38",
  	edge: "13",
  	firefox: "48",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.weak-map": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "9",
  	node: "6.5",
  	ios: "9",
  	samsung: "5",
  	electron: "1.2"
  },
  	"es6.weak-set": {
  	chrome: "51",
  	opera: "38",
  	edge: "15",
  	firefox: "53",
  	safari: "9",
  	node: "6.5",
  	ios: "9",
  	samsung: "5",
  	electron: "1.2"
  }
  };

  var corejs2BuiltIns = require$$0$5;

  var ZERO_REFS = function () {
    var node = identifier("a");
    var property = objectProperty(identifier("key"), node);
    var pattern = objectPattern([property]);
    return isReferenced(node, property, pattern) ? 1 : 0;
  }();

  var _proposalObjectRestSpread = declare(function (api, opts) {
    var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;

    api.assertVersion(7);
    var targets = api.targets();
    var supportsObjectAssign = !isRequired("es6.object.assign", targets, {
      compatData: corejs2BuiltIns
    });
    var _opts$useBuiltIns = opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? supportsObjectAssign : _opts$useBuiltIns,
        _opts$loose = opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose;

    if (typeof loose !== "boolean") {
      throw new Error(".loose must be a boolean, or undefined");
    }

    var ignoreFunctionLength = (_api$assumption = api.assumption("ignoreFunctionLength")) != null ? _api$assumption : loose;
    var objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : loose;
    var pureGetters = (_api$assumption3 = api.assumption("pureGetters")) != null ? _api$assumption3 : loose;
    var setSpreadProperties = (_api$assumption4 = api.assumption("setSpreadProperties")) != null ? _api$assumption4 : loose;

    function getExtendsHelper(file) {
      return useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
    }

    function hasRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        foundRestElement = true;
        restElement.stop();
      });
      return foundRestElement;
    }

    function hasObjectPatternRestElement(path) {
      var foundRestElement = false;
      visitRestElements(path, function (restElement) {
        if (restElement.parentPath.isObjectPattern()) {
          foundRestElement = true;
          restElement.stop();
        }
      });
      return foundRestElement;
    }

    function visitRestElements(path, visitor) {
      path.traverse({
        Expression: function Expression(path) {
          var parentType = path.parent.type;

          if (parentType === "AssignmentPattern" && path.key === "right" || parentType === "ObjectProperty" && path.parent.computed && path.key === "key") {
            path.skip();
          }
        },
        RestElement: visitor
      });
    }

    function hasSpread(node) {
      for (var _iterator = _createForOfIteratorHelperLoose(node.properties), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (isSpreadElement(prop)) {
          return true;
        }
      }

      return false;
    }

    function extractNormalizedKeys(path) {
      var props = path.node.properties;
      var keys = [];
      var allLiteral = true;
      var hasTemplateLiteral = false;

      for (var _iterator2 = _createForOfIteratorHelperLoose(props), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;

        if (isIdentifier(prop.key) && !prop.computed) {
          keys.push(stringLiteral(prop.key.name));
        } else if (isTemplateLiteral(prop.key)) {
          keys.push(cloneNode(prop.key));
          hasTemplateLiteral = true;
        } else if (isLiteral(prop.key)) {
          keys.push(stringLiteral(String(prop.key.value)));
        } else {
          keys.push(cloneNode(prop.key));
          allLiteral = false;
        }
      }

      return {
        keys: keys,
        allLiteral: allLiteral,
        hasTemplateLiteral: hasTemplateLiteral
      };
    }

    function replaceImpureComputedKeys(properties, scope) {
      var impureComputedPropertyDeclarators = [];

      for (var _iterator3 = _createForOfIteratorHelperLoose(properties), _step3; !(_step3 = _iterator3()).done;) {
        var propPath = _step3.value;
        var key = propPath.get("key");

        if (propPath.node.computed && !key.isPure()) {
          var name = scope.generateUidBasedOnNode(key.node);
          var declarator = variableDeclarator(identifier(name), key.node);
          impureComputedPropertyDeclarators.push(declarator);
          key.replaceWith(identifier(name));
        }
      }

      return impureComputedPropertyDeclarators;
    }

    function removeUnusedExcludedKeys(path) {
      var bindings = path.getOuterBindingIdentifierPaths();
      Object.keys(bindings).forEach(function (bindingName) {
        var bindingParentPath = bindings[bindingName].parentPath;

        if (path.scope.getBinding(bindingName).references > ZERO_REFS || !bindingParentPath.isObjectProperty()) {
          return;
        }

        bindingParentPath.remove();
      });
    }

    function createObjectRest(path, file, objRef) {
      var props = path.get("properties");
      var last = props[props.length - 1];
      assertRestElement(last.node);
      var restElement = cloneNode(last.node);
      last.remove();
      var impureComputedPropertyDeclarators = replaceImpureComputedKeys(path.get("properties"), path.scope);

      var _extractNormalizedKey = extractNormalizedKeys(path),
          keys = _extractNormalizedKey.keys,
          allLiteral = _extractNormalizedKey.allLiteral,
          hasTemplateLiteral = _extractNormalizedKey.hasTemplateLiteral;

      if (keys.length === 0) {
        return [impureComputedPropertyDeclarators, restElement.argument, callExpression(getExtendsHelper(file), [objectExpression([]), cloneNode(objRef)])];
      }

      var keyExpression;

      if (!allLiteral) {
        keyExpression = callExpression(memberExpression(arrayExpression(keys), identifier("map")), [file.addHelper("toPropertyKey")]);
      } else {
        keyExpression = arrayExpression(keys);

        if (!hasTemplateLiteral && !isProgram(path.scope.block)) {
          var program = path.findParent(function (path) {
            return path.isProgram();
          });
          var id = path.scope.generateUidIdentifier("excluded");
          program.scope.push({
            id: id,
            init: keyExpression,
            kind: "const"
          });
          keyExpression = cloneNode(id);
        }
      }

      return [impureComputedPropertyDeclarators, restElement.argument, callExpression(file.addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [cloneNode(objRef), keyExpression])];
    }

    function replaceRestElement(parentPath, paramPath, container) {
      if (paramPath.isAssignmentPattern()) {
        replaceRestElement(parentPath, paramPath.get("left"), container);
        return;
      }

      if (paramPath.isArrayPattern() && hasRestElement(paramPath)) {
        var elements = paramPath.get("elements");

        for (var i = 0; i < elements.length; i++) {
          replaceRestElement(parentPath, elements[i], container);
        }
      }

      if (paramPath.isObjectPattern() && hasRestElement(paramPath)) {
        var uid = parentPath.scope.generateUidIdentifier("ref");
        var declar = variableDeclaration("let", [variableDeclarator(paramPath.node, uid)]);

        if (container) {
          container.push(declar);
        } else {
          parentPath.ensureBlock();
          parentPath.get("body").unshiftContainer("body", declar);
        }

        paramPath.replaceWith(cloneNode(uid));
      }
    }

    return {
      name: "proposal-object-rest-spread",
      inherits: lib$e["default"],
      visitor: {
        Function: function Function(path) {
          var params = path.get("params");
          var paramsWithRestElement = new Set();
          var idsInRestParams = new Set();

          for (var _i = 0; _i < params.length; ++_i) {
            var param = params[_i];

            if (hasRestElement(param)) {
              paramsWithRestElement.add(_i);

              for (var _i2 = 0, _Object$keys = Object.keys(param.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
                var name = _Object$keys[_i2];
                idsInRestParams.add(name);
              }
            }
          }

          var idInRest = false;

          var IdentifierHandler = function IdentifierHandler(path, functionScope) {
            var name = path.node.name;

            if (path.scope.getBinding(name) === functionScope.getBinding(name) && idsInRestParams.has(name)) {
              idInRest = true;
              path.stop();
            }
          };

          var i;

          for (i = 0; i < params.length && !idInRest; ++i) {
            var _param = params[i];

            if (!paramsWithRestElement.has(i)) {
              if (_param.isReferencedIdentifier() || _param.isBindingIdentifier()) {
                IdentifierHandler(path, path.scope);
              } else {
                _param.traverse({
                  "Scope|TypeAnnotation|TSTypeAnnotation": function ScopeTypeAnnotationTSTypeAnnotation(path) {
                    return path.skip();
                  },
                  "ReferencedIdentifier|BindingIdentifier": IdentifierHandler
                }, path.scope);
              }
            }
          }

          if (!idInRest) {
            for (var _i3 = 0; _i3 < params.length; ++_i3) {
              var _param2 = params[_i3];

              if (paramsWithRestElement.has(_i3)) {
                replaceRestElement(_param2.parentPath, _param2);
              }
            }
          } else {
            var shouldTransformParam = function shouldTransformParam(idx) {
              return idx >= i - 1 || paramsWithRestElement.has(idx);
            };

            convertFunctionParams(path, ignoreFunctionLength, shouldTransformParam, replaceRestElement);
          }
        },
        VariableDeclarator: function VariableDeclarator(path, file) {
          if (!path.get("id").isObjectPattern()) {
            return;
          }

          var insertionPath = path;
          var originalPath = path;
          visitRestElements(path.get("id"), function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            if (originalPath.node.id.properties.length > 1 && !isIdentifier(originalPath.node.init)) {
              var initRef = path.scope.generateUidIdentifierBasedOnNode(originalPath.node.init, "ref");
              originalPath.insertBefore(variableDeclarator(initRef, originalPath.node.init));
              originalPath.replaceWith(variableDeclarator(originalPath.node.id, cloneNode(initRef)));
              return;
            }

            var ref = originalPath.node.init;
            var refPropertyPath = [];
            var kind;
            path.findParent(function (path) {
              if (path.isObjectProperty()) {
                refPropertyPath.unshift(path);
              } else if (path.isVariableDeclarator()) {
                kind = path.parentPath.node.kind;
                return true;
              }
            });
            var impureObjRefComputedDeclarators = replaceImpureComputedKeys(refPropertyPath, path.scope);
            refPropertyPath.forEach(function (prop) {
              var node = prop.node;
              ref = memberExpression(ref, cloneNode(node.key), node.computed || isLiteral(node.key));
            });
            var objectPatternPath = path.findParent(function (path) {
              return path.isObjectPattern();
            });

            var _createObjectRest = createObjectRest(objectPatternPath, file, ref),
                _createObjectRest2 = _slicedToArray$2(_createObjectRest, 3),
                impureComputedPropertyDeclarators = _createObjectRest2[0],
                argument = _createObjectRest2[1],
                callExpression = _createObjectRest2[2];

            if (pureGetters) {
              removeUnusedExcludedKeys(objectPatternPath);
            }

            assertIdentifier(argument);
            insertionPath.insertBefore(impureComputedPropertyDeclarators);
            insertionPath.insertBefore(impureObjRefComputedDeclarators);
            insertionPath.insertAfter(variableDeclarator(argument, callExpression));
            insertionPath = insertionPath.getSibling(insertionPath.key + 1);
            path.scope.registerBinding(kind, insertionPath);

            if (objectPatternPath.node.properties.length === 0) {
              objectPatternPath.findParent(function (path) {
                return path.isObjectProperty() || path.isVariableDeclarator();
              }).remove();
            }
          });
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          var hasRest = declaration.get("declarations").some(function (path) {
            return hasObjectPatternRestElement(path.get("id"));
          });
          if (!hasRest) return;
          var specifiers = [];

          for (var _i4 = 0, _Object$keys2 = Object.keys(path.getOuterBindingIdentifiers(path)); _i4 < _Object$keys2.length; _i4++) {
            var name = _Object$keys2[_i4];
            specifiers.push(exportSpecifier(identifier(name), identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(exportNamedDeclaration(null, specifiers));
        },
        CatchClause: function CatchClause(path) {
          var paramPath = path.get("param");
          replaceRestElement(paramPath.parentPath, paramPath);
        },
        AssignmentExpression: function AssignmentExpression(path, file) {
          var leftPath = path.get("left");

          if (leftPath.isObjectPattern() && hasRestElement(leftPath)) {
            var nodes = [];
            var refName = path.scope.generateUidBasedOnNode(path.node.right, "ref");
            nodes.push(variableDeclaration("var", [variableDeclarator(identifier(refName), path.node.right)]));

            var _createObjectRest3 = createObjectRest(leftPath, file, identifier(refName)),
                _createObjectRest4 = _slicedToArray$2(_createObjectRest3, 3),
                impureComputedPropertyDeclarators = _createObjectRest4[0],
                argument = _createObjectRest4[1],
                callExpression = _createObjectRest4[2];

            if (impureComputedPropertyDeclarators.length > 0) {
              nodes.push(variableDeclaration("var", impureComputedPropertyDeclarators));
            }

            var nodeWithoutSpread = cloneNode(path.node);
            nodeWithoutSpread.right = identifier(refName);
            nodes.push(expressionStatement(nodeWithoutSpread));
            nodes.push(toStatement(assignmentExpression("=", argument, callExpression)));
            nodes.push(expressionStatement(identifier(refName)));
            path.replaceWithMultiple(nodes);
          }
        },
        ForXStatement: function ForXStatement(path) {
          var node = path.node,
              scope = path.scope;
          var leftPath = path.get("left");
          var left = node.left;

          if (!hasObjectPatternRestElement(leftPath)) {
            return;
          }

          if (!isVariableDeclaration(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration("var", [variableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(expressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(expressionStatement(assignmentExpression("=", left, cloneNode(temp))));
          } else {
            var pattern = left.declarations[0].id;
            var key = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration(left.kind, [variableDeclarator(key, null)]);
            path.ensureBlock();
            node.body.body.unshift(variableDeclaration(node.left.kind, [variableDeclarator(pattern, cloneNode(key))]));
          }
        },
        ArrayPattern: function ArrayPattern(path) {
          var objectPatterns = [];
          visitRestElements(path, function (path) {
            if (!path.parentPath.isObjectPattern()) {
              return;
            }

            var objectPattern = path.parentPath;
            var uid = path.scope.generateUidIdentifier("ref");
            objectPatterns.push(variableDeclarator(objectPattern.node, uid));
            objectPattern.replaceWith(cloneNode(uid));
            path.skip();
          });

          if (objectPatterns.length > 0) {
            var statementPath = path.getStatementParent();
            statementPath.insertAfter(variableDeclaration(statementPath.node.kind || "var", objectPatterns));
          }
        },
        ObjectExpression: function ObjectExpression(path, file) {
          if (!hasSpread(path.node)) return;
          var helper;

          if (setSpreadProperties) {
            helper = getExtendsHelper(file);
          } else {
            try {
              helper = file.addHelper("objectSpread2");
            } catch (_unused) {
              this.file.declarations["objectSpread2"] = null;
              helper = file.addHelper("objectSpread");
            }
          }

          var exp = null;
          var props = [];

          function make() {
            var hadProps = props.length > 0;
            var obj = objectExpression(props);
            props = [];

            if (!exp) {
              exp = callExpression(helper, [obj]);
              return;
            }

            if (pureGetters) {
              if (hadProps) {
                exp.arguments.push(obj);
              }

              return;
            }

            exp = callExpression(cloneNode(helper), [exp].concat(_toConsumableArray(hadProps ? [objectExpression([]), obj] : [])));
          }

          for (var _i5 = 0, _arr = path.node.properties; _i5 < _arr.length; _i5++) {
            var prop = _arr[_i5];

            if (isSpreadElement(prop)) {
              make();
              exp.arguments.push(prop.argument);
            } else {
              props.push(prop);
            }
          }

          if (props.length) make();
          path.replaceWith(exp);
        }
      }
    };
  });

  var lib$d = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-optional-catch-binding/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

  var _proposalOptionalCatchBinding = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-optional-catch-binding",
      inherits: lib$d["default"],
      visitor: {
        CatchClause: function CatchClause(path) {
          if (!path.node.param) {
            var uid = path.scope.generateUidIdentifier("unused");
            var paramPath = path.get("param");
            paramPath.replaceWith(uid);
          }
        }
      }
    };
  });

  var lib$c = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-chaining",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-plugin-proposal-optional-chaining/node_modules/@babel/plugin-syntax-optional-chaining/lib");

  function isTransparentExprWrapper(node) {
    return isTSAsExpression(node) || isTSTypeAssertion(node) || isTSNonNullExpression(node) || isTypeCastExpression(node) || isParenthesizedExpression(node);
  }
  function skipTransparentExprWrappers(path) {
    while (isTransparentExprWrapper(path.node)) {
      path = path.get("expression");
    }

    return path;
  }

  function willPathCastToBoolean(path) {
    var maybeWrapped = findOutermostTransparentParent(path);
    var node = maybeWrapped.node,
        parentPath = maybeWrapped.parentPath;

    if (parentPath.isLogicalExpression()) {
      var _parentPath$node = parentPath.node,
          operator = _parentPath$node.operator,
          right = _parentPath$node.right;

      if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
        return willPathCastToBoolean(parentPath);
      }
    }

    if (parentPath.isSequenceExpression()) {
      var expressions = parentPath.node.expressions;

      if (expressions[expressions.length - 1] === node) {
        return willPathCastToBoolean(parentPath);
      } else {
        return true;
      }
    }

    return parentPath.isConditional({
      test: node
    }) || parentPath.isUnaryExpression({
      operator: "!"
    }) || parentPath.isLoop({
      test: node
    });
  }
  function findOutermostTransparentParent(path) {
    var maybeWrapped = path;
    path.findParent(function (p) {
      if (!isTransparentExprWrapper(p)) return true;
      maybeWrapped = p;
    });
    return maybeWrapped;
  }

  var _templateObject$e, _templateObject2$7, _templateObject3$6, _templateObject4$2, _templateObject5$1, _templateObject6$1, _templateObject7;
  var ast = template$2.expression.ast;

  function isSimpleMemberExpression(expression) {
    expression = skipTransparentExprWrappers(expression);
    return isIdentifier(expression) || isSuper(expression) || isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
  }

  function needsMemoize(path) {
    var optionalPath = path;
    var scope = path.scope;

    while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
      var _optionalPath = optionalPath,
          node = _optionalPath.node;
      var childKey = optionalPath.isOptionalMemberExpression() ? "object" : "callee";
      var childPath = skipTransparentExprWrappers(optionalPath.get(childKey));

      if (node.optional) {
        return !scope.isStatic(childPath.node);
      }

      optionalPath = childPath;
    }
  }

  function transform$1(path, _ref) {
    var pureGetters = _ref.pureGetters,
        noDocumentAll = _ref.noDocumentAll;
    var scope = path.scope;
    var maybeWrapped = findOutermostTransparentParent(path);
    var parentPath = maybeWrapped.parentPath;
    var willReplacementCastToBoolean = willPathCastToBoolean(maybeWrapped);
    var isDeleteOperation = false;
    var parentIsCall = parentPath.isCallExpression({
      callee: maybeWrapped.node
    }) && path.isOptionalMemberExpression();
    var optionals = [];
    var optionalPath = path;

    if (scope.path.isPattern() && needsMemoize(optionalPath)) {
      path.replaceWith(template$2.ast(_templateObject$e || (_templateObject$e = _taggedTemplateLiteralLoose(["(() => ", ")()"])), path.node));
      return;
    }

    while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
      var _optionalPath2 = optionalPath,
          node = _optionalPath2.node;

      if (node.optional) {
        optionals.push(node);
      }

      if (optionalPath.isOptionalMemberExpression()) {
        optionalPath.node.type = "MemberExpression";
        optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
      } else if (optionalPath.isOptionalCallExpression()) {
        optionalPath.node.type = "CallExpression";
        optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
      }
    }

    var replacementPath = path;

    if (parentPath.isUnaryExpression({
      operator: "delete"
    })) {
      replacementPath = parentPath;
      isDeleteOperation = true;
    }

    for (var i = optionals.length - 1; i >= 0; i--) {
      var _node = optionals[i];
      var isCall = isCallExpression(_node);
      var replaceKey = isCall ? "callee" : "object";
      var chainWithTypes = _node[replaceKey];
      var chain = chainWithTypes;

      while (isTransparentExprWrapper(chain)) {
        chain = chain.expression;
      }

      var ref = void 0;
      var check = void 0;

      if (isCall && isIdentifier(chain, {
        name: "eval"
      })) {
        check = ref = chain;
        _node[replaceKey] = sequenceExpression([numericLiteral(0), ref]);
      } else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
        check = ref = chainWithTypes;
      } else {
        ref = scope.maybeGenerateMemoised(chain);

        if (ref) {
          check = assignmentExpression("=", cloneNode(ref), chainWithTypes);
          _node[replaceKey] = ref;
        } else {
          check = ref = chainWithTypes;
        }
      }

      if (isCall && isMemberExpression(chain)) {
        if (pureGetters && isSimpleMemberExpression(chain)) {
          _node.callee = chainWithTypes;
        } else {
          var _chain = chain,
              object = _chain.object;
          var context = scope.maybeGenerateMemoised(object);

          if (context) {
            chain.object = assignmentExpression("=", context, object);
          } else if (isSuper(object)) {
            context = thisExpression();
          } else {
            context = object;
          }

          _node.arguments.unshift(cloneNode(context));

          _node.callee = memberExpression(_node.callee, identifier("call"));
        }
      }

      var replacement = replacementPath.node;

      if (i === 0 && parentIsCall) {
        var _baseRef;

        var _object = skipTransparentExprWrappers(replacementPath.get("object")).node;
        var baseRef = void 0;

        if (!pureGetters || !isSimpleMemberExpression(_object)) {
          baseRef = scope.maybeGenerateMemoised(_object);

          if (baseRef) {
            replacement.object = assignmentExpression("=", baseRef, _object);
          }
        }

        replacement = callExpression(memberExpression(replacement, identifier("bind")), [cloneNode((_baseRef = baseRef) != null ? _baseRef : _object)]);
      }

      if (willReplacementCastToBoolean) {
        var nonNullishCheck = noDocumentAll ? ast(_templateObject2$7 || (_templateObject2$7 = _taggedTemplateLiteralLoose(["", " != null"])), cloneNode(check)) : ast(_templateObject3$6 || (_templateObject3$6 = _taggedTemplateLiteralLoose(["\n            ", " !== null && ", " !== void 0"])), cloneNode(check), cloneNode(ref));
        replacementPath.replaceWith(logicalExpression("&&", nonNullishCheck, replacement));
        replacementPath = skipTransparentExprWrappers(replacementPath.get("right"));
      } else {
        var nullishCheck = noDocumentAll ? ast(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteralLoose(["", " == null"])), cloneNode(check)) : ast(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteralLoose(["\n            ", " === null || ", " === void 0"])), cloneNode(check), cloneNode(ref));
        var returnValue = isDeleteOperation ? ast(_templateObject6$1 || (_templateObject6$1 = _taggedTemplateLiteralLoose(["true"]))) : ast(_templateObject7 || (_templateObject7 = _taggedTemplateLiteralLoose(["void 0"])));
        replacementPath.replaceWith(conditionalExpression(nullishCheck, returnValue, replacement));
        replacementPath = skipTransparentExprWrappers(replacementPath.get("alternate"));
      }
    }
  }

  var _proposalOptionalChaining = declare(function (api, options) {
    var _api$assumption, _api$assumption2;

    api.assertVersion(7);
    var _options$loose = options.loose,
        loose = _options$loose === void 0 ? false : _options$loose;
    var noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
    var pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
    return {
      name: "proposal-optional-chaining",
      inherits: lib$c["default"],
      visitor: {
        "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
          transform$1(path, {
            noDocumentAll: noDocumentAll,
            pureGetters: pureGetters
          });
        }
      }
    };
  });

  var buildOptimizedSequenceExpression = function buildOptimizedSequenceExpression(_ref) {
    var assign = _ref.assign,
        call = _ref.call,
        path = _ref.path;
    var placeholderNode = assign.left,
        pipelineLeft = assign.right;
    var calledExpression = call.callee;
    var optimizeArrow = isArrowFunctionExpression(calledExpression) && isExpression(calledExpression.body) && !calledExpression.async && !calledExpression.generator;
    var param;

    if (optimizeArrow) {
      var params = calledExpression.params;

      if (params.length === 1 && isIdentifier(params[0])) {
        param = params[0];
      } else if (params.length > 0) {
        optimizeArrow = false;
      }
    } else if (isIdentifier(calledExpression, {
      name: "eval"
    })) {
      var evalSequence = sequenceExpression([numericLiteral(0), calledExpression]);
      call.callee = evalSequence;
      path.scope.push({
        id: cloneNode(placeholderNode)
      });
      return sequenceExpression([assign, call]);
    }

    if (optimizeArrow && !param) {
      return sequenceExpression([pipelineLeft, calledExpression.body]);
    }

    path.scope.push({
      id: cloneNode(placeholderNode)
    });

    if (param) {
      path.get("right").scope.rename(param.name, placeholderNode.name);
      return sequenceExpression([assign, calledExpression.body]);
    }

    return sequenceExpression([assign, call]);
  };

  var minimalVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = callExpression(right, [cloneNode(placeholder)]);
      path.replaceWith(buildOptimizedSequenceExpression({
        assign: assignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      }));
    }
  };

  var updateTopicReferenceVisitor = {
    PipelinePrimaryTopicReference: function PipelinePrimaryTopicReference(path) {
      path.replaceWith(cloneNode(this.topicId));
    },
    PipelineTopicExpression: function PipelineTopicExpression(path) {
      path.skip();
    }
  };
  var smartVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope;
      var node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      scope.push({
        id: placeholder
      });
      var call;

      if (isPipelineTopicExpression(right)) {
        path.get("right").traverse(updateTopicReferenceVisitor, {
          topicId: placeholder
        });
        call = right.expression;
      } else {
        var callee = right.callee;

        if (isIdentifier(callee, {
          name: "eval"
        })) {
          callee = sequenceExpression([numericLiteral(0), callee]);
        }

        call = callExpression(callee, [cloneNode(placeholder)]);
      }

      path.replaceWith(sequenceExpression([assignmentExpression("=", cloneNode(placeholder), left), call]));
    }
  };

  var fsharpVisitor = {
    BinaryExpression: function BinaryExpression(path) {
      var scope = path.scope,
          node = path.node;
      var operator = node.operator,
          left = node.left,
          right = node.right;
      if (operator !== "|>") return;
      var placeholder = scope.generateUidIdentifierBasedOnNode(left);
      var call = right.type === "AwaitExpression" ? awaitExpression(cloneNode(placeholder)) : callExpression(right, [cloneNode(placeholder)]);
      var sequence = buildOptimizedSequenceExpression({
        assign: assignmentExpression("=", cloneNode(placeholder), left),
        call: call,
        path: path
      });
      path.replaceWith(sequence);
    }
  };

  var visitorsPerProposal = {
    minimal: minimalVisitor,
    smart: smartVisitor,
    fsharp: fsharpVisitor
  };
  var proposalPipelineOperator = declare(function (api, options) {
    api.assertVersion(7);
    return {
      name: "proposal-pipeline-operator",
      inherits: syntaxPipelineOperator,
      visitor: visitorsPerProposal[options.proposal]
    };
  });

  var _proposalPrivateMethods = declare(function (api, options) {
    api.assertVersion(7);
    return createClassFeaturePlugin({
      name: "proposal-private-methods",
      api: api,
      feature: FEATURES$1.privateMethods,
      loose: options.loose,
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("classPrivateMethods");
      }
    });
  });

  var _syntaxPrivatePropertyInObject = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-private-property-in-object",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("privateIn");
      }
    };
  });

  var _templateObject$d, _templateObject2$6, _templateObject3$5, _templateObject4$1, _templateObject5, _templateObject6;
  var _proposalPrivatePropertyInObject = declare(function (_ref, _ref2) {
    var assertVersion = _ref.assertVersion,
        t = _ref.types,
        template = _ref.template;
    var loose = _ref2.loose;
    assertVersion(7);
    var classWeakSets = new WeakMap();
    var fieldsWeakSets = new WeakMap();

    function unshadow(name, targetScope, scope) {
      while (scope !== targetScope) {
        if (scope.hasOwnBinding(name)) scope.rename(name);
        scope = scope.parent;
      }
    }

    function injectToFieldInit(fieldPath, expr, before) {
      if (before === void 0) {
        before = false;
      }

      if (fieldPath.node.value) {
        if (before) {
          fieldPath.get("value").insertBefore(expr);
        } else {
          fieldPath.get("value").insertAfter(expr);
        }
      } else {
        fieldPath.set("value", t.unaryExpression("void", expr));
      }
    }

    function injectInitialization$1(classPath, init) {
      var firstFieldPath;
      var consturctorPath;

      for (var _iterator = _createForOfIteratorHelperLoose(classPath.get("body.body")), _step; !(_step = _iterator()).done;) {
        var el = _step.value;

        if ((el.isClassProperty() || el.isClassPrivateProperty()) && !el.node["static"]) {
          firstFieldPath = el;
          break;
        }

        if (!consturctorPath && el.isClassMethod({
          kind: "constructor"
        })) {
          consturctorPath = el;
        }
      }

      if (firstFieldPath) {
        injectToFieldInit(firstFieldPath, init, true);
      } else {
        injectInitialization(classPath, consturctorPath, [t.expressionStatement(init)]);
      }
    }

    function getWeakSetId(weakSets, outerClass, reference, name, inject) {
      if (name === void 0) {
        name = "";
      }

      var id = classWeakSets.get(reference.node);

      if (!id) {
        id = outerClass.scope.generateUidIdentifier((name || "") + " brandCheck");
        classWeakSets.set(reference.node, id);
        inject(reference, template.expression.ast(_templateObject$d || (_templateObject$d = _taggedTemplateLiteralLoose(["", ".add(this)"])), t.cloneNode(id)));
        var newExpr = t.newExpression(t.identifier("WeakSet"), []);
        annotateAsPure(newExpr);
        outerClass.insertBefore(template.ast(_templateObject2$6 || (_templateObject2$6 = _taggedTemplateLiteralLoose(["var ", " = ", ""])), id, newExpr));
      }

      return t.cloneNode(id);
    }

    return {
      name: "proposal-private-property-in-object",
      inherits: _syntaxPrivatePropertyInObject,
      pre: function pre() {
        enableFeature$1(this.file, FEATURES$1.privateIn, loose);
      },
      visitor: {
        BinaryExpression: function BinaryExpression(path) {
          var node = path.node;
          if (node.operator !== "in") return;
          if (!t.isPrivateName(node.left)) return;
          var name = node.left.id.name;
          var privateElement;
          var outerClass = path.findParent(function (path) {
            if (!path.isClass()) return false;
            privateElement = path.get("body.body").find(function (_ref3) {
              var node = _ref3.node;
              return t.isPrivate(node) && node.key.id.name === name;
            });
            return !!privateElement;
          });

          if (outerClass.parentPath.scope.path.isPattern()) {
            outerClass.replaceWith(template.ast(_templateObject3$5 || (_templateObject3$5 = _taggedTemplateLiteralLoose(["(() => ", ")()"])), outerClass.node));
            return;
          }

          if (privateElement.isMethod()) {
            if (privateElement.node["static"]) {
              if (outerClass.node.id) {
                unshadow(outerClass.node.id.name, outerClass.scope, path.scope);
              } else {
                outerClass.set("id", path.scope.generateUidIdentifier("class"));
              }

              path.replaceWith(template.expression.ast(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteralLoose(["\n                ", " === ", "\n              "])), t.cloneNode(outerClass.node.id), path.node.right));
            } else {
              var _outerClass$node$id;

              var id = getWeakSetId(classWeakSets, outerClass, outerClass, (_outerClass$node$id = outerClass.node.id) == null ? void 0 : _outerClass$node$id.name, injectInitialization$1);
              path.replaceWith(template.expression.ast(_templateObject5 || (_templateObject5 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), id, path.node.right));
            }
          } else {
            var _id = getWeakSetId(fieldsWeakSets, outerClass, privateElement, privateElement.node.key.id.name, injectToFieldInit);

            path.replaceWith(template.expression.ast(_templateObject6 || (_templateObject6 = _taggedTemplateLiteralLoose(["", ".has(", ")"])), _id, path.node.right));
          }
        }
      }
    };
  });

  var syntaxThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "syntax-throw-expressions",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("throwExpressions");
      }
    };
  });

  var proposalThrowExpressions = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "proposal-throw-expressions",
      inherits: syntaxThrowExpressions,
      visitor: {
        UnaryExpression: function UnaryExpression(path) {
          var _path$node = path.node,
              operator = _path$node.operator,
              argument = _path$node.argument;
          if (operator !== "throw") return;
          var arrow = functionExpression(null, [identifier("e")], blockStatement([throwStatement(identifier("e"))]));
          path.replaceWith(callExpression(arrow, [argument]));
        }
      }
    };
  });

  var regjsgen = createCommonjsModule(function (module, exports) {
    (function () {

      var objectTypes = {
        'function': true,
        'object': true
      };
      var root = objectTypes[typeof window] && window || this;
      var freeExports = exports && !exports.nodeType && exports;
      var hasFreeModule = module && !module.nodeType;
      var freeGlobal = freeExports && hasFreeModule && typeof commonjsGlobal == 'object' && commonjsGlobal;

      if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal)) {
        root = freeGlobal;
      }

      var hasOwnProperty = Object.prototype.hasOwnProperty;

      function fromCodePoint() {
        var codePoint = Number(arguments[0]);

        if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || Math.floor(codePoint) != codePoint) {
            throw RangeError('Invalid code point: ' + codePoint);
          }

        if (codePoint <= 0xFFFF) {
          return String.fromCharCode(codePoint);
        } else {
          codePoint -= 0x10000;
          var highSurrogate = (codePoint >> 10) + 0xD800;
          var lowSurrogate = codePoint % 0x400 + 0xDC00;
          return String.fromCharCode(highSurrogate, lowSurrogate);
        }
      }

      var assertTypeRegexMap = {};

      function assertType(type, expected) {
        if (expected.indexOf('|') == -1) {
          if (type == expected) {
            return;
          }

          throw Error('Invalid node type: ' + type + '; expected type: ' + expected);
        }

        expected = hasOwnProperty.call(assertTypeRegexMap, expected) ? assertTypeRegexMap[expected] : assertTypeRegexMap[expected] = RegExp('^(?:' + expected + ')$');

        if (expected.test(type)) {
          return;
        }

        throw Error('Invalid node type: ' + type + '; expected types: ' + expected);
      }

      function generate(node) {
        var type = node.type;

        if (hasOwnProperty.call(generators, type)) {
          return generators[type](node);
        }

        throw Error('Invalid node type: ' + type);
      }

      function generateAlternative(node) {
        assertType(node.type, 'alternative');
        var terms = node.body,
            i = -1,
            length = terms.length,
            result = '';

        while (++i < length) {
          result += generateTerm(terms[i]);
        }

        return result;
      }

      function generateAnchor(node) {
        assertType(node.type, 'anchor');

        switch (node.kind) {
          case 'start':
            return '^';

          case 'end':
            return '$';

          case 'boundary':
            return '\\b';

          case 'not-boundary':
            return '\\B';

          default:
            throw Error('Invalid assertion');
        }
      }

      function generateAtom(node) {
        assertType(node.type, 'anchor|characterClass|characterClassEscape|dot|group|reference|value');
        return generate(node);
      }

      function generateCharacterClass(node) {
        assertType(node.type, 'characterClass');
        var classRanges = node.body,
            i = -1,
            length = classRanges.length,
            result = '';

        if (node.negative) {
          result += '^';
        }

        while (++i < length) {
          result += generateClassAtom(classRanges[i]);
        }

        return '[' + result + ']';
      }

      function generateCharacterClassEscape(node) {
        assertType(node.type, 'characterClassEscape');
        return '\\' + node.value;
      }

      function generateUnicodePropertyEscape(node) {
        assertType(node.type, 'unicodePropertyEscape');
        return '\\' + (node.negative ? 'P' : 'p') + '{' + node.value + '}';
      }

      function generateCharacterClassRange(node) {
        assertType(node.type, 'characterClassRange');
        var min = node.min,
            max = node.max;

        if (min.type == 'characterClassRange' || max.type == 'characterClassRange') {
          throw Error('Invalid character class range');
        }

        return generateClassAtom(min) + '-' + generateClassAtom(max);
      }

      function generateClassAtom(node) {
        assertType(node.type, 'anchor|characterClassEscape|characterClassRange|dot|value');
        return generate(node);
      }

      function generateDisjunction(node) {
        assertType(node.type, 'disjunction');
        var body = node.body,
            i = -1,
            length = body.length,
            result = '';

        while (++i < length) {
          if (i != 0) {
            result += '|';
          }

          result += generate(body[i]);
        }

        return result;
      }

      function generateDot(node) {
        assertType(node.type, 'dot');
        return '.';
      }

      function generateGroup(node) {
        assertType(node.type, 'group');
        var result = '';

        switch (node.behavior) {
          case 'normal':
            if (node.name) {
              result += '?<' + generateIdentifier(node.name) + '>';
            }

            break;

          case 'ignore':
            result += '?:';
            break;

          case 'lookahead':
            result += '?=';
            break;

          case 'negativeLookahead':
            result += '?!';
            break;

          case 'lookbehind':
            result += '?<=';
            break;

          case 'negativeLookbehind':
            result += '?<!';
            break;

          default:
            throw Error('Invalid behaviour: ' + node.behaviour);
        }

        var body = node.body,
            i = -1,
            length = body.length;

        while (++i < length) {
          result += generate(body[i]);
        }

        return '(' + result + ')';
      }

      function generateIdentifier(node) {
        assertType(node.type, 'identifier');
        return node.value;
      }

      function generateQuantifier(node) {
        assertType(node.type, 'quantifier');
        var quantifier = '',
            min = node.min,
            max = node.max;

        if (max == null) {
          if (min == 0) {
            quantifier = '*';
          } else if (min == 1) {
            quantifier = '+';
          } else {
            quantifier = '{' + min + ',}';
          }
        } else if (min == max) {
          quantifier = '{' + min + '}';
        } else if (min == 0 && max == 1) {
          quantifier = '?';
        } else {
          quantifier = '{' + min + ',' + max + '}';
        }

        if (!node.greedy) {
          quantifier += '?';
        }

        return generateAtom(node.body[0]) + quantifier;
      }

      function generateReference(node) {
        assertType(node.type, 'reference');

        if (node.matchIndex) {
          return '\\' + node.matchIndex;
        }

        if (node.name) {
          return '\\k<' + generateIdentifier(node.name) + '>';
        }

        throw new Error('Unknown reference type');
      }

      function generateTerm(node) {
        assertType(node.type, 'anchor|characterClass|characterClassEscape|empty|group|quantifier|reference|unicodePropertyEscape|value|dot');
        return generate(node);
      }

      function generateValue(node) {
        assertType(node.type, 'value');
        var kind = node.kind,
            codePoint = node.codePoint;

        if (typeof codePoint != 'number') {
          throw new Error('Invalid code point: ' + codePoint);
        }

        switch (kind) {
          case 'controlLetter':
            return '\\c' + fromCodePoint(codePoint + 64);

          case 'hexadecimalEscape':
            return '\\x' + ('00' + codePoint.toString(16).toUpperCase()).slice(-2);

          case 'identifier':
            return '\\' + fromCodePoint(codePoint);

          case 'null':
            return '\\' + codePoint;

          case 'octal':
            return '\\' + codePoint.toString(8);

          case 'singleEscape':
            switch (codePoint) {
              case 0x0008:
                return '\\b';

              case 0x0009:
                return '\\t';

              case 0x000A:
                return '\\n';

              case 0x000B:
                return '\\v';

              case 0x000C:
                return '\\f';

              case 0x000D:
                return '\\r';

              default:
                throw Error('Invalid code point: ' + codePoint);
            }

          case 'symbol':
            return fromCodePoint(codePoint);

          case 'unicodeEscape':
            return "\\u" + ('0000' + codePoint.toString(16).toUpperCase()).slice(-4);

          case 'unicodeCodePointEscape':
            return "\\u{" + codePoint.toString(16).toUpperCase() + '}';

          default:
            throw Error('Unsupported node kind: ' + kind);
        }
      }

      var generators = {
        'alternative': generateAlternative,
        'anchor': generateAnchor,
        'characterClass': generateCharacterClass,
        'characterClassEscape': generateCharacterClassEscape,
        'characterClassRange': generateCharacterClassRange,
        'unicodePropertyEscape': generateUnicodePropertyEscape,
        'disjunction': generateDisjunction,
        'dot': generateDot,
        'group': generateGroup,
        'quantifier': generateQuantifier,
        'reference': generateReference,
        'value': generateValue
      };
      var regjsgen = {
        'generate': generate
      };

      if (freeExports && hasFreeModule) {
          freeExports.generate = generate;
        } else {
          root.regjsgen = regjsgen;
        }
    }).call(commonjsGlobal);
  }, "/$$rollup_base$$/node_modules/regjsgen");

  var parser = createCommonjsModule(function (module) {
    (function () {
      var fromCodePoint = String.fromCodePoint || function () {
        var stringFromCharCode = String.fromCharCode;
        var floor = Math.floor;
        return function fromCodePoint() {
          var MAX_SIZE = 0x4000;
          var codeUnits = [];
          var highSurrogate;
          var lowSurrogate;
          var index = -1;
          var length = arguments.length;

          if (!length) {
            return '';
          }

          var result = '';

          while (++index < length) {
            var codePoint = Number(arguments[index]);

            if (!isFinite(codePoint) || codePoint < 0 || codePoint > 0x10FFFF || floor(codePoint) != codePoint) {
                throw RangeError('Invalid code point: ' + codePoint);
              }

            if (codePoint <= 0xFFFF) {
              codeUnits.push(codePoint);
            } else {
              codePoint -= 0x10000;
              highSurrogate = (codePoint >> 10) + 0xD800;
              lowSurrogate = codePoint % 0x400 + 0xDC00;
              codeUnits.push(highSurrogate, lowSurrogate);
            }

            if (index + 1 == length || codeUnits.length > MAX_SIZE) {
              result += stringFromCharCode.apply(null, codeUnits);
              codeUnits.length = 0;
            }
          }

          return result;
        };
      }();

      function parse(str, flags, features) {
        if (!features) {
          features = {};
        }

        function addRaw(node) {
          node.raw = str.substring(node.range[0], node.range[1]);
          return node;
        }

        function updateRawStart(node, start) {
          node.range[0] = start;
          return addRaw(node);
        }

        function createAnchor(kind, rawLength) {
          return addRaw({
            type: 'anchor',
            kind: kind,
            range: [pos - rawLength, pos]
          });
        }

        function createValue(kind, codePoint, from, to) {
          return addRaw({
            type: 'value',
            kind: kind,
            codePoint: codePoint,
            range: [from, to]
          });
        }

        function createEscaped(kind, codePoint, value, fromOffset) {
          fromOffset = fromOffset || 0;
          return createValue(kind, codePoint, pos - (value.length + fromOffset), pos);
        }

        function createCharacter(matches) {
          var _char = matches[0];

          var first = _char.charCodeAt(0);

          if (hasUnicodeFlag) {
            var second;

            if (_char.length === 1 && first >= 0xD800 && first <= 0xDBFF) {
              second = lookahead().charCodeAt(0);

              if (second >= 0xDC00 && second <= 0xDFFF) {
                pos++;
                return createValue('symbol', (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000, pos - 2, pos);
              }
            }
          }

          return createValue('symbol', first, pos - 1, pos);
        }

        function createDisjunction(alternatives, from, to) {
          return addRaw({
            type: 'disjunction',
            body: alternatives,
            range: [from, to]
          });
        }

        function createDot() {
          return addRaw({
            type: 'dot',
            range: [pos - 1, pos]
          });
        }

        function createCharacterClassEscape(value) {
          return addRaw({
            type: 'characterClassEscape',
            value: value,
            range: [pos - 2, pos]
          });
        }

        function createReference(matchIndex) {
          return addRaw({
            type: 'reference',
            matchIndex: parseInt(matchIndex, 10),
            range: [pos - 1 - matchIndex.length, pos]
          });
        }

        function createNamedReference(name) {
          return addRaw({
            type: 'reference',
            name: name,
            range: [name.range[0] - 3, pos]
          });
        }

        function createGroup(behavior, disjunction, from, to) {
          return addRaw({
            type: 'group',
            behavior: behavior,
            body: disjunction,
            range: [from, to]
          });
        }

        function createQuantifier(min, max, from, to) {
          if (to == null) {
            from = pos - 1;
            to = pos;
          }

          return addRaw({
            type: 'quantifier',
            min: min,
            max: max,
            greedy: true,
            body: null,
            range: [from, to]
          });
        }

        function createAlternative(terms, from, to) {
          return addRaw({
            type: 'alternative',
            body: terms,
            range: [from, to]
          });
        }

        function createCharacterClass(classRanges, negative, from, to) {
          return addRaw({
            type: 'characterClass',
            body: classRanges,
            negative: negative,
            range: [from, to]
          });
        }

        function createClassRange(min, max, from, to) {
          if (min.codePoint > max.codePoint) {
            bail('invalid range in character class', min.raw + '-' + max.raw, from, to);
          }

          return addRaw({
            type: 'characterClassRange',
            min: min,
            max: max,
            range: [from, to]
          });
        }

        function flattenBody(body) {
          if (body.type === 'alternative') {
            return body.body;
          } else {
            return [body];
          }
        }

        function incr(amount) {
          amount = amount || 1;
          var res = str.substring(pos, pos + amount);
          pos += amount || 1;
          return res;
        }

        function skip(value) {
          if (!match(value)) {
            bail('character', value);
          }
        }

        function match(value) {
          if (str.indexOf(value, pos) === pos) {
            return incr(value.length);
          }
        }

        function lookahead() {
          return str[pos];
        }

        function current(value) {
          return str.indexOf(value, pos) === pos;
        }

        function next(value) {
          return str[pos + 1] === value;
        }

        function matchReg(regExp) {
          var subStr = str.substring(pos);
          var res = subStr.match(regExp);

          if (res) {
            res.range = [];
            res.range[0] = pos;
            incr(res[0].length);
            res.range[1] = pos;
          }

          return res;
        }

        function parseDisjunction() {
          var res = [],
              from = pos;
          res.push(parseAlternative());

          while (match('|')) {
            res.push(parseAlternative());
          }

          if (res.length === 1) {
            return res[0];
          }

          return createDisjunction(res, from, pos);
        }

        function parseAlternative() {
          var res = [],
              from = pos;
          var term;

          while (term = parseTerm()) {
            res.push(term);
          }

          if (res.length === 1) {
            return res[0];
          }

          return createAlternative(res, from, pos);
        }

        function parseTerm() {
          if (pos >= str.length || current('|') || current(')')) {
            return null;
          }

          var anchor = parseAnchor();

          if (anchor) {
            return anchor;
          }

          var atom = parseAtomAndExtendedAtom();

          if (!atom) {
            bail('Expected atom');
          }

          var quantifier = parseQuantifier() || false;

          if (quantifier) {
            quantifier.body = flattenBody(atom);
            updateRawStart(quantifier, atom.range[0]);
            return quantifier;
          }

          return atom;
        }

        function parseGroup(matchA, typeA, matchB, typeB) {
          var type = null,
              from = pos;

          if (match(matchA)) {
            type = typeA;
          } else if (match(matchB)) {
            type = typeB;
          } else {
            return false;
          }

          return finishGroup(type, from);
        }

        function finishGroup(type, from) {
          var body = parseDisjunction();

          if (!body) {
            bail('Expected disjunction');
          }

          skip(')');
          var group = createGroup(type, flattenBody(body), from, pos);

          if (type == 'normal') {
            if (firstIteration) {
              closedCaptureCounter++;
            }
          }

          return group;
        }

        function parseAnchor() {

          if (match('^')) {
            return createAnchor('start', 1);
          } else if (match('$')) {
            return createAnchor('end', 1);
          } else if (match('\\b')) {
            return createAnchor('boundary', 2);
          } else if (match('\\B')) {
            return createAnchor('not-boundary', 2);
          } else {
            return parseGroup('(?=', 'lookahead', '(?!', 'negativeLookahead');
          }
        }

        function parseQuantifier() {
          var res,
              from = pos;
          var quantifier;
          var min, max;

          if (match('*')) {
            quantifier = createQuantifier(0);
          } else if (match('+')) {
            quantifier = createQuantifier(1);
          } else if (match('?')) {
            quantifier = createQuantifier(0, 1);
          } else if (res = matchReg(/^\{([0-9]+)\}/)) {
            min = parseInt(res[1], 10);
            quantifier = createQuantifier(min, min, res.range[0], res.range[1]);
          } else if (res = matchReg(/^\{([0-9]+),\}/)) {
            min = parseInt(res[1], 10);
            quantifier = createQuantifier(min, undefined, res.range[0], res.range[1]);
          } else if (res = matchReg(/^\{([0-9]+),([0-9]+)\}/)) {
            min = parseInt(res[1], 10);
            max = parseInt(res[2], 10);

            if (min > max) {
              bail('numbers out of order in {} quantifier', '', from, pos);
            }

            quantifier = createQuantifier(min, max, res.range[0], res.range[1]);
          }

          if (quantifier) {
            if (match('?')) {
              quantifier.greedy = false;
              quantifier.range[1] += 1;
            }
          }

          return quantifier;
        }

        function parseAtomAndExtendedAtom() {
          var res;

          if (res = matchReg(/^[^^$\\.*+?()[\]{}|]/)) {
            return createCharacter(res);
          } else if (!hasUnicodeFlag && (res = matchReg(/^(?:]|})/))) {
            return createCharacter(res);
          } else if (match('.')) {
            return createDot();
          } else if (match('\\')) {
            res = parseAtomEscape();

            if (!res) {
              if (!hasUnicodeFlag && lookahead() == 'c') {
                return createValue('symbol', 92, pos - 1, pos);
              }

              bail('atomEscape');
            }

            return res;
          } else if (res = parseCharacterClass()) {
            return res;
          } else if (features.lookbehind && (res = parseGroup('(?<=', 'lookbehind', '(?<!', 'negativeLookbehind'))) {
            return res;
          } else if (features.namedGroups && match("(?<")) {
            var name = parseIdentifier();
            skip(">");
            var group = finishGroup("normal", name.range[0] - 3);
            group.name = name;
            return group;
          } else {
            return parseGroup('(?:', 'ignore', '(', 'normal');
          }
        }

        function parseUnicodeSurrogatePairEscape(firstEscape) {
          if (hasUnicodeFlag) {
            var first, second;

            if (firstEscape.kind == 'unicodeEscape' && (first = firstEscape.codePoint) >= 0xD800 && first <= 0xDBFF && current('\\') && next('u')) {
              var prevPos = pos;
              pos++;
              var secondEscape = parseClassEscape();

              if (secondEscape.kind == 'unicodeEscape' && (second = secondEscape.codePoint) >= 0xDC00 && second <= 0xDFFF) {
                firstEscape.range[1] = secondEscape.range[1];
                firstEscape.codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
                firstEscape.type = 'value';
                firstEscape.kind = 'unicodeCodePointEscape';
                addRaw(firstEscape);
              } else {
                pos = prevPos;
              }
            }
          }

          return firstEscape;
        }

        function parseClassEscape() {
          return parseAtomEscape(true);
        }

        function parseAtomEscape(insideCharacterClass) {
          var res,
              from = pos;
          res = parseDecimalEscape() || parseNamedReference();

          if (res) {
            return res;
          }

          if (insideCharacterClass) {
            if (match('b')) {
              return createEscaped('singleEscape', 0x0008, '\\b');
            } else if (match('B')) {
              bail('\\B not possible inside of CharacterClass', '', from);
            } else if (!hasUnicodeFlag && (res = matchReg(/^c([0-9])/))) {
              return createEscaped('controlLetter', res[1] + 16, res[1], 2);
            }

            if (match('-') && hasUnicodeFlag) {
              return createEscaped('singleEscape', 0x002d, '\\-');
            }
          }

          res = parseCharacterEscape();
          return res;
        }

        function parseDecimalEscape() {
          var res, match;

          if (res = matchReg(/^(?!0)\d+/)) {
            match = res[0];
            var refIdx = parseInt(res[0], 10);

            if (refIdx <= closedCaptureCounter) {
              return createReference(res[0]);
            } else {
              backrefDenied.push(refIdx);
              incr(-res[0].length);

              if (res = matchReg(/^[0-7]{1,3}/)) {
                return createEscaped('octal', parseInt(res[0], 8), res[0], 1);
              } else {
                res = createCharacter(matchReg(/^[89]/));
                return updateRawStart(res, res.range[0] - 1);
              }
            }
          } else if (res = matchReg(/^[0-7]{1,3}/)) {
              match = res[0];

              if (/^0{1,3}$/.test(match)) {
                return createEscaped('null', 0x0000, '0', match.length + 1);
              } else {
                return createEscaped('octal', parseInt(match, 8), match, 1);
              }
            } else if (res = matchReg(/^[dDsSwW]/)) {
              return createCharacterClassEscape(res[0]);
            }

          return false;
        }

        function parseNamedReference() {
          if (features.namedGroups && matchReg(/^k<(?=.*?>)/)) {
            var name = parseIdentifier();
            skip('>');
            return createNamedReference(name);
          }
        }

        function parseRegExpUnicodeEscapeSequence() {
          var res;

          if (res = matchReg(/^u([0-9a-fA-F]{4})/)) {
            return parseUnicodeSurrogatePairEscape(createEscaped('unicodeEscape', parseInt(res[1], 16), res[1], 2));
          } else if (hasUnicodeFlag && (res = matchReg(/^u\{([0-9a-fA-F]+)\}/))) {
            return createEscaped('unicodeCodePointEscape', parseInt(res[1], 16), res[1], 4);
          }
        }

        function parseCharacterEscape() {
          var res;
          var from = pos;

          if (res = matchReg(/^[fnrtv]/)) {
            var codePoint = 0;

            switch (res[0]) {
              case 't':
                codePoint = 0x009;
                break;

              case 'n':
                codePoint = 0x00A;
                break;

              case 'v':
                codePoint = 0x00B;
                break;

              case 'f':
                codePoint = 0x00C;
                break;

              case 'r':
                codePoint = 0x00D;
                break;
            }

            return createEscaped('singleEscape', codePoint, '\\' + res[0]);
          } else if (res = matchReg(/^c([a-zA-Z])/)) {
            return createEscaped('controlLetter', res[1].charCodeAt(0) % 32, res[1], 2);
          } else if (res = matchReg(/^x([0-9a-fA-F]{2})/)) {
            return createEscaped('hexadecimalEscape', parseInt(res[1], 16), res[1], 2);
          } else if (res = parseRegExpUnicodeEscapeSequence()) {
            if (!res || res.codePoint > 0x10FFFF) {
              bail('Invalid escape sequence', null, from, pos);
            }

            return res;
          } else if (features.unicodePropertyEscape && hasUnicodeFlag && (res = matchReg(/^([pP])\{([^\}]+)\}/))) {
            return addRaw({
              type: 'unicodePropertyEscape',
              negative: res[1] === 'P',
              value: res[2],
              range: [res.range[0] - 1, res.range[1]],
              raw: res[0]
            });
          } else {
            return parseIdentityEscape();
          }
        }

        function parseIdentifierAtom(check) {
          var ch = lookahead();
          var from = pos;

          if (ch === '\\') {
            incr();
            var esc = parseRegExpUnicodeEscapeSequence();

            if (!esc || !check(esc.codePoint)) {
              bail('Invalid escape sequence', null, from, pos);
            }

            return fromCodePoint(esc.codePoint);
          }

          var code = ch.charCodeAt(0);

          if (code >= 0xD800 && code <= 0xDBFF) {
            ch += str[pos + 1];
            var second = ch.charCodeAt(1);

            if (second >= 0xDC00 && second <= 0xDFFF) {
              code = (code - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
          }

          if (!check(code)) return;
          incr();
          if (code > 0xFFFF) incr();
          return ch;
        }

        function parseIdentifier() {
          var start = pos;
          var res = parseIdentifierAtom(isIdentifierStart);

          if (!res) {
            bail('Invalid identifier');
          }

          var ch;

          while (ch = parseIdentifierAtom(isIdentifierPart)) {
            res += ch;
          }

          return addRaw({
            type: 'identifier',
            value: res,
            range: [start, pos]
          });
        }

        function isIdentifierStart(ch) {
          var NonAsciiIdentifierStart = /[\$A-Z_a-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEF\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7B9\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDF00-\uDF1C\uDF27\uDF30-\uDF45]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF1A]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDE9D\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFF1]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
          return ch === 36 || ch === 95 || ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122 || ch >= 0x80 && NonAsciiIdentifierStart.test(fromCodePoint(ch));
        }

        function isIdentifierPart(ch) {
          var NonAsciiIdentifierPartOnly = /[0-9_\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD801[\uDCA0-\uDCA9]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDD30-\uDD39\uDF46-\uDF50]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC66-\uDC6F\uDC7F-\uDC82\uDCB0-\uDCBA\uDCF0-\uDCF9\uDD00-\uDD02\uDD27-\uDD34\uDD36-\uDD3F\uDD45\uDD46\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDDC9-\uDDCC\uDDD0-\uDDD9\uDE2C-\uDE37\uDE3E\uDEDF-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF3B\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC35-\uDC46\uDC50-\uDC59\uDC5E\uDCB0-\uDCC3\uDCD0-\uDCD9\uDDAF-\uDDB5\uDDB8-\uDDC0\uDDDC\uDDDD\uDE30-\uDE40\uDE50-\uDE59\uDEAB-\uDEB7\uDEC0-\uDEC9\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDC2C-\uDC3A\uDCE0-\uDCE9\uDE01-\uDE0A\uDE33-\uDE39\uDE3B-\uDE3E\uDE47\uDE51-\uDE5B\uDE8A-\uDE99]|\uD807[\uDC2F-\uDC36\uDC38-\uDC3F\uDC50-\uDC59\uDC92-\uDCA7\uDCA9-\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD50-\uDD59\uDD8A-\uDD8E\uDD90\uDD91\uDD93-\uDD97\uDDA0-\uDDA9\uDEF3-\uDEF6]|\uD81A[\uDE60-\uDE69\uDEF0-\uDEF4\uDF30-\uDF36\uDF50-\uDF59]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A\uDD50-\uDD59]|\uDB40[\uDD00-\uDDEF]/;
          return isIdentifierStart(ch) || ch >= 48 && ch <= 57 || ch >= 0x80 && NonAsciiIdentifierPartOnly.test(fromCodePoint(ch));
        }

        function parseIdentityEscape() {
          var tmp;
          var l = lookahead();

          if (hasUnicodeFlag && /[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/.test(l) || !hasUnicodeFlag && l !== "c") {
            if (l === "k" && features.lookbehind) {
              return null;
            }

            tmp = incr();
            return createEscaped('identifier', tmp.charCodeAt(0), tmp, 1);
          }

          return null;
        }

        function parseCharacterClass() {
          var res,
              from = pos;

          if (res = matchReg(/^\[\^/)) {
            res = parseClassRanges();
            skip(']');
            return createCharacterClass(res, true, from, pos);
          } else if (match('[')) {
            res = parseClassRanges();
            skip(']');
            return createCharacterClass(res, false, from, pos);
          }

          return null;
        }

        function parseClassRanges() {
          var res;

          if (current(']')) {
            return [];
          } else {
            res = parseNonemptyClassRanges();

            if (!res) {
              bail('nonEmptyClassRanges');
            }

            return res;
          }
        }

        function parseHelperClassRanges(atom) {
          var from, to, res;

          if (current('-') && !next(']')) {
            skip('-');
            res = parseClassAtom();

            if (!res) {
              bail('classAtom');
            }

            to = pos;
            var classRanges = parseClassRanges();

            if (!classRanges) {
              bail('classRanges');
            }

            from = atom.range[0];

            if (classRanges.type === 'empty') {
              return [createClassRange(atom, res, from, to)];
            }

            return [createClassRange(atom, res, from, to)].concat(classRanges);
          }

          res = parseNonemptyClassRangesNoDash();

          if (!res) {
            bail('nonEmptyClassRangesNoDash');
          }

          return [atom].concat(res);
        }

        function parseNonemptyClassRanges() {
          var atom = parseClassAtom();

          if (!atom) {
            bail('classAtom');
          }

          if (current(']')) {
            return [atom];
          }

          return parseHelperClassRanges(atom);
        }

        function parseNonemptyClassRangesNoDash() {
          var res = parseClassAtom();

          if (!res) {
            bail('classAtom');
          }

          if (current(']')) {
            return res;
          }

          return parseHelperClassRanges(res);
        }

        function parseClassAtom() {
          if (match('-')) {
            return createCharacter('-');
          } else {
            return parseClassAtomNoDash();
          }
        }

        function parseClassAtomNoDash() {
          var res;

          if (res = matchReg(/^[^\\\]-]/)) {
            return createCharacter(res[0]);
          } else if (match('\\')) {
            res = parseClassEscape();

            if (!res) {
              bail('classEscape');
            }

            return parseUnicodeSurrogatePairEscape(res);
          }
        }

        function bail(message, details, from, to) {
          from = from == null ? pos : from;
          to = to == null ? from : to;
          var contextStart = Math.max(0, from - 10);
          var contextEnd = Math.min(to + 10, str.length);
          var context = '    ' + str.substring(contextStart, contextEnd);
          var pointer = '    ' + new Array(from - contextStart + 1).join(' ') + '^';
          throw SyntaxError(message + ' at position ' + from + (details ? ': ' + details : '') + '\n' + context + '\n' + pointer);
        }

        var backrefDenied = [];
        var closedCaptureCounter = 0;
        var firstIteration = true;
        var hasUnicodeFlag = (flags || "").indexOf("u") !== -1;
        var pos = 0;
        str = String(str);

        if (str === '') {
          str = '(?:)';
        }

        var result = parseDisjunction();

        if (result.range[1] !== str.length) {
          bail('Could not parse entire input - got stuck', '', result.range[1]);
        }

        for (var i = 0; i < backrefDenied.length; i++) {
          if (backrefDenied[i] <= closedCaptureCounter) {
            pos = 0;
            firstIteration = false;
            return parseDisjunction();
          }
        }

        return result;
      }

      var regjsparser = {
        parse: parse
      };

      if (module.exports) {
        module.exports = regjsparser;
      } else {
        window.regjsparser = regjsparser;
      }
    })();
  }, "/$$rollup_base$$/node_modules/regjsparser");

  var regenerate = createCommonjsModule(function (module, exports) {

    (function (root) {
      var freeExports = exports;
      var freeModule = module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal;

      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }

      var ERRORS = {
        'rangeOrder': "A range\u2019s `stop` value must be greater than or equal " + 'to the `start` value.',
        'codePointRange': 'Invalid code point value. Code points range from ' + 'U+000000 to U+10FFFF.'
      };
      var HIGH_SURROGATE_MIN = 0xD800;
      var HIGH_SURROGATE_MAX = 0xDBFF;
      var LOW_SURROGATE_MIN = 0xDC00;
      var LOW_SURROGATE_MAX = 0xDFFF;
      var regexNull = /\\x00([^0123456789]|$)/g;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;

      var extend = function extend(destination, source) {
        var key;

        for (key in source) {
          if (hasOwnProperty.call(source, key)) {
            destination[key] = source[key];
          }
        }

        return destination;
      };

      var forEach = function forEach(array, callback) {
        var index = -1;
        var length = array.length;

        while (++index < length) {
          callback(array[index], index);
        }
      };

      var toString = object.toString;

      var isArray = function isArray(value) {
        return toString.call(value) == '[object Array]';
      };

      var isNumber = function isNumber(value) {
        return typeof value == 'number' || toString.call(value) == '[object Number]';
      };

      var zeroes = '0000';

      var pad = function pad(number, totalCharacters) {
        var string = String(number);
        return string.length < totalCharacters ? (zeroes + string).slice(-totalCharacters) : string;
      };

      var hex = function hex(number) {
        return Number(number).toString(16).toUpperCase();
      };

      var slice = [].slice;

      var dataFromCodePoints = function dataFromCodePoints(codePoints) {
        var index = -1;
        var length = codePoints.length;
        var max = length - 1;
        var result = [];
        var isStart = true;
        var tmp;
        var previous = 0;

        while (++index < length) {
          tmp = codePoints[index];

          if (isStart) {
            result.push(tmp);
            previous = tmp;
            isStart = false;
          } else {
            if (tmp == previous + 1) {
              if (index != max) {
                previous = tmp;
                continue;
              } else {
                isStart = true;
                result.push(tmp + 1);
              }
            } else {
              result.push(previous + 1, tmp);
              previous = tmp;
            }
          }
        }

        if (!isStart) {
          result.push(tmp + 1);
        }

        return result;
      };

      var dataRemove = function dataRemove(data, codePoint) {
        var index = 0;
        var start;
        var end;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            if (codePoint == start) {
              if (end == start + 1) {
                data.splice(index, 2);
                return data;
              } else {
                data[index] = codePoint + 1;
                return data;
              }
            } else if (codePoint == end - 1) {
              data[index + 1] = codePoint;
              return data;
            } else {
              data.splice(index, 2, start, codePoint, codePoint + 1, end);
              return data;
            }
          }

          index += 2;
        }

        return data;
      };

      var dataRemoveRange = function dataRemoveRange(data, rangeStart, rangeEnd) {
        if (rangeEnd < rangeStart) {
          throw Error(ERRORS.rangeOrder);
        }

        var index = 0;
        var start;
        var end;

        while (index < data.length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start > rangeEnd) {
            return data;
          }

          if (rangeStart <= start && rangeEnd >= end) {
            data.splice(index, 2);
            continue;
          }

          if (rangeStart >= start && rangeEnd < end) {
            if (rangeStart == start) {
              data[index] = rangeEnd + 1;
              data[index + 1] = end + 1;
              return data;
            }

            data.splice(index, 2, start, rangeStart, rangeEnd + 1, end + 1);
            return data;
          }

          if (rangeStart >= start && rangeStart <= end) {
            data[index + 1] = rangeStart;
          } else if (rangeEnd >= start && rangeEnd <= end) {
              data[index] = rangeEnd + 1;
              return data;
            }

          index += 2;
        }

        return data;
      };

      var dataAdd = function dataAdd(data, codePoint) {
        var index = 0;
        var start;
        var end;
        var lastIndex = null;
        var length = data.length;

        if (codePoint < 0x0 || codePoint > 0x10FFFF) {
          throw RangeError(ERRORS.codePointRange);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            return data;
          }

          if (codePoint == start - 1) {
            data[index] = codePoint;
            return data;
          }

          if (start > codePoint) {
            data.splice(lastIndex != null ? lastIndex + 2 : 0, 0, codePoint, codePoint + 1);
            return data;
          }

          if (codePoint == end) {
            if (codePoint + 1 == data[index + 2]) {
              data.splice(index, 4, start, data[index + 3]);
              return data;
            }

            data[index + 1] = codePoint + 1;
            return data;
          }

          lastIndex = index;
          index += 2;
        }

        data.push(codePoint, codePoint + 1);
        return data;
      };

      var dataAddData = function dataAddData(dataA, dataB) {
        var index = 0;
        var start;
        var end;
        var data = dataA.slice();
        var length = dataB.length;

        while (index < length) {
          start = dataB[index];
          end = dataB[index + 1] - 1;

          if (start == end) {
            data = dataAdd(data, start);
          } else {
            data = dataAddRange(data, start, end);
          }

          index += 2;
        }

        return data;
      };

      var dataRemoveData = function dataRemoveData(dataA, dataB) {
        var index = 0;
        var start;
        var end;
        var data = dataA.slice();
        var length = dataB.length;

        while (index < length) {
          start = dataB[index];
          end = dataB[index + 1] - 1;

          if (start == end) {
            data = dataRemove(data, start);
          } else {
            data = dataRemoveRange(data, start, end);
          }

          index += 2;
        }

        return data;
      };

      var dataAddRange = function dataAddRange(data, rangeStart, rangeEnd) {
        if (rangeEnd < rangeStart) {
          throw Error(ERRORS.rangeOrder);
        }

        if (rangeStart < 0x0 || rangeStart > 0x10FFFF || rangeEnd < 0x0 || rangeEnd > 0x10FFFF) {
          throw RangeError(ERRORS.codePointRange);
        }

        var index = 0;
        var start;
        var end;
        var added = false;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (added) {
            if (start == rangeEnd + 1) {
              data.splice(index - 1, 2);
              return data;
            }

            if (start > rangeEnd) {
              return data;
            }

            if (start >= rangeStart && start <= rangeEnd) {
              if (end > rangeStart && end - 1 <= rangeEnd) {
                data.splice(index, 2);
                index -= 2;
              } else {
                data.splice(index - 1, 2);
                index -= 2;
              }
            }
          } else if (start == rangeEnd + 1 || start == rangeEnd) {
            data[index] = rangeStart;
            return data;
          } else if (start > rangeEnd) {
              data.splice(index, 0, rangeStart, rangeEnd + 1);
              return data;
            } else if (rangeStart >= start && rangeStart < end && rangeEnd + 1 <= end) {
              return data;
            } else if (rangeStart >= start && rangeStart < end || end == rangeStart) {
              data[index + 1] = rangeEnd + 1;
              added = true;
            } else if (rangeStart <= start && rangeEnd + 1 >= end) {
              data[index] = rangeStart;
              data[index + 1] = rangeEnd + 1;
              added = true;
            }

          index += 2;
        }

        if (!added) {
          data.push(rangeStart, rangeEnd + 1);
        }

        return data;
      };

      var dataContains = function dataContains(data, codePoint) {
        var index = 0;
        var length = data.length;
        var start = data[index];
        var end = data[length - 1];

        if (length >= 2) {
          if (codePoint < start || codePoint > end) {
            return false;
          }
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          if (codePoint >= start && codePoint < end) {
            return true;
          }

          index += 2;
        }

        return false;
      };

      var dataIntersection = function dataIntersection(data, codePoints) {
        var index = 0;
        var length = codePoints.length;
        var codePoint;
        var result = [];

        while (index < length) {
          codePoint = codePoints[index];

          if (dataContains(data, codePoint)) {
            result.push(codePoint);
          }

          ++index;
        }

        return dataFromCodePoints(result);
      };

      var dataIsEmpty = function dataIsEmpty(data) {
        return !data.length;
      };

      var dataIsSingleton = function dataIsSingleton(data) {
        return data.length == 2 && data[0] + 1 == data[1];
      };

      var dataToArray = function dataToArray(data) {
        var index = 0;
        var start;
        var end;
        var result = [];
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1];

          while (start < end) {
            result.push(start);
            ++start;
          }

          index += 2;
        }

        return result;
      };

      var floor = Math.floor;

      var highSurrogate = function highSurrogate(codePoint) {
        return parseInt(floor((codePoint - 0x10000) / 0x400) + HIGH_SURROGATE_MIN, 10);
      };

      var lowSurrogate = function lowSurrogate(codePoint) {
        return parseInt((codePoint - 0x10000) % 0x400 + LOW_SURROGATE_MIN, 10);
      };

      var stringFromCharCode = String.fromCharCode;

      var codePointToString = function codePointToString(codePoint) {
        var string;

        if (codePoint == 0x09) {
          string = '\\t';
        } else if (codePoint == 0x0A) {
            string = '\\n';
          } else if (codePoint == 0x0C) {
            string = '\\f';
          } else if (codePoint == 0x0D) {
            string = '\\r';
          } else if (codePoint == 0x2D) {
            string = '\\x2D';
          } else if (codePoint == 0x5C) {
            string = '\\\\';
          } else if (codePoint == 0x24 || codePoint >= 0x28 && codePoint <= 0x2B || codePoint == 0x2E || codePoint == 0x2F || codePoint == 0x3F || codePoint >= 0x5B && codePoint <= 0x5E || codePoint >= 0x7B && codePoint <= 0x7D) {
            string = '\\' + stringFromCharCode(codePoint);
          } else if (codePoint >= 0x20 && codePoint <= 0x7E) {
            string = stringFromCharCode(codePoint);
          } else if (codePoint <= 0xFF) {
            string = '\\x' + pad(hex(codePoint), 2);
          } else {
            string = "\\u" + pad(hex(codePoint), 4);
          }

        return string;
      };

      var codePointToStringUnicode = function codePointToStringUnicode(codePoint) {
        if (codePoint <= 0xFFFF) {
          return codePointToString(codePoint);
        }

        return "\\u{" + codePoint.toString(16).toUpperCase() + '}';
      };

      var symbolToCodePoint = function symbolToCodePoint(symbol) {
        var length = symbol.length;
        var first = symbol.charCodeAt(0);
        var second;

        if (first >= HIGH_SURROGATE_MIN && first <= HIGH_SURROGATE_MAX && length > 1) {
            second = symbol.charCodeAt(1);
            return (first - HIGH_SURROGATE_MIN) * 0x400 + second - LOW_SURROGATE_MIN + 0x10000;
          }

        return first;
      };

      var createBMPCharacterClasses = function createBMPCharacterClasses(data) {
        var result = '';
        var index = 0;
        var start;
        var end;
        var length = data.length;

        if (dataIsSingleton(data)) {
          return codePointToString(data[0]);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start == end) {
            result += codePointToString(start);
          } else if (start + 1 == end) {
            result += codePointToString(start) + codePointToString(end);
          } else {
            result += codePointToString(start) + '-' + codePointToString(end);
          }

          index += 2;
        }

        return '[' + result + ']';
      };

      var createUnicodeCharacterClasses = function createUnicodeCharacterClasses(data) {
        var result = '';
        var index = 0;
        var start;
        var end;
        var length = data.length;

        if (dataIsSingleton(data)) {
          return codePointToStringUnicode(data[0]);
        }

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start == end) {
            result += codePointToStringUnicode(start);
          } else if (start + 1 == end) {
            result += codePointToStringUnicode(start) + codePointToStringUnicode(end);
          } else {
            result += codePointToStringUnicode(start) + '-' + codePointToStringUnicode(end);
          }

          index += 2;
        }

        return '[' + result + ']';
      };

      var splitAtBMP = function splitAtBMP(data) {
        var loneHighSurrogates = [];
        var loneLowSurrogates = [];
        var bmp = [];
        var astral = [];
        var index = 0;
        var start;
        var end;
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;

          if (start < HIGH_SURROGATE_MIN) {
            if (end < HIGH_SURROGATE_MIN) {
              bmp.push(start, end + 1);
            }

            if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, end + 1);
            }

            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              bmp.push(start, HIGH_SURROGATE_MIN);
              loneHighSurrogates.push(HIGH_SURROGATE_MIN, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start >= HIGH_SURROGATE_MIN && start <= HIGH_SURROGATE_MAX) {
            if (end >= HIGH_SURROGATE_MIN && end <= HIGH_SURROGATE_MAX) {
              loneHighSurrogates.push(start, end + 1);
            }

            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              loneHighSurrogates.push(start, HIGH_SURROGATE_MAX + 1);
              loneLowSurrogates.push(LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start >= LOW_SURROGATE_MIN && start <= LOW_SURROGATE_MAX) {
            if (end >= LOW_SURROGATE_MIN && end <= LOW_SURROGATE_MAX) {
              loneLowSurrogates.push(start, end + 1);
            }

            if (end > LOW_SURROGATE_MAX) {
              loneLowSurrogates.push(start, LOW_SURROGATE_MAX + 1);

              if (end <= 0xFFFF) {
                bmp.push(LOW_SURROGATE_MAX + 1, end + 1);
              } else {
                bmp.push(LOW_SURROGATE_MAX + 1, 0xFFFF + 1);
                astral.push(0xFFFF + 1, end + 1);
              }
            }
          } else if (start > LOW_SURROGATE_MAX && start <= 0xFFFF) {
            if (end <= 0xFFFF) {
              bmp.push(start, end + 1);
            } else {
              bmp.push(start, 0xFFFF + 1);
              astral.push(0xFFFF + 1, end + 1);
            }
          } else {
            astral.push(start, end + 1);
          }

          index += 2;
        }

        return {
          'loneHighSurrogates': loneHighSurrogates,
          'loneLowSurrogates': loneLowSurrogates,
          'bmp': bmp,
          'astral': astral
        };
      };

      var optimizeSurrogateMappings = function optimizeSurrogateMappings(surrogateMappings) {
        var result = [];
        var tmpLow = [];
        var addLow = false;
        var mapping;
        var nextMapping;
        var highSurrogates;
        var lowSurrogates;
        var nextHighSurrogates;
        var nextLowSurrogates;
        var index = -1;
        var length = surrogateMappings.length;

        while (++index < length) {
          mapping = surrogateMappings[index];
          nextMapping = surrogateMappings[index + 1];

          if (!nextMapping) {
            result.push(mapping);
            continue;
          }

          highSurrogates = mapping[0];
          lowSurrogates = mapping[1];
          nextHighSurrogates = nextMapping[0];
          nextLowSurrogates = nextMapping[1];
          tmpLow = lowSurrogates;

          while (nextHighSurrogates && highSurrogates[0] == nextHighSurrogates[0] && highSurrogates[1] == nextHighSurrogates[1]) {
            if (dataIsSingleton(nextLowSurrogates)) {
              tmpLow = dataAdd(tmpLow, nextLowSurrogates[0]);
            } else {
              tmpLow = dataAddRange(tmpLow, nextLowSurrogates[0], nextLowSurrogates[1] - 1);
            }

            ++index;
            mapping = surrogateMappings[index];
            highSurrogates = mapping[0];
            lowSurrogates = mapping[1];
            nextMapping = surrogateMappings[index + 1];
            nextHighSurrogates = nextMapping && nextMapping[0];
            nextLowSurrogates = nextMapping && nextMapping[1];
            addLow = true;
          }

          result.push([highSurrogates, addLow ? tmpLow : lowSurrogates]);
          addLow = false;
        }

        return optimizeByLowSurrogates(result);
      };

      var optimizeByLowSurrogates = function optimizeByLowSurrogates(surrogateMappings) {
        if (surrogateMappings.length == 1) {
          return surrogateMappings;
        }

        var index = -1;
        var innerIndex = -1;

        while (++index < surrogateMappings.length) {
          var mapping = surrogateMappings[index];
          var lowSurrogates = mapping[1];
          var lowSurrogateStart = lowSurrogates[0];
          var lowSurrogateEnd = lowSurrogates[1];
          innerIndex = index;

          while (++innerIndex < surrogateMappings.length) {
            var otherMapping = surrogateMappings[innerIndex];
            var otherLowSurrogates = otherMapping[1];
            var otherLowSurrogateStart = otherLowSurrogates[0];
            var otherLowSurrogateEnd = otherLowSurrogates[1];

            if (lowSurrogateStart == otherLowSurrogateStart && lowSurrogateEnd == otherLowSurrogateEnd && otherLowSurrogates.length === 2) {
              if (dataIsSingleton(otherMapping[0])) {
                mapping[0] = dataAdd(mapping[0], otherMapping[0][0]);
              } else {
                mapping[0] = dataAddRange(mapping[0], otherMapping[0][0], otherMapping[0][1] - 1);
              }

              surrogateMappings.splice(innerIndex, 1);
              --innerIndex;
            }
          }
        }

        return surrogateMappings;
      };

      var surrogateSet = function surrogateSet(data) {
        if (!data.length) {
          return [];
        }

        var index = 0;
        var start;
        var end;
        var startHigh;
        var startLow;
        var endHigh;
        var endLow;
        var surrogateMappings = [];
        var length = data.length;

        while (index < length) {
          start = data[index];
          end = data[index + 1] - 1;
          startHigh = highSurrogate(start);
          startLow = lowSurrogate(start);
          endHigh = highSurrogate(end);
          endLow = lowSurrogate(end);
          var startsWithLowestLowSurrogate = startLow == LOW_SURROGATE_MIN;
          var endsWithHighestLowSurrogate = endLow == LOW_SURROGATE_MAX;
          var complete = false;

          if (startHigh == endHigh || startsWithLowestLowSurrogate && endsWithHighestLowSurrogate) {
            surrogateMappings.push([[startHigh, endHigh + 1], [startLow, endLow + 1]]);
            complete = true;
          } else {
            surrogateMappings.push([[startHigh, startHigh + 1], [startLow, LOW_SURROGATE_MAX + 1]]);
          }

          if (!complete && startHigh + 1 < endHigh) {
            if (endsWithHighestLowSurrogate) {
              surrogateMappings.push([[startHigh + 1, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
              complete = true;
            } else {
              surrogateMappings.push([[startHigh + 1, endHigh], [LOW_SURROGATE_MIN, LOW_SURROGATE_MAX + 1]]);
            }
          }

          if (!complete) {
            surrogateMappings.push([[endHigh, endHigh + 1], [LOW_SURROGATE_MIN, endLow + 1]]);
          }

          index += 2;
        }

        return optimizeSurrogateMappings(surrogateMappings);
      };

      var createSurrogateCharacterClasses = function createSurrogateCharacterClasses(surrogateMappings) {
        var result = [];
        forEach(surrogateMappings, function (surrogateMapping) {
          var highSurrogates = surrogateMapping[0];
          var lowSurrogates = surrogateMapping[1];
          result.push(createBMPCharacterClasses(highSurrogates) + createBMPCharacterClasses(lowSurrogates));
        });
        return result.join('|');
      };

      var createCharacterClassesFromData = function createCharacterClassesFromData(data, bmpOnly, hasUnicodeFlag) {
        if (hasUnicodeFlag) {
          return createUnicodeCharacterClasses(data);
        }

        var result = [];
        var parts = splitAtBMP(data);
        var loneHighSurrogates = parts.loneHighSurrogates;
        var loneLowSurrogates = parts.loneLowSurrogates;
        var bmp = parts.bmp;
        var astral = parts.astral;
        var hasLoneHighSurrogates = !dataIsEmpty(loneHighSurrogates);
        var hasLoneLowSurrogates = !dataIsEmpty(loneLowSurrogates);
        var surrogateMappings = surrogateSet(astral);

        if (bmpOnly) {
          bmp = dataAddData(bmp, loneHighSurrogates);
          hasLoneHighSurrogates = false;
          bmp = dataAddData(bmp, loneLowSurrogates);
          hasLoneLowSurrogates = false;
        }

        if (!dataIsEmpty(bmp)) {
          result.push(createBMPCharacterClasses(bmp));
        }

        if (surrogateMappings.length) {
          result.push(createSurrogateCharacterClasses(surrogateMappings));
        }

        if (hasLoneHighSurrogates) {
          result.push(createBMPCharacterClasses(loneHighSurrogates) + "(?![\\uDC00-\\uDFFF])");
        }

        if (hasLoneLowSurrogates) {
          result.push("(?:[^\\uD800-\\uDBFF]|^)" + createBMPCharacterClasses(loneLowSurrogates));
        }

        return result.join('|');
      };

      var regenerate = function regenerate(value) {
        if (arguments.length > 1) {
          value = slice.call(arguments);
        }

        if (this instanceof regenerate) {
          this.data = [];
          return value ? this.add(value) : this;
        }

        return new regenerate().add(value);
      };

      regenerate.version = '1.4.2';
      var proto = regenerate.prototype;
      extend(proto, {
        'add': function add(value) {
          var $this = this;

          if (value == null) {
            return $this;
          }

          if (value instanceof regenerate) {
            $this.data = dataAddData($this.data, value.data);
            return $this;
          }

          if (arguments.length > 1) {
            value = slice.call(arguments);
          }

          if (isArray(value)) {
            forEach(value, function (item) {
              $this.add(item);
            });
            return $this;
          }

          $this.data = dataAdd($this.data, isNumber(value) ? value : symbolToCodePoint(value));
          return $this;
        },
        'remove': function remove(value) {
          var $this = this;

          if (value == null) {
            return $this;
          }

          if (value instanceof regenerate) {
            $this.data = dataRemoveData($this.data, value.data);
            return $this;
          }

          if (arguments.length > 1) {
            value = slice.call(arguments);
          }

          if (isArray(value)) {
            forEach(value, function (item) {
              $this.remove(item);
            });
            return $this;
          }

          $this.data = dataRemove($this.data, isNumber(value) ? value : symbolToCodePoint(value));
          return $this;
        },
        'addRange': function addRange(start, end) {
          var $this = this;
          $this.data = dataAddRange($this.data, isNumber(start) ? start : symbolToCodePoint(start), isNumber(end) ? end : symbolToCodePoint(end));
          return $this;
        },
        'removeRange': function removeRange(start, end) {
          var $this = this;
          var startCodePoint = isNumber(start) ? start : symbolToCodePoint(start);
          var endCodePoint = isNumber(end) ? end : symbolToCodePoint(end);
          $this.data = dataRemoveRange($this.data, startCodePoint, endCodePoint);
          return $this;
        },
        'intersection': function intersection(argument) {
          var $this = this;
          var array = argument instanceof regenerate ? dataToArray(argument.data) : argument;
          $this.data = dataIntersection($this.data, array);
          return $this;
        },
        'contains': function contains(codePoint) {
          return dataContains(this.data, isNumber(codePoint) ? codePoint : symbolToCodePoint(codePoint));
        },
        'clone': function clone() {
          var set = new regenerate();
          set.data = this.data.slice(0);
          return set;
        },
        'toString': function toString(options) {
          var result = createCharacterClassesFromData(this.data, options ? options.bmpOnly : false, options ? options.hasUnicodeFlag : false);

          if (!result) {
            return '[]';
          }

          return result.replace(regexNull, '\\0$1');
        },
        'toRegExp': function toRegExp(flags) {
          var pattern = this.toString(flags && flags.indexOf('u') != -1 ? {
            'hasUnicodeFlag': true
          } : null);
          return RegExp(pattern, flags || '');
        },
        'valueOf': function valueOf() {
          return dataToArray(this.data);
        }
      });
      proto.toArray = proto.valueOf;

      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = regenerate;
        } else {
          freeExports.regenerate = regenerate;
        }
      } else {
        root.regenerate = regenerate;
      }
    })(commonjsGlobal);
  }, "/$$rollup_base$$/node_modules/regenerate");

  var unicodeCanonicalPropertyNamesEcmascript = new Set(['General_Category', 'Script', 'Script_Extensions', 'Alphabetic', 'Any', 'ASCII', 'ASCII_Hex_Digit', 'Assigned', 'Bidi_Control', 'Bidi_Mirrored', 'Case_Ignorable', 'Cased', 'Changes_When_Casefolded', 'Changes_When_Casemapped', 'Changes_When_Lowercased', 'Changes_When_NFKC_Casefolded', 'Changes_When_Titlecased', 'Changes_When_Uppercased', 'Dash', 'Default_Ignorable_Code_Point', 'Deprecated', 'Diacritic', 'Emoji', 'Emoji_Component', 'Emoji_Modifier', 'Emoji_Modifier_Base', 'Emoji_Presentation', 'Extended_Pictographic', 'Extender', 'Grapheme_Base', 'Grapheme_Extend', 'Hex_Digit', 'ID_Continue', 'ID_Start', 'Ideographic', 'IDS_Binary_Operator', 'IDS_Trinary_Operator', 'Join_Control', 'Logical_Order_Exception', 'Lowercase', 'Math', 'Noncharacter_Code_Point', 'Pattern_Syntax', 'Pattern_White_Space', 'Quotation_Mark', 'Radical', 'Regional_Indicator', 'Sentence_Terminal', 'Soft_Dotted', 'Terminal_Punctuation', 'Unified_Ideograph', 'Uppercase', 'Variation_Selector', 'White_Space', 'XID_Continue', 'XID_Start']);

  var unicodePropertyAliasesEcmascript = new Map([['scx', 'Script_Extensions'], ['sc', 'Script'], ['gc', 'General_Category'], ['AHex', 'ASCII_Hex_Digit'], ['Alpha', 'Alphabetic'], ['Bidi_C', 'Bidi_Control'], ['Bidi_M', 'Bidi_Mirrored'], ['Cased', 'Cased'], ['CI', 'Case_Ignorable'], ['CWCF', 'Changes_When_Casefolded'], ['CWCM', 'Changes_When_Casemapped'], ['CWKCF', 'Changes_When_NFKC_Casefolded'], ['CWL', 'Changes_When_Lowercased'], ['CWT', 'Changes_When_Titlecased'], ['CWU', 'Changes_When_Uppercased'], ['Dash', 'Dash'], ['Dep', 'Deprecated'], ['DI', 'Default_Ignorable_Code_Point'], ['Dia', 'Diacritic'], ['Ext', 'Extender'], ['Gr_Base', 'Grapheme_Base'], ['Gr_Ext', 'Grapheme_Extend'], ['Hex', 'Hex_Digit'], ['IDC', 'ID_Continue'], ['Ideo', 'Ideographic'], ['IDS', 'ID_Start'], ['IDSB', 'IDS_Binary_Operator'], ['IDST', 'IDS_Trinary_Operator'], ['Join_C', 'Join_Control'], ['LOE', 'Logical_Order_Exception'], ['Lower', 'Lowercase'], ['Math', 'Math'], ['NChar', 'Noncharacter_Code_Point'], ['Pat_Syn', 'Pattern_Syntax'], ['Pat_WS', 'Pattern_White_Space'], ['QMark', 'Quotation_Mark'], ['Radical', 'Radical'], ['RI', 'Regional_Indicator'], ['SD', 'Soft_Dotted'], ['STerm', 'Sentence_Terminal'], ['Term', 'Terminal_Punctuation'], ['UIdeo', 'Unified_Ideograph'], ['Upper', 'Uppercase'], ['VS', 'Variation_Selector'], ['WSpace', 'White_Space'], ['space', 'White_Space'], ['XIDC', 'XID_Continue'], ['XIDS', 'XID_Start']]);

  var matchProperty = function matchProperty(property) {
    if (unicodeCanonicalPropertyNamesEcmascript.has(property)) {
      return property;
    }

    if (unicodePropertyAliasesEcmascript.has(property)) {
      return unicodePropertyAliasesEcmascript.get(property);
    }

    throw new Error("Unknown property: " + property);
  };

  var unicodeMatchPropertyEcmascript = matchProperty;

  var mappings = new Map([['General_Category', new Map([['C', 'Other'], ['Cc', 'Control'], ['cntrl', 'Control'], ['Cf', 'Format'], ['Cn', 'Unassigned'], ['Co', 'Private_Use'], ['Cs', 'Surrogate'], ['L', 'Letter'], ['LC', 'Cased_Letter'], ['Ll', 'Lowercase_Letter'], ['Lm', 'Modifier_Letter'], ['Lo', 'Other_Letter'], ['Lt', 'Titlecase_Letter'], ['Lu', 'Uppercase_Letter'], ['M', 'Mark'], ['Combining_Mark', 'Mark'], ['Mc', 'Spacing_Mark'], ['Me', 'Enclosing_Mark'], ['Mn', 'Nonspacing_Mark'], ['N', 'Number'], ['Nd', 'Decimal_Number'], ['digit', 'Decimal_Number'], ['Nl', 'Letter_Number'], ['No', 'Other_Number'], ['P', 'Punctuation'], ['punct', 'Punctuation'], ['Pc', 'Connector_Punctuation'], ['Pd', 'Dash_Punctuation'], ['Pe', 'Close_Punctuation'], ['Pf', 'Final_Punctuation'], ['Pi', 'Initial_Punctuation'], ['Po', 'Other_Punctuation'], ['Ps', 'Open_Punctuation'], ['S', 'Symbol'], ['Sc', 'Currency_Symbol'], ['Sk', 'Modifier_Symbol'], ['Sm', 'Math_Symbol'], ['So', 'Other_Symbol'], ['Z', 'Separator'], ['Zl', 'Line_Separator'], ['Zp', 'Paragraph_Separator'], ['Zs', 'Space_Separator'], ['Other', 'Other'], ['Control', 'Control'], ['Format', 'Format'], ['Unassigned', 'Unassigned'], ['Private_Use', 'Private_Use'], ['Surrogate', 'Surrogate'], ['Letter', 'Letter'], ['Cased_Letter', 'Cased_Letter'], ['Lowercase_Letter', 'Lowercase_Letter'], ['Modifier_Letter', 'Modifier_Letter'], ['Other_Letter', 'Other_Letter'], ['Titlecase_Letter', 'Titlecase_Letter'], ['Uppercase_Letter', 'Uppercase_Letter'], ['Mark', 'Mark'], ['Spacing_Mark', 'Spacing_Mark'], ['Enclosing_Mark', 'Enclosing_Mark'], ['Nonspacing_Mark', 'Nonspacing_Mark'], ['Number', 'Number'], ['Decimal_Number', 'Decimal_Number'], ['Letter_Number', 'Letter_Number'], ['Other_Number', 'Other_Number'], ['Punctuation', 'Punctuation'], ['Connector_Punctuation', 'Connector_Punctuation'], ['Dash_Punctuation', 'Dash_Punctuation'], ['Close_Punctuation', 'Close_Punctuation'], ['Final_Punctuation', 'Final_Punctuation'], ['Initial_Punctuation', 'Initial_Punctuation'], ['Other_Punctuation', 'Other_Punctuation'], ['Open_Punctuation', 'Open_Punctuation'], ['Symbol', 'Symbol'], ['Currency_Symbol', 'Currency_Symbol'], ['Modifier_Symbol', 'Modifier_Symbol'], ['Math_Symbol', 'Math_Symbol'], ['Other_Symbol', 'Other_Symbol'], ['Separator', 'Separator'], ['Line_Separator', 'Line_Separator'], ['Paragraph_Separator', 'Paragraph_Separator'], ['Space_Separator', 'Space_Separator']])], ['Script', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])], ['Script_Extensions', new Map([['Adlm', 'Adlam'], ['Aghb', 'Caucasian_Albanian'], ['Ahom', 'Ahom'], ['Arab', 'Arabic'], ['Armi', 'Imperial_Aramaic'], ['Armn', 'Armenian'], ['Avst', 'Avestan'], ['Bali', 'Balinese'], ['Bamu', 'Bamum'], ['Bass', 'Bassa_Vah'], ['Batk', 'Batak'], ['Beng', 'Bengali'], ['Bhks', 'Bhaiksuki'], ['Bopo', 'Bopomofo'], ['Brah', 'Brahmi'], ['Brai', 'Braille'], ['Bugi', 'Buginese'], ['Buhd', 'Buhid'], ['Cakm', 'Chakma'], ['Cans', 'Canadian_Aboriginal'], ['Cari', 'Carian'], ['Cham', 'Cham'], ['Cher', 'Cherokee'], ['Chrs', 'Chorasmian'], ['Copt', 'Coptic'], ['Qaac', 'Coptic'], ['Cprt', 'Cypriot'], ['Cyrl', 'Cyrillic'], ['Deva', 'Devanagari'], ['Diak', 'Dives_Akuru'], ['Dogr', 'Dogra'], ['Dsrt', 'Deseret'], ['Dupl', 'Duployan'], ['Egyp', 'Egyptian_Hieroglyphs'], ['Elba', 'Elbasan'], ['Elym', 'Elymaic'], ['Ethi', 'Ethiopic'], ['Geor', 'Georgian'], ['Glag', 'Glagolitic'], ['Gong', 'Gunjala_Gondi'], ['Gonm', 'Masaram_Gondi'], ['Goth', 'Gothic'], ['Gran', 'Grantha'], ['Grek', 'Greek'], ['Gujr', 'Gujarati'], ['Guru', 'Gurmukhi'], ['Hang', 'Hangul'], ['Hani', 'Han'], ['Hano', 'Hanunoo'], ['Hatr', 'Hatran'], ['Hebr', 'Hebrew'], ['Hira', 'Hiragana'], ['Hluw', 'Anatolian_Hieroglyphs'], ['Hmng', 'Pahawh_Hmong'], ['Hmnp', 'Nyiakeng_Puachue_Hmong'], ['Hrkt', 'Katakana_Or_Hiragana'], ['Hung', 'Old_Hungarian'], ['Ital', 'Old_Italic'], ['Java', 'Javanese'], ['Kali', 'Kayah_Li'], ['Kana', 'Katakana'], ['Khar', 'Kharoshthi'], ['Khmr', 'Khmer'], ['Khoj', 'Khojki'], ['Kits', 'Khitan_Small_Script'], ['Knda', 'Kannada'], ['Kthi', 'Kaithi'], ['Lana', 'Tai_Tham'], ['Laoo', 'Lao'], ['Latn', 'Latin'], ['Lepc', 'Lepcha'], ['Limb', 'Limbu'], ['Lina', 'Linear_A'], ['Linb', 'Linear_B'], ['Lisu', 'Lisu'], ['Lyci', 'Lycian'], ['Lydi', 'Lydian'], ['Mahj', 'Mahajani'], ['Maka', 'Makasar'], ['Mand', 'Mandaic'], ['Mani', 'Manichaean'], ['Marc', 'Marchen'], ['Medf', 'Medefaidrin'], ['Mend', 'Mende_Kikakui'], ['Merc', 'Meroitic_Cursive'], ['Mero', 'Meroitic_Hieroglyphs'], ['Mlym', 'Malayalam'], ['Modi', 'Modi'], ['Mong', 'Mongolian'], ['Mroo', 'Mro'], ['Mtei', 'Meetei_Mayek'], ['Mult', 'Multani'], ['Mymr', 'Myanmar'], ['Nand', 'Nandinagari'], ['Narb', 'Old_North_Arabian'], ['Nbat', 'Nabataean'], ['Newa', 'Newa'], ['Nkoo', 'Nko'], ['Nshu', 'Nushu'], ['Ogam', 'Ogham'], ['Olck', 'Ol_Chiki'], ['Orkh', 'Old_Turkic'], ['Orya', 'Oriya'], ['Osge', 'Osage'], ['Osma', 'Osmanya'], ['Palm', 'Palmyrene'], ['Pauc', 'Pau_Cin_Hau'], ['Perm', 'Old_Permic'], ['Phag', 'Phags_Pa'], ['Phli', 'Inscriptional_Pahlavi'], ['Phlp', 'Psalter_Pahlavi'], ['Phnx', 'Phoenician'], ['Plrd', 'Miao'], ['Prti', 'Inscriptional_Parthian'], ['Rjng', 'Rejang'], ['Rohg', 'Hanifi_Rohingya'], ['Runr', 'Runic'], ['Samr', 'Samaritan'], ['Sarb', 'Old_South_Arabian'], ['Saur', 'Saurashtra'], ['Sgnw', 'SignWriting'], ['Shaw', 'Shavian'], ['Shrd', 'Sharada'], ['Sidd', 'Siddham'], ['Sind', 'Khudawadi'], ['Sinh', 'Sinhala'], ['Sogd', 'Sogdian'], ['Sogo', 'Old_Sogdian'], ['Sora', 'Sora_Sompeng'], ['Soyo', 'Soyombo'], ['Sund', 'Sundanese'], ['Sylo', 'Syloti_Nagri'], ['Syrc', 'Syriac'], ['Tagb', 'Tagbanwa'], ['Takr', 'Takri'], ['Tale', 'Tai_Le'], ['Talu', 'New_Tai_Lue'], ['Taml', 'Tamil'], ['Tang', 'Tangut'], ['Tavt', 'Tai_Viet'], ['Telu', 'Telugu'], ['Tfng', 'Tifinagh'], ['Tglg', 'Tagalog'], ['Thaa', 'Thaana'], ['Thai', 'Thai'], ['Tibt', 'Tibetan'], ['Tirh', 'Tirhuta'], ['Ugar', 'Ugaritic'], ['Vaii', 'Vai'], ['Wara', 'Warang_Citi'], ['Wcho', 'Wancho'], ['Xpeo', 'Old_Persian'], ['Xsux', 'Cuneiform'], ['Yezi', 'Yezidi'], ['Yiii', 'Yi'], ['Zanb', 'Zanabazar_Square'], ['Zinh', 'Inherited'], ['Qaai', 'Inherited'], ['Zyyy', 'Common'], ['Zzzz', 'Unknown'], ['Adlam', 'Adlam'], ['Caucasian_Albanian', 'Caucasian_Albanian'], ['Arabic', 'Arabic'], ['Imperial_Aramaic', 'Imperial_Aramaic'], ['Armenian', 'Armenian'], ['Avestan', 'Avestan'], ['Balinese', 'Balinese'], ['Bamum', 'Bamum'], ['Bassa_Vah', 'Bassa_Vah'], ['Batak', 'Batak'], ['Bengali', 'Bengali'], ['Bhaiksuki', 'Bhaiksuki'], ['Bopomofo', 'Bopomofo'], ['Brahmi', 'Brahmi'], ['Braille', 'Braille'], ['Buginese', 'Buginese'], ['Buhid', 'Buhid'], ['Chakma', 'Chakma'], ['Canadian_Aboriginal', 'Canadian_Aboriginal'], ['Carian', 'Carian'], ['Cherokee', 'Cherokee'], ['Chorasmian', 'Chorasmian'], ['Coptic', 'Coptic'], ['Cypriot', 'Cypriot'], ['Cyrillic', 'Cyrillic'], ['Devanagari', 'Devanagari'], ['Dives_Akuru', 'Dives_Akuru'], ['Dogra', 'Dogra'], ['Deseret', 'Deseret'], ['Duployan', 'Duployan'], ['Egyptian_Hieroglyphs', 'Egyptian_Hieroglyphs'], ['Elbasan', 'Elbasan'], ['Elymaic', 'Elymaic'], ['Ethiopic', 'Ethiopic'], ['Georgian', 'Georgian'], ['Glagolitic', 'Glagolitic'], ['Gunjala_Gondi', 'Gunjala_Gondi'], ['Masaram_Gondi', 'Masaram_Gondi'], ['Gothic', 'Gothic'], ['Grantha', 'Grantha'], ['Greek', 'Greek'], ['Gujarati', 'Gujarati'], ['Gurmukhi', 'Gurmukhi'], ['Hangul', 'Hangul'], ['Han', 'Han'], ['Hanunoo', 'Hanunoo'], ['Hatran', 'Hatran'], ['Hebrew', 'Hebrew'], ['Hiragana', 'Hiragana'], ['Anatolian_Hieroglyphs', 'Anatolian_Hieroglyphs'], ['Pahawh_Hmong', 'Pahawh_Hmong'], ['Nyiakeng_Puachue_Hmong', 'Nyiakeng_Puachue_Hmong'], ['Katakana_Or_Hiragana', 'Katakana_Or_Hiragana'], ['Old_Hungarian', 'Old_Hungarian'], ['Old_Italic', 'Old_Italic'], ['Javanese', 'Javanese'], ['Kayah_Li', 'Kayah_Li'], ['Katakana', 'Katakana'], ['Kharoshthi', 'Kharoshthi'], ['Khmer', 'Khmer'], ['Khojki', 'Khojki'], ['Khitan_Small_Script', 'Khitan_Small_Script'], ['Kannada', 'Kannada'], ['Kaithi', 'Kaithi'], ['Tai_Tham', 'Tai_Tham'], ['Lao', 'Lao'], ['Latin', 'Latin'], ['Lepcha', 'Lepcha'], ['Limbu', 'Limbu'], ['Linear_A', 'Linear_A'], ['Linear_B', 'Linear_B'], ['Lycian', 'Lycian'], ['Lydian', 'Lydian'], ['Mahajani', 'Mahajani'], ['Makasar', 'Makasar'], ['Mandaic', 'Mandaic'], ['Manichaean', 'Manichaean'], ['Marchen', 'Marchen'], ['Medefaidrin', 'Medefaidrin'], ['Mende_Kikakui', 'Mende_Kikakui'], ['Meroitic_Cursive', 'Meroitic_Cursive'], ['Meroitic_Hieroglyphs', 'Meroitic_Hieroglyphs'], ['Malayalam', 'Malayalam'], ['Mongolian', 'Mongolian'], ['Mro', 'Mro'], ['Meetei_Mayek', 'Meetei_Mayek'], ['Multani', 'Multani'], ['Myanmar', 'Myanmar'], ['Nandinagari', 'Nandinagari'], ['Old_North_Arabian', 'Old_North_Arabian'], ['Nabataean', 'Nabataean'], ['Nko', 'Nko'], ['Nushu', 'Nushu'], ['Ogham', 'Ogham'], ['Ol_Chiki', 'Ol_Chiki'], ['Old_Turkic', 'Old_Turkic'], ['Oriya', 'Oriya'], ['Osage', 'Osage'], ['Osmanya', 'Osmanya'], ['Palmyrene', 'Palmyrene'], ['Pau_Cin_Hau', 'Pau_Cin_Hau'], ['Old_Permic', 'Old_Permic'], ['Phags_Pa', 'Phags_Pa'], ['Inscriptional_Pahlavi', 'Inscriptional_Pahlavi'], ['Psalter_Pahlavi', 'Psalter_Pahlavi'], ['Phoenician', 'Phoenician'], ['Miao', 'Miao'], ['Inscriptional_Parthian', 'Inscriptional_Parthian'], ['Rejang', 'Rejang'], ['Hanifi_Rohingya', 'Hanifi_Rohingya'], ['Runic', 'Runic'], ['Samaritan', 'Samaritan'], ['Old_South_Arabian', 'Old_South_Arabian'], ['Saurashtra', 'Saurashtra'], ['SignWriting', 'SignWriting'], ['Shavian', 'Shavian'], ['Sharada', 'Sharada'], ['Siddham', 'Siddham'], ['Khudawadi', 'Khudawadi'], ['Sinhala', 'Sinhala'], ['Sogdian', 'Sogdian'], ['Old_Sogdian', 'Old_Sogdian'], ['Sora_Sompeng', 'Sora_Sompeng'], ['Soyombo', 'Soyombo'], ['Sundanese', 'Sundanese'], ['Syloti_Nagri', 'Syloti_Nagri'], ['Syriac', 'Syriac'], ['Tagbanwa', 'Tagbanwa'], ['Takri', 'Takri'], ['Tai_Le', 'Tai_Le'], ['New_Tai_Lue', 'New_Tai_Lue'], ['Tamil', 'Tamil'], ['Tangut', 'Tangut'], ['Tai_Viet', 'Tai_Viet'], ['Telugu', 'Telugu'], ['Tifinagh', 'Tifinagh'], ['Tagalog', 'Tagalog'], ['Thaana', 'Thaana'], ['Tibetan', 'Tibetan'], ['Tirhuta', 'Tirhuta'], ['Ugaritic', 'Ugaritic'], ['Vai', 'Vai'], ['Warang_Citi', 'Warang_Citi'], ['Wancho', 'Wancho'], ['Old_Persian', 'Old_Persian'], ['Cuneiform', 'Cuneiform'], ['Yezidi', 'Yezidi'], ['Yi', 'Yi'], ['Zanabazar_Square', 'Zanabazar_Square'], ['Inherited', 'Inherited'], ['Common', 'Common'], ['Unknown', 'Unknown']])]]);

  var matchPropertyValue = function matchPropertyValue(property, value) {
    var aliasToValue = mappings.get(property);

    if (!aliasToValue) {
      throw new Error("Unknown property `" + property + "`.");
    }

    var canonicalValue = aliasToValue.get(value);

    if (canonicalValue) {
      return canonicalValue;
    }

    throw new Error("Unknown value `" + value + "` for property `" + property + "`.");
  };

  var unicodeMatchPropertyValueEcmascript = matchPropertyValue;

  var iuMappings = new Map([[0x4B, 0x212A], [0x53, 0x17F], [0x6B, 0x212A], [0x73, 0x17F], [0xB5, 0x39C], [0xC5, 0x212B], [0xDF, 0x1E9E], [0xE5, 0x212B], [0x17F, 0x53], [0x1C4, 0x1C5], [0x1C5, 0x1C4], [0x1C7, 0x1C8], [0x1C8, 0x1C7], [0x1CA, 0x1CB], [0x1CB, 0x1CA], [0x1F1, 0x1F2], [0x1F2, 0x1F1], [0x345, 0x1FBE], [0x392, 0x3D0], [0x395, 0x3F5], [0x398, 0x3F4], [0x399, 0x1FBE], [0x39A, 0x3F0], [0x39C, 0xB5], [0x3A0, 0x3D6], [0x3A1, 0x3F1], [0x3A3, 0x3C2], [0x3A6, 0x3D5], [0x3A9, 0x2126], [0x3B8, 0x3F4], [0x3C2, 0x3A3], [0x3C9, 0x2126], [0x3D0, 0x392], [0x3D1, 0x3F4], [0x3D5, 0x3A6], [0x3D6, 0x3A0], [0x3F0, 0x39A], [0x3F1, 0x3A1], [0x3F4, [0x398, 0x3D1, 0x3B8]], [0x3F5, 0x395], [0x412, 0x1C80], [0x414, 0x1C81], [0x41E, 0x1C82], [0x421, 0x1C83], [0x422, 0x1C85], [0x42A, 0x1C86], [0x462, 0x1C87], [0x1C80, 0x412], [0x1C81, 0x414], [0x1C82, 0x41E], [0x1C83, 0x421], [0x1C84, 0x1C85], [0x1C85, [0x422, 0x1C84]], [0x1C86, 0x42A], [0x1C87, 0x462], [0x1C88, 0xA64A], [0x1E60, 0x1E9B], [0x1E9B, 0x1E60], [0x1E9E, 0xDF], [0x1F80, 0x1F88], [0x1F81, 0x1F89], [0x1F82, 0x1F8A], [0x1F83, 0x1F8B], [0x1F84, 0x1F8C], [0x1F85, 0x1F8D], [0x1F86, 0x1F8E], [0x1F87, 0x1F8F], [0x1F88, 0x1F80], [0x1F89, 0x1F81], [0x1F8A, 0x1F82], [0x1F8B, 0x1F83], [0x1F8C, 0x1F84], [0x1F8D, 0x1F85], [0x1F8E, 0x1F86], [0x1F8F, 0x1F87], [0x1F90, 0x1F98], [0x1F91, 0x1F99], [0x1F92, 0x1F9A], [0x1F93, 0x1F9B], [0x1F94, 0x1F9C], [0x1F95, 0x1F9D], [0x1F96, 0x1F9E], [0x1F97, 0x1F9F], [0x1F98, 0x1F90], [0x1F99, 0x1F91], [0x1F9A, 0x1F92], [0x1F9B, 0x1F93], [0x1F9C, 0x1F94], [0x1F9D, 0x1F95], [0x1F9E, 0x1F96], [0x1F9F, 0x1F97], [0x1FA0, 0x1FA8], [0x1FA1, 0x1FA9], [0x1FA2, 0x1FAA], [0x1FA3, 0x1FAB], [0x1FA4, 0x1FAC], [0x1FA5, 0x1FAD], [0x1FA6, 0x1FAE], [0x1FA7, 0x1FAF], [0x1FA8, 0x1FA0], [0x1FA9, 0x1FA1], [0x1FAA, 0x1FA2], [0x1FAB, 0x1FA3], [0x1FAC, 0x1FA4], [0x1FAD, 0x1FA5], [0x1FAE, 0x1FA6], [0x1FAF, 0x1FA7], [0x1FB3, 0x1FBC], [0x1FBC, 0x1FB3], [0x1FBE, [0x345, 0x399]], [0x1FC3, 0x1FCC], [0x1FCC, 0x1FC3], [0x1FF3, 0x1FFC], [0x1FFC, 0x1FF3], [0x2126, [0x3A9, 0x3C9]], [0x212A, 0x4B], [0x212B, [0xC5, 0xE5]], [0xA64A, 0x1C88], [0x10400, 0x10428], [0x10401, 0x10429], [0x10402, 0x1042A], [0x10403, 0x1042B], [0x10404, 0x1042C], [0x10405, 0x1042D], [0x10406, 0x1042E], [0x10407, 0x1042F], [0x10408, 0x10430], [0x10409, 0x10431], [0x1040A, 0x10432], [0x1040B, 0x10433], [0x1040C, 0x10434], [0x1040D, 0x10435], [0x1040E, 0x10436], [0x1040F, 0x10437], [0x10410, 0x10438], [0x10411, 0x10439], [0x10412, 0x1043A], [0x10413, 0x1043B], [0x10414, 0x1043C], [0x10415, 0x1043D], [0x10416, 0x1043E], [0x10417, 0x1043F], [0x10418, 0x10440], [0x10419, 0x10441], [0x1041A, 0x10442], [0x1041B, 0x10443], [0x1041C, 0x10444], [0x1041D, 0x10445], [0x1041E, 0x10446], [0x1041F, 0x10447], [0x10420, 0x10448], [0x10421, 0x10449], [0x10422, 0x1044A], [0x10423, 0x1044B], [0x10424, 0x1044C], [0x10425, 0x1044D], [0x10426, 0x1044E], [0x10427, 0x1044F], [0x10428, 0x10400], [0x10429, 0x10401], [0x1042A, 0x10402], [0x1042B, 0x10403], [0x1042C, 0x10404], [0x1042D, 0x10405], [0x1042E, 0x10406], [0x1042F, 0x10407], [0x10430, 0x10408], [0x10431, 0x10409], [0x10432, 0x1040A], [0x10433, 0x1040B], [0x10434, 0x1040C], [0x10435, 0x1040D], [0x10436, 0x1040E], [0x10437, 0x1040F], [0x10438, 0x10410], [0x10439, 0x10411], [0x1043A, 0x10412], [0x1043B, 0x10413], [0x1043C, 0x10414], [0x1043D, 0x10415], [0x1043E, 0x10416], [0x1043F, 0x10417], [0x10440, 0x10418], [0x10441, 0x10419], [0x10442, 0x1041A], [0x10443, 0x1041B], [0x10444, 0x1041C], [0x10445, 0x1041D], [0x10446, 0x1041E], [0x10447, 0x1041F], [0x10448, 0x10420], [0x10449, 0x10421], [0x1044A, 0x10422], [0x1044B, 0x10423], [0x1044C, 0x10424], [0x1044D, 0x10425], [0x1044E, 0x10426], [0x1044F, 0x10427], [0x104B0, 0x104D8], [0x104B1, 0x104D9], [0x104B2, 0x104DA], [0x104B3, 0x104DB], [0x104B4, 0x104DC], [0x104B5, 0x104DD], [0x104B6, 0x104DE], [0x104B7, 0x104DF], [0x104B8, 0x104E0], [0x104B9, 0x104E1], [0x104BA, 0x104E2], [0x104BB, 0x104E3], [0x104BC, 0x104E4], [0x104BD, 0x104E5], [0x104BE, 0x104E6], [0x104BF, 0x104E7], [0x104C0, 0x104E8], [0x104C1, 0x104E9], [0x104C2, 0x104EA], [0x104C3, 0x104EB], [0x104C4, 0x104EC], [0x104C5, 0x104ED], [0x104C6, 0x104EE], [0x104C7, 0x104EF], [0x104C8, 0x104F0], [0x104C9, 0x104F1], [0x104CA, 0x104F2], [0x104CB, 0x104F3], [0x104CC, 0x104F4], [0x104CD, 0x104F5], [0x104CE, 0x104F6], [0x104CF, 0x104F7], [0x104D0, 0x104F8], [0x104D1, 0x104F9], [0x104D2, 0x104FA], [0x104D3, 0x104FB], [0x104D8, 0x104B0], [0x104D9, 0x104B1], [0x104DA, 0x104B2], [0x104DB, 0x104B3], [0x104DC, 0x104B4], [0x104DD, 0x104B5], [0x104DE, 0x104B6], [0x104DF, 0x104B7], [0x104E0, 0x104B8], [0x104E1, 0x104B9], [0x104E2, 0x104BA], [0x104E3, 0x104BB], [0x104E4, 0x104BC], [0x104E5, 0x104BD], [0x104E6, 0x104BE], [0x104E7, 0x104BF], [0x104E8, 0x104C0], [0x104E9, 0x104C1], [0x104EA, 0x104C2], [0x104EB, 0x104C3], [0x104EC, 0x104C4], [0x104ED, 0x104C5], [0x104EE, 0x104C6], [0x104EF, 0x104C7], [0x104F0, 0x104C8], [0x104F1, 0x104C9], [0x104F2, 0x104CA], [0x104F3, 0x104CB], [0x104F4, 0x104CC], [0x104F5, 0x104CD], [0x104F6, 0x104CE], [0x104F7, 0x104CF], [0x104F8, 0x104D0], [0x104F9, 0x104D1], [0x104FA, 0x104D2], [0x104FB, 0x104D3], [0x10C80, 0x10CC0], [0x10C81, 0x10CC1], [0x10C82, 0x10CC2], [0x10C83, 0x10CC3], [0x10C84, 0x10CC4], [0x10C85, 0x10CC5], [0x10C86, 0x10CC6], [0x10C87, 0x10CC7], [0x10C88, 0x10CC8], [0x10C89, 0x10CC9], [0x10C8A, 0x10CCA], [0x10C8B, 0x10CCB], [0x10C8C, 0x10CCC], [0x10C8D, 0x10CCD], [0x10C8E, 0x10CCE], [0x10C8F, 0x10CCF], [0x10C90, 0x10CD0], [0x10C91, 0x10CD1], [0x10C92, 0x10CD2], [0x10C93, 0x10CD3], [0x10C94, 0x10CD4], [0x10C95, 0x10CD5], [0x10C96, 0x10CD6], [0x10C97, 0x10CD7], [0x10C98, 0x10CD8], [0x10C99, 0x10CD9], [0x10C9A, 0x10CDA], [0x10C9B, 0x10CDB], [0x10C9C, 0x10CDC], [0x10C9D, 0x10CDD], [0x10C9E, 0x10CDE], [0x10C9F, 0x10CDF], [0x10CA0, 0x10CE0], [0x10CA1, 0x10CE1], [0x10CA2, 0x10CE2], [0x10CA3, 0x10CE3], [0x10CA4, 0x10CE4], [0x10CA5, 0x10CE5], [0x10CA6, 0x10CE6], [0x10CA7, 0x10CE7], [0x10CA8, 0x10CE8], [0x10CA9, 0x10CE9], [0x10CAA, 0x10CEA], [0x10CAB, 0x10CEB], [0x10CAC, 0x10CEC], [0x10CAD, 0x10CED], [0x10CAE, 0x10CEE], [0x10CAF, 0x10CEF], [0x10CB0, 0x10CF0], [0x10CB1, 0x10CF1], [0x10CB2, 0x10CF2], [0x10CC0, 0x10C80], [0x10CC1, 0x10C81], [0x10CC2, 0x10C82], [0x10CC3, 0x10C83], [0x10CC4, 0x10C84], [0x10CC5, 0x10C85], [0x10CC6, 0x10C86], [0x10CC7, 0x10C87], [0x10CC8, 0x10C88], [0x10CC9, 0x10C89], [0x10CCA, 0x10C8A], [0x10CCB, 0x10C8B], [0x10CCC, 0x10C8C], [0x10CCD, 0x10C8D], [0x10CCE, 0x10C8E], [0x10CCF, 0x10C8F], [0x10CD0, 0x10C90], [0x10CD1, 0x10C91], [0x10CD2, 0x10C92], [0x10CD3, 0x10C93], [0x10CD4, 0x10C94], [0x10CD5, 0x10C95], [0x10CD6, 0x10C96], [0x10CD7, 0x10C97], [0x10CD8, 0x10C98], [0x10CD9, 0x10C99], [0x10CDA, 0x10C9A], [0x10CDB, 0x10C9B], [0x10CDC, 0x10C9C], [0x10CDD, 0x10C9D], [0x10CDE, 0x10C9E], [0x10CDF, 0x10C9F], [0x10CE0, 0x10CA0], [0x10CE1, 0x10CA1], [0x10CE2, 0x10CA2], [0x10CE3, 0x10CA3], [0x10CE4, 0x10CA4], [0x10CE5, 0x10CA5], [0x10CE6, 0x10CA6], [0x10CE7, 0x10CA7], [0x10CE8, 0x10CA8], [0x10CE9, 0x10CA9], [0x10CEA, 0x10CAA], [0x10CEB, 0x10CAB], [0x10CEC, 0x10CAC], [0x10CED, 0x10CAD], [0x10CEE, 0x10CAE], [0x10CEF, 0x10CAF], [0x10CF0, 0x10CB0], [0x10CF1, 0x10CB1], [0x10CF2, 0x10CB2], [0x118A0, 0x118C0], [0x118A1, 0x118C1], [0x118A2, 0x118C2], [0x118A3, 0x118C3], [0x118A4, 0x118C4], [0x118A5, 0x118C5], [0x118A6, 0x118C6], [0x118A7, 0x118C7], [0x118A8, 0x118C8], [0x118A9, 0x118C9], [0x118AA, 0x118CA], [0x118AB, 0x118CB], [0x118AC, 0x118CC], [0x118AD, 0x118CD], [0x118AE, 0x118CE], [0x118AF, 0x118CF], [0x118B0, 0x118D0], [0x118B1, 0x118D1], [0x118B2, 0x118D2], [0x118B3, 0x118D3], [0x118B4, 0x118D4], [0x118B5, 0x118D5], [0x118B6, 0x118D6], [0x118B7, 0x118D7], [0x118B8, 0x118D8], [0x118B9, 0x118D9], [0x118BA, 0x118DA], [0x118BB, 0x118DB], [0x118BC, 0x118DC], [0x118BD, 0x118DD], [0x118BE, 0x118DE], [0x118BF, 0x118DF], [0x118C0, 0x118A0], [0x118C1, 0x118A1], [0x118C2, 0x118A2], [0x118C3, 0x118A3], [0x118C4, 0x118A4], [0x118C5, 0x118A5], [0x118C6, 0x118A6], [0x118C7, 0x118A7], [0x118C8, 0x118A8], [0x118C9, 0x118A9], [0x118CA, 0x118AA], [0x118CB, 0x118AB], [0x118CC, 0x118AC], [0x118CD, 0x118AD], [0x118CE, 0x118AE], [0x118CF, 0x118AF], [0x118D0, 0x118B0], [0x118D1, 0x118B1], [0x118D2, 0x118B2], [0x118D3, 0x118B3], [0x118D4, 0x118B4], [0x118D5, 0x118B5], [0x118D6, 0x118B6], [0x118D7, 0x118B7], [0x118D8, 0x118B8], [0x118D9, 0x118B9], [0x118DA, 0x118BA], [0x118DB, 0x118BB], [0x118DC, 0x118BC], [0x118DD, 0x118BD], [0x118DE, 0x118BE], [0x118DF, 0x118BF], [0x16E40, 0x16E60], [0x16E41, 0x16E61], [0x16E42, 0x16E62], [0x16E43, 0x16E63], [0x16E44, 0x16E64], [0x16E45, 0x16E65], [0x16E46, 0x16E66], [0x16E47, 0x16E67], [0x16E48, 0x16E68], [0x16E49, 0x16E69], [0x16E4A, 0x16E6A], [0x16E4B, 0x16E6B], [0x16E4C, 0x16E6C], [0x16E4D, 0x16E6D], [0x16E4E, 0x16E6E], [0x16E4F, 0x16E6F], [0x16E50, 0x16E70], [0x16E51, 0x16E71], [0x16E52, 0x16E72], [0x16E53, 0x16E73], [0x16E54, 0x16E74], [0x16E55, 0x16E75], [0x16E56, 0x16E76], [0x16E57, 0x16E77], [0x16E58, 0x16E78], [0x16E59, 0x16E79], [0x16E5A, 0x16E7A], [0x16E5B, 0x16E7B], [0x16E5C, 0x16E7C], [0x16E5D, 0x16E7D], [0x16E5E, 0x16E7E], [0x16E5F, 0x16E7F], [0x16E60, 0x16E40], [0x16E61, 0x16E41], [0x16E62, 0x16E42], [0x16E63, 0x16E43], [0x16E64, 0x16E44], [0x16E65, 0x16E45], [0x16E66, 0x16E46], [0x16E67, 0x16E47], [0x16E68, 0x16E48], [0x16E69, 0x16E49], [0x16E6A, 0x16E4A], [0x16E6B, 0x16E4B], [0x16E6C, 0x16E4C], [0x16E6D, 0x16E4D], [0x16E6E, 0x16E4E], [0x16E6F, 0x16E4F], [0x16E70, 0x16E50], [0x16E71, 0x16E51], [0x16E72, 0x16E52], [0x16E73, 0x16E53], [0x16E74, 0x16E54], [0x16E75, 0x16E55], [0x16E76, 0x16E56], [0x16E77, 0x16E57], [0x16E78, 0x16E58], [0x16E79, 0x16E59], [0x16E7A, 0x16E5A], [0x16E7B, 0x16E5B], [0x16E7C, 0x16E5C], [0x16E7D, 0x16E5D], [0x16E7E, 0x16E5E], [0x16E7F, 0x16E5F], [0x1E900, 0x1E922], [0x1E901, 0x1E923], [0x1E902, 0x1E924], [0x1E903, 0x1E925], [0x1E904, 0x1E926], [0x1E905, 0x1E927], [0x1E906, 0x1E928], [0x1E907, 0x1E929], [0x1E908, 0x1E92A], [0x1E909, 0x1E92B], [0x1E90A, 0x1E92C], [0x1E90B, 0x1E92D], [0x1E90C, 0x1E92E], [0x1E90D, 0x1E92F], [0x1E90E, 0x1E930], [0x1E90F, 0x1E931], [0x1E910, 0x1E932], [0x1E911, 0x1E933], [0x1E912, 0x1E934], [0x1E913, 0x1E935], [0x1E914, 0x1E936], [0x1E915, 0x1E937], [0x1E916, 0x1E938], [0x1E917, 0x1E939], [0x1E918, 0x1E93A], [0x1E919, 0x1E93B], [0x1E91A, 0x1E93C], [0x1E91B, 0x1E93D], [0x1E91C, 0x1E93E], [0x1E91D, 0x1E93F], [0x1E91E, 0x1E940], [0x1E91F, 0x1E941], [0x1E920, 0x1E942], [0x1E921, 0x1E943], [0x1E922, 0x1E900], [0x1E923, 0x1E901], [0x1E924, 0x1E902], [0x1E925, 0x1E903], [0x1E926, 0x1E904], [0x1E927, 0x1E905], [0x1E928, 0x1E906], [0x1E929, 0x1E907], [0x1E92A, 0x1E908], [0x1E92B, 0x1E909], [0x1E92C, 0x1E90A], [0x1E92D, 0x1E90B], [0x1E92E, 0x1E90C], [0x1E92F, 0x1E90D], [0x1E930, 0x1E90E], [0x1E931, 0x1E90F], [0x1E932, 0x1E910], [0x1E933, 0x1E911], [0x1E934, 0x1E912], [0x1E935, 0x1E913], [0x1E936, 0x1E914], [0x1E937, 0x1E915], [0x1E938, 0x1E916], [0x1E939, 0x1E917], [0x1E93A, 0x1E918], [0x1E93B, 0x1E919], [0x1E93C, 0x1E91A], [0x1E93D, 0x1E91B], [0x1E93E, 0x1E91C], [0x1E93F, 0x1E91D], [0x1E940, 0x1E91E], [0x1E941, 0x1E91F], [0x1E942, 0x1E920], [0x1E943, 0x1E921]]);

  var REGULAR = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0xFFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0xFFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0xFFFF)]]);
  var UNICODE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x10FFFF)]]);
  var UNICODE_IGNORE_CASE = new Map([['d', regenerate().addRange(0x30, 0x39)], ['D', regenerate().addRange(0x0, 0x2F).addRange(0x3A, 0x10FFFF)], ['s', regenerate(0x20, 0xA0, 0x1680, 0x202F, 0x205F, 0x3000, 0xFEFF).addRange(0x9, 0xD).addRange(0x2000, 0x200A).addRange(0x2028, 0x2029)], ['S', regenerate().addRange(0x0, 0x8).addRange(0xE, 0x1F).addRange(0x21, 0x9F).addRange(0xA1, 0x167F).addRange(0x1681, 0x1FFF).addRange(0x200B, 0x2027).addRange(0x202A, 0x202E).addRange(0x2030, 0x205E).addRange(0x2060, 0x2FFF).addRange(0x3001, 0xFEFE).addRange(0xFF00, 0x10FFFF)], ['w', regenerate(0x5F, 0x17F, 0x212A).addRange(0x30, 0x39).addRange(0x41, 0x5A).addRange(0x61, 0x7A)], ['W', regenerate(0x60).addRange(0x0, 0x2F).addRange(0x3A, 0x40).addRange(0x5B, 0x5E).addRange(0x7B, 0x17E).addRange(0x180, 0x2129).addRange(0x212B, 0x10FFFF)]]);
  var characterClassEscapeSets = {
    REGULAR: REGULAR,
    UNICODE: UNICODE,
    UNICODE_IGNORE_CASE: UNICODE_IGNORE_CASE
  };

  var generate = regjsgen.generate;
  var parse$2 = parser.parse;
  var UNICODE_SET = regenerate().addRange(0x0, 0x10FFFF);
  regenerate().addRange(0x0, 0xFFFF);
  var DOT_SET_UNICODE = UNICODE_SET.clone().remove(0x000A, 0x000D, 0x2028, 0x2029);

  var getCharacterClassEscapeSet = function getCharacterClassEscapeSet(character, unicode, ignoreCase) {
    if (unicode) {
      if (ignoreCase) {
        return characterClassEscapeSets.UNICODE_IGNORE_CASE.get(character);
      }

      return characterClassEscapeSets.UNICODE.get(character);
    }

    return characterClassEscapeSets.REGULAR.get(character);
  };

  var getUnicodeDotSet = function getUnicodeDotSet(dotAll) {
    return dotAll ? UNICODE_SET : DOT_SET_UNICODE;
  };

  var getUnicodePropertyValueSet = function getUnicodePropertyValueSet(property, value) {
    var path = value ? property + "/" + value : "Binary_Property/" + property;

    try {
      return commonjsRequire("regenerate-unicode-properties/" + path + ".js", "/$$rollup_base$$/node_modules/regexpu-core");
    } catch (exception) {
      throw new Error("Failed to recognize value `" + value + "` for property " + ("`" + property + "`."));
    }
  };

  var handleLoneUnicodePropertyNameOrValue = function handleLoneUnicodePropertyNameOrValue(value) {
    try {
      var _property = 'General_Category';
      var category = unicodeMatchPropertyValueEcmascript(_property, value);
      return getUnicodePropertyValueSet(_property, category);
    } catch (exception) {}

    var property = unicodeMatchPropertyEcmascript(value);
    return getUnicodePropertyValueSet(property);
  };

  var getUnicodePropertyEscapeSet = function getUnicodePropertyEscapeSet(value, isNegative) {
    var parts = value.split('=');
    var firstPart = parts[0];
    var set;

    if (parts.length == 1) {
      set = handleLoneUnicodePropertyNameOrValue(firstPart);
    } else {
      var property = unicodeMatchPropertyEcmascript(firstPart);

      var _value = unicodeMatchPropertyValueEcmascript(property, parts[1]);

      set = getUnicodePropertyValueSet(property, _value);
    }

    if (isNegative) {
      return UNICODE_SET.clone().remove(set);
    }

    return set.clone();
  };

  regenerate.prototype.iuAddRange = function (min, max) {
    var $this = this;

    do {
      var folded = caseFold(min);

      if (folded) {
        $this.add(folded);
      }
    } while (++min <= max);

    return $this;
  };

  var update = function update(item, pattern) {
    var tree = parse$2(pattern, config.useUnicodeFlag ? 'u' : '');

    switch (tree.type) {
      case 'characterClass':
      case 'group':
      case 'value':
        break;

      default:
        tree = wrap(tree, pattern);
    }

    Object.assign(item, tree);
  };

  var wrap = function wrap(tree, pattern) {
    return {
      'type': 'group',
      'behavior': 'ignore',
      'body': [tree],
      'raw': "(?:" + pattern + ")"
    };
  };

  var caseFold = function caseFold(codePoint) {
    return iuMappings.get(codePoint) || false;
  };

  var processCharacterClass = function processCharacterClass(characterClassItem, regenerateOptions) {
    var set = regenerate();

    for (var _iterator = _createForOfIteratorHelperLoose(characterClassItem.body), _step; !(_step = _iterator()).done;) {
      var item = _step.value;

      switch (item.type) {
        case 'value':
          set.add(item.codePoint);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            var folded = caseFold(item.codePoint);

            if (folded) {
              set.add(folded);
            }
          }

          break;

        case 'characterClassRange':
          var min = item.min.codePoint;
          var max = item.max.codePoint;
          set.addRange(min, max);

          if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
            set.iuAddRange(min, max);
          }

          break;

        case 'characterClassEscape':
          set.add(getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase));
          break;

        case 'unicodePropertyEscape':
          set.add(getUnicodePropertyEscapeSet(item.value, item.negative));
          break;

        default:
          throw new Error("Unknown term type: " + item.type);
      }
    }

    if (characterClassItem.negative) {
      update(characterClassItem, "(?!" + set.toString(regenerateOptions) + ")[\\s\\S]");
    } else {
      update(characterClassItem, set.toString(regenerateOptions));
    }

    return characterClassItem;
  };

  var updateNamedReference = function updateNamedReference(item, index) {
    delete item.name;
    item.matchIndex = index;
  };

  var assertNoUnmatchedReferences = function assertNoUnmatchedReferences(groups) {
    var unmatchedReferencesNames = Object.keys(groups.unmatchedReferences);

    if (unmatchedReferencesNames.length > 0) {
      throw new Error("Unknown group names: " + unmatchedReferencesNames);
    }
  };

  var processTerm = function processTerm(item, regenerateOptions, groups) {
    switch (item.type) {
      case 'dot':
        if (config.useDotAllFlag) {
          break;
        } else if (config.unicode) {
          update(item, getUnicodeDotSet(config.dotAll).toString(regenerateOptions));
        } else if (config.dotAll) {
          update(item, '[\\s\\S]');
        }

        break;

      case 'characterClass':
        item = processCharacterClass(item, regenerateOptions);
        break;

      case 'unicodePropertyEscape':
        if (config.unicodePropertyEscape) {
          update(item, getUnicodePropertyEscapeSet(item.value, item.negative).toString(regenerateOptions));
        }

        break;

      case 'characterClassEscape':
        update(item, getCharacterClassEscapeSet(item.value, config.unicode, config.ignoreCase).toString(regenerateOptions));
        break;

      case 'group':
        if (item.behavior == 'normal') {
          groups.lastIndex++;
        }

        if (item.name && config.namedGroup) {
          var name = item.name.value;

          if (groups.names[name]) {
            throw new Error("Multiple groups with the same name (" + name + ") are not allowed.");
          }

          var index = groups.lastIndex;
          delete item.name;
          groups.names[name] = index;

          if (groups.onNamedGroup) {
            groups.onNamedGroup.call(null, name, index);
          }

          if (groups.unmatchedReferences[name]) {
            groups.unmatchedReferences[name].forEach(function (reference) {
              updateNamedReference(reference, index);
            });
            delete groups.unmatchedReferences[name];
          }
        }

      case 'alternative':
      case 'disjunction':
      case 'quantifier':
        item.body = item.body.map(function (term) {
          return processTerm(term, regenerateOptions, groups);
        });
        break;

      case 'value':
        var codePoint = item.codePoint;
        var set = regenerate(codePoint);

        if (config.ignoreCase && config.unicode && !config.useUnicodeFlag) {
          var folded = caseFold(codePoint);

          if (folded) {
            set.add(folded);
          }
        }

        update(item, set.toString(regenerateOptions));
        break;

      case 'reference':
        if (item.name) {
          var _name = item.name.value;
          var _index = groups.names[_name];

          if (_index) {
            updateNamedReference(item, _index);
            break;
          }

          if (!groups.unmatchedReferences[_name]) {
            groups.unmatchedReferences[_name] = [];
          }

          groups.unmatchedReferences[_name].push(item);
        }

        break;

      case 'anchor':
      case 'empty':
      case 'group':
        break;

      default:
        throw new Error("Unknown term type: " + item.type);
    }

    return item;
  };

  var config = {
    'ignoreCase': false,
    'unicode': false,
    'dotAll': false,
    'useDotAllFlag': false,
    'useUnicodeFlag': false,
    'unicodePropertyEscape': false,
    'namedGroup': false
  };

  var rewritePattern = function rewritePattern(pattern, flags, options) {
    config.unicode = flags && flags.includes('u');
    var regjsparserFeatures = {
      'unicodePropertyEscape': config.unicode,
      'namedGroups': true,
      'lookbehind': options && options.lookbehind
    };
    config.ignoreCase = flags && flags.includes('i');
    var supportDotAllFlag = options && options.dotAllFlag;
    config.dotAll = supportDotAllFlag && flags && flags.includes('s');
    config.namedGroup = options && options.namedGroup;
    config.useDotAllFlag = options && options.useDotAllFlag;
    config.useUnicodeFlag = options && options.useUnicodeFlag;
    config.unicodePropertyEscape = options && options.unicodePropertyEscape;

    if (supportDotAllFlag && config.useDotAllFlag) {
      throw new Error('`useDotAllFlag` and `dotAllFlag` cannot both be true!');
    }

    var regenerateOptions = {
      'hasUnicodeFlag': config.useUnicodeFlag,
      'bmpOnly': !config.unicode
    };
    var groups = {
      'onNamedGroup': options && options.onNamedGroup,
      'lastIndex': 0,
      'names': Object.create(null),
      'unmatchedReferences': Object.create(null)
    };
    var tree = parse$2(pattern, flags, regjsparserFeatures);
    processTerm(tree, regenerateOptions, groups);
    assertNoUnmatchedReferences(groups);
    return generate(tree);
  };

  var rewritePattern_1 = rewritePattern;

  var FEATURES = Object.freeze({
    unicodeFlag: 1 << 0,
    dotAllFlag: 1 << 1,
    unicodePropertyEscape: 1 << 2,
    namedCaptureGroups: 1 << 3
  });
  var featuresKey = "@babel/plugin-regexp-features/featuresKey";
  var runtimeKey = "@babel/plugin-regexp-features/runtimeKey";
  function enableFeature(features, feature) {
    return features | feature;
  }
  function hasFeature(features, feature) {
    return !!(features & feature);
  }

  function generateRegexpuOptions(node, features) {
    var useUnicodeFlag = false,
        dotAllFlag = false,
        unicodePropertyEscape = false,
        namedGroup = false;
    var flags = node.flags,
        pattern = node.pattern;
    var flagsIncludesU = flags.includes("u");

    if (flagsIncludesU) {
      if (!hasFeature(features, FEATURES.unicodeFlag)) {
        useUnicodeFlag = true;
      }

      if (hasFeature(features, FEATURES.unicodePropertyEscape) && /\\[pP]{/.test(pattern)) {
        unicodePropertyEscape = true;
      }
    }

    if (hasFeature(features, FEATURES.dotAllFlag) && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    if (hasFeature(features, FEATURES.namedCaptureGroups) && /\(\?<(?![=!])/.test(pattern)) {
      namedGroup = true;
    }

    if (!namedGroup && !unicodePropertyEscape && !dotAllFlag && (!flagsIncludesU || useUnicodeFlag)) {
      return null;
    }

    if (flagsIncludesU && flags.indexOf("s") >= 0) {
      dotAllFlag = true;
    }

    return {
      useUnicodeFlag: useUnicodeFlag,
      onNamedGroup: function onNamedGroup() {},
      namedGroup: namedGroup,
      unicodePropertyEscape: unicodePropertyEscape,
      dotAllFlag: dotAllFlag,
      lookbehind: true
    };
  }

  function pullFlag(node, flag) {
    node.flags = node.flags.replace(flag, "");
  }

  var version$1 = "7.14.5".split(".").reduce(function (v, x) {
    return v * 1e5 + +x;
  }, 0);
  var versionKey = "@babel/plugin-regexp-features/version";
  function createRegExpFeaturePlugin(_ref) {
    var name = _ref.name,
        feature = _ref.feature,
        _ref$options = _ref.options,
        options = _ref$options === void 0 ? {} : _ref$options;
    return {
      name: name,
      pre: function pre() {
        var _file$get;

        var file = this.file;
        var features = (_file$get = file.get(featuresKey)) != null ? _file$get : 0;
        var newFeatures = enableFeature(features, FEATURES[feature]);
        var useUnicodeFlag = options.useUnicodeFlag,
            _options$runtime = options.runtime,
            runtime = _options$runtime === void 0 ? true : _options$runtime;

        if (useUnicodeFlag === false) {
          newFeatures = enableFeature(newFeatures, FEATURES.unicodeFlag);
        }

        if (newFeatures !== features) {
          file.set(featuresKey, newFeatures);
        }

        if (!runtime) {
          file.set(runtimeKey, false);
        }

        if (!file.has(versionKey) || file.get(versionKey) < version$1) {
          file.set(versionKey, version$1);
        }
      },
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var _file$get2;

          var node = path.node;
          var file = this.file;
          var features = file.get(featuresKey);
          var runtime = (_file$get2 = file.get(runtimeKey)) != null ? _file$get2 : true;
          var regexpuOptions = generateRegexpuOptions(node, features);

          if (regexpuOptions === null) {
            return;
          }

          var namedCaptureGroups = {};

          if (regexpuOptions.namedGroup) {
            regexpuOptions.onNamedGroup = function (name, index) {
              namedCaptureGroups[name] = index;
            };
          }

          node.pattern = rewritePattern_1(node.pattern, node.flags, regexpuOptions);

          if (regexpuOptions.namedGroup && Object.keys(namedCaptureGroups).length > 0 && runtime && !isRegExpTest(path)) {
            var call = callExpression(this.addHelper("wrapRegExp"), [node, valueToNode(namedCaptureGroups)]);
            annotateAsPure(call);
            path.replaceWith(call);
          }

          if (hasFeature(features, FEATURES.unicodeFlag)) {
            pullFlag(node, "u");
          }

          if (hasFeature(features, FEATURES.dotAllFlag)) {
            pullFlag(node, "s");
          }
        }
      }
    };
  }

  function isRegExpTest(path) {
    return path.parentPath.isMemberExpression({
      object: path.node,
      computed: false
    }) && path.parentPath.get("property").isIdentifier({
      name: "test"
    });
  }

  var _proposalUnicodePropertyRegex = declare(function (api, options) {
    api.assertVersion(7);
    var _options$useUnicodeFl = options.useUnicodeFlag,
        useUnicodeFlag = _options$useUnicodeFl === void 0 ? true : _options$useUnicodeFl;

    if (typeof useUnicodeFlag !== "boolean") {
      throw new Error(".useUnicodeFlag must be a boolean, or undefined");
    }

    return createRegExpFeaturePlugin({
      name: "proposal-unicode-property-regex",
      feature: "unicodePropertyEscape",
      options: {
        useUnicodeFlag: useUnicodeFlag
      }
    });
  });

  var _transformAsyncToGenerator = declare(function (api, options) {
    api.assertVersion(7);
    var method = options.method,
        module = options.module;
    var noNewArrows = api.assumption("noNewArrows");

    if (method && module) {
      return {
        name: "transform-async-to-generator",
        visitor: {
          Function: function Function(path, state) {
            if (!path.node.async || path.node.generator) return;
            var wrapAsync = state.methodWrapper;

            if (wrapAsync) {
              wrapAsync = cloneNode(wrapAsync);
            } else {
              wrapAsync = state.methodWrapper = addNamed(path, method, module);
            }

            remapAsyncToGenerator(path, {
              wrapAsync: wrapAsync
            }, noNewArrows);
          }
        }
      };
    }

    return {
      name: "transform-async-to-generator",
      visitor: {
        Function: function Function(path, state) {
          if (!path.node.async || path.node.generator) return;
          remapAsyncToGenerator(path, {
            wrapAsync: state.addHelper("asyncToGenerator")
          }, noNewArrows);
        }
      }
    };
  });

  var _transformArrowFunctions = declare(function (api, options) {
    var _api$assumption;

    api.assertVersion(7);
    var noNewArrows = (_api$assumption = api.assumption("noNewArrows")) != null ? _api$assumption : !options.spec;
    return {
      name: "transform-arrow-functions",
      visitor: {
        ArrowFunctionExpression: function ArrowFunctionExpression(path) {
          if (!path.isArrowFunctionExpression()) return;
          path.arrowFunctionToExpression({
            allowInsertArrow: false,
            noNewArrows: noNewArrows,
            specCompliant: !noNewArrows
          });
        }
      }
    };
  });

  var _transformBlockScopedFunctions = declare(function (api) {
    api.assertVersion(7);

    function statementList(key, path) {
      var paths = path.get(key);

      for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
        var _path = _step.value;
        var func = _path.node;
        if (!_path.isFunctionDeclaration()) continue;
        var declar = variableDeclaration("let", [variableDeclarator(func.id, toExpression(func))]);
        declar._blockHoist = 2;
        func.id = null;

        _path.replaceWith(declar);
      }
    }

    return {
      name: "transform-block-scoped-functions",
      visitor: {
        BlockStatement: function BlockStatement(path) {
          var node = path.node,
              parent = path.parent;

          if (isFunction$1(parent, {
            body: node
          }) || isExportDeclaration(parent)) {
            return;
          }

          statementList("body", path);
        },
        SwitchCase: function SwitchCase(path) {
          statementList("consequent", path);
        }
      }
    };
  });

  var _templateObject$c;

  function getTDZStatus(refPath, bindingPath) {
    var executionStatus = bindingPath._guessExecutionStatusRelativeTo(refPath);

    if (executionStatus === "before") {
      return "outside";
    } else if (executionStatus === "after") {
      return "inside";
    } else {
      return "maybe";
    }
  }

  function buildTDZAssert(node, state) {
    return callExpression(state.addHelper("temporalRef"), [node, stringLiteral(node.name)]);
  }

  function isReference$1(node, scope, state) {
    var declared = state.letReferences.get(node.name);
    if (!declared) return false;
    return scope.getBindingIdentifier(node.name) === declared;
  }

  var visitedMaybeTDZNodes = new WeakSet();
  var visitor = {
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      if (!state.tdzEnabled) return;
      var node = path.node,
          parent = path.parent,
          scope = path.scope;
      if (path.parentPath.isFor({
        left: node
      })) return;
      if (!isReference$1(node, scope, state)) return;
      var bindingPath = scope.getBinding(node.name).path;
      if (bindingPath.isFunctionDeclaration()) return;
      var status = getTDZStatus(path, bindingPath);
      if (status === "outside") return;

      if (status === "maybe") {
        if (visitedMaybeTDZNodes.has(node)) {
          return;
        }

        visitedMaybeTDZNodes.add(node);
        var assert = buildTDZAssert(node, state);
        bindingPath.parent._tdzThis = true;

        if (path.parentPath.isUpdateExpression()) {
          if (parent._ignoreBlockScopingTDZ) return;
          path.parentPath.replaceWith(sequenceExpression([assert, parent]));
        } else {
          path.replaceWith(assert);
        }
      } else if (status === "inside") {
        path.replaceWith(template$2.ast(_templateObject$c || (_templateObject$c = _taggedTemplateLiteralLoose(["", "(\"", "\")"])), state.addHelper("tdz"), node.name));
      }
    },
    AssignmentExpression: {
      exit: function exit(path, state) {
        if (!state.tdzEnabled) return;
        var node = path.node;
        if (node._ignoreBlockScopingTDZ) return;
        var nodes = [];
        var ids = path.getBindingIdentifiers();

        for (var _i = 0, _Object$keys = Object.keys(ids); _i < _Object$keys.length; _i++) {
          var name = _Object$keys[_i];
          var id = ids[name];

          if (isReference$1(id, path.scope, state)) {
            nodes.push(id);
          }
        }

        if (nodes.length) {
          node._ignoreBlockScopingTDZ = true;
          nodes.push(node);
          path.replaceWithMultiple(nodes.map(function (n) {
            return expressionStatement(n);
          }));
        }
      }
    }
  };

  var DONE = new WeakSet();
  var _transformBlockScoping = declare(function (api, opts) {
    api.assertVersion(7);
    var _opts$throwIfClosureR = opts.throwIfClosureRequired,
        throwIfClosureRequired = _opts$throwIfClosureR === void 0 ? false : _opts$throwIfClosureR,
        _opts$tdz = opts.tdz,
        tdzEnabled = _opts$tdz === void 0 ? false : _opts$tdz;

    if (typeof throwIfClosureRequired !== "boolean") {
      throw new Error(".throwIfClosureRequired must be a boolean, or undefined");
    }

    if (typeof tdzEnabled !== "boolean") {
      throw new Error(".tdz must be a boolean, or undefined");
    }

    return {
      name: "transform-block-scoping",
      visitor: {
        VariableDeclaration: function VariableDeclaration(path) {
          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          if (!isBlockScoped(node)) return;
          convertBlockScopedToVar(path, null, parent, scope, true);

          if (node._tdzThis) {
            var nodes = [node];

            for (var i = 0; i < node.declarations.length; i++) {
              var decl = node.declarations[i];
              var assign = assignmentExpression("=", cloneNode(decl.id), decl.init || scope.buildUndefinedNode());
              assign._ignoreBlockScopingTDZ = true;
              nodes.push(expressionStatement(assign));
              decl.init = this.addHelper("temporalUndefined");
            }

            node._blockHoist = 2;

            if (path.isCompletionRecord()) {
              nodes.push(expressionStatement(scope.buildUndefinedNode()));
            }

            path.replaceWithMultiple(nodes);
          }
        },
        Loop: function Loop(path, state) {
          var parent = path.parent,
              scope = path.scope;
          path.ensureBlock();
          var blockScoping = new BlockScoping(path, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          var replace = blockScoping.run();
          if (replace) path.replaceWith(replace);
        },
        CatchClause: function CatchClause(path, state) {
          var parent = path.parent,
              scope = path.scope;
          var blockScoping = new BlockScoping(null, path.get("body"), parent, scope, throwIfClosureRequired, tdzEnabled, state);
          blockScoping.run();
        },
        "BlockStatement|SwitchStatement|Program": function BlockStatementSwitchStatementProgram(path, state) {
          if (!ignoreBlock(path)) {
            var blockScoping = new BlockScoping(null, path, path.parent, path.scope, throwIfClosureRequired, tdzEnabled, state);
            blockScoping.run();
          }
        }
      }
    };
  });

  function ignoreBlock(path) {
    return isLoop$1(path.parent) || isCatchClause(path.parent);
  }

  var buildRetCheck = template$2("\n  if (typeof RETURN === \"object\") return RETURN.v;\n");

  function isBlockScoped(node) {
    if (!isVariableDeclaration(node)) return false;
    if (node[BLOCK_SCOPED_SYMBOL]) return true;
    if (node.kind !== "let" && node.kind !== "const") return false;
    return true;
  }

  function isInLoop(path) {
    var loopOrFunctionParent = path.find(function (path) {
      return path.isLoop() || path.isFunction();
    });
    return loopOrFunctionParent == null ? void 0 : loopOrFunctionParent.isLoop();
  }

  function convertBlockScopedToVar(path, node, parent, scope, moveBindingsToParent) {
    if (moveBindingsToParent === void 0) {
      moveBindingsToParent = false;
    }

    if (!node) {
      node = path.node;
    }

    if (isInLoop(path) && !isFor(parent)) {
      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        declar.init = declar.init || scope.buildUndefinedNode();
      }
    }

    node[BLOCK_SCOPED_SYMBOL] = true;
    node.kind = "var";

    if (moveBindingsToParent) {
      var parentScope = scope.getFunctionParent() || scope.getProgramParent();

      for (var _i = 0, _Object$keys = Object.keys(path.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
        var name = _Object$keys[_i];
        var binding = scope.getOwnBinding(name);
        if (binding) binding.kind = "var";
        scope.moveBindingTo(name, parentScope);
      }
    }
  }

  function isVar(node) {
    return isVariableDeclaration(node, {
      kind: "var"
    }) && !isBlockScoped(node);
  }

  var letReferenceBlockVisitor = traverse.visitors.merge([{
    Loop: {
      enter: function enter(path, state) {
        state.loopDepth++;
      },
      exit: function exit(path, state) {
        state.loopDepth--;
      }
    },
    FunctionParent: function FunctionParent(path, state) {
      if (state.loopDepth > 0) {
        path.traverse(letReferenceFunctionVisitor, state);
      } else {
        path.traverse(visitor, state);
      }

      return path.skip();
    }
  }, visitor]);
  var letReferenceFunctionVisitor = traverse.visitors.merge([{
    ReferencedIdentifier: function ReferencedIdentifier(path, state) {
      var ref = state.letReferences.get(path.node.name);
      if (!ref) return;
      var localBinding = path.scope.getBindingIdentifier(path.node.name);
      if (localBinding && localBinding !== ref) return;
      state.closurify = true;
    }
  }, visitor]);
  var hoistVarDeclarationsVisitor = {
    enter: function enter(path, self) {
      var node = path.node;
          path.parent;

      if (path.isForStatement()) {
        if (isVar(node.init)) {
          var nodes = self.pushDeclar(node.init);

          if (nodes.length === 1) {
            node.init = nodes[0];
          } else {
            node.init = sequenceExpression(nodes);
          }
        }
      } else if (path.isFor()) {
        if (isVar(node.left)) {
          self.pushDeclar(node.left);
          node.left = node.left.declarations[0].id;
        }
      } else if (isVar(node)) {
        path.replaceWithMultiple(self.pushDeclar(node).map(function (expr) {
          return expressionStatement(expr);
        }));
      } else if (path.isFunction()) {
        return path.skip();
      }
    }
  };
  var loopLabelVisitor = {
    LabeledStatement: function LabeledStatement(_ref, state) {
      var node = _ref.node;
      state.innerLabels.push(node.label.name);
    }
  };
  var continuationVisitor = {
    enter: function enter(path, state) {
      if (path.isAssignmentExpression() || path.isUpdateExpression()) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(path.getBindingIdentifiers()); _i2 < _Object$keys2.length; _i2++) {
          var name = _Object$keys2[_i2];

          if (state.outsideReferences.get(name) !== path.scope.getBindingIdentifier(name)) {
            continue;
          }

          state.reassignments[name] = true;
        }
      } else if (path.isReturnStatement()) {
        state.returnStatements.push(path);
      }
    }
  };

  function loopNodeTo(node) {
    if (isBreakStatement(node)) {
      return "break";
    } else if (isContinueStatement(node)) {
      return "continue";
    }
  }

  var loopVisitor = {
    Loop: function Loop(path, state) {
      var oldIgnoreLabeless = state.ignoreLabeless;
      state.ignoreLabeless = true;
      path.traverse(loopVisitor, state);
      state.ignoreLabeless = oldIgnoreLabeless;
      path.skip();
    },
    Function: function Function(path) {
      path.skip();
    },
    SwitchCase: function SwitchCase(path, state) {
      var oldInSwitchCase = state.inSwitchCase;
      state.inSwitchCase = true;
      path.traverse(loopVisitor, state);
      state.inSwitchCase = oldInSwitchCase;
      path.skip();
    },
    "BreakStatement|ContinueStatement|ReturnStatement": function BreakStatementContinueStatementReturnStatement(path, state) {
      var node = path.node,
          scope = path.scope;
      if (node[this.LOOP_IGNORE]) return;
      var replace;
      var loopText = loopNodeTo(node);

      if (loopText) {
        if (node.label) {
          if (state.innerLabels.indexOf(node.label.name) >= 0) {
            return;
          }

          loopText = loopText + "|" + node.label.name;
        } else {
          if (state.ignoreLabeless) return;
          if (isBreakStatement(node) && state.inSwitchCase) return;
        }

        state.hasBreakContinue = true;
        state.map[loopText] = node;
        replace = stringLiteral(loopText);
      }

      if (path.isReturnStatement()) {
        state.hasReturn = true;
        replace = objectExpression([objectProperty(identifier("v"), node.argument || scope.buildUndefinedNode())]);
      }

      if (replace) {
        replace = returnStatement(replace);
        replace[this.LOOP_IGNORE] = true;
        path.skip();
        path.replaceWith(inherits(replace, node));
      }
    }
  };

  function isStrict(path) {
    return !!path.find(function (_ref2) {
      var node = _ref2.node;

      if (isProgram(node)) {
        if (node.sourceType === "module") return true;
      } else if (!isBlockStatement(node)) return false;

      return node.directives.some(function (directive) {
        return directive.value.value === "use strict";
      });
    });
  }

  var BlockScoping = function () {
    function BlockScoping(loopPath, blockPath, parent, scope, throwIfClosureRequired, tdzEnabled, state) {
      this.parent = parent;
      this.scope = scope;
      this.state = state;
      this.throwIfClosureRequired = throwIfClosureRequired;
      this.tdzEnabled = tdzEnabled;
      this.blockPath = blockPath;
      this.block = blockPath.node;
      this.outsideLetReferences = new Map();
      this.hasLetReferences = false;
      this.letReferences = new Map();
      this.body = [];

      if (loopPath) {
        this.loopParent = loopPath.parent;
        this.loopLabel = isLabeledStatement(this.loopParent) && this.loopParent.label;
        this.loopPath = loopPath;
        this.loop = loopPath.node;
      }
    }

    var _proto = BlockScoping.prototype;

    _proto.run = function run() {
      var block = this.block;
      if (DONE.has(block)) return;
      DONE.add(block);
      var needsClosure = this.getLetReferences();
      this.checkConstants();

      if (isFunction$1(this.parent) || isProgram(this.block)) {
        this.updateScopeInfo();
        return;
      }

      if (!this.hasLetReferences) return;

      if (needsClosure) {
        this.wrapClosure();
      } else {
        this.remap();
      }

      this.updateScopeInfo(needsClosure);

      if (this.loopLabel && !isLabeledStatement(this.loopParent)) {
        return labeledStatement(this.loopLabel, this.loop);
      }
    };

    _proto.checkConstants = function checkConstants() {
      var scope = this.scope;
      var state = this.state;

      for (var _i3 = 0, _Object$keys3 = Object.keys(scope.bindings); _i3 < _Object$keys3.length; _i3++) {
        var name = _Object$keys3[_i3];
        var binding = scope.bindings[name];
        if (binding.kind !== "const") continue;

        for (var _i4 = 0, _arr = binding.constantViolations; _i4 < _arr.length; _i4++) {
          var violation = _arr[_i4];
          var readOnlyError = state.addHelper("readOnlyError");
          var throwNode = callExpression(readOnlyError, [stringLiteral(name)]);

          if (violation.isAssignmentExpression()) {
            var operator = violation.node.operator;

            if (operator === "=") {
              violation.replaceWith(sequenceExpression([violation.get("right").node, throwNode]));
            } else if (["&&=", "||=", "??="].includes(operator)) {
              violation.replaceWith(logicalExpression(operator.slice(0, -1), violation.get("left").node, sequenceExpression([violation.get("right").node, throwNode])));
            } else {
              violation.replaceWith(sequenceExpression([binaryExpression(operator.slice(0, -1), violation.get("left").node, violation.get("right").node), throwNode]));
            }
          } else if (violation.isUpdateExpression()) {
            violation.replaceWith(sequenceExpression([unaryExpression("+", violation.get("argument").node), throwNode]));
          } else if (violation.isForXStatement()) {
            violation.ensureBlock();
            violation.get("left").replaceWith(variableDeclaration("var", [variableDeclarator(violation.scope.generateUidIdentifier(name))]));
            violation.node.body.body.unshift(expressionStatement(throwNode));
          }
        }
      }
    };

    _proto.updateScopeInfo = function updateScopeInfo(wrappedInClosure) {
      var blockScope = this.blockPath.scope;
      var parentScope = blockScope.getFunctionParent() || blockScope.getProgramParent();
      var letRefs = this.letReferences;

      for (var _iterator = _createForOfIteratorHelperLoose(letRefs.keys()), _step; !(_step = _iterator()).done;) {
        var key = _step.value;
        var ref = letRefs.get(key);
        var binding = blockScope.getBinding(ref.name);
        if (!binding) continue;

        if (binding.kind === "let" || binding.kind === "const") {
          binding.kind = "var";

          if (wrappedInClosure) {
            if (blockScope.hasOwnBinding(ref.name)) {
              blockScope.removeBinding(ref.name);
            }
          } else {
            blockScope.moveBindingTo(ref.name, parentScope);
          }
        }
      }
    };

    _proto.remap = function remap() {
      var letRefs = this.letReferences;
      var outsideLetRefs = this.outsideLetReferences;
      var scope = this.scope;
      var blockPathScope = this.blockPath.scope;

      for (var _iterator2 = _createForOfIteratorHelperLoose(letRefs.keys()), _step2; !(_step2 = _iterator2()).done;) {
        var key = _step2.value;
        var ref = letRefs.get(key);

        if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {
          var binding = scope.getOwnBinding(key);

          if (binding) {
            var parentBinding = scope.parent.getOwnBinding(key);

            if (binding.kind === "hoisted" && !binding.path.node.async && !binding.path.node.generator && (!parentBinding || isVar(parentBinding.path.parent)) && !isStrict(binding.path.parentPath)) {
              continue;
            }

            scope.rename(ref.name);
          }

          if (blockPathScope.hasOwnBinding(key)) {
            blockPathScope.rename(ref.name);
          }
        }
      }

      for (var _iterator3 = _createForOfIteratorHelperLoose(outsideLetRefs.keys()), _step3; !(_step3 = _iterator3()).done;) {
        var _key = _step3.value;

        var _ref3 = letRefs.get(_key);

        if (isInLoop(this.blockPath) && blockPathScope.hasOwnBinding(_key)) {
          blockPathScope.rename(_ref3.name);
        }
      }
    };

    _proto.wrapClosure = function wrapClosure() {
      if (this.throwIfClosureRequired) {
        throw this.blockPath.buildCodeFrameError("Compiling let/const in this block would add a closure " + "(throwIfClosureRequired).");
      }

      var block = this.block;
      var outsideRefs = this.outsideLetReferences;

      if (this.loop) {
        for (var _i5 = 0, _Array$from = Array.from(outsideRefs.keys()); _i5 < _Array$from.length; _i5++) {
          var name = _Array$from[_i5];
          var id = outsideRefs.get(name);

          if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {
            outsideRefs["delete"](id.name);
            this.letReferences["delete"](id.name);
            this.scope.rename(id.name);
            this.letReferences.set(id.name, id);
            outsideRefs.set(id.name, id);
          }
        }
      }

      this.has = this.checkLoop();
      this.hoistVarDeclarations();
      var args = Array.from(outsideRefs.values(), function (node) {
        return cloneNode(node);
      });
      var params = args.map(function (id) {
        return cloneNode(id);
      });
      var isSwitch = this.blockPath.isSwitchStatement();
      var fn = functionExpression(null, params, blockStatement(isSwitch ? [block] : block.body));
      this.addContinuations(fn);
      var call = callExpression(nullLiteral(), args);
      var basePath = ".callee";
      var hasYield = traverse.hasType(fn.body, "YieldExpression", FUNCTION_TYPES);

      if (hasYield) {
        fn.generator = true;
        call = yieldExpression(call, true);
        basePath = ".argument" + basePath;
      }

      var hasAsync = traverse.hasType(fn.body, "AwaitExpression", FUNCTION_TYPES);

      if (hasAsync) {
        fn.async = true;
        call = awaitExpression(call);
        basePath = ".argument" + basePath;
      }

      var placeholderPath;
      var index;

      if (this.has.hasReturn || this.has.hasBreakContinue) {
        var ret = this.scope.generateUid("ret");
        this.body.push(variableDeclaration("var", [variableDeclarator(identifier(ret), call)]));
        placeholderPath = "declarations.0.init" + basePath;
        index = this.body.length - 1;
        this.buildHas(ret);
      } else {
        this.body.push(expressionStatement(call));
        placeholderPath = "expression" + basePath;
        index = this.body.length - 1;
      }

      var callPath;

      if (isSwitch) {
        var _this$blockPath = this.blockPath,
            parentPath = _this$blockPath.parentPath,
            listKey = _this$blockPath.listKey,
            key = _this$blockPath.key;
        this.blockPath.replaceWithMultiple(this.body);
        callPath = parentPath.get(listKey)[key + index];
      } else {
        block.body = this.body;
        callPath = this.blockPath.get("body")[index];
      }

      var placeholder = callPath.get(placeholderPath);
      var fnPath;

      if (this.loop) {
        var loopId = this.scope.generateUid("loop");
        var p = this.loopPath.insertBefore(variableDeclaration("var", [variableDeclarator(identifier(loopId), fn)]));
        placeholder.replaceWith(identifier(loopId));
        fnPath = p[0].get("declarations.0.init");
      } else {
        placeholder.replaceWith(fn);
        fnPath = placeholder;
      }

      fnPath.unwrapFunctionEnvironment();
    };

    _proto.addContinuations = function addContinuations(fn) {
      var _this = this;

      var state = {
        reassignments: {},
        returnStatements: [],
        outsideReferences: this.outsideLetReferences
      };
      this.scope.traverse(fn, continuationVisitor, state);

      var _loop = function _loop(i) {
        var param = fn.params[i];
        if (!state.reassignments[param.name]) return "continue";
        var paramName = param.name;

        var newParamName = _this.scope.generateUid(param.name);

        fn.params[i] = identifier(newParamName);

        _this.scope.rename(paramName, newParamName, fn);

        state.returnStatements.forEach(function (returnStatement) {
          returnStatement.insertBefore(expressionStatement(assignmentExpression("=", identifier(paramName), identifier(newParamName))));
        });
        fn.body.body.push(expressionStatement(assignmentExpression("=", identifier(paramName), identifier(newParamName))));
      };

      for (var i = 0; i < fn.params.length; i++) {
        var _ret = _loop(i);

        if (_ret === "continue") continue;
      }
    };

    _proto.getLetReferences = function getLetReferences() {
      var _this2 = this;

      var block = this.block;
      var declarators = [];

      if (this.loop) {
        var init = this.loop.left || this.loop.init;

        if (isBlockScoped(init)) {
          declarators.push(init);
          var names = getBindingIdentifiers$1(init);

          for (var _i6 = 0, _Object$keys4 = Object.keys(names); _i6 < _Object$keys4.length; _i6++) {
            var name = _Object$keys4[_i6];
            this.outsideLetReferences.set(name, names[name]);
          }
        }
      }

      var addDeclarationsFromChild = function addDeclarationsFromChild(path, node) {
        node = node || path.node;

        if (isClassDeclaration(node) || isFunctionDeclaration(node) || isBlockScoped(node)) {
          if (isBlockScoped(node)) {
            convertBlockScopedToVar(path, node, block, _this2.scope);
          }

          if (node.declarations) {
            for (var i = 0; i < node.declarations.length; i++) {
              declarators.push(node.declarations[i]);
            }
          } else {
            declarators.push(node);
          }
        }

        if (isLabeledStatement(node)) {
          addDeclarationsFromChild(path.get("body"), node.body);
        }
      };

      if (block.body) {
        var declarPaths = this.blockPath.get("body");

        for (var i = 0; i < block.body.length; i++) {
          addDeclarationsFromChild(declarPaths[i]);
        }
      }

      if (block.cases) {
        var _declarPaths = this.blockPath.get("cases");

        for (var _i7 = 0; _i7 < block.cases.length; _i7++) {
          var consequents = block.cases[_i7].consequent;

          for (var j = 0; j < consequents.length; j++) {
            var declar = consequents[j];
            addDeclarationsFromChild(_declarPaths[_i7], declar);
          }
        }
      }

      for (var _i8 = 0; _i8 < declarators.length; _i8++) {
        var _declar = declarators[_i8];
        var keys = getBindingIdentifiers$1(_declar, false, true);

        for (var _i9 = 0, _Object$keys5 = Object.keys(keys); _i9 < _Object$keys5.length; _i9++) {
          var key = _Object$keys5[_i9];
          this.letReferences.set(key, keys[key]);
        }

        this.hasLetReferences = true;
      }

      if (!this.hasLetReferences) return;
      var state = {
        letReferences: this.letReferences,
        closurify: false,
        loopDepth: 0,
        tdzEnabled: this.tdzEnabled,
        addHelper: function addHelper(name) {
          return _this2.state.addHelper(name);
        }
      };

      if (isInLoop(this.blockPath)) {
        state.loopDepth++;
      }

      this.blockPath.traverse(letReferenceBlockVisitor, state);
      return state.closurify;
    };

    _proto.checkLoop = function checkLoop() {
      var state = {
        hasBreakContinue: false,
        ignoreLabeless: false,
        inSwitchCase: false,
        innerLabels: [],
        hasReturn: false,
        isLoop: !!this.loop,
        map: {},
        LOOP_IGNORE: Symbol()
      };
      this.blockPath.traverse(loopLabelVisitor, state);
      this.blockPath.traverse(loopVisitor, state);
      return state;
    };

    _proto.hoistVarDeclarations = function hoistVarDeclarations() {
      this.blockPath.traverse(hoistVarDeclarationsVisitor, this);
    };

    _proto.pushDeclar = function pushDeclar(node) {
      var declars = [];
      var names = getBindingIdentifiers$1(node);

      for (var _i10 = 0, _Object$keys6 = Object.keys(names); _i10 < _Object$keys6.length; _i10++) {
        var name = _Object$keys6[_i10];
        declars.push(variableDeclarator(names[name]));
      }

      this.body.push(variableDeclaration(node.kind, declars));
      var replace = [];

      for (var i = 0; i < node.declarations.length; i++) {
        var declar = node.declarations[i];
        if (!declar.init) continue;
        var expr = assignmentExpression("=", cloneNode(declar.id), cloneNode(declar.init));
        replace.push(inherits(expr, declar));
      }

      return replace;
    };

    _proto.buildHas = function buildHas(ret) {
      var body = this.body;
      var has = this.has;

      if (has.hasBreakContinue) {
        for (var _i11 = 0, _Object$keys7 = Object.keys(has.map); _i11 < _Object$keys7.length; _i11++) {
          var key = _Object$keys7[_i11];
          body.push(ifStatement(binaryExpression("===", identifier(ret), stringLiteral(key)), has.map[key]));
        }
      }

      if (has.hasReturn) {
        body.push(buildRetCheck({
          RETURN: identifier(ret)
        }));
      }
    };

    return BlockScoping;
  }();

  var builtin = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	BigInt: false,
  	BigInt64Array: false,
  	BigUint64Array: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	globalThis: false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es5 = {
  	"Array": false,
  	"Boolean": false,
  	constructor: false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	propertyIsEnumerable: false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"RegExp": false,
  	"String": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false
  };
  var es2015 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var es2017 = {
  	"Array": false,
  	"ArrayBuffer": false,
  	Atomics: false,
  	"Boolean": false,
  	constructor: false,
  	"DataView": false,
  	"Date": false,
  	"decodeURI": false,
  	"decodeURIComponent": false,
  	"encodeURI": false,
  	"encodeURIComponent": false,
  	"Error": false,
  	"escape": false,
  	"eval": false,
  	"EvalError": false,
  	"Float32Array": false,
  	"Float64Array": false,
  	"Function": false,
  	hasOwnProperty: false,
  	"Infinity": false,
  	"Int16Array": false,
  	"Int32Array": false,
  	"Int8Array": false,
  	"isFinite": false,
  	"isNaN": false,
  	isPrototypeOf: false,
  	"JSON": false,
  	"Map": false,
  	"Math": false,
  	"NaN": false,
  	"Number": false,
  	"Object": false,
  	"parseFloat": false,
  	"parseInt": false,
  	"Promise": false,
  	propertyIsEnumerable: false,
  	"Proxy": false,
  	"RangeError": false,
  	"ReferenceError": false,
  	"Reflect": false,
  	"RegExp": false,
  	"Set": false,
  	SharedArrayBuffer: false,
  	"String": false,
  	"Symbol": false,
  	"SyntaxError": false,
  	toLocaleString: false,
  	toString: false,
  	"TypeError": false,
  	"Uint16Array": false,
  	"Uint32Array": false,
  	"Uint8Array": false,
  	"Uint8ClampedArray": false,
  	"undefined": false,
  	"unescape": false,
  	"URIError": false,
  	valueOf: false,
  	"WeakMap": false,
  	"WeakSet": false
  };
  var browser = {
  	AbortController: false,
  	AbortSignal: false,
  	addEventListener: false,
  	alert: false,
  	AnalyserNode: false,
  	Animation: false,
  	AnimationEffectReadOnly: false,
  	AnimationEffectTiming: false,
  	AnimationEffectTimingReadOnly: false,
  	AnimationEvent: false,
  	AnimationPlaybackEvent: false,
  	AnimationTimeline: false,
  	applicationCache: false,
  	ApplicationCache: false,
  	ApplicationCacheErrorEvent: false,
  	atob: false,
  	Attr: false,
  	Audio: false,
  	AudioBuffer: false,
  	AudioBufferSourceNode: false,
  	AudioContext: false,
  	AudioDestinationNode: false,
  	AudioListener: false,
  	AudioNode: false,
  	AudioParam: false,
  	AudioProcessingEvent: false,
  	AudioScheduledSourceNode: false,
  	"AudioWorkletGlobalScope ": false,
  	AudioWorkletNode: false,
  	AudioWorkletProcessor: false,
  	BarProp: false,
  	BaseAudioContext: false,
  	BatteryManager: false,
  	BeforeUnloadEvent: false,
  	BiquadFilterNode: false,
  	Blob: false,
  	BlobEvent: false,
  	blur: false,
  	BroadcastChannel: false,
  	btoa: false,
  	BudgetService: false,
  	ByteLengthQueuingStrategy: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	cancelAnimationFrame: false,
  	cancelIdleCallback: false,
  	CanvasCaptureMediaStreamTrack: false,
  	CanvasGradient: false,
  	CanvasPattern: false,
  	CanvasRenderingContext2D: false,
  	ChannelMergerNode: false,
  	ChannelSplitterNode: false,
  	CharacterData: false,
  	clearInterval: false,
  	clearTimeout: false,
  	clientInformation: false,
  	ClipboardEvent: false,
  	close: false,
  	closed: false,
  	CloseEvent: false,
  	Comment: false,
  	CompositionEvent: false,
  	confirm: false,
  	console: false,
  	ConstantSourceNode: false,
  	ConvolverNode: false,
  	CountQueuingStrategy: false,
  	createImageBitmap: false,
  	Credential: false,
  	CredentialsContainer: false,
  	crypto: false,
  	Crypto: false,
  	CryptoKey: false,
  	CSS: false,
  	CSSConditionRule: false,
  	CSSFontFaceRule: false,
  	CSSGroupingRule: false,
  	CSSImportRule: false,
  	CSSKeyframeRule: false,
  	CSSKeyframesRule: false,
  	CSSMediaRule: false,
  	CSSNamespaceRule: false,
  	CSSPageRule: false,
  	CSSRule: false,
  	CSSRuleList: false,
  	CSSStyleDeclaration: false,
  	CSSStyleRule: false,
  	CSSStyleSheet: false,
  	CSSSupportsRule: false,
  	CustomElementRegistry: false,
  	customElements: false,
  	CustomEvent: false,
  	DataTransfer: false,
  	DataTransferItem: false,
  	DataTransferItemList: false,
  	defaultstatus: false,
  	defaultStatus: false,
  	DelayNode: false,
  	DeviceMotionEvent: false,
  	DeviceOrientationEvent: false,
  	devicePixelRatio: false,
  	dispatchEvent: false,
  	document: false,
  	Document: false,
  	DocumentFragment: false,
  	DocumentType: false,
  	DOMError: false,
  	DOMException: false,
  	DOMImplementation: false,
  	DOMMatrix: false,
  	DOMMatrixReadOnly: false,
  	DOMParser: false,
  	DOMPoint: false,
  	DOMPointReadOnly: false,
  	DOMQuad: false,
  	DOMRect: false,
  	DOMRectReadOnly: false,
  	DOMStringList: false,
  	DOMStringMap: false,
  	DOMTokenList: false,
  	DragEvent: false,
  	DynamicsCompressorNode: false,
  	Element: false,
  	ErrorEvent: false,
  	event: false,
  	Event: false,
  	EventSource: false,
  	EventTarget: false,
  	external: false,
  	fetch: false,
  	File: false,
  	FileList: false,
  	FileReader: false,
  	find: false,
  	focus: false,
  	FocusEvent: false,
  	FontFace: false,
  	FontFaceSetLoadEvent: false,
  	FormData: false,
  	frameElement: false,
  	frames: false,
  	GainNode: false,
  	Gamepad: false,
  	GamepadButton: false,
  	GamepadEvent: false,
  	getComputedStyle: false,
  	getSelection: false,
  	HashChangeEvent: false,
  	Headers: false,
  	history: false,
  	History: false,
  	HTMLAllCollection: false,
  	HTMLAnchorElement: false,
  	HTMLAreaElement: false,
  	HTMLAudioElement: false,
  	HTMLBaseElement: false,
  	HTMLBodyElement: false,
  	HTMLBRElement: false,
  	HTMLButtonElement: false,
  	HTMLCanvasElement: false,
  	HTMLCollection: false,
  	HTMLContentElement: false,
  	HTMLDataElement: false,
  	HTMLDataListElement: false,
  	HTMLDetailsElement: false,
  	HTMLDialogElement: false,
  	HTMLDirectoryElement: false,
  	HTMLDivElement: false,
  	HTMLDListElement: false,
  	HTMLDocument: false,
  	HTMLElement: false,
  	HTMLEmbedElement: false,
  	HTMLFieldSetElement: false,
  	HTMLFontElement: false,
  	HTMLFormControlsCollection: false,
  	HTMLFormElement: false,
  	HTMLFrameElement: false,
  	HTMLFrameSetElement: false,
  	HTMLHeadElement: false,
  	HTMLHeadingElement: false,
  	HTMLHRElement: false,
  	HTMLHtmlElement: false,
  	HTMLIFrameElement: false,
  	HTMLImageElement: false,
  	HTMLInputElement: false,
  	HTMLLabelElement: false,
  	HTMLLegendElement: false,
  	HTMLLIElement: false,
  	HTMLLinkElement: false,
  	HTMLMapElement: false,
  	HTMLMarqueeElement: false,
  	HTMLMediaElement: false,
  	HTMLMenuElement: false,
  	HTMLMetaElement: false,
  	HTMLMeterElement: false,
  	HTMLModElement: false,
  	HTMLObjectElement: false,
  	HTMLOListElement: false,
  	HTMLOptGroupElement: false,
  	HTMLOptionElement: false,
  	HTMLOptionsCollection: false,
  	HTMLOutputElement: false,
  	HTMLParagraphElement: false,
  	HTMLParamElement: false,
  	HTMLPictureElement: false,
  	HTMLPreElement: false,
  	HTMLProgressElement: false,
  	HTMLQuoteElement: false,
  	HTMLScriptElement: false,
  	HTMLSelectElement: false,
  	HTMLShadowElement: false,
  	HTMLSlotElement: false,
  	HTMLSourceElement: false,
  	HTMLSpanElement: false,
  	HTMLStyleElement: false,
  	HTMLTableCaptionElement: false,
  	HTMLTableCellElement: false,
  	HTMLTableColElement: false,
  	HTMLTableElement: false,
  	HTMLTableRowElement: false,
  	HTMLTableSectionElement: false,
  	HTMLTemplateElement: false,
  	HTMLTextAreaElement: false,
  	HTMLTimeElement: false,
  	HTMLTitleElement: false,
  	HTMLTrackElement: false,
  	HTMLUListElement: false,
  	HTMLUnknownElement: false,
  	HTMLVideoElement: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	IdleDeadline: false,
  	IIRFilterNode: false,
  	Image: false,
  	ImageBitmap: false,
  	ImageBitmapRenderingContext: false,
  	ImageCapture: false,
  	ImageData: false,
  	indexedDB: false,
  	innerHeight: false,
  	innerWidth: false,
  	InputEvent: false,
  	IntersectionObserver: false,
  	IntersectionObserverEntry: false,
  	"Intl": false,
  	isSecureContext: false,
  	KeyboardEvent: false,
  	KeyframeEffect: false,
  	KeyframeEffectReadOnly: false,
  	length: false,
  	localStorage: false,
  	location: true,
  	Location: false,
  	locationbar: false,
  	matchMedia: false,
  	MediaDeviceInfo: false,
  	MediaDevices: false,
  	MediaElementAudioSourceNode: false,
  	MediaEncryptedEvent: false,
  	MediaError: false,
  	MediaKeyMessageEvent: false,
  	MediaKeySession: false,
  	MediaKeyStatusMap: false,
  	MediaKeySystemAccess: false,
  	MediaList: false,
  	MediaQueryList: false,
  	MediaQueryListEvent: false,
  	MediaRecorder: false,
  	MediaSettingsRange: false,
  	MediaSource: false,
  	MediaStream: false,
  	MediaStreamAudioDestinationNode: false,
  	MediaStreamAudioSourceNode: false,
  	MediaStreamEvent: false,
  	MediaStreamTrack: false,
  	MediaStreamTrackEvent: false,
  	menubar: false,
  	MessageChannel: false,
  	MessageEvent: false,
  	MessagePort: false,
  	MIDIAccess: false,
  	MIDIConnectionEvent: false,
  	MIDIInput: false,
  	MIDIInputMap: false,
  	MIDIMessageEvent: false,
  	MIDIOutput: false,
  	MIDIOutputMap: false,
  	MIDIPort: false,
  	MimeType: false,
  	MimeTypeArray: false,
  	MouseEvent: false,
  	moveBy: false,
  	moveTo: false,
  	MutationEvent: false,
  	MutationObserver: false,
  	MutationRecord: false,
  	name: false,
  	NamedNodeMap: false,
  	NavigationPreloadManager: false,
  	navigator: false,
  	Navigator: false,
  	NetworkInformation: false,
  	Node: false,
  	NodeFilter: false,
  	NodeIterator: false,
  	NodeList: false,
  	Notification: false,
  	OfflineAudioCompletionEvent: false,
  	OfflineAudioContext: false,
  	offscreenBuffering: false,
  	OffscreenCanvas: true,
  	onabort: true,
  	onafterprint: true,
  	onanimationend: true,
  	onanimationiteration: true,
  	onanimationstart: true,
  	onappinstalled: true,
  	onauxclick: true,
  	onbeforeinstallprompt: true,
  	onbeforeprint: true,
  	onbeforeunload: true,
  	onblur: true,
  	oncancel: true,
  	oncanplay: true,
  	oncanplaythrough: true,
  	onchange: true,
  	onclick: true,
  	onclose: true,
  	oncontextmenu: true,
  	oncuechange: true,
  	ondblclick: true,
  	ondevicemotion: true,
  	ondeviceorientation: true,
  	ondeviceorientationabsolute: true,
  	ondrag: true,
  	ondragend: true,
  	ondragenter: true,
  	ondragleave: true,
  	ondragover: true,
  	ondragstart: true,
  	ondrop: true,
  	ondurationchange: true,
  	onemptied: true,
  	onended: true,
  	onerror: true,
  	onfocus: true,
  	ongotpointercapture: true,
  	onhashchange: true,
  	oninput: true,
  	oninvalid: true,
  	onkeydown: true,
  	onkeypress: true,
  	onkeyup: true,
  	onlanguagechange: true,
  	onload: true,
  	onloadeddata: true,
  	onloadedmetadata: true,
  	onloadstart: true,
  	onlostpointercapture: true,
  	onmessage: true,
  	onmessageerror: true,
  	onmousedown: true,
  	onmouseenter: true,
  	onmouseleave: true,
  	onmousemove: true,
  	onmouseout: true,
  	onmouseover: true,
  	onmouseup: true,
  	onmousewheel: true,
  	onoffline: true,
  	ononline: true,
  	onpagehide: true,
  	onpageshow: true,
  	onpause: true,
  	onplay: true,
  	onplaying: true,
  	onpointercancel: true,
  	onpointerdown: true,
  	onpointerenter: true,
  	onpointerleave: true,
  	onpointermove: true,
  	onpointerout: true,
  	onpointerover: true,
  	onpointerup: true,
  	onpopstate: true,
  	onprogress: true,
  	onratechange: true,
  	onrejectionhandled: true,
  	onreset: true,
  	onresize: true,
  	onscroll: true,
  	onsearch: true,
  	onseeked: true,
  	onseeking: true,
  	onselect: true,
  	onstalled: true,
  	onstorage: true,
  	onsubmit: true,
  	onsuspend: true,
  	ontimeupdate: true,
  	ontoggle: true,
  	ontransitionend: true,
  	onunhandledrejection: true,
  	onunload: true,
  	onvolumechange: true,
  	onwaiting: true,
  	onwheel: true,
  	open: false,
  	openDatabase: false,
  	opener: false,
  	Option: false,
  	origin: false,
  	OscillatorNode: false,
  	outerHeight: false,
  	outerWidth: false,
  	PageTransitionEvent: false,
  	pageXOffset: false,
  	pageYOffset: false,
  	PannerNode: false,
  	parent: false,
  	Path2D: false,
  	PaymentAddress: false,
  	PaymentRequest: false,
  	PaymentRequestUpdateEvent: false,
  	PaymentResponse: false,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceLongTaskTiming: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceNavigationTiming: false,
  	PerformanceObserver: false,
  	PerformanceObserverEntryList: false,
  	PerformancePaintTiming: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	PeriodicWave: false,
  	Permissions: false,
  	PermissionStatus: false,
  	personalbar: false,
  	PhotoCapabilities: false,
  	Plugin: false,
  	PluginArray: false,
  	PointerEvent: false,
  	PopStateEvent: false,
  	postMessage: false,
  	Presentation: false,
  	PresentationAvailability: false,
  	PresentationConnection: false,
  	PresentationConnectionAvailableEvent: false,
  	PresentationConnectionCloseEvent: false,
  	PresentationConnectionList: false,
  	PresentationReceiver: false,
  	PresentationRequest: false,
  	print: false,
  	ProcessingInstruction: false,
  	ProgressEvent: false,
  	PromiseRejectionEvent: false,
  	prompt: false,
  	PushManager: false,
  	PushSubscription: false,
  	PushSubscriptionOptions: false,
  	queueMicrotask: false,
  	RadioNodeList: false,
  	Range: false,
  	ReadableStream: false,
  	registerProcessor: false,
  	RemotePlayback: false,
  	removeEventListener: false,
  	Request: false,
  	requestAnimationFrame: false,
  	requestIdleCallback: false,
  	resizeBy: false,
  	ResizeObserver: false,
  	ResizeObserverEntry: false,
  	resizeTo: false,
  	Response: false,
  	RTCCertificate: false,
  	RTCDataChannel: false,
  	RTCDataChannelEvent: false,
  	RTCDtlsTransport: false,
  	RTCIceCandidate: false,
  	RTCIceGatherer: false,
  	RTCIceTransport: false,
  	RTCPeerConnection: false,
  	RTCPeerConnectionIceEvent: false,
  	RTCRtpContributingSource: false,
  	RTCRtpReceiver: false,
  	RTCRtpSender: false,
  	RTCSctpTransport: false,
  	RTCSessionDescription: false,
  	RTCStatsReport: false,
  	RTCTrackEvent: false,
  	screen: false,
  	Screen: false,
  	screenLeft: false,
  	ScreenOrientation: false,
  	screenTop: false,
  	screenX: false,
  	screenY: false,
  	ScriptProcessorNode: false,
  	scroll: false,
  	scrollbars: false,
  	scrollBy: false,
  	scrollTo: false,
  	scrollX: false,
  	scrollY: false,
  	SecurityPolicyViolationEvent: false,
  	Selection: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerRegistration: false,
  	sessionStorage: false,
  	setInterval: false,
  	setTimeout: false,
  	ShadowRoot: false,
  	SharedWorker: false,
  	SourceBuffer: false,
  	SourceBufferList: false,
  	speechSynthesis: false,
  	SpeechSynthesisEvent: false,
  	SpeechSynthesisUtterance: false,
  	StaticRange: false,
  	status: false,
  	statusbar: false,
  	StereoPannerNode: false,
  	stop: false,
  	Storage: false,
  	StorageEvent: false,
  	StorageManager: false,
  	styleMedia: false,
  	StyleSheet: false,
  	StyleSheetList: false,
  	SubtleCrypto: false,
  	SVGAElement: false,
  	SVGAngle: false,
  	SVGAnimatedAngle: false,
  	SVGAnimatedBoolean: false,
  	SVGAnimatedEnumeration: false,
  	SVGAnimatedInteger: false,
  	SVGAnimatedLength: false,
  	SVGAnimatedLengthList: false,
  	SVGAnimatedNumber: false,
  	SVGAnimatedNumberList: false,
  	SVGAnimatedPreserveAspectRatio: false,
  	SVGAnimatedRect: false,
  	SVGAnimatedString: false,
  	SVGAnimatedTransformList: false,
  	SVGAnimateElement: false,
  	SVGAnimateMotionElement: false,
  	SVGAnimateTransformElement: false,
  	SVGAnimationElement: false,
  	SVGCircleElement: false,
  	SVGClipPathElement: false,
  	SVGComponentTransferFunctionElement: false,
  	SVGDefsElement: false,
  	SVGDescElement: false,
  	SVGDiscardElement: false,
  	SVGElement: false,
  	SVGEllipseElement: false,
  	SVGFEBlendElement: false,
  	SVGFEColorMatrixElement: false,
  	SVGFEComponentTransferElement: false,
  	SVGFECompositeElement: false,
  	SVGFEConvolveMatrixElement: false,
  	SVGFEDiffuseLightingElement: false,
  	SVGFEDisplacementMapElement: false,
  	SVGFEDistantLightElement: false,
  	SVGFEDropShadowElement: false,
  	SVGFEFloodElement: false,
  	SVGFEFuncAElement: false,
  	SVGFEFuncBElement: false,
  	SVGFEFuncGElement: false,
  	SVGFEFuncRElement: false,
  	SVGFEGaussianBlurElement: false,
  	SVGFEImageElement: false,
  	SVGFEMergeElement: false,
  	SVGFEMergeNodeElement: false,
  	SVGFEMorphologyElement: false,
  	SVGFEOffsetElement: false,
  	SVGFEPointLightElement: false,
  	SVGFESpecularLightingElement: false,
  	SVGFESpotLightElement: false,
  	SVGFETileElement: false,
  	SVGFETurbulenceElement: false,
  	SVGFilterElement: false,
  	SVGForeignObjectElement: false,
  	SVGGElement: false,
  	SVGGeometryElement: false,
  	SVGGradientElement: false,
  	SVGGraphicsElement: false,
  	SVGImageElement: false,
  	SVGLength: false,
  	SVGLengthList: false,
  	SVGLinearGradientElement: false,
  	SVGLineElement: false,
  	SVGMarkerElement: false,
  	SVGMaskElement: false,
  	SVGMatrix: false,
  	SVGMetadataElement: false,
  	SVGMPathElement: false,
  	SVGNumber: false,
  	SVGNumberList: false,
  	SVGPathElement: false,
  	SVGPatternElement: false,
  	SVGPoint: false,
  	SVGPointList: false,
  	SVGPolygonElement: false,
  	SVGPolylineElement: false,
  	SVGPreserveAspectRatio: false,
  	SVGRadialGradientElement: false,
  	SVGRect: false,
  	SVGRectElement: false,
  	SVGScriptElement: false,
  	SVGSetElement: false,
  	SVGStopElement: false,
  	SVGStringList: false,
  	SVGStyleElement: false,
  	SVGSVGElement: false,
  	SVGSwitchElement: false,
  	SVGSymbolElement: false,
  	SVGTextContentElement: false,
  	SVGTextElement: false,
  	SVGTextPathElement: false,
  	SVGTextPositioningElement: false,
  	SVGTitleElement: false,
  	SVGTransform: false,
  	SVGTransformList: false,
  	SVGTSpanElement: false,
  	SVGUnitTypes: false,
  	SVGUseElement: false,
  	SVGViewElement: false,
  	TaskAttributionTiming: false,
  	Text: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	TextEvent: false,
  	TextMetrics: false,
  	TextTrack: false,
  	TextTrackCue: false,
  	TextTrackCueList: false,
  	TextTrackList: false,
  	TimeRanges: false,
  	toolbar: false,
  	top: false,
  	Touch: false,
  	TouchEvent: false,
  	TouchList: false,
  	TrackEvent: false,
  	TransitionEvent: false,
  	TreeWalker: false,
  	UIEvent: false,
  	URL: false,
  	URLSearchParams: false,
  	ValidityState: false,
  	visualViewport: false,
  	VisualViewport: false,
  	VTTCue: false,
  	WaveShaperNode: false,
  	WebAssembly: false,
  	WebGL2RenderingContext: false,
  	WebGLActiveInfo: false,
  	WebGLBuffer: false,
  	WebGLContextEvent: false,
  	WebGLFramebuffer: false,
  	WebGLProgram: false,
  	WebGLQuery: false,
  	WebGLRenderbuffer: false,
  	WebGLRenderingContext: false,
  	WebGLSampler: false,
  	WebGLShader: false,
  	WebGLShaderPrecisionFormat: false,
  	WebGLSync: false,
  	WebGLTexture: false,
  	WebGLTransformFeedback: false,
  	WebGLUniformLocation: false,
  	WebGLVertexArrayObject: false,
  	WebSocket: false,
  	WheelEvent: false,
  	window: false,
  	Window: false,
  	Worker: false,
  	WritableStream: false,
  	XMLDocument: false,
  	XMLHttpRequest: false,
  	XMLHttpRequestEventTarget: false,
  	XMLHttpRequestUpload: false,
  	XMLSerializer: false,
  	XPathEvaluator: false,
  	XPathExpression: false,
  	XPathResult: false,
  	XSLTProcessor: false
  };
  var worker = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	clearInterval: false,
  	clearTimeout: false,
  	close: true,
  	console: false,
  	fetch: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: true,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onoffline: true,
  	ononline: true,
  	onrejectionhandled: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: true,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var node = {
  	__dirname: false,
  	__filename: false,
  	Buffer: false,
  	clearImmediate: false,
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	exports: true,
  	global: false,
  	"Intl": false,
  	module: false,
  	process: false,
  	queueMicrotask: false,
  	require: false,
  	setImmediate: false,
  	setInterval: false,
  	setTimeout: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false
  };
  var commonjs = {
  	exports: true,
  	global: false,
  	module: false,
  	require: false
  };
  var amd = {
  	define: false,
  	require: false
  };
  var mocha = {
  	after: false,
  	afterEach: false,
  	before: false,
  	beforeEach: false,
  	context: false,
  	describe: false,
  	it: false,
  	mocha: false,
  	run: false,
  	setup: false,
  	specify: false,
  	suite: false,
  	suiteSetup: false,
  	suiteTeardown: false,
  	teardown: false,
  	test: false,
  	xcontext: false,
  	xdescribe: false,
  	xit: false,
  	xspecify: false
  };
  var jasmine = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fail: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jasmine: false,
  	pending: false,
  	runs: false,
  	spyOn: false,
  	spyOnProperty: false,
  	waits: false,
  	waitsFor: false,
  	xdescribe: false,
  	xit: false
  };
  var jest = {
  	afterAll: false,
  	afterEach: false,
  	beforeAll: false,
  	beforeEach: false,
  	describe: false,
  	expect: false,
  	fdescribe: false,
  	fit: false,
  	it: false,
  	jest: false,
  	pit: false,
  	require: false,
  	test: false,
  	xdescribe: false,
  	xit: false,
  	xtest: false
  };
  var qunit = {
  	asyncTest: false,
  	deepEqual: false,
  	equal: false,
  	expect: false,
  	module: false,
  	notDeepEqual: false,
  	notEqual: false,
  	notOk: false,
  	notPropEqual: false,
  	notStrictEqual: false,
  	ok: false,
  	propEqual: false,
  	QUnit: false,
  	raises: false,
  	start: false,
  	stop: false,
  	strictEqual: false,
  	test: false,
  	throws: false
  };
  var phantomjs = {
  	console: true,
  	exports: true,
  	phantom: true,
  	require: true,
  	WebPage: true
  };
  var couch = {
  	emit: false,
  	exports: false,
  	getRow: false,
  	log: false,
  	module: false,
  	provides: false,
  	require: false,
  	respond: false,
  	send: false,
  	start: false,
  	sum: false
  };
  var rhino = {
  	defineClass: false,
  	deserialize: false,
  	gc: false,
  	help: false,
  	importClass: false,
  	importPackage: false,
  	java: false,
  	load: false,
  	loadClass: false,
  	Packages: false,
  	print: false,
  	quit: false,
  	readFile: false,
  	readUrl: false,
  	runCommand: false,
  	seal: false,
  	serialize: false,
  	spawn: false,
  	sync: false,
  	toint32: false,
  	version: false
  };
  var nashorn = {
  	__DIR__: false,
  	__FILE__: false,
  	__LINE__: false,
  	com: false,
  	edu: false,
  	exit: false,
  	java: false,
  	Java: false,
  	javafx: false,
  	JavaImporter: false,
  	javax: false,
  	JSAdapter: false,
  	load: false,
  	loadWithNewGlobal: false,
  	org: false,
  	Packages: false,
  	print: false,
  	quit: false
  };
  var wsh = {
  	ActiveXObject: true,
  	Enumerator: true,
  	GetObject: true,
  	ScriptEngine: true,
  	ScriptEngineBuildVersion: true,
  	ScriptEngineMajorVersion: true,
  	ScriptEngineMinorVersion: true,
  	VBArray: true,
  	WScript: true,
  	WSH: true,
  	XDomainRequest: true
  };
  var jquery = {
  	$: false,
  	jQuery: false
  };
  var yui = {
  	YAHOO: false,
  	YAHOO_config: false,
  	YUI: false,
  	YUI_config: false
  };
  var shelljs = {
  	cat: false,
  	cd: false,
  	chmod: false,
  	config: false,
  	cp: false,
  	dirs: false,
  	echo: false,
  	env: false,
  	error: false,
  	exec: false,
  	exit: false,
  	find: false,
  	grep: false,
  	ln: false,
  	ls: false,
  	mkdir: false,
  	mv: false,
  	popd: false,
  	pushd: false,
  	pwd: false,
  	rm: false,
  	sed: false,
  	set: false,
  	target: false,
  	tempdir: false,
  	test: false,
  	touch: false,
  	which: false
  };
  var prototypejs = {
  	$: false,
  	$$: false,
  	$A: false,
  	$break: false,
  	$continue: false,
  	$F: false,
  	$H: false,
  	$R: false,
  	$w: false,
  	Abstract: false,
  	Ajax: false,
  	Autocompleter: false,
  	Builder: false,
  	Class: false,
  	Control: false,
  	Draggable: false,
  	Draggables: false,
  	Droppables: false,
  	Effect: false,
  	Element: false,
  	Enumerable: false,
  	Event: false,
  	Field: false,
  	Form: false,
  	Hash: false,
  	Insertion: false,
  	ObjectRange: false,
  	PeriodicalExecuter: false,
  	Position: false,
  	Prototype: false,
  	Scriptaculous: false,
  	Selector: false,
  	Sortable: false,
  	SortableObserver: false,
  	Sound: false,
  	Template: false,
  	Toggle: false,
  	Try: false
  };
  var meteor = {
  	_: false,
  	$: false,
  	Accounts: false,
  	AccountsClient: false,
  	AccountsCommon: false,
  	AccountsServer: false,
  	App: false,
  	Assets: false,
  	Blaze: false,
  	check: false,
  	Cordova: false,
  	DDP: false,
  	DDPRateLimiter: false,
  	DDPServer: false,
  	Deps: false,
  	EJSON: false,
  	Email: false,
  	HTTP: false,
  	Log: false,
  	Match: false,
  	Meteor: false,
  	Mongo: false,
  	MongoInternals: false,
  	Npm: false,
  	Package: false,
  	Plugin: false,
  	process: false,
  	Random: false,
  	ReactiveDict: false,
  	ReactiveVar: false,
  	Router: false,
  	ServiceConfiguration: false,
  	Session: false,
  	share: false,
  	Spacebars: false,
  	Template: false,
  	Tinytest: false,
  	Tracker: false,
  	UI: false,
  	Utils: false,
  	WebApp: false,
  	WebAppInternals: false
  };
  var mongo = {
  	_isWindows: false,
  	_rand: false,
  	BulkWriteResult: false,
  	cat: false,
  	cd: false,
  	connect: false,
  	db: false,
  	getHostName: false,
  	getMemInfo: false,
  	hostname: false,
  	ISODate: false,
  	listFiles: false,
  	load: false,
  	ls: false,
  	md5sumFile: false,
  	mkdir: false,
  	Mongo: false,
  	NumberInt: false,
  	NumberLong: false,
  	ObjectId: false,
  	PlanCache: false,
  	print: false,
  	printjson: false,
  	pwd: false,
  	quit: false,
  	removeFile: false,
  	rs: false,
  	sh: false,
  	UUID: false,
  	version: false,
  	WriteResult: false
  };
  var applescript = {
  	$: false,
  	Application: false,
  	Automation: false,
  	console: false,
  	delay: false,
  	Library: false,
  	ObjC: false,
  	ObjectSpecifier: false,
  	Path: false,
  	Progress: false,
  	Ref: false
  };
  var serviceworker = {
  	addEventListener: false,
  	applicationCache: false,
  	atob: false,
  	Blob: false,
  	BroadcastChannel: false,
  	btoa: false,
  	Cache: false,
  	caches: false,
  	CacheStorage: false,
  	clearInterval: false,
  	clearTimeout: false,
  	Client: false,
  	clients: false,
  	Clients: false,
  	close: true,
  	console: false,
  	ExtendableEvent: false,
  	ExtendableMessageEvent: false,
  	fetch: false,
  	FetchEvent: false,
  	FileReaderSync: false,
  	FormData: false,
  	Headers: false,
  	IDBCursor: false,
  	IDBCursorWithValue: false,
  	IDBDatabase: false,
  	IDBFactory: false,
  	IDBIndex: false,
  	IDBKeyRange: false,
  	IDBObjectStore: false,
  	IDBOpenDBRequest: false,
  	IDBRequest: false,
  	IDBTransaction: false,
  	IDBVersionChangeEvent: false,
  	ImageData: false,
  	importScripts: false,
  	indexedDB: false,
  	location: false,
  	MessageChannel: false,
  	MessagePort: false,
  	name: false,
  	navigator: false,
  	Notification: false,
  	onclose: true,
  	onconnect: true,
  	onerror: true,
  	onfetch: true,
  	oninstall: true,
  	onlanguagechange: true,
  	onmessage: true,
  	onmessageerror: true,
  	onnotificationclick: true,
  	onnotificationclose: true,
  	onoffline: true,
  	ononline: true,
  	onpush: true,
  	onpushsubscriptionchange: true,
  	onrejectionhandled: true,
  	onsync: true,
  	onunhandledrejection: true,
  	performance: false,
  	Performance: false,
  	PerformanceEntry: false,
  	PerformanceMark: false,
  	PerformanceMeasure: false,
  	PerformanceNavigation: false,
  	PerformanceResourceTiming: false,
  	PerformanceTiming: false,
  	postMessage: true,
  	"Promise": false,
  	queueMicrotask: false,
  	registration: false,
  	removeEventListener: false,
  	Request: false,
  	Response: false,
  	self: false,
  	ServiceWorker: false,
  	ServiceWorkerContainer: false,
  	ServiceWorkerGlobalScope: false,
  	ServiceWorkerMessageEvent: false,
  	ServiceWorkerRegistration: false,
  	setInterval: false,
  	setTimeout: false,
  	skipWaiting: false,
  	TextDecoder: false,
  	TextEncoder: false,
  	URL: false,
  	URLSearchParams: false,
  	WebSocket: false,
  	WindowClient: false,
  	Worker: false,
  	WorkerGlobalScope: false,
  	XMLHttpRequest: false
  };
  var atomtest = {
  	advanceClock: false,
  	fakeClearInterval: false,
  	fakeClearTimeout: false,
  	fakeSetInterval: false,
  	fakeSetTimeout: false,
  	resetTimeouts: false,
  	waitsForPromise: false
  };
  var embertest = {
  	andThen: false,
  	click: false,
  	currentPath: false,
  	currentRouteName: false,
  	currentURL: false,
  	fillIn: false,
  	find: false,
  	findAll: false,
  	findWithAssert: false,
  	keyEvent: false,
  	pauseTest: false,
  	resumeTest: false,
  	triggerEvent: false,
  	visit: false,
  	wait: false
  };
  var protractor = {
  	$: false,
  	$$: false,
  	browser: false,
  	by: false,
  	By: false,
  	DartObject: false,
  	element: false,
  	protractor: false
  };
  var webextensions = {
  	browser: false,
  	chrome: false,
  	opr: false
  };
  var greasemonkey = {
  	cloneInto: false,
  	createObjectIn: false,
  	exportFunction: false,
  	GM: false,
  	GM_addStyle: false,
  	GM_deleteValue: false,
  	GM_getResourceText: false,
  	GM_getResourceURL: false,
  	GM_getValue: false,
  	GM_info: false,
  	GM_listValues: false,
  	GM_log: false,
  	GM_openInTab: false,
  	GM_registerMenuCommand: false,
  	GM_setClipboard: false,
  	GM_setValue: false,
  	GM_xmlhttpRequest: false,
  	unsafeWindow: false
  };
  var devtools = {
  	$: false,
  	$_: false,
  	$$: false,
  	$0: false,
  	$1: false,
  	$2: false,
  	$3: false,
  	$4: false,
  	$x: false,
  	chrome: false,
  	clear: false,
  	copy: false,
  	debug: false,
  	dir: false,
  	dirxml: false,
  	getEventListeners: false,
  	inspect: false,
  	keys: false,
  	monitor: false,
  	monitorEvents: false,
  	profile: false,
  	profileEnd: false,
  	queryObjects: false,
  	table: false,
  	undebug: false,
  	unmonitor: false,
  	unmonitorEvents: false,
  	values: false
  };
  var require$$0$4 = {
  	builtin: builtin,
  	es5: es5,
  	es2015: es2015,
  	es2017: es2017,
  	browser: browser,
  	worker: worker,
  	node: node,
  	commonjs: commonjs,
  	amd: amd,
  	mocha: mocha,
  	jasmine: jasmine,
  	jest: jest,
  	qunit: qunit,
  	phantomjs: phantomjs,
  	couch: couch,
  	rhino: rhino,
  	nashorn: nashorn,
  	wsh: wsh,
  	jquery: jquery,
  	yui: yui,
  	shelljs: shelljs,
  	prototypejs: prototypejs,
  	meteor: meteor,
  	mongo: mongo,
  	applescript: applescript,
  	serviceworker: serviceworker,
  	atomtest: atomtest,
  	embertest: embertest,
  	protractor: protractor,
  	"shared-node-browser": {
  	clearInterval: false,
  	clearTimeout: false,
  	console: false,
  	setInterval: false,
  	setTimeout: false,
  	URL: false,
  	URLSearchParams: false
  },
  	webextensions: webextensions,
  	greasemonkey: greasemonkey,
  	devtools: devtools
  };

  var globalsBABEL_8_BREAKINGFalse = require$$0$4;

  var globals = globalsBABEL_8_BREAKINGFalse;

  var _templateObject$b;
  var helperIDs = new WeakMap();
  function addCreateSuperHelper(file) {
    if (helperIDs.has(file)) {
      return (cloneNode || clone)(helperIDs.get(file));
    }

    try {
      return file.addHelper("createSuper");
    } catch (_unused) {}

    var id = file.scope.generateUidIdentifier("createSuper");
    helperIDs.set(file, id);
    var fn = helper$1({
      CREATE_SUPER: id,
      GET_PROTOTYPE_OF: file.addHelper("getPrototypeOf"),
      POSSIBLE_CONSTRUCTOR_RETURN: file.addHelper("possibleConstructorReturn")
    });
    file.path.unshiftContainer("body", [fn]);
    file.scope.registerDeclaration(file.path.get("body.0"));
    return cloneNode(id);
  }
  var helper$1 = template$2.statement(_templateObject$b || (_templateObject$b = _taggedTemplateLiteralLoose(["\n  function CREATE_SUPER(Derived) {\n    function isNativeReflectConstruct() {\n      if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n\n      // core-js@3\n      if (Reflect.construct.sham) return false;\n\n      // Proxy can't be polyfilled. Every browser implemented\n      // proxies before or at the same time as Reflect.construct,\n      // so if they support Proxy they also support Reflect.construct.\n      if (typeof Proxy === \"function\") return true;\n\n      // Since Reflect.construct can't be properly polyfilled, some\n      // implementations (e.g. core-js@2) don't set the correct internal slots.\n      // Those polyfills don't allow us to subclass built-ins, so we need to\n      // use our fallback implementation.\n      try {\n        // If the internal slots aren't set, this throws an error similar to\n        //   TypeError: this is not a Date object.\n        Date.prototype.toString.call(Reflect.construct(Date, [], function() {}));\n        return true;\n      } catch (e) {\n        return false;\n      }\n    }\n\n    return function () {\n      var Super = GET_PROTOTYPE_OF(Derived), result;\n      if (isNativeReflectConstruct()) {\n        // NOTE: This doesn't work if this.__proto__.constructor has been modified.\n        var NewTarget = GET_PROTOTYPE_OF(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return POSSIBLE_CONSTRUCTOR_RETURN(this, result);\n    }\n  }\n"])));

  var _templateObject$a;

  function buildConstructor(classRef, constructorBody, node) {
    var func = functionDeclaration(cloneNode(classRef), [], constructorBody);
    inherits(func, node);
    return func;
  }

  function transformClass(path, file, builtinClasses, isLoose, assumptions) {
    var classState = {
      parent: undefined,
      scope: undefined,
      node: undefined,
      path: undefined,
      file: undefined,
      classId: undefined,
      classRef: undefined,
      superFnId: undefined,
      superName: undefined,
      superReturns: [],
      isDerived: false,
      extendsNative: false,
      construct: undefined,
      constructorBody: undefined,
      userConstructor: undefined,
      userConstructorPath: undefined,
      hasConstructor: false,
      staticPropBody: [],
      body: [],
      superThises: [],
      pushedConstructor: false,
      pushedInherits: false,
      protoAlias: null,
      isLoose: false,
      methods: {
        instance: {
          hasComputed: false,
          list: [],
          map: new Map()
        },
        "static": {
          hasComputed: false,
          list: [],
          map: new Map()
        }
      }
    };

    var setState = function setState(newState) {
      Object.assign(classState, newState);
    };

    var findThisesVisitor = traverse.visitors.merge([environmentVisitor, {
      ThisExpression: function ThisExpression(path) {
        classState.superThises.push(path);
      }
    }]);

    function maybeCreateConstructor() {
      var hasConstructor = false;
      var paths = classState.path.get("body.body");

      for (var _iterator = _createForOfIteratorHelperLoose(paths), _step; !(_step = _iterator()).done;) {
        var _path = _step.value;
        hasConstructor = _path.equals("kind", "constructor");
        if (hasConstructor) break;
      }

      if (hasConstructor) return;
      var params, body;

      if (classState.isDerived) {
        var _constructor = template$2.expression.ast(_templateObject$a || (_templateObject$a = _taggedTemplateLiteralLoose(["\n        (function () {\n          super(...arguments);\n        })\n      "])));

        params = _constructor.params;
        body = _constructor.body;
      } else {
        params = [];
        body = blockStatement([]);
      }

      classState.path.get("body").unshiftContainer("body", classMethod("constructor", identifier("constructor"), params, body));
    }

    function buildBody() {
      maybeCreateConstructor();
      pushBody();
      verifyConstructor();

      if (classState.userConstructor) {
        var constructorBody = classState.constructorBody,
            userConstructor = classState.userConstructor,
            construct = classState.construct;
        constructorBody.body = constructorBody.body.concat(userConstructor.body.body);
        inherits(construct, userConstructor);
        inherits(constructorBody, userConstructor.body);
      }

      pushDescriptors();
    }

    function pushBody() {
      var classBodyPaths = classState.path.get("body.body");

      for (var _iterator2 = _createForOfIteratorHelperLoose(classBodyPaths), _step2; !(_step2 = _iterator2()).done;) {
        var _path2 = _step2.value;
        var node = _path2.node;

        if (_path2.isClassProperty()) {
          throw _path2.buildCodeFrameError("Missing class properties transform.");
        }

        if (node.decorators) {
          throw _path2.buildCodeFrameError("Method has decorators, put the decorator plugin before the classes one.");
        }

        if (isClassMethod(node)) {
          (function () {
            var isConstructor = node.kind === "constructor";
            var replaceSupers = new ReplaceSupers({
              methodPath: _path2,
              objectRef: classState.classRef,
              superRef: classState.superName,
              constantSuper: assumptions.constantSuper,
              file: classState.file,
              refToPreserve: classState.classRef
            });
            replaceSupers.replace();
            var superReturns = [];

            _path2.traverse(traverse.visitors.merge([environmentVisitor, {
              ReturnStatement: function ReturnStatement(path) {
                if (!path.getFunctionParent().isArrowFunctionExpression()) {
                  superReturns.push(path);
                }
              }
            }]));

            if (isConstructor) {
              pushConstructor(superReturns, node, _path2);
            } else {
              pushMethod(node, _path2);
            }
          })();
        }
      }
    }

    function pushDescriptors() {
      pushInheritsToBody();
      var body = classState.body;
      var props = {
        instance: null,
        "static": null
      };

      for (var _i = 0, _arr = ["static", "instance"]; _i < _arr.length; _i++) {
        var placement = _arr[_i];

        if (classState.methods[placement].list.length) {
          props[placement] = classState.methods[placement].list.map(function (desc) {
            var obj = objectExpression([objectProperty(identifier("key"), desc.key)]);

            for (var _i2 = 0, _arr2 = ["get", "set", "value"]; _i2 < _arr2.length; _i2++) {
              var kind = _arr2[_i2];

              if (desc[kind] != null) {
                obj.properties.push(objectProperty(identifier(kind), desc[kind]));
              }
            }

            return obj;
          });
        }
      }

      if (props.instance || props["static"]) {
        var args = [cloneNode(classState.classRef), props.instance ? arrayExpression(props.instance) : nullLiteral(), props["static"] ? arrayExpression(props["static"]) : nullLiteral()];
        var lastNonNullIndex = 0;

        for (var i = 0; i < args.length; i++) {
          if (!isNullLiteral(args[i])) lastNonNullIndex = i;
        }

        args = args.slice(0, lastNonNullIndex + 1);
        body.push(expressionStatement(callExpression(classState.file.addHelper("createClass"), args)));
      }
    }

    function wrapSuperCall(bareSuper, superRef, thisRef, body) {
      var bareSuperNode = bareSuper.node;
      var call;

      if (assumptions.superIsCallableConstructor) {
        bareSuperNode.arguments.unshift(thisExpression());

        if (bareSuperNode.arguments.length === 2 && isSpreadElement(bareSuperNode.arguments[1]) && isIdentifier(bareSuperNode.arguments[1].argument, {
          name: "arguments"
        })) {
          bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;
          bareSuperNode.callee = memberExpression(cloneNode(superRef), identifier("apply"));
        } else {
          bareSuperNode.callee = memberExpression(cloneNode(superRef), identifier("call"));
        }

        call = logicalExpression("||", bareSuperNode, thisExpression());
      } else {
        call = optimiseCallExpression(cloneNode(classState.superFnId), thisExpression(), bareSuperNode.arguments, false);
      }

      if (bareSuper.parentPath.isExpressionStatement() && bareSuper.parentPath.container === body.node.body && body.node.body.length - 1 === bareSuper.parentPath.key) {
        if (classState.superThises.length) {
          call = assignmentExpression("=", thisRef(), call);
        }

        bareSuper.parentPath.replaceWith(returnStatement(call));
      } else {
        bareSuper.replaceWith(assignmentExpression("=", thisRef(), call));
      }
    }

    function verifyConstructor() {
      if (!classState.isDerived) return;
      var path = classState.userConstructorPath;
      var body = path.get("body");
      path.traverse(findThisesVisitor);

      var _thisRef = function thisRef() {
        var ref = path.scope.generateDeclaredUidIdentifier("this");

        _thisRef = function thisRef() {
          return cloneNode(ref);
        };

        return ref;
      };

      for (var _iterator3 = _createForOfIteratorHelperLoose(classState.superThises), _step3; !(_step3 = _iterator3()).done;) {
        var thisPath = _step3.value;
        var node = thisPath.node,
            parentPath = thisPath.parentPath;

        if (parentPath.isMemberExpression({
          object: node
        })) {
          thisPath.replaceWith(_thisRef());
          continue;
        }

        thisPath.replaceWith(callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]));
      }

      var bareSupers = new Set();
      path.traverse(traverse.visitors.merge([environmentVisitor, {
        Super: function Super(path) {
          var node = path.node,
              parentPath = path.parentPath;

          if (parentPath.isCallExpression({
            callee: node
          })) {
            bareSupers.add(parentPath);
          }
        }
      }]));
      var guaranteedSuperBeforeFinish = !!bareSupers.size;

      for (var _iterator4 = _createForOfIteratorHelperLoose(bareSupers), _step4; !(_step4 = _iterator4()).done;) {
        var bareSuper = _step4.value;
        wrapSuperCall(bareSuper, classState.superName, _thisRef, body);

        if (guaranteedSuperBeforeFinish) {
          bareSuper.find(function (parentPath) {
            if (parentPath === path) {
              return true;
            }

            if (parentPath.isLoop() || parentPath.isConditional() || parentPath.isArrowFunctionExpression()) {
              guaranteedSuperBeforeFinish = false;
              return true;
            }
          });
        }
      }

      var wrapReturn;

      if (classState.isLoose) {
        wrapReturn = function wrapReturn(returnArg) {
          var thisExpr = callExpression(classState.file.addHelper("assertThisInitialized"), [_thisRef()]);
          return returnArg ? logicalExpression("||", returnArg, thisExpr) : thisExpr;
        };
      } else {
        wrapReturn = function wrapReturn(returnArg) {
          return callExpression(classState.file.addHelper("possibleConstructorReturn"), [_thisRef()].concat(returnArg || []));
        };
      }

      var bodyPaths = body.get("body");

      if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {
        body.pushContainer("body", returnStatement(guaranteedSuperBeforeFinish ? _thisRef() : wrapReturn()));
      }

      for (var _iterator5 = _createForOfIteratorHelperLoose(classState.superReturns), _step5; !(_step5 = _iterator5()).done;) {
        var returnPath = _step5.value;
        returnPath.get("argument").replaceWith(wrapReturn(returnPath.node.argument));
      }
    }

    function pushMethod(node, path) {
      var scope = path ? path.scope : classState.scope;

      if (node.kind === "method") {
        if (processMethod(node, scope)) return;
      }

      var placement = node["static"] ? "static" : "instance";
      var methods = classState.methods[placement];
      var descKey = node.kind === "method" ? "value" : node.kind;
      var key = isNumericLiteral(node.key) || isBigIntLiteral(node.key) ? stringLiteral(String(node.key.value)) : toComputedKey$1(node);
      var fn = toExpression(node);

      if (isStringLiteral(key)) {
        if (node.kind === "method") {
          fn = nameFunction({
            id: key,
            node: node,
            scope: scope
          });
        }
      } else {
        methods.hasComputed = true;
      }

      var descriptor;

      if (!methods.hasComputed && methods.map.has(key.value)) {
        descriptor = methods.map.get(key.value);
        descriptor[descKey] = fn;

        if (descKey === "value") {
          descriptor.get = null;
          descriptor.set = null;
        } else {
          descriptor.value = null;
        }
      } else {
        var _descriptor;

        descriptor = (_descriptor = {
          key: key
        }, _descriptor[descKey] = fn, _descriptor);
        methods.list.push(descriptor);

        if (!methods.hasComputed) {
          methods.map.set(key.value, descriptor);
        }
      }
    }

    function processMethod(node, scope) {
      if (assumptions.setClassMethods && !node.decorators) {
        var classRef = classState.classRef;

        if (!node["static"]) {
          insertProtoAliasOnce();
          classRef = classState.protoAlias;
        }

        var methodName = memberExpression(cloneNode(classRef), node.key, node.computed || isLiteral(node.key));
        var func = functionExpression(null, node.params, node.body, node.generator, node.async);
        inherits(func, node);
        var key = toComputedKey$1(node, node.key);

        if (isStringLiteral(key)) {
          func = nameFunction({
            node: func,
            id: key,
            scope: scope
          });
        }

        var expr = expressionStatement(assignmentExpression("=", methodName, func));
        inheritsComments(expr, node);
        classState.body.push(expr);
        return true;
      }

      return false;
    }

    function insertProtoAliasOnce() {
      if (classState.protoAlias === null) {
        setState({
          protoAlias: classState.scope.generateUidIdentifier("proto")
        });
        var classProto = memberExpression(classState.classRef, identifier("prototype"));
        var protoDeclaration = variableDeclaration("var", [variableDeclarator(classState.protoAlias, classProto)]);
        classState.body.push(protoDeclaration);
      }
    }

    function pushConstructor(superReturns, method, path) {
      setState({
        userConstructorPath: path,
        userConstructor: method,
        hasConstructor: true,
        superReturns: superReturns
      });
      var construct = classState.construct;
      inheritsComments(construct, method);
      construct.params = method.params;
      inherits(construct.body, method.body);
      construct.body.directives = method.body.directives;
      pushConstructorToBody();
    }

    function pushConstructorToBody() {
      if (classState.pushedConstructor) return;
      classState.pushedConstructor = true;

      if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {
        pushDescriptors();
      }

      classState.body.push(classState.construct);
      pushInheritsToBody();
    }

    function pushInheritsToBody() {
      if (!classState.isDerived || classState.pushedInherits) return;
      var superFnId = path.scope.generateUidIdentifier("super");
      setState({
        pushedInherits: true,
        superFnId: superFnId
      });

      if (!assumptions.superIsCallableConstructor) {
        classState.body.unshift(variableDeclaration("var", [variableDeclarator(superFnId, callExpression(addCreateSuperHelper(classState.file), [cloneNode(classState.classRef)]))]));
      }

      classState.body.unshift(expressionStatement(callExpression(classState.file.addHelper(classState.isLoose ? "inheritsLoose" : "inherits"), [cloneNode(classState.classRef), cloneNode(classState.superName)])));
    }

    function setupClosureParamsArgs() {
      var superName = classState.superName;
      var closureParams = [];
      var closureArgs = [];

      if (classState.isDerived) {
        var arg = cloneNode(superName);

        if (classState.extendsNative) {
          arg = callExpression(classState.file.addHelper("wrapNativeSuper"), [arg]);
          annotateAsPure(arg);
        }

        var param = classState.scope.generateUidIdentifierBasedOnNode(superName);
        closureParams.push(param);
        closureArgs.push(arg);
        setState({
          superName: cloneNode(param)
        });
      }

      return {
        closureParams: closureParams,
        closureArgs: closureArgs
      };
    }

    function classTransformer(path, file, builtinClasses, isLoose) {
      setState({
        parent: path.parent,
        scope: path.scope,
        node: path.node,
        path: path,
        file: file,
        isLoose: isLoose
      });
      setState({
        classId: classState.node.id,
        classRef: classState.node.id ? identifier(classState.node.id.name) : classState.scope.generateUidIdentifier("class"),
        superName: classState.node.superClass,
        isDerived: !!classState.node.superClass,
        constructorBody: blockStatement([])
      });
      setState({
        extendsNative: classState.isDerived && builtinClasses.has(classState.superName.name) && !classState.scope.hasBinding(classState.superName.name, true)
      });
      var classRef = classState.classRef,
          node = classState.node,
          constructorBody = classState.constructorBody;
      setState({
        construct: buildConstructor(classRef, constructorBody, node)
      });
      var body = classState.body;

      var _setupClosureParamsAr = setupClosureParamsArgs(),
          closureParams = _setupClosureParamsAr.closureParams,
          closureArgs = _setupClosureParamsAr.closureArgs;

      buildBody();

      if (!assumptions.noClassCalls) {
        constructorBody.body.unshift(expressionStatement(callExpression(classState.file.addHelper("classCallCheck"), [thisExpression(), cloneNode(classState.classRef)])));
      }

      body = body.concat(classState.staticPropBody.map(function (fn) {
        return fn(cloneNode(classState.classRef));
      }));
      var isStrict = path.isInStrictMode();
      var constructorOnly = classState.classId && body.length === 1;

      if (constructorOnly && !isStrict) {
        for (var _iterator6 = _createForOfIteratorHelperLoose(classState.construct.params), _step6; !(_step6 = _iterator6()).done;) {
          var param = _step6.value;

          if (!isIdentifier(param)) {
            constructorOnly = false;
            break;
          }
        }
      }

      var directives = constructorOnly ? body[0].body.directives : [];

      if (!isStrict) {
        directives.push(directive(directiveLiteral("use strict")));
      }

      if (constructorOnly) {
        return toExpression(body[0]);
      }

      body.push(returnStatement(cloneNode(classState.classRef)));
      var container = arrowFunctionExpression(closureParams, blockStatement(body, directives));
      return callExpression(container, closureArgs);
    }

    return classTransformer(path, file, builtinClasses, isLoose);
  }

  var getBuiltinClasses = function getBuiltinClasses(category) {
    return Object.keys(globals[category]).filter(function (name) {
      return /^[A-Z]/.test(name);
    });
  };

  var builtinClasses = new Set([].concat(_toConsumableArray(getBuiltinClasses("builtin")), _toConsumableArray(getBuiltinClasses("browser"))));
  var _transformClasses = declare(function (api, options) {
    var _api$assumption, _api$assumption2, _api$assumption3, _api$assumption4;

    api.assertVersion(7);
    var loose = options.loose;
    var setClassMethods = (_api$assumption = api.assumption("setClassMethods")) != null ? _api$assumption : options.loose;
    var constantSuper = (_api$assumption2 = api.assumption("constantSuper")) != null ? _api$assumption2 : options.loose;
    var superIsCallableConstructor = (_api$assumption3 = api.assumption("superIsCallableConstructor")) != null ? _api$assumption3 : options.loose;
    var noClassCalls = (_api$assumption4 = api.assumption("noClassCalls")) != null ? _api$assumption4 : options.loose;
    var VISITED = Symbol();
    return {
      name: "transform-classes",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path) {
          if (!path.get("declaration").isClassDeclaration()) return;
          splitExportDeclaration(path);
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;
          var ref = node.id || path.scope.generateUidIdentifier("class");
          path.replaceWith(variableDeclaration("let", [variableDeclarator(ref, toExpression(node))]));
        },
        ClassExpression: function ClassExpression(path, state) {
          var node = path.node;
          if (node[VISITED]) return;
          var inferred = nameFunction(path);

          if (inferred && inferred !== node) {
            path.replaceWith(inferred);
            return;
          }

          node[VISITED] = true;
          path.replaceWith(transformClass(path, state.file, builtinClasses, loose, {
            setClassMethods: setClassMethods,
            constantSuper: constantSuper,
            superIsCallableConstructor: superIsCallableConstructor,
            noClassCalls: noClassCalls
          }));

          if (path.isCallExpression()) {
            annotateAsPure(path);
            var callee = path.get("callee");

            if (callee.isArrowFunctionExpression()) {
              callee.arrowFunctionToExpression();
            }
          }
        }
      }
    };
  });

  var _transformComputedProperties = declare(function (api, options) {
    var _api$assumption;

    api.assertVersion(7);
    var setComputedProperties = (_api$assumption = api.assumption("setComputedProperties")) != null ? _api$assumption : options.loose;
    var pushComputedProps = setComputedProperties ? pushComputedPropsLoose : pushComputedPropsSpec;
    var buildMutatorMapAssign = template$2("\n    MUTATOR_MAP_REF[KEY] = MUTATOR_MAP_REF[KEY] || {};\n    MUTATOR_MAP_REF[KEY].KIND = VALUE;\n  ");

    function getValue(prop) {
      if (isObjectProperty(prop)) {
        return prop.value;
      } else if (isObjectMethod(prop)) {
        return functionExpression(null, prop.params, prop.body, prop.generator, prop.async);
      }
    }

    function pushAssign(objId, prop, body) {
      if (prop.kind === "get" && prop.kind === "set") {
        pushMutatorDefine(objId, prop);
      } else {
        body.push(expressionStatement(assignmentExpression("=", memberExpression(cloneNode(objId), prop.key, prop.computed || isLiteral(prop.key)), getValue(prop))));
      }
    }

    function pushMutatorDefine(_ref, prop) {
      var body = _ref.body,
          getMutatorId = _ref.getMutatorId,
          scope = _ref.scope;
      var key = !prop.computed && isIdentifier(prop.key) ? stringLiteral(prop.key.name) : prop.key;
      var maybeMemoise = scope.maybeGenerateMemoised(key);

      if (maybeMemoise) {
        body.push(expressionStatement(assignmentExpression("=", maybeMemoise, key)));
        key = maybeMemoise;
      }

      body.push.apply(body, _toConsumableArray(buildMutatorMapAssign({
        MUTATOR_MAP_REF: getMutatorId(),
        KEY: cloneNode(key),
        VALUE: getValue(prop),
        KIND: identifier(prop.kind)
      })));
    }

    function pushComputedPropsLoose(info) {
      for (var _iterator = _createForOfIteratorHelperLoose(info.computedProps), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else {
          pushAssign(cloneNode(info.objId), prop, info.body);
        }
      }
    }

    function pushComputedPropsSpec(info) {
      var objId = info.objId,
          body = info.body,
          computedProps = info.computedProps,
          state = info.state;

      for (var _iterator2 = _createForOfIteratorHelperLoose(computedProps), _step2; !(_step2 = _iterator2()).done;) {
        var prop = _step2.value;
        var key = toComputedKey$1(prop);

        if (prop.kind === "get" || prop.kind === "set") {
          pushMutatorDefine(info, prop);
        } else {
          if (computedProps.length === 1) {
            return callExpression(state.addHelper("defineProperty"), [info.initPropExpression, key, getValue(prop)]);
          } else {
            body.push(expressionStatement(callExpression(state.addHelper("defineProperty"), [cloneNode(objId), key, getValue(prop)])));
          }
        }
      }
    }

    return {
      name: "transform-computed-properties",
      visitor: {
        ObjectExpression: {
          exit: function exit(path, state) {
            var node = path.node,
                parent = path.parent,
                scope = path.scope;
            var hasComputed = false;

            for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
              var prop = _arr[_i];
              hasComputed = prop.computed === true;
              if (hasComputed) break;
            }

            if (!hasComputed) return;
            var initProps = [];
            var computedProps = [];
            var foundComputed = false;

            for (var _iterator3 = _createForOfIteratorHelperLoose(node.properties), _step3; !(_step3 = _iterator3()).done;) {
              var _prop = _step3.value;

              if (_prop.computed) {
                foundComputed = true;
              }

              if (foundComputed) {
                computedProps.push(_prop);
              } else {
                initProps.push(_prop);
              }
            }

            var objId = scope.generateUidIdentifierBasedOnNode(parent);
            var initPropExpression = objectExpression(initProps);
            var body = [];
            body.push(variableDeclaration("var", [variableDeclarator(objId, initPropExpression)]));
            var mutatorRef;

            var getMutatorId = function getMutatorId() {
              if (!mutatorRef) {
                mutatorRef = scope.generateUidIdentifier("mutatorMap");
                body.push(variableDeclaration("var", [variableDeclarator(mutatorRef, objectExpression([]))]));
              }

              return cloneNode(mutatorRef);
            };

            var single = pushComputedProps({
              scope: scope,
              objId: objId,
              body: body,
              computedProps: computedProps,
              initPropExpression: initPropExpression,
              getMutatorId: getMutatorId,
              state: state
            });

            if (mutatorRef) {
              body.push(expressionStatement(callExpression(state.addHelper("defineEnumerableProperties"), [cloneNode(objId), cloneNode(mutatorRef)])));
            }

            if (single) {
              path.replaceWith(single);
            } else {
              body.push(expressionStatement(cloneNode(objId)));
              path.replaceWithMultiple(body);
            }
          }
        }
      }
    };
  });

  var _transformDestructuring = declare(function (api, options) {
    var _api$assumption, _options$allowArrayLi, _api$assumption2;

    api.assertVersion(7);
    var _options$useBuiltIns = options.useBuiltIns,
        useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;
    var iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
    var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
    var objectRestNoSymbols = (_api$assumption2 = api.assumption("objectRestNoSymbols")) != null ? _api$assumption2 : options.loose;

    function getExtendsHelper(file) {
      return useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
    }

    function variableDeclarationHasPattern(node) {
      for (var _i = 0, _arr = node.declarations; _i < _arr.length; _i++) {
        var declar = _arr[_i];

        if (isPattern(declar.id)) {
          return true;
        }
      }

      return false;
    }

    function hasRest(pattern) {
      for (var _i2 = 0, _arr2 = pattern.elements; _i2 < _arr2.length; _i2++) {
        var elem = _arr2[_i2];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    function hasObjectRest(pattern) {
      for (var _i3 = 0, _arr3 = pattern.properties; _i3 < _arr3.length; _i3++) {
        var elem = _arr3[_i3];

        if (isRestElement(elem)) {
          return true;
        }
      }

      return false;
    }

    var STOP_TRAVERSAL = {};

    var arrayUnpackVisitor = function arrayUnpackVisitor(node, ancestors, state) {
      if (!ancestors.length) {
        return;
      }

      if (isIdentifier(node) && isReferenced(node, ancestors[ancestors.length - 1]) && state.bindings[node.name]) {
        state.deopt = true;
        throw STOP_TRAVERSAL;
      }
    };

    var DestructuringTransformer = function () {
      function DestructuringTransformer(opts) {
        this.blockHoist = opts.blockHoist;
        this.operator = opts.operator;
        this.arrays = {};
        this.nodes = opts.nodes || [];
        this.scope = opts.scope;
        this.kind = opts.kind;
        this.iterableIsArray = opts.iterableIsArray;
        this.arrayLikeIsIterable = opts.arrayLikeIsIterable;
        this.addHelper = opts.addHelper;
      }

      var _proto = DestructuringTransformer.prototype;

      _proto.buildVariableAssignment = function buildVariableAssignment(id, init) {
        var op = this.operator;
        if (isMemberExpression(id)) op = "=";
        var node;

        if (op) {
          node = expressionStatement(assignmentExpression(op, id, cloneNode(init) || this.scope.buildUndefinedNode()));
        } else {
          node = variableDeclaration(this.kind, [variableDeclarator(id, cloneNode(init))]);
        }

        node._blockHoist = this.blockHoist;
        return node;
      };

      _proto.buildVariableDeclaration = function buildVariableDeclaration(id, init) {
        var declar = variableDeclaration("var", [variableDeclarator(cloneNode(id), cloneNode(init))]);
        declar._blockHoist = this.blockHoist;
        return declar;
      };

      _proto.push = function push(id, _init) {
        var init = cloneNode(_init);

        if (isObjectPattern(id)) {
          this.pushObjectPattern(id, init);
        } else if (isArrayPattern(id)) {
          this.pushArrayPattern(id, init);
        } else if (isAssignmentPattern(id)) {
          this.pushAssignmentPattern(id, init);
        } else {
          this.nodes.push(this.buildVariableAssignment(id, init));
        }
      };

      _proto.toArray = function toArray(node, count) {
        if (this.iterableIsArray || isIdentifier(node) && this.arrays[node.name]) {
          return node;
        } else {
          return this.scope.toArray(node, count, this.arrayLikeIsIterable);
        }
      };

      _proto.pushAssignmentPattern = function pushAssignmentPattern(_ref, valueRef) {
        var left = _ref.left,
            right = _ref.right;
        var tempId = this.scope.generateUidIdentifierBasedOnNode(valueRef);
        this.nodes.push(this.buildVariableDeclaration(tempId, valueRef));
        var tempConditional = conditionalExpression(binaryExpression("===", cloneNode(tempId), this.scope.buildUndefinedNode()), right, cloneNode(tempId));

        if (isPattern(left)) {
          var patternId;
          var node;

          if (this.kind === "const" || this.kind === "let") {
            patternId = this.scope.generateUidIdentifier(tempId.name);
            node = this.buildVariableDeclaration(patternId, tempConditional);
          } else {
            patternId = tempId;
            node = expressionStatement(assignmentExpression("=", cloneNode(tempId), tempConditional));
          }

          this.nodes.push(node);
          this.push(left, patternId);
        } else {
          this.nodes.push(this.buildVariableAssignment(left, tempConditional));
        }
      };

      _proto.pushObjectRest = function pushObjectRest(pattern, objRef, spreadProp, spreadPropIndex) {
        var keys = [];
        var allLiteral = true;
        var hasTemplateLiteral = false;

        for (var i = 0; i < pattern.properties.length; i++) {
          var prop = pattern.properties[i];
          if (i >= spreadPropIndex) break;
          if (isRestElement(prop)) continue;
          var key = prop.key;

          if (isIdentifier(key) && !prop.computed) {
            keys.push(stringLiteral(key.name));
          } else if (isTemplateLiteral(key)) {
            keys.push(cloneNode(key));
            hasTemplateLiteral = true;
          } else if (isLiteral(key)) {
            keys.push(stringLiteral(String(key.value)));
          } else {
            keys.push(cloneNode(key));
            allLiteral = false;
          }
        }

        var value;

        if (keys.length === 0) {
          value = callExpression(getExtendsHelper(this), [objectExpression([]), cloneNode(objRef)]);
        } else {
          var keyExpression = arrayExpression(keys);

          if (!allLiteral) {
            keyExpression = callExpression(memberExpression(keyExpression, identifier("map")), [this.addHelper("toPropertyKey")]);
          } else if (!hasTemplateLiteral && !isProgram(this.scope.block)) {
            var program = this.scope.path.findParent(function (path) {
              return path.isProgram();
            });
            var id = this.scope.generateUidIdentifier("excluded");
            program.scope.push({
              id: id,
              init: keyExpression,
              kind: "const"
            });
            keyExpression = cloneNode(id);
          }

          value = callExpression(this.addHelper("objectWithoutProperties" + (objectRestNoSymbols ? "Loose" : "")), [cloneNode(objRef), keyExpression]);
        }

        this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));
      };

      _proto.pushObjectProperty = function pushObjectProperty(prop, propRef) {
        if (isLiteral(prop.key)) prop.computed = true;
        var pattern = prop.value;
        var objRef = memberExpression(cloneNode(propRef), prop.key, prop.computed);

        if (isPattern(pattern)) {
          this.push(pattern, objRef);
        } else {
          this.nodes.push(this.buildVariableAssignment(pattern, objRef));
        }
      };

      _proto.pushObjectPattern = function pushObjectPattern(pattern, objRef) {
        if (!pattern.properties.length) {
          this.nodes.push(expressionStatement(callExpression(this.addHelper("objectDestructuringEmpty"), [objRef])));
        }

        if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {
          var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);
          this.nodes.push(this.buildVariableDeclaration(temp, objRef));
          objRef = temp;
        }

        if (hasObjectRest(pattern)) {
          var copiedPattern;

          for (var i = 0; i < pattern.properties.length; i++) {
            var prop = pattern.properties[i];

            if (isRestElement(prop)) {
              break;
            }

            var key = prop.key;

            if (prop.computed && !this.scope.isPure(key)) {
              var name = this.scope.generateUidIdentifierBasedOnNode(key);
              this.nodes.push(this.buildVariableDeclaration(name, key));

              if (!copiedPattern) {
                copiedPattern = pattern = Object.assign({}, pattern, {
                  properties: pattern.properties.slice()
                });
              }

              copiedPattern.properties[i] = Object.assign({}, copiedPattern.properties[i], {
                key: name
              });
            }
          }
        }

        for (var _i4 = 0; _i4 < pattern.properties.length; _i4++) {
          var _prop = pattern.properties[_i4];

          if (isRestElement(_prop)) {
            this.pushObjectRest(pattern, objRef, _prop, _i4);
          } else {
            this.pushObjectProperty(_prop, objRef);
          }
        }
      };

      _proto.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {
        if (!isArrayExpression(arr)) return false;
        if (pattern.elements.length > arr.elements.length) return;

        if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) {
          return false;
        }

        for (var _i5 = 0, _arr4 = pattern.elements; _i5 < _arr4.length; _i5++) {
          var elem = _arr4[_i5];
          if (!elem) return false;
          if (isMemberExpression(elem)) return false;
        }

        for (var _i6 = 0, _arr5 = arr.elements; _i6 < _arr5.length; _i6++) {
          var _elem = _arr5[_i6];
          if (isSpreadElement(_elem)) return false;
          if (isCallExpression(_elem)) return false;
          if (isMemberExpression(_elem)) return false;
        }

        var bindings = getBindingIdentifiers$1(pattern);
        var state = {
          deopt: false,
          bindings: bindings
        };

        try {
          traverse$1(arr, arrayUnpackVisitor, state);
        } catch (e) {
          if (e !== STOP_TRAVERSAL) throw e;
        }

        return !state.deopt;
      };

      _proto.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {
        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];

          if (isRestElement(elem)) {
            this.push(elem.argument, arrayExpression(arr.elements.slice(i)));
          } else {
            this.push(elem, arr.elements[i]);
          }
        }
      };

      _proto.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {
        if (!pattern.elements) return;

        if (this.canUnpackArrayPattern(pattern, arrayRef)) {
          return this.pushUnpackedArrayPattern(pattern, arrayRef);
        }

        var count = !hasRest(pattern) && pattern.elements.length;
        var toArray = this.toArray(arrayRef, count);

        if (isIdentifier(toArray)) {
          arrayRef = toArray;
        } else {
          arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);
          this.arrays[arrayRef.name] = true;
          this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));
        }

        for (var i = 0; i < pattern.elements.length; i++) {
          var elem = pattern.elements[i];
          if (!elem) continue;
          var elemRef = void 0;

          if (isRestElement(elem)) {
            elemRef = this.toArray(arrayRef);
            elemRef = callExpression(memberExpression(elemRef, identifier("slice")), [numericLiteral(i)]);
            elem = elem.argument;
          } else {
            elemRef = memberExpression(arrayRef, numericLiteral(i), true);
          }

          this.push(elem, elemRef);
        }
      };

      _proto.init = function init(pattern, ref) {
        if (!isArrayExpression(ref) && !isMemberExpression(ref)) {
          var memo = this.scope.maybeGenerateMemoised(ref, true);

          if (memo) {
            this.nodes.push(this.buildVariableDeclaration(memo, cloneNode(ref)));
            ref = memo;
          }
        }

        this.push(pattern, ref);
        return this.nodes;
      };

      return DestructuringTransformer;
    }();

    return {
      name: "transform-destructuring",
      visitor: {
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var declaration = path.get("declaration");
          if (!declaration.isVariableDeclaration()) return;
          if (!variableDeclarationHasPattern(declaration.node)) return;
          var specifiers = [];

          for (var _i7 = 0, _Object$keys = Object.keys(path.getOuterBindingIdentifiers(path)); _i7 < _Object$keys.length; _i7++) {
            var name = _Object$keys[_i7];
            specifiers.push(exportSpecifier(identifier(name), identifier(name)));
          }

          path.replaceWith(declaration.node);
          path.insertAfter(exportNamedDeclaration(null, specifiers));
        },
        ForXStatement: function ForXStatement(path) {
          var _this = this;

          var node = path.node,
              scope = path.scope;
          var left = node.left;

          if (isPattern(left)) {
            var temp = scope.generateUidIdentifier("ref");
            node.left = variableDeclaration("var", [variableDeclarator(temp)]);
            path.ensureBlock();

            if (node.body.body.length === 0 && path.isCompletionRecord()) {
              node.body.body.unshift(expressionStatement(scope.buildUndefinedNode()));
            }

            node.body.body.unshift(expressionStatement(assignmentExpression("=", left, temp)));
            return;
          }

          if (!isVariableDeclaration(left)) return;
          var pattern = left.declarations[0].id;
          if (!isPattern(pattern)) return;
          var key = scope.generateUidIdentifier("ref");
          node.left = variableDeclaration(left.kind, [variableDeclarator(key, null)]);
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: left.kind,
            scope: scope,
            nodes: nodes,
            iterableIsArray: iterableIsArray,
            arrayLikeIsIterable: arrayLikeIsIterable,
            addHelper: function addHelper(name) {
              return _this.addHelper(name);
            }
          });
          destructuring.init(pattern, key);
          path.ensureBlock();
          var block = node.body;
          block.body = nodes.concat(block.body);
        },
        CatchClause: function CatchClause(_ref2) {
          var _this2 = this;

          var node = _ref2.node,
              scope = _ref2.scope;
          var pattern = node.param;
          if (!isPattern(pattern)) return;
          var ref = scope.generateUidIdentifier("ref");
          node.param = ref;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            kind: "let",
            scope: scope,
            nodes: nodes,
            iterableIsArray: iterableIsArray,
            arrayLikeIsIterable: arrayLikeIsIterable,
            addHelper: function addHelper(name) {
              return _this2.addHelper(name);
            }
          });
          destructuring.init(pattern, ref);
          node.body.body = nodes.concat(node.body.body);
        },
        AssignmentExpression: function AssignmentExpression(path) {
          var _this3 = this;

          var node = path.node,
              scope = path.scope;
          if (!isPattern(node.left)) return;
          var nodes = [];
          var destructuring = new DestructuringTransformer({
            operator: node.operator,
            scope: scope,
            nodes: nodes,
            iterableIsArray: iterableIsArray,
            arrayLikeIsIterable: arrayLikeIsIterable,
            addHelper: function addHelper(name) {
              return _this3.addHelper(name);
            }
          });
          var ref;

          if (path.isCompletionRecord() || !path.parentPath.isExpressionStatement()) {
            ref = scope.generateUidIdentifierBasedOnNode(node.right, "ref");
            nodes.push(variableDeclaration("var", [variableDeclarator(ref, node.right)]));

            if (isArrayExpression(node.right)) {
              destructuring.arrays[ref.name] = true;
            }
          }

          destructuring.init(node.left, ref || node.right);

          if (ref) {
            if (path.parentPath.isArrowFunctionExpression()) {
              path.replaceWith(blockStatement([]));
              nodes.push(returnStatement(cloneNode(ref)));
            } else {
              nodes.push(expressionStatement(cloneNode(ref)));
            }
          }

          path.replaceWithMultiple(nodes);
          path.scope.crawl();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          var _this4 = this;

          var node = path.node,
              scope = path.scope,
              parent = path.parent;
          if (isForXStatement(parent)) return;
          if (!parent || !path.container) return;
          if (!variableDeclarationHasPattern(node)) return;
          var nodeKind = node.kind;
          var nodeLoc = node.loc;
          var nodes = [];
          var declar;

          for (var i = 0; i < node.declarations.length; i++) {
            declar = node.declarations[i];
            var patternId = declar.init;
            var pattern = declar.id;
            var destructuring = new DestructuringTransformer({
              blockHoist: node._blockHoist,
              nodes: nodes,
              scope: scope,
              kind: node.kind,
              iterableIsArray: iterableIsArray,
              arrayLikeIsIterable: arrayLikeIsIterable,
              addHelper: function addHelper(name) {
                return _this4.addHelper(name);
              }
            });

            if (isPattern(pattern)) {
              destructuring.init(pattern, patternId);

              if (+i !== node.declarations.length - 1) {
                inherits(nodes[nodes.length - 1], declar);
              }
            } else {
              nodes.push(inherits(destructuring.buildVariableAssignment(declar.id, cloneNode(declar.init)), declar));
            }
          }

          var tail = null;
          var nodesOut = [];

          for (var _i8 = 0, _nodes = nodes; _i8 < _nodes.length; _i8++) {
            var _node = _nodes[_i8];

            if (tail !== null && isVariableDeclaration(_node)) {
              var _tail$declarations;

              (_tail$declarations = tail.declarations).push.apply(_tail$declarations, _toConsumableArray(_node.declarations));
            } else {
              _node.kind = nodeKind;

              if (!_node.loc) {
                _node.loc = nodeLoc;
              }

              nodesOut.push(_node);
              tail = isVariableDeclaration(_node) ? _node : null;
            }
          }

          for (var _i9 = 0, _nodesOut = nodesOut; _i9 < _nodesOut.length; _i9++) {
            var nodeOut = _nodesOut[_i9];
            if (!nodeOut.declarations) continue;

            for (var _iterator = _createForOfIteratorHelperLoose(nodeOut.declarations), _step; !(_step = _iterator()).done;) {
              var declaration = _step.value;
              var name = declaration.id.name;

              if (scope.bindings[name]) {
                scope.bindings[name].kind = nodeOut.kind;
              }
            }
          }

          if (nodesOut.length === 1) {
            path.replaceWith(nodesOut[0]);
          } else {
            path.replaceWithMultiple(nodesOut);
          }
        }
      }
    };
  });

  var _transformDotallRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-dotall-regex",
      feature: "dotAllFlag"
    });
  });

  function getName(key) {
    if (isIdentifier(key)) {
      return key.name;
    }

    return key.value.toString();
  }

  var _transformDuplicateKeys = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-duplicate-keys",
      visitor: {
        ObjectExpression: function ObjectExpression(path) {
          var node = path.node;
          var plainProps = node.properties.filter(function (prop) {
            return !isSpreadElement(prop) && !prop.computed;
          });
          var alreadySeenData = Object.create(null);
          var alreadySeenGetters = Object.create(null);
          var alreadySeenSetters = Object.create(null);

          for (var _iterator = _createForOfIteratorHelperLoose(plainProps), _step; !(_step = _iterator()).done;) {
            var prop = _step.value;
            var name = getName(prop.key);
            var isDuplicate = false;

            switch (prop.kind) {
              case "get":
                if (alreadySeenData[name] || alreadySeenGetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenGetters[name] = true;
                break;

              case "set":
                if (alreadySeenData[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenSetters[name] = true;
                break;

              default:
                if (alreadySeenData[name] || alreadySeenGetters[name] || alreadySeenSetters[name]) {
                  isDuplicate = true;
                }

                alreadySeenData[name] = true;
            }

            if (isDuplicate) {
              prop.computed = true;
              prop.key = stringLiteral(name);
            }
          }
        }
      }
    };
  });

  function getObjRef(node, nodes, scope) {
    var ref;

    if (isIdentifier(node)) {
      if (scope.hasBinding(node.name)) {
        return node;
      } else {
        ref = node;
      }
    } else if (isMemberExpression(node)) {
      ref = node.object;

      if (isSuper(ref) || isIdentifier(ref) && scope.hasBinding(ref.name)) {
        return ref;
      }
    } else {
      throw new Error("We can't explode this node type " + node["type"]);
    }

    var temp = scope.generateUidIdentifierBasedOnNode(ref);
    scope.push({
      id: temp
    });
    nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(ref)));
    return temp;
  }

  function getPropRef(node, nodes, scope) {
    var prop = node.property;

    if (isPrivateName(prop)) {
      throw new Error("We can't generate property ref for private name, please install `@babel/plugin-proposal-class-properties`");
    }

    var key = toComputedKey$1(node, prop);
    if (isLiteral(key) && isPureish(key)) return key;
    var temp = scope.generateUidIdentifierBasedOnNode(prop);
    scope.push({
      id: temp
    });
    nodes.push(assignmentExpression("=", cloneNode(temp), cloneNode(prop)));
    return temp;
  }

  function explode (node, nodes, file, scope, allowedSingleIdent) {
    var obj;

    if (isIdentifier(node) && allowedSingleIdent) {
      obj = node;
    } else {
      obj = getObjRef(node, nodes, scope);
    }

    var ref, uid;

    if (isIdentifier(node)) {
      ref = cloneNode(node);
      uid = obj;
    } else {
      var prop = getPropRef(node, nodes, scope);
      var computed = node.computed || isLiteral(prop);
      uid = memberExpression(cloneNode(obj), cloneNode(prop), computed);
      ref = memberExpression(cloneNode(obj), cloneNode(prop), computed);
    }

    return {
      uid: uid,
      ref: ref
    };
  }

  function build (opts) {
    var build = opts.build,
        operator = opts.operator;
    return {
      AssignmentExpression: function AssignmentExpression(path) {
        var node = path.node,
            scope = path.scope;
        if (node.operator !== operator + "=") return;
        var nodes = [];
        var exploded = explode(node.left, nodes, this, scope);
        nodes.push(assignmentExpression("=", exploded.ref, build(exploded.uid, node.right)));
        path.replaceWith(sequenceExpression(nodes));
      },
      BinaryExpression: function BinaryExpression(path) {
        var node = path.node;

        if (node.operator === operator) {
          path.replaceWith(build(node.left, node.right));
        }
      }
    };
  }

  var transformExponentialOperator = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-exponentiation-operator",
      visitor: build({
        operator: "**",
        build: function build(left, right) {
          return callExpression(memberExpression(identifier("Math"), identifier("pow")), [left, right]);
        }
      })
    };
  });

  var transformFlowComments = declare(function (api) {
    api.assertVersion(7);

    function commentFromString(comment) {
      return typeof comment === "string" ? {
        type: "CommentBlock",
        value: comment
      } : comment;
    }

    function attachComment(_ref) {
      var _toPath;

      var ofPath = _ref.ofPath,
          toPath = _ref.toPath,
          _ref$where = _ref.where,
          where = _ref$where === void 0 ? "trailing" : _ref$where,
          _ref$optional = _ref.optional,
          optional = _ref$optional === void 0 ? false : _ref$optional,
          _ref$comments = _ref.comments,
          comments = _ref$comments === void 0 ? generateComment(ofPath, optional) : _ref$comments,
          _ref$keepType = _ref.keepType,
          keepType = _ref$keepType === void 0 ? false : _ref$keepType;

      if (!((_toPath = toPath) != null && _toPath.node)) {
        toPath = ofPath.getPrevSibling();
        where = "trailing";
      }

      if (!toPath.node) {
        toPath = ofPath.getNextSibling();
        where = "leading";
      }

      if (!toPath.node) {
        toPath = ofPath.parentPath;
        where = "inner";
      }

      if (!Array.isArray(comments)) {
        comments = [comments];
      }

      comments = comments.map(commentFromString);

      if (!keepType && ofPath != null && ofPath.node) {
        var node = ofPath.node;
        var parent = ofPath.parentPath;
        var prev = ofPath.getPrevSibling();
        var next = ofPath.getNextSibling();
        var isSingleChild = !(prev.node || next.node);
        var leading = node.leadingComments;
        var trailing = node.trailingComments;

        if (isSingleChild && leading) {
          parent.addComments("inner", leading);
        }

        toPath.addComments(where, comments);
        ofPath.remove();

        if (isSingleChild && trailing) {
          parent.addComments("inner", trailing);
        }
      } else {
        toPath.addComments(where, comments);
      }
    }

    function wrapInFlowComment(path) {
      attachComment({
        ofPath: path,
        comments: generateComment(path, path.parent.optional)
      });
    }

    function generateComment(path, optional) {
      var comment = path.getSource().replace(/\*-\//g, "*-ESCAPED/").replace(/\*\//g, "*-/");
      if (optional) comment = "?" + comment;
      if (comment[0] !== ":") comment = ":: " + comment;
      return comment;
    }

    function isTypeImport(importKind) {
      return importKind === "type" || importKind === "typeof";
    }

    return {
      name: "transform-flow-comments",
      inherits: syntaxFlow,
      visitor: {
        TypeCastExpression: function TypeCastExpression(path) {
          var node = path.node;
          attachComment({
            ofPath: path.get("typeAnnotation"),
            toPath: path.get("expression"),
            keepType: true
          });
          path.replaceWith(parenthesizedExpression(node.expression));
        },
        Identifier: function Identifier(path) {
          if (path.parentPath.isFlow()) return;
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });

            if (node.optional) {
              node.optional = false;
            }
          } else if (node.optional) {
            attachComment({
              toPath: path,
              comments: ":: ?"
            });
            node.optional = false;
          }
        },
        AssignmentPattern: {
          exit: function exit(_ref2) {
            var node = _ref2.node;
            var left = node.left;

            if (left.optional) {
              left.optional = false;
            }
          }
        },
        Function: function Function(path) {
          if (path.isDeclareFunction()) return;
          var node = path.node;

          if (node.typeParameters) {
            attachComment({
              ofPath: path.get("typeParameters"),
              toPath: path.get("id"),
              optional: node.typeParameters.optional
            });
          }

          if (node.returnType) {
            attachComment({
              ofPath: path.get("returnType"),
              toPath: path.get("body"),
              where: "leading",
              optional: node.returnType.typeAnnotation.optional
            });
          }
        },
        ClassProperty: function ClassProperty(path) {
          var node = path.node;

          if (!node.value) {
            wrapInFlowComment(path);
          } else if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path.get("key"),
              optional: node.typeAnnotation.optional
            });
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path) {
          var node = path.node;

          if (node.exportKind !== "type" && !isFlow(node.declaration)) {
            return;
          }

          wrapInFlowComment(path);
        },
        ImportDeclaration: function ImportDeclaration(path) {
          var node = path.node;

          if (isTypeImport(node.importKind)) {
            wrapInFlowComment(path);
            return;
          }

          var typeSpecifiers = node.specifiers.filter(function (specifier) {
            return isTypeImport(specifier.importKind);
          });
          var nonTypeSpecifiers = node.specifiers.filter(function (specifier) {
            return !isTypeImport(specifier.importKind);
          });
          node.specifiers = nonTypeSpecifiers;

          if (typeSpecifiers.length > 0) {
            var typeImportNode = cloneNode(node);
            typeImportNode.specifiers = typeSpecifiers;
            var comment = ":: " + generate$1(typeImportNode).code;

            if (nonTypeSpecifiers.length > 0) {
              attachComment({
                toPath: path,
                comments: comment
              });
            } else {
              attachComment({
                ofPath: path,
                comments: comment
              });
            }
          }
        },
        ObjectPattern: function ObjectPattern(path) {
          var node = path.node;

          if (node.typeAnnotation) {
            attachComment({
              ofPath: path.get("typeAnnotation"),
              toPath: path,
              optional: node.optional || node.typeAnnotation.optional
            });
          }
        },
        Flow: function Flow(path) {
          wrapInFlowComment(path);
        },
        Class: function Class(path) {
          var node = path.node;
          var comments = [];

          if (node.typeParameters) {
            var typeParameters = path.get("typeParameters");
            comments.push(generateComment(typeParameters, node.typeParameters.optional));
            var trailingComments = node.typeParameters.trailingComments;

            if (trailingComments) {
              var _comments;

              (_comments = comments).push.apply(_comments, _toConsumableArray(trailingComments));
            }

            typeParameters.remove();
          }

          if (node.superClass) {
            if (comments.length > 0) {
              attachComment({
                toPath: path.get("id"),
                comments: comments
              });
              comments = [];
            }

            if (node.superTypeParameters) {
              var superTypeParameters = path.get("superTypeParameters");
              comments.push(generateComment(superTypeParameters, superTypeParameters.node.optional));
              superTypeParameters.remove();
            }
          }

          if (node["implements"]) {
            var impls = path.get("implements");
            var comment = "implements " + impls.map(function (impl) {
              return generateComment(impl).replace(/^:: /, "");
            }).join(", ");
            delete node["implements"];

            if (comments.length === 1) {
              comments[0] += " " + comment;
            } else {
              comments.push(":: " + comment);
            }
          }

          if (comments.length > 0) {
            attachComment({
              toPath: path.get("body"),
              where: "leading",
              comments: comments
            });
          }
        }
      }
    };
  });

  var transformFlowStripTypes = declare(function (api, opts) {
    api.assertVersion(7);
    var FLOW_DIRECTIVE = /(@flow(\s+(strict(-local)?|weak))?|@noflow)/;
    var skipStrip = false;
    var _opts$requireDirectiv = opts.requireDirective,
        requireDirective = _opts$requireDirectiv === void 0 ? false : _opts$requireDirectiv;
    {
      var _opts$allowDeclareFie = opts.allowDeclareFields,
          allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
    }
    return {
      name: "transform-flow-strip-types",
      inherits: syntaxFlow,
      visitor: {
        Program: function Program(path, _ref) {
          var comments = _ref.file.ast.comments;
          skipStrip = false;
          var directiveFound = false;

          if (comments) {
            for (var _i = 0, _arr = comments; _i < _arr.length; _i++) {
              var comment = _arr[_i];

              if (FLOW_DIRECTIVE.test(comment.value)) {
                directiveFound = true;
                comment.value = comment.value.replace(FLOW_DIRECTIVE, "");

                if (!comment.value.replace(/\*/g, "").trim()) {
                  comment.ignore = true;
                }
              }
            }
          }

          if (!directiveFound && requireDirective) {
            skipStrip = true;
          }
        },
        ImportDeclaration: function ImportDeclaration(path) {
          if (skipStrip) return;
          if (!path.node.specifiers.length) return;
          var typeCount = 0;
          path.node.specifiers.forEach(function (_ref2) {
            var importKind = _ref2.importKind;

            if (importKind === "type" || importKind === "typeof") {
              typeCount++;
            }
          });

          if (typeCount === path.node.specifiers.length) {
            path.remove();
          }
        },
        Flow: function Flow(path) {
          if (skipStrip) {
            throw path.buildCodeFrameError("A @flow directive is required when using Flow annotations with " + "the `requireDirective` option.");
          }

          path.remove();
        },
        ClassPrivateProperty: function ClassPrivateProperty(path) {
          if (skipStrip) return;
          path.node.typeAnnotation = null;
        },
        Class: function Class(path) {
          if (skipStrip) return;
          path.node["implements"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassProperty()) {
              var node = child.node;
              {
                if (!allowDeclareFields && node.declare) {
                  throw child.buildCodeFrameError("The 'declare' modifier is only allowed when the " + "'allowDeclareFields' option of " + "@babel/plugin-transform-flow-strip-types or " + "@babel/preset-flow is enabled.");
                }
              }

              if (node.declare) {
                child.remove();
              } else {
                {
                  if (!allowDeclareFields && !node.value && !node.decorators) {
                    child.remove();
                    return;
                  }
                }
                node.variance = null;
                node.typeAnnotation = null;
              }
            }
          });
        },
        AssignmentPattern: function AssignmentPattern(_ref3) {
          var node = _ref3.node;
          if (skipStrip) return;
          node.left.optional = false;
        },
        Function: function Function(_ref4) {
          var node = _ref4.node;
          if (skipStrip) return;

          if (node.params.length > 0 && node.params[0].type === "Identifier" && node.params[0].name === "this") {
            node.params.shift();
          }

          for (var i = 0; i < node.params.length; i++) {
            var param = node.params[i];
            param.optional = false;

            if (param.type === "AssignmentPattern") {
              param.left.optional = false;
            }
          }

          node.predicate = null;
        },
        TypeCastExpression: function TypeCastExpression(path) {
          if (skipStrip) return;
          var node = path.node;

          do {
            node = node.expression;
          } while (isTypeCastExpression(node));

          path.replaceWith(node);
        },
        CallExpression: function CallExpression(_ref5) {
          var node = _ref5.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        OptionalCallExpression: function OptionalCallExpression(_ref6) {
          var node = _ref6.node;
          if (skipStrip) return;
          node.typeArguments = null;
        },
        NewExpression: function NewExpression(_ref7) {
          var node = _ref7.node;
          if (skipStrip) return;
          node.typeArguments = null;
        }
      }
    };
  });

  function transformWithoutHelper(loose, path, state) {
    var pushComputedProps = loose ? pushComputedPropsLoose : pushComputedPropsSpec;
    var node = path.node;
    var build = pushComputedProps(path, state);
    var declar = build.declar;
    var loop = build.loop;
    var block = loop.body;
    path.ensureBlock();

    if (declar) {
      block.body.push(declar);
    }

    block.body = block.body.concat(node.body.body);
    inherits(loop, node);
    inherits(loop.body, node.body);

    if (build.replaceParent) {
      path.parentPath.replaceWithMultiple(build.node);
      path.remove();
    } else {
      path.replaceWithMultiple(build.node);
    }
  }
  var buildForOfLoose = template$2("\n  for (var LOOP_OBJECT = OBJECT,\n          IS_ARRAY = Array.isArray(LOOP_OBJECT),\n          INDEX = 0,\n          LOOP_OBJECT = IS_ARRAY ? LOOP_OBJECT : LOOP_OBJECT[Symbol.iterator]();;) {\n    INTERMEDIATE;\n    if (IS_ARRAY) {\n      if (INDEX >= LOOP_OBJECT.length) break;\n      ID = LOOP_OBJECT[INDEX++];\n    } else {\n      INDEX = LOOP_OBJECT.next();\n      if (INDEX.done) break;\n      ID = INDEX.value;\n    }\n  }\n");
  var buildForOf = template$2("\n  var ITERATOR_COMPLETION = true;\n  var ITERATOR_HAD_ERROR_KEY = false;\n  var ITERATOR_ERROR_KEY = undefined;\n  try {\n    for (\n      var ITERATOR_KEY = OBJECT[Symbol.iterator](), STEP_KEY;\n      !(ITERATOR_COMPLETION = (STEP_KEY = ITERATOR_KEY.next()).done);\n      ITERATOR_COMPLETION = true\n    ) {}\n  } catch (err) {\n    ITERATOR_HAD_ERROR_KEY = true;\n    ITERATOR_ERROR_KEY = err;\n  } finally {\n    try {\n      if (!ITERATOR_COMPLETION && ITERATOR_KEY.return != null) {\n        ITERATOR_KEY.return();\n      }\n    } finally {\n      if (ITERATOR_HAD_ERROR_KEY) {\n        throw ITERATOR_ERROR_KEY;\n      }\n    }\n  }\n");

  function pushComputedPropsLoose(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar, id, intermediate;

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      id = left;
      intermediate = null;
    } else if (isVariableDeclaration(left)) {
      id = scope.generateUidIdentifier("ref");
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, identifier(id.name))]);
      intermediate = variableDeclaration("var", [variableDeclarator(identifier(id.name))]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var iteratorKey = scope.generateUidIdentifier("iterator");
    var isArrayKey = scope.generateUidIdentifier("isArray");
    var loop = buildForOfLoose({
      LOOP_OBJECT: iteratorKey,
      IS_ARRAY: isArrayKey,
      OBJECT: node.right,
      INDEX: scope.generateUidIdentifier("i"),
      ID: id,
      INTERMEDIATE: intermediate
    });
    var isLabeledParent = isLabeledStatement(parent);
    var labeled;

    if (isLabeledParent) {
      labeled = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      node: labeled || loop,
      loop: loop
    };
  }

  function pushComputedPropsSpec(path, file) {
    var node = path.node,
        scope = path.scope,
        parent = path.parent;
    var left = node.left;
    var declar;
    var stepKey = scope.generateUid("step");
    var stepValue = memberExpression(identifier(stepKey), identifier("value"));

    if (isIdentifier(left) || isPattern(left) || isMemberExpression(left)) {
      declar = expressionStatement(assignmentExpression("=", left, stepValue));
    } else if (isVariableDeclaration(left)) {
      declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
    } else {
      throw file.buildCodeFrameError(left, "Unknown node type " + left.type + " in ForStatement");
    }

    var template = buildForOf({
      ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier("didIteratorError"),
      ITERATOR_COMPLETION: scope.generateUidIdentifier("iteratorNormalCompletion"),
      ITERATOR_ERROR_KEY: scope.generateUidIdentifier("iteratorError"),
      ITERATOR_KEY: scope.generateUidIdentifier("iterator"),
      STEP_KEY: identifier(stepKey),
      OBJECT: node.right
    });
    var isLabeledParent = isLabeledStatement(parent);
    var tryBody = template[3].block.body;
    var loop = tryBody[0];

    if (isLabeledParent) {
      tryBody[0] = labeledStatement(parent.label, loop);
    }

    return {
      replaceParent: isLabeledParent,
      declar: declar,
      loop: loop,
      node: template
    };
  }

  var _templateObject$9, _templateObject2$5, _templateObject3$4;
  var _transformForOf = declare(function (api, options) {
    var _options$assumeArray, _options$allowArrayLi, _api$assumption;

    api.assertVersion(7);
    {
      var assumeArray = options.assumeArray,
          allowArrayLike = options.allowArrayLike,
          loose = options.loose;

      if (loose === true && assumeArray === true) {
        throw new Error("The loose and assumeArray options cannot be used together in @babel/plugin-transform-for-of");
      }

      if (assumeArray === true && allowArrayLike === true) {
        throw new Error("The assumeArray and allowArrayLike options cannot be used together in @babel/plugin-transform-for-of");
      }

      if (allowArrayLike && /^7\.\d\./.test(api.version)) {
        throw new Error("The allowArrayLike is only supported when using @babel/core@^7.10.0");
      }
    }
    var iterableIsArray = (_options$assumeArray = options.assumeArray) != null ? _options$assumeArray : !options.loose && api.assumption("iterableIsArray");
    var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");
    var skipteratorClosing = (_api$assumption = api.assumption("skipForOfIteratorClosing")) != null ? _api$assumption : options.loose;

    if (iterableIsArray && arrayLikeIsIterable) {
      throw new Error("The \"iterableIsArray\" and \"arrayLikeIsIterable\" assumptions are not compatible.");
    }

    if (iterableIsArray) {
      return {
        name: "transform-for-of",
        visitor: {
          ForOfStatement: function ForOfStatement(path) {
            var scope = path.scope;
            var _path$node = path.node,
                left = _path$node.left,
                right = _path$node.right,
                isAwait = _path$node["await"];

            if (isAwait) {
              return;
            }

            var i = scope.generateUidIdentifier("i");
            var array = scope.maybeGenerateMemoised(right, true);
            var inits = [variableDeclarator(i, numericLiteral(0))];

            if (array) {
              inits.push(variableDeclarator(array, right));
            } else {
              array = right;
            }

            var item = memberExpression(cloneNode(array), cloneNode(i), true);
            var assignment;

            if (isVariableDeclaration(left)) {
              assignment = left;
              assignment.declarations[0].init = item;
            } else {
              assignment = expressionStatement(assignmentExpression("=", left, item));
            }

            var blockBody;
            var body = path.get("body");

            if (body.isBlockStatement() && Object.keys(path.getBindingIdentifiers()).some(function (id) {
              return body.scope.hasOwnBinding(id);
            })) {
              blockBody = blockStatement([assignment, body.node]);
            } else {
              blockBody = toBlock(body.node);
              blockBody.body.unshift(assignment);
            }

            path.replaceWith(forStatement(variableDeclaration("let", inits), binaryExpression("<", cloneNode(i), memberExpression(cloneNode(array), identifier("length"))), updateExpression("++", cloneNode(i)), blockBody));
          }
        }
      };
    }

    var buildForOfArray = template$2(_templateObject$9 || (_templateObject$9 = _taggedTemplateLiteralLoose(["\n    for (var KEY = 0, NAME = ARR; KEY < NAME.length; KEY++) BODY;\n  "])));
    var buildForOfNoIteratorClosing = template$2.statements(_templateObject2$5 || (_templateObject2$5 = _taggedTemplateLiteralLoose(["\n    for (var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n        !(STEP_KEY = ITERATOR_HELPER()).done;) BODY;\n  "])));
    var buildForOf = template$2.statements(_templateObject3$4 || (_templateObject3$4 = _taggedTemplateLiteralLoose(["\n    var ITERATOR_HELPER = CREATE_ITERATOR_HELPER(OBJECT, ARRAY_LIKE_IS_ITERABLE), STEP_KEY;\n    try {\n      for (ITERATOR_HELPER.s(); !(STEP_KEY = ITERATOR_HELPER.n()).done;) BODY;\n    } catch (err) {\n      ITERATOR_HELPER.e(err);\n    } finally {\n      ITERATOR_HELPER.f();\n    }\n  "])));
    var builder = skipteratorClosing ? {
      build: buildForOfNoIteratorClosing,
      helper: "createForOfIteratorHelperLoose",
      getContainer: function getContainer(nodes) {
        return nodes;
      }
    } : {
      build: buildForOf,
      helper: "createForOfIteratorHelper",
      getContainer: function getContainer(nodes) {
        return nodes[1].block.body;
      }
    };

    function _ForOfStatementArray(path) {
      var node = path.node,
          scope = path.scope;
      var right = scope.generateUidIdentifierBasedOnNode(node.right, "arr");
      var iterationKey = scope.generateUidIdentifier("i");
      var loop = buildForOfArray({
        BODY: node.body,
        KEY: iterationKey,
        NAME: right,
        ARR: node.right
      });
      inherits(loop, node);
      ensureBlock$1(loop);
      var iterationValue = memberExpression(cloneNode(right), cloneNode(iterationKey), true);
      var left = node.left;

      if (isVariableDeclaration(left)) {
        left.declarations[0].init = iterationValue;
        loop.body.body.unshift(left);
      } else {
        loop.body.body.unshift(expressionStatement(assignmentExpression("=", left, iterationValue)));
      }

      return loop;
    }

    return {
      name: "transform-for-of",
      visitor: {
        ForOfStatement: function ForOfStatement(path, state) {
          var right = path.get("right");

          if (right.isArrayExpression() || right.isGenericType("Array") || isArrayTypeAnnotation(right.getTypeAnnotation())) {
            path.replaceWith(_ForOfStatementArray(path));
            return;
          }

          if (!state.availableHelper(builder.helper)) {
            transformWithoutHelper(skipteratorClosing, path, state);
            return;
          }

          var node = path.node,
              parent = path.parent,
              scope = path.scope;
          var left = node.left;
          var declar;
          var stepKey = scope.generateUid("step");
          var stepValue = memberExpression(identifier(stepKey), identifier("value"));

          if (isVariableDeclaration(left)) {
            declar = variableDeclaration(left.kind, [variableDeclarator(left.declarations[0].id, stepValue)]);
          } else {
            declar = expressionStatement(assignmentExpression("=", left, stepValue));
          }

          path.ensureBlock();
          node.body.body.unshift(declar);
          var nodes = builder.build({
            CREATE_ITERATOR_HELPER: state.addHelper(builder.helper),
            ITERATOR_HELPER: scope.generateUidIdentifier("iterator"),
            ARRAY_LIKE_IS_ITERABLE: arrayLikeIsIterable ? booleanLiteral(true) : null,
            STEP_KEY: identifier(stepKey),
            OBJECT: node.right,
            BODY: node.body
          });
          var container = builder.getContainer(nodes);
          inherits(container[0], node);
          inherits(container[0].body, node.body);

          if (isLabeledStatement(parent)) {
            container[0] = labeledStatement(parent.label, container[0]);
            path.parentPath.replaceWithMultiple(nodes);
            path.skip();
          } else {
            path.replaceWithMultiple(nodes);
          }
        }
      }
    };
  });

  var _transformFunctionName = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-function-name",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            if (path.key !== "value" && !path.parentPath.isObjectProperty()) {
              var replacement = nameFunction(path);
              if (replacement) path.replaceWith(replacement);
            }
          }
        },
        ObjectProperty: function ObjectProperty(path) {
          var value = path.get("value");

          if (value.isFunction()) {
            var newNode = nameFunction(value);
            if (newNode) value.replaceWith(newNode);
          }
        }
      }
    };
  });

  var transformInstanceof = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-instanceof",
      visitor: {
        BinaryExpression: function BinaryExpression(path) {
          var node = path.node;

          if (node.operator === "instanceof") {
            var helper = this.addHelper("instanceof");
            var isUnderHelper = path.findParent(function (path) {
              return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
            });

            if (isUnderHelper) {
              return;
            } else {
              path.replaceWith(callExpression(helper, [node.left, node.right]));
            }
          }
        }
      }
    };
  });

  var transformJscript = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-jscript",
      visitor: {
        FunctionExpression: {
          exit: function exit(path) {
            var node = path.node;
            if (!node.id) return;
            path.replaceWith(callExpression(functionExpression(null, [], blockStatement([toStatement(node), returnStatement(cloneNode(node.id))])), []));
          }
        }
      }
    };
  });

  var _transformLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-literals",
      visitor: {
        NumericLiteral: function NumericLiteral(_ref) {
          var node = _ref.node;

          if (node.extra && /^0[ob]/i.test(node.extra.raw)) {
            node.extra = undefined;
          }
        },
        StringLiteral: function StringLiteral(_ref2) {
          var node = _ref2.node;

          if (node.extra && /\\[u]/gi.test(node.extra.raw)) {
            node.extra = undefined;
          }
        }
      }
    };
  });

  var _transformMemberExpressionLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-member-expression-literals",
      visitor: {
        MemberExpression: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var prop = node.property;

            if (!node.computed && isIdentifier(prop) && !isValidES3Identifier(prop.name)) {
              node.property = stringLiteral(prop.name);
              node.computed = true;
            }
          }
        }
      }
    };
  });

  var _slicedToArray$1 = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var getImportSource_1$1 = getImportSource$4;
  var createDynamicImportTransform_1$1 = createDynamicImportTransform$1;

  function getImportSource$4(t, callNode) {
    var importArguments = callNode.arguments;

    var _importArguments = _slicedToArray$1(importArguments, 1),
        importPath = _importArguments[0];

    var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

    if (isString) {
      t.removeComments(importPath);
      return importPath;
    }

    return t.templateLiteral([t.templateElement({
      raw: '',
      cooked: ''
    }), t.templateElement({
      raw: '',
      cooked: ''
    }, true)], importArguments);
  }

  function createDynamicImportTransform$1(_ref) {
    var template = _ref.template,
        t = _ref.types;
    var builders = {
      'static': {
        interop: template('Promise.resolve().then(() => INTEROP(require(SOURCE)))'),
        noInterop: template('Promise.resolve().then(() => require(SOURCE))')
      },
      dynamic: {
        interop: template('Promise.resolve(SOURCE).then(s => INTEROP(require(s)))'),
        noInterop: template('Promise.resolve(SOURCE).then(s => require(s))')
      }
    };
    var visited = typeof WeakSet === 'function' && new WeakSet();

    var isString = function isString(node) {
      return t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0;
    };

    return function (context, path) {
      if (visited) {
        if (visited.has(path)) {
          return;
        }

        visited.add(path);
      }

      var SOURCE = getImportSource$4(t, path.parent);
      var builder = isString(SOURCE) ? builders['static'] : builders.dynamic;
      var newImport = context.opts.noInterop ? builder.noInterop({
        SOURCE: SOURCE
      }) : builder.interop({
        SOURCE: SOURCE,
        INTEROP: context.addHelper('interopRequireWildcard')
      });
      path.parentPath.replaceWith(newImport);
    };
  }

  var utils$3 = Object.defineProperty({
    getImportSource: getImportSource_1$1,
    createDynamicImportTransform: createDynamicImportTransform_1$1
  }, '__esModule', {
    value: true
  });

  var utils$2 = utils$3;

  var _templateObject$8;
  var buildWrapper$1 = template$2("\n  define(MODULE_NAME, AMD_ARGUMENTS, function(IMPORT_NAMES) {\n  })\n");
  var buildAnonymousWrapper = template$2("\n  define([\"require\"], function(REQUIRE) {\n  })\n");

  function injectWrapper(path, wrapper) {
    var _path$node = path.node,
        body = _path$node.body,
        directives = _path$node.directives;
    path.node.directives = [];
    path.node.body = [];
    var amdWrapper = path.pushContainer("body", wrapper)[0];
    var amdFactory = amdWrapper.get("expression.arguments").filter(function (arg) {
      return arg.isFunctionExpression();
    })[0].get("body");
    amdFactory.pushContainer("directives", directives);
    amdFactory.pushContainer("body", body);
  }

  var _transformModulesAmd = declare(function (api, options) {
    var _api$assumption, _api$assumption2;

    api.assertVersion(7);
    var allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        importInterop = options.importInterop,
        noInterop = options.noInterop;
    var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
    var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;
    return {
      name: "transform-modules-amd",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "amd");
      },
      visitor: {
        CallExpression: function CallExpression(path, state) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var requireId = state.requireId,
              resolveId = state.resolveId,
              rejectId = state.rejectId;

          if (!requireId) {
            requireId = path.scope.generateUidIdentifier("require");
            state.requireId = requireId;
          }

          if (!resolveId || !rejectId) {
            resolveId = path.scope.generateUidIdentifier("resolve");
            rejectId = path.scope.generateUidIdentifier("reject");
            state.resolveId = resolveId;
            state.rejectId = rejectId;
          }

          var result = identifier("imported");
          if (!noInterop) result = wrapInterop(path, result, "namespace");
          path.replaceWith(template$2.expression.ast(_templateObject$8 || (_templateObject$8 = _taggedTemplateLiteralLoose(["\n            new Promise((", ", ", ") =>\n              ", "(\n                [", "],\n                imported => ", "(", "),\n                ", "\n              )\n            )"])), resolveId, rejectId, requireId, utils$2.getImportSource(t$p, path.node), cloneNode(resolveId), result, cloneNode(rejectId)));
        },
        Program: {
          exit: function exit(path, _ref) {
            var requireId = _ref.requireId;

            if (!isModule(path)) {
              if (requireId) {
                injectWrapper(path, buildAnonymousWrapper({
                  REQUIRE: cloneNode(requireId)
                }));
              }

              return;
            }

            var amdArgs = [];
            var importNames = [];

            if (requireId) {
              amdArgs.push(stringLiteral("require"));
              importNames.push(cloneNode(requireId));
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              enumerableModuleMeta: enumerableModuleMeta,
              constantReexports: constantReexports,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              importInterop: importInterop,
              noInterop: noInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            if (hasExports(meta)) {
              amdArgs.push(stringLiteral("exports"));
              importNames.push(identifier(meta.exportName));
            }

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _slicedToArray$2(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              amdArgs.push(stringLiteral(source));
              importNames.push(identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = expressionStatement(assignmentExpression("=", identifier(metadata.name), interop));
                  header.loc = metadata.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            injectWrapper(path, buildWrapper$1({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: arrayExpression(amdArgs),
              IMPORT_NAMES: importNames
            }));
          }
        }
      }
    };
  });

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var getImportSource_1 = getImportSource$3;
  var createDynamicImportTransform_1 = createDynamicImportTransform;

  function getImportSource$3(t, callNode) {
    var importArguments = callNode.arguments;

    var _importArguments = _slicedToArray(importArguments, 1),
        importPath = _importArguments[0];

    var isString = t.isStringLiteral(importPath) || t.isTemplateLiteral(importPath);

    if (isString) {
      t.removeComments(importPath);
      return importPath;
    }

    return t.templateLiteral([t.templateElement({
      raw: '',
      cooked: ''
    }), t.templateElement({
      raw: '',
      cooked: ''
    }, true)], importArguments);
  }

  function createDynamicImportTransform(_ref) {
    var template = _ref.template,
        t = _ref.types;
    var builders = {
      'static': {
        interop: template('Promise.resolve().then(() => INTEROP(require(SOURCE)))'),
        noInterop: template('Promise.resolve().then(() => require(SOURCE))')
      },
      dynamic: {
        interop: template('Promise.resolve(SOURCE).then(s => INTEROP(require(s)))'),
        noInterop: template('Promise.resolve(SOURCE).then(s => require(s))')
      }
    };
    var visited = typeof WeakSet === 'function' && new WeakSet();

    var isString = function isString(node) {
      return t.isStringLiteral(node) || t.isTemplateLiteral(node) && node.expressions.length === 0;
    };

    return function (context, path) {
      if (visited) {
        if (visited.has(path)) {
          return;
        }

        visited.add(path);
      }

      var SOURCE = getImportSource$3(t, path.parent);
      var builder = isString(SOURCE) ? builders['static'] : builders.dynamic;
      var newImport = context.opts.noInterop ? builder.noInterop({
        SOURCE: SOURCE
      }) : builder.interop({
        SOURCE: SOURCE,
        INTEROP: context.addHelper('interopRequireWildcard')
      });
      path.parentPath.replaceWith(newImport);
    };
  }

  var utils$1 = Object.defineProperty({
    getImportSource: getImportSource_1,
    createDynamicImportTransform: createDynamicImportTransform_1
  }, '__esModule', {
    value: true
  });

  var utils = utils$1;

  var _templateObject$7, _templateObject2$4, _templateObject3$3;
  var _transformModulesCommonjs = declare(function (api, options) {
    var _api$assumption, _api$assumption2;

    api.assertVersion(7);
    var transformImportCall = utils.createDynamicImportTransform(api);
    var _options$strictNamesp = options.strictNamespace,
        strictNamespace = _options$strictNamesp === void 0 ? false : _options$strictNamesp,
        _options$mjsStrictNam = options.mjsStrictNamespace,
        mjsStrictNamespace = _options$mjsStrictNam === void 0 ? true : _options$mjsStrictNam,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop,
        importInterop = options.importInterop,
        _options$lazy = options.lazy,
        lazy = _options$lazy === void 0 ? false : _options$lazy,
        _options$allowCommonJ = options.allowCommonJSExports,
        allowCommonJSExports = _options$allowCommonJ === void 0 ? true : _options$allowCommonJ;
    var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
    var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;

    if (typeof lazy !== "boolean" && typeof lazy !== "function" && (!Array.isArray(lazy) || !lazy.every(function (item) {
      return typeof item === "string";
    }))) {
      throw new Error(".lazy must be a boolean, array of strings, or a function");
    }

    if (typeof strictNamespace !== "boolean") {
      throw new Error(".strictNamespace must be a boolean, or undefined");
    }

    if (typeof mjsStrictNamespace !== "boolean") {
      throw new Error(".mjsStrictNamespace must be a boolean, or undefined");
    }

    var getAssertion = function getAssertion(localName) {
      return template$2.expression.ast(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose(["\n    (function(){\n      throw new Error(\n        \"The CommonJS '\" + \"", "\" + \"' variable is not available in ES6 modules.\" +\n        \"Consider setting setting sourceType:script or sourceType:unambiguous in your \" +\n        \"Babel config for this file.\");\n    })()\n  "])), localName);
    };

    var moduleExportsVisitor = {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var localName = path.node.name;
        if (localName !== "module" && localName !== "exports") return;
        var localBinding = path.scope.getBinding(localName);
        var rootBinding = this.scope.getBinding(localName);

        if (rootBinding !== localBinding || path.parentPath.isObjectProperty({
          value: path.node
        }) && path.parentPath.parentPath.isObjectPattern() || path.parentPath.isAssignmentExpression({
          left: path.node
        }) || path.isAssignmentExpression({
          left: path.node
        })) {
          return;
        }

        path.replaceWith(getAssertion(localName));
      },
      AssignmentExpression: function AssignmentExpression(path) {
        var _this = this;

        var left = path.get("left");

        if (left.isIdentifier()) {
          var localName = path.node.name;
          if (localName !== "module" && localName !== "exports") return;
          var localBinding = path.scope.getBinding(localName);
          var rootBinding = this.scope.getBinding(localName);
          if (rootBinding !== localBinding) return;
          var right = path.get("right");
          right.replaceWith(sequenceExpression([right.node, getAssertion(localName)]));
        } else if (left.isPattern()) {
          var ids = left.getOuterBindingIdentifiers();
          var _localName = Object.keys(ids).filter(function (localName) {
            if (localName !== "module" && localName !== "exports") return false;
            return _this.scope.getBinding(localName) === path.scope.getBinding(localName);
          })[0];

          if (_localName) {
            var _right = path.get("right");

            _right.replaceWith(sequenceExpression([_right.node, getAssertion(_localName)]));
          }
        }
      }
    };
    return {
      name: "transform-modules-commonjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "commonjs");
      },
      visitor: {
        CallExpression: function CallExpression(path) {
          if (!this.file.has("@babel/plugin-proposal-dynamic-import")) return;
          if (!path.get("callee").isImport()) return;
          var scope = path.scope;

          do {
            scope.rename("require");
          } while (scope = scope.parent);

          transformImportCall(this, path.get("callee"));
        },
        Program: {
          exit: function exit(path, state) {
            if (!isModule(path)) return;
            path.scope.rename("exports");
            path.scope.rename("module");
            path.scope.rename("require");
            path.scope.rename("__filename");
            path.scope.rename("__dirname");

            if (!allowCommonJSExports) {
              simplifyAccess(path, new Set(["module", "exports"]));
              path.traverse(moduleExportsVisitor, {
                scope: path.scope
              });
            }

            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              exportName: "exports",
              constantReexports: constantReexports,
              enumerableModuleMeta: enumerableModuleMeta,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop,
              importInterop: importInterop,
              lazy: lazy,
              esNamespaceOnly: typeof state.filename === "string" && /\.mjs$/.test(state.filename) ? mjsStrictNamespace : strictNamespace
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _slicedToArray$2(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              var loadExpr = callExpression(identifier("require"), [stringLiteral(source)]);
              var header = void 0;

              if (isSideEffectImport(metadata)) {
                if (metadata.lazy) throw new Error("Assertion failure");
                header = expressionStatement(loadExpr);
              } else {
                var init = wrapInterop(path, loadExpr, metadata.interop) || loadExpr;

                if (metadata.lazy) {
                  header = template$2.ast(_templateObject2$4 || (_templateObject2$4 = _taggedTemplateLiteralLoose(["\n                  function ", "() {\n                    const data = ", ";\n                    ", " = function(){ return data; };\n                    return data;\n                  }\n                "])), metadata.name, init, metadata.name);
                } else {
                  header = template$2.ast(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteralLoose(["\n                  var ", " = ", ";\n                "])), metadata.name, init);
                }
              }

              header.loc = metadata.loc;
              headers.push(header);
              headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
          }
        }
      }
    };
  });

  var buildTemplate = template$2("\n  SYSTEM_REGISTER(MODULE_NAME, SOURCES, function (EXPORT_IDENTIFIER, CONTEXT_IDENTIFIER) {\n    \"use strict\";\n    BEFORE_BODY;\n    return {\n      setters: SETTERS,\n      execute: EXECUTE,\n    };\n  });\n");
  var buildExportAll = template$2("\n  for (var KEY in TARGET) {\n    if (KEY !== \"default\" && KEY !== \"__esModule\") EXPORT_OBJ[KEY] = TARGET[KEY];\n  }\n");
  var MISSING_PLUGIN_WARNING = "WARNING: Dynamic import() transformation must be enabled using the\n         @babel/plugin-proposal-dynamic-import plugin. Babel 8 will\n         no longer transform import() without using that plugin.\n";
  function getExportSpecifierName(node, stringSpecifiers) {
    if (node.type === "Identifier") {
      return node.name;
    } else if (node.type === "StringLiteral") {
      var stringValue = node.value;

      if (!isIdentifierName(stringValue)) {
        stringSpecifiers.add(stringValue);
      }

      return stringValue;
    } else {
      throw new Error("Expected export specifier to be either Identifier or StringLiteral, got " + node.type);
    }
  }

  function constructExportCall(path, exportIdent, exportNames, exportValues, exportStarTarget, stringSpecifiers) {
    var statements = [];

    if (!exportStarTarget) {
      if (exportNames.length === 1) {
        statements.push(expressionStatement(callExpression(exportIdent, [stringLiteral(exportNames[0]), exportValues[0]])));
      } else {
        var objectProperties = [];

        for (var i = 0; i < exportNames.length; i++) {
          var exportName = exportNames[i];
          var exportValue = exportValues[i];
          objectProperties.push(objectProperty(stringSpecifiers.has(exportName) ? stringLiteral(exportName) : identifier(exportName), exportValue));
        }

        statements.push(expressionStatement(callExpression(exportIdent, [objectExpression(objectProperties)])));
      }
    } else {
      var exportObj = path.scope.generateUid("exportObj");
      statements.push(variableDeclaration("var", [variableDeclarator(identifier(exportObj), objectExpression([]))]));
      statements.push(buildExportAll({
        KEY: path.scope.generateUidIdentifier("key"),
        EXPORT_OBJ: identifier(exportObj),
        TARGET: exportStarTarget
      }));

      for (var _i = 0; _i < exportNames.length; _i++) {
        var _exportName = exportNames[_i];
        var _exportValue = exportValues[_i];
        statements.push(expressionStatement(assignmentExpression("=", memberExpression(identifier(exportObj), identifier(_exportName)), _exportValue)));
      }

      statements.push(expressionStatement(callExpression(exportIdent, [identifier(exportObj)])));
    }

    return statements;
  }

  var _transformModulesSystemjs = declare(function (api, options) {
    api.assertVersion(7);
    var _options$systemGlobal = options.systemGlobal,
        systemGlobal = _options$systemGlobal === void 0 ? "System" : _options$systemGlobal,
        _options$allowTopLeve = options.allowTopLevelThis,
        allowTopLevelThis = _options$allowTopLeve === void 0 ? false : _options$allowTopLeve;
    var IGNORE_REASSIGNMENT_SYMBOL = Symbol();
    var reassignmentVisitor = {
      "AssignmentExpression|UpdateExpression": function AssignmentExpressionUpdateExpression(path) {
        if (path.node[IGNORE_REASSIGNMENT_SYMBOL]) return;
        path.node[IGNORE_REASSIGNMENT_SYMBOL] = true;
        var arg = path.get(path.isAssignmentExpression() ? "left" : "argument");

        if (arg.isObjectPattern() || arg.isArrayPattern()) {
          var exprs = [path.node];

          for (var _i2 = 0, _Object$keys = Object.keys(arg.getBindingIdentifiers()); _i2 < _Object$keys.length; _i2++) {
            var _name = _Object$keys[_i2];

            if (this.scope.getBinding(_name) !== path.scope.getBinding(_name)) {
              return;
            }

            var _exportedNames = this.exports[_name];
            if (!_exportedNames) return;

            for (var _iterator = _createForOfIteratorHelperLoose(_exportedNames), _step; !(_step = _iterator()).done;) {
              var exportedName = _step.value;
              exprs.push(this.buildCall(exportedName, identifier(_name)).expression);
            }
          }

          path.replaceWith(sequenceExpression(exprs));
          return;
        }

        if (!arg.isIdentifier()) return;
        var name = arg.node.name;
        if (this.scope.getBinding(name) !== path.scope.getBinding(name)) return;
        var exportedNames = this.exports[name];
        if (!exportedNames) return;
        var node = path.node;
        var isPostUpdateExpression = path.isUpdateExpression({
          prefix: false
        });

        if (isPostUpdateExpression) {
          node = binaryExpression(node.operator[0], unaryExpression("+", cloneNode(node.argument)), numericLiteral(1));
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(exportedNames), _step2; !(_step2 = _iterator2()).done;) {
          var _exportedName = _step2.value;
          node = this.buildCall(_exportedName, node).expression;
        }

        if (isPostUpdateExpression) {
          node = sequenceExpression([node, path.node]);
        }

        path.replaceWith(node);
      }
    };
    return {
      name: "transform-modules-systemjs",
      pre: function pre() {
        this.file.set("@babel/plugin-transform-modules-*", "systemjs");
      },
      visitor: {
        CallExpression: function CallExpression(path, state) {
          if (isImport(path.node.callee)) {
            if (!this.file.has("@babel/plugin-proposal-dynamic-import")) {
              {
                console.warn(MISSING_PLUGIN_WARNING);
              }
            }

            path.replaceWith(callExpression(memberExpression(identifier(state.contextIdent), identifier("import")), [utils$2.getImportSource(t$p, path.node)]));
          }
        },
        MetaProperty: function MetaProperty(path, state) {
          if (path.node.meta.name === "import" && path.node.property.name === "meta") {
            path.replaceWith(memberExpression(identifier(state.contextIdent), identifier("meta")));
          }
        },
        ReferencedIdentifier: function ReferencedIdentifier(path, state) {
          if (path.node.name === "__moduleName" && !path.scope.hasBinding("__moduleName")) {
            path.replaceWith(memberExpression(identifier(state.contextIdent), identifier("id")));
          }
        },
        Program: {
          enter: function enter(path, state) {
            state.contextIdent = path.scope.generateUid("context");
            state.stringSpecifiers = new Set();

            if (!allowTopLevelThis) {
              rewriteThis(path);
            }
          },
          exit: function exit(path, state) {
            var scope = path.scope;
            var exportIdent = scope.generateUid("export");
            var contextIdent = state.contextIdent,
                stringSpecifiers = state.stringSpecifiers;
            var exportMap = Object.create(null);
            var modules = [];
            var beforeBody = [];
            var setters = [];
            var sources = [];
            var variableIds = [];
            var removedPaths = [];

            function addExportName(key, val) {
              exportMap[key] = exportMap[key] || [];
              exportMap[key].push(val);
            }

            function pushModule(source, key, specifiers) {
              var module;
              modules.forEach(function (m) {
                if (m.key === source) {
                  module = m;
                }
              });

              if (!module) {
                modules.push(module = {
                  key: source,
                  imports: [],
                  exports: []
                });
              }

              module[key] = module[key].concat(specifiers);
            }

            function buildExportCall(name, val) {
              return expressionStatement(callExpression(identifier(exportIdent), [stringLiteral(name), val]));
            }

            var exportNames = [];
            var exportValues = [];
            var body = path.get("body");

            for (var _iterator3 = _createForOfIteratorHelperLoose(body), _step3; !(_step3 = _iterator3()).done;) {
              var _path2 = _step3.value;

              if (_path2.isFunctionDeclaration()) {
                beforeBody.push(_path2.node);
                removedPaths.push(_path2);
              } else if (_path2.isClassDeclaration()) {
                variableIds.push(cloneNode(_path2.node.id));

                _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(_path2.node.id), toExpression(_path2.node))));
              } else if (_path2.isImportDeclaration()) {
                var source = _path2.node.source.value;
                pushModule(source, "imports", _path2.node.specifiers);

                for (var _i4 = 0, _Object$keys2 = Object.keys(_path2.getBindingIdentifiers()); _i4 < _Object$keys2.length; _i4++) {
                  var name = _Object$keys2[_i4];
                  scope.removeBinding(name);
                  variableIds.push(identifier(name));
                }

                _path2.remove();
              } else if (_path2.isExportAllDeclaration()) {
                pushModule(_path2.node.source.value, "exports", _path2.node);

                _path2.remove();
              } else if (_path2.isExportDefaultDeclaration()) {
                var declar = _path2.get("declaration");

                var id = declar.node.id;

                if (declar.isClassDeclaration()) {
                  if (id) {
                    exportNames.push("default");
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(cloneNode(id));
                    addExportName(id.name, "default");

                    _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(id), toExpression(declar.node))));
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                    removedPaths.push(_path2);
                  }
                } else if (declar.isFunctionDeclaration()) {
                  if (id) {
                    beforeBody.push(declar.node);
                    exportNames.push("default");
                    exportValues.push(cloneNode(id));
                    addExportName(id.name, "default");
                  } else {
                    exportNames.push("default");
                    exportValues.push(toExpression(declar.node));
                  }

                  removedPaths.push(_path2);
                } else {
                  _path2.replaceWith(buildExportCall("default", declar.node));
                }
              } else if (_path2.isExportNamedDeclaration()) {
                var _declar = _path2.get("declaration");

                if (_declar.node) {
                  _path2.replaceWith(_declar);

                  if (_path2.isFunction()) {
                    var node = _declar.node;
                    var _name2 = node.id.name;
                    addExportName(_name2, _name2);
                    beforeBody.push(node);
                    exportNames.push(_name2);
                    exportValues.push(cloneNode(node.id));
                    removedPaths.push(_path2);
                  } else if (_path2.isClass()) {
                    var _name3 = _declar.node.id.name;
                    exportNames.push(_name3);
                    exportValues.push(scope.buildUndefinedNode());
                    variableIds.push(cloneNode(_declar.node.id));

                    _path2.replaceWith(expressionStatement(assignmentExpression("=", cloneNode(_declar.node.id), toExpression(_declar.node))));

                    addExportName(_name3, _name3);
                  } else {
                    for (var _i5 = 0, _Object$keys3 = Object.keys(_declar.getBindingIdentifiers()); _i5 < _Object$keys3.length; _i5++) {
                      var _name4 = _Object$keys3[_i5];
                      addExportName(_name4, _name4);
                    }
                  }
                } else {
                  var specifiers = _path2.node.specifiers;

                  if (specifiers != null && specifiers.length) {
                    if (_path2.node.source) {
                      pushModule(_path2.node.source.value, "exports", specifiers);

                      _path2.remove();
                    } else {
                      var nodes = [];

                      for (var _iterator7 = _createForOfIteratorHelperLoose(specifiers), _step7; !(_step7 = _iterator7()).done;) {
                        var specifier = _step7.value;
                        var local = specifier.local,
                            exported = specifier.exported;
                        var binding = scope.getBinding(local.name);
                        var exportedName = getExportSpecifierName(exported, stringSpecifiers);

                        if (binding && isFunctionDeclaration(binding.path.node)) {
                          exportNames.push(exportedName);
                          exportValues.push(cloneNode(local));
                        } else if (!binding) {
                            nodes.push(buildExportCall(exportedName, local));
                          }

                        addExportName(local.name, exportedName);
                      }

                      _path2.replaceWithMultiple(nodes);
                    }
                  } else {
                    _path2.remove();
                  }
                }
              }
            }

            modules.forEach(function (specifiers) {
              var setterBody = [];
              var target = scope.generateUid(specifiers.key);

              for (var _iterator4 = _createForOfIteratorHelperLoose(specifiers.imports), _step4; !(_step4 = _iterator4()).done;) {
                var specifier = _step4.value;

                if (isImportNamespaceSpecifier(specifier)) {
                  setterBody.push(expressionStatement(assignmentExpression("=", specifier.local, identifier(target))));
                } else if (isImportDefaultSpecifier(specifier)) {
                  specifier = importSpecifier(specifier.local, identifier("default"));
                }

                if (isImportSpecifier(specifier)) {
                  var _specifier = specifier,
                      imported = _specifier.imported;
                  setterBody.push(expressionStatement(assignmentExpression("=", specifier.local, memberExpression(identifier(target), specifier.imported, imported.type === "StringLiteral"))));
                }
              }

              if (specifiers.exports.length) {
                var _exportNames = [];
                var _exportValues = [];
                var hasExportStar = false;

                for (var _iterator5 = _createForOfIteratorHelperLoose(specifiers.exports), _step5; !(_step5 = _iterator5()).done;) {
                  var node = _step5.value;

                  if (isExportAllDeclaration(node)) {
                    hasExportStar = true;
                  } else if (isExportSpecifier(node)) {
                    var exportedName = getExportSpecifierName(node.exported, stringSpecifiers);

                    _exportNames.push(exportedName);

                    _exportValues.push(memberExpression(identifier(target), node.local, isStringLiteral(node.local)));
                  } else ;
                }

                setterBody = setterBody.concat(constructExportCall(path, identifier(exportIdent), _exportNames, _exportValues, hasExportStar ? identifier(target) : null, stringSpecifiers));
              }

              sources.push(stringLiteral(specifiers.key));
              setters.push(functionExpression(null, [identifier(target)], blockStatement(setterBody)));
            });
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);
            hoistVariables(path, function (id, name, hasInit) {
              variableIds.push(id);

              if (!hasInit && name in exportMap) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(exportMap[name]), _step6; !(_step6 = _iterator6()).done;) {
                  var exported = _step6.value;
                  exportNames.push(exported);
                  exportValues.push(scope.buildUndefinedNode());
                }
              }
            }, null);

            if (variableIds.length) {
              beforeBody.unshift(variableDeclaration("var", variableIds.map(function (id) {
                return variableDeclarator(id);
              })));
            }

            if (exportNames.length) {
              beforeBody = beforeBody.concat(constructExportCall(path, identifier(exportIdent), exportNames, exportValues, null, stringSpecifiers));
            }

            path.traverse(reassignmentVisitor, {
              exports: exportMap,
              buildCall: buildExportCall,
              scope: scope
            });

            for (var _i3 = 0, _removedPaths = removedPaths; _i3 < _removedPaths.length; _i3++) {
              var _path = _removedPaths[_i3];

              _path.remove();
            }

            var hasTLA = false;
            path.traverse({
              AwaitExpression: function AwaitExpression(path) {
                hasTLA = true;
                path.stop();
              },
              Function: function Function(path) {
                path.skip();
              },
              noScope: true
            });
            path.node.body = [buildTemplate({
              SYSTEM_REGISTER: memberExpression(identifier(systemGlobal), identifier("register")),
              BEFORE_BODY: beforeBody,
              MODULE_NAME: moduleName,
              SETTERS: arrayExpression(setters),
              EXECUTE: functionExpression(null, [], blockStatement(path.node.body), false, hasTLA),
              SOURCES: arrayExpression(sources),
              EXPORT_IDENTIFIER: identifier(exportIdent),
              CONTEXT_IDENTIFIER: identifier(contextIdent)
            })];
          }
        }
      }
    };
  });

  var buildPrerequisiteAssignment = template$2("\n  GLOBAL_REFERENCE = GLOBAL_REFERENCE || {}\n");
  var buildWrapper = template$2("\n  (function (global, factory) {\n    if (typeof define === \"function\" && define.amd) {\n      define(MODULE_NAME, AMD_ARGUMENTS, factory);\n    } else if (typeof exports !== \"undefined\") {\n      factory(COMMONJS_ARGUMENTS);\n    } else {\n      var mod = { exports: {} };\n      factory(BROWSER_ARGUMENTS);\n\n      GLOBAL_TO_ASSIGN;\n    }\n  })(\n    typeof globalThis !== \"undefined\" ? globalThis\n      : typeof self !== \"undefined\" ? self\n      : this,\n    function(IMPORT_NAMES) {\n  })\n");
  var _transformModulesUmd = declare(function (api, options) {
    var _api$assumption, _api$assumption2;

    api.assertVersion(7);
    var globals = options.globals,
        exactGlobals = options.exactGlobals,
        allowTopLevelThis = options.allowTopLevelThis,
        strict = options.strict,
        strictMode = options.strictMode,
        noInterop = options.noInterop,
        importInterop = options.importInterop;
    var constantReexports = (_api$assumption = api.assumption("constantReexports")) != null ? _api$assumption : options.loose;
    var enumerableModuleMeta = (_api$assumption2 = api.assumption("enumerableModuleMeta")) != null ? _api$assumption2 : options.loose;

    function buildBrowserInit(browserGlobals, exactGlobals, filename, moduleName) {
      var moduleNameOrBasename = moduleName ? moduleName.value : basename(filename, extname(filename));
      var globalToAssign = memberExpression(identifier("global"), identifier(toIdentifier(moduleNameOrBasename)));
      var initAssignments = [];

      if (exactGlobals) {
        var globalName = browserGlobals[moduleNameOrBasename];

        if (globalName) {
          initAssignments = [];
          var members = globalName.split(".");
          globalToAssign = members.slice(1).reduce(function (accum, curr) {
            initAssignments.push(buildPrerequisiteAssignment({
              GLOBAL_REFERENCE: cloneNode(accum)
            }));
            return memberExpression(accum, identifier(curr));
          }, memberExpression(identifier("global"), identifier(members[0])));
        }
      }

      initAssignments.push(expressionStatement(assignmentExpression("=", globalToAssign, memberExpression(identifier("mod"), identifier("exports")))));
      return initAssignments;
    }

    function buildBrowserArg(browserGlobals, exactGlobals, source) {
      var memberExpression$1;

      if (exactGlobals) {
        var globalRef = browserGlobals[source];

        if (globalRef) {
          memberExpression$1 = globalRef.split(".").reduce(function (accum, curr) {
            return memberExpression(accum, identifier(curr));
          }, identifier("global"));
        } else {
          memberExpression$1 = memberExpression(identifier("global"), identifier(toIdentifier(source)));
        }
      } else {
        var requireName = basename(source, extname(source));
        var globalName = browserGlobals[requireName] || requireName;
        memberExpression$1 = memberExpression(identifier("global"), identifier(toIdentifier(globalName)));
      }

      return memberExpression$1;
    }

    return {
      name: "transform-modules-umd",
      visitor: {
        Program: {
          exit: function exit(path) {
            if (!isModule(path)) return;
            var browserGlobals = globals || {};
            var moduleName = getModuleName(this.file.opts, options);
            if (moduleName) moduleName = stringLiteral(moduleName);

            var _rewriteModuleStateme = rewriteModuleStatementsAndPrepareHeader(path, {
              constantReexports: constantReexports,
              enumerableModuleMeta: enumerableModuleMeta,
              strict: strict,
              strictMode: strictMode,
              allowTopLevelThis: allowTopLevelThis,
              noInterop: noInterop,
              importInterop: importInterop
            }),
                meta = _rewriteModuleStateme.meta,
                headers = _rewriteModuleStateme.headers;

            var amdArgs = [];
            var commonjsArgs = [];
            var browserArgs = [];
            var importNames = [];

            if (hasExports(meta)) {
              amdArgs.push(stringLiteral("exports"));
              commonjsArgs.push(identifier("exports"));
              browserArgs.push(memberExpression(identifier("mod"), identifier("exports")));
              importNames.push(identifier(meta.exportName));
            }

            for (var _iterator = _createForOfIteratorHelperLoose(meta.source), _step; !(_step = _iterator()).done;) {
              var _step$value = _slicedToArray$2(_step.value, 2),
                  source = _step$value[0],
                  metadata = _step$value[1];

              amdArgs.push(stringLiteral(source));
              commonjsArgs.push(callExpression(identifier("require"), [stringLiteral(source)]));
              browserArgs.push(buildBrowserArg(browserGlobals, exactGlobals, source));
              importNames.push(identifier(metadata.name));

              if (!isSideEffectImport(metadata)) {
                var interop = wrapInterop(path, identifier(metadata.name), metadata.interop);

                if (interop) {
                  var header = expressionStatement(assignmentExpression("=", identifier(metadata.name), interop));
                  header.loc = meta.loc;
                  headers.push(header);
                }
              }

              headers.push.apply(headers, _toConsumableArray(buildNamespaceInitStatements(meta, metadata, constantReexports)));
            }

            ensureStatementsHoisted(headers);
            path.unshiftContainer("body", headers);
            var _path$node = path.node,
                body = _path$node.body,
                directives = _path$node.directives;
            path.node.directives = [];
            path.node.body = [];
            var umdWrapper = path.pushContainer("body", [buildWrapper({
              MODULE_NAME: moduleName,
              AMD_ARGUMENTS: arrayExpression(amdArgs),
              COMMONJS_ARGUMENTS: commonjsArgs,
              BROWSER_ARGUMENTS: browserArgs,
              IMPORT_NAMES: importNames,
              GLOBAL_TO_ASSIGN: buildBrowserInit(browserGlobals, exactGlobals, this.filename || "unknown", moduleName)
            })])[0];
            var umdFactory = umdWrapper.get("expression.arguments")[1].get("body");
            umdFactory.pushContainer("directives", directives);
            umdFactory.pushContainer("body", body);
          }
        }
      }
    };
  });

  function _transformNamedCapturingGroupsRegex (core, options) {
    var _options$runtime = options.runtime,
        runtime = _options$runtime === void 0 ? true : _options$runtime;

    if (typeof runtime !== "boolean") {
      throw new Error("The 'runtime' option must be boolean");
    }

    return createRegExpFeaturePlugin({
      name: "transform-named-capturing-groups-regex",
      feature: "namedCaptureGroups",
      options: {
        runtime: runtime
      }
    });
  }

  var _transformNewTarget = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-new-target",
      visitor: {
        MetaProperty: function MetaProperty(path) {
          var meta = path.get("meta");
          var property = path.get("property");
          var scope = path.scope;

          if (meta.isIdentifier({
            name: "new"
          }) && property.isIdentifier({
            name: "target"
          })) {
            var func = path.findParent(function (path) {
              if (path.isClass()) return true;

              if (path.isFunction() && !path.isArrowFunctionExpression()) {
                if (path.isClassMethod({
                  kind: "constructor"
                })) {
                  return false;
                }

                return true;
              }

              return false;
            });

            if (!func) {
              throw path.buildCodeFrameError("new.target must be under a (non-arrow) function or a class.");
            }

            var node = func.node;

            if (!node.id) {
              if (func.isMethod()) {
                path.replaceWith(scope.buildUndefinedNode());
                return;
              }

              node.id = scope.generateUidIdentifier("target");
            }

            var _constructor = memberExpression(thisExpression(), identifier("constructor"));

            if (func.isClass()) {
              path.replaceWith(_constructor);
              return;
            }

            path.replaceWith(conditionalExpression(binaryExpression("instanceof", thisExpression(), cloneNode(node.id)), _constructor, scope.buildUndefinedNode()));
          }
        }
      }
    };
  });

  var transformObjectAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.assign")) {
            path.node.callee = file.addHelper("extends");
          }
        }
      }
    };
  });

  function replacePropertySuper(path, getObjectRef, file) {
    var replaceSupers = new ReplaceSupers({
      getObjectRef: getObjectRef,
      methodPath: path,
      file: file
    });
    replaceSupers.replace();
  }

  var _transformObjectSuper = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-super",
      visitor: {
        ObjectExpression: function ObjectExpression(path, state) {
          var objectRef;

          var getObjectRef = function getObjectRef() {
            return objectRef = objectRef || path.scope.generateUidIdentifier("obj");
          };

          path.get("properties").forEach(function (propPath) {
            if (!propPath.isMethod()) return;
            replacePropertySuper(propPath, getObjectRef, state);
          });

          if (objectRef) {
            path.scope.push({
              id: cloneNode(objectRef)
            });
            path.replaceWith(assignmentExpression("=", cloneNode(objectRef), path.node));
          }
        }
      }
    };
  });

  var transformObjectSetPrototypeOfToAssign = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-object-set-prototype-of-to-assign",
      visitor: {
        CallExpression: function CallExpression(path, file) {
          if (path.get("callee").matchesPattern("Object.setPrototypeOf")) {
            path.node.callee = file.addHelper("defaults");
          }
        }
      }
    };
  });

  var _transformPropertyLiterals = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-literals",
      visitor: {
        ObjectProperty: {
          exit: function exit(_ref) {
            var node = _ref.node;
            var key = node.key;

            if (!node.computed && isIdentifier(key) && !isValidES3Identifier(key.name)) {
              node.key = stringLiteral(key.name);
            }
          }
        }
      }
    };
  });

  function toKind(node) {
    if (isClassMethod(node) || isObjectMethod(node)) {
      if (node.kind === "get" || node.kind === "set") {
        return node.kind;
      }
    }

    return "value";
  }

  var has$7 = Function.prototype.call.bind(Object.prototype.hasOwnProperty);
  function push$1(mutatorMap, node, kind, file, scope) {
    var alias = toKeyAlias(node);
    var map = {};
    if (has$7(mutatorMap, alias)) map = mutatorMap[alias];
    mutatorMap[alias] = map;
    map._inherits = map._inherits || [];

    map._inherits.push(node);

    map._key = node.key;

    if (node.computed) {
      map._computed = true;
    }

    if (node.decorators) {
      var decorators = map.decorators = map.decorators || arrayExpression([]);
      decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {
        return dec.expression;
      }).reverse());
    }

    if (map.value || map.initializer) {
      throw file.buildCodeFrameError(node, "Key conflict with sibling node");
    }

    var key, value;

    if (isObjectProperty(node) || isObjectMethod(node) || isClassMethod(node)) {
      key = toComputedKey$1(node, node.key);
    }

    if (isProperty(node)) {
      value = node.value;
    } else if (isObjectMethod(node) || isClassMethod(node)) {
      value = functionExpression(null, node.params, node.body, node.generator, node.async);
      value.returnType = node.returnType;
    }

    var inheritedKind = toKind(node);

    if (!kind || inheritedKind !== "value") {
      kind = inheritedKind;
    }

    if (scope && isStringLiteral(key) && (kind === "value" || kind === "initializer") && isFunctionExpression(value)) {
      value = nameFunction({
        id: key,
        node: value,
        scope: scope
      });
    }

    if (value) {
      inheritsComments(value, node);
      map[kind] = value;
    }

    return map;
  }
  function toClassObject(mutatorMap) {
    var objExpr = objectExpression([]);
    Object.keys(mutatorMap).forEach(function (mutatorMapKey) {
      var map = mutatorMap[mutatorMapKey];
      var mapNode = objectExpression([]);
      var propNode = objectProperty(map._key, mapNode, map._computed);
      Object.keys(map).forEach(function (key) {
        var node = map[key];
        if (key[0] === "_") return;
        var prop = objectProperty(identifier(key), node);
        inheritsComments(prop, node);
        removeComments(node);
        mapNode.properties.push(prop);
      });
      objExpr.properties.push(propNode);
    });
    return objExpr;
  }
  function toDefineObject(mutatorMap) {
    Object.keys(mutatorMap).forEach(function (key) {
      var map = mutatorMap[key];
      if (map.value) map.writable = booleanLiteral(true);
      map.configurable = booleanLiteral(true);
      map.enumerable = booleanLiteral(true);
    });
    return toClassObject(mutatorMap);
  }

  var transformPropertyMutators = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-property-mutators",
      visitor: {
        ObjectExpression: function ObjectExpression(path, file) {
          var node = path.node;
          var hasAny = false;

          for (var _i = 0, _arr = node.properties; _i < _arr.length; _i++) {
            var prop = _arr[_i];

            if (prop.kind === "get" || prop.kind === "set") {
              hasAny = true;
              break;
            }
          }

          if (!hasAny) return;
          var mutatorMap = {};
          node.properties = node.properties.filter(function (prop) {
            if (!prop.computed && (prop.kind === "get" || prop.kind === "set")) {
              push$1(mutatorMap, prop, null, file);
              return false;
            } else {
              return true;
            }
          });
          path.replaceWith(callExpression(memberExpression(identifier("Object"), identifier("defineProperties")), [node, toDefineObject(mutatorMap)]));
        }
      }
    };
  });

  var transformProtoToAssign = declare(function (api) {
    api.assertVersion(7);

    function isProtoKey(node) {
      return isLiteral(toComputedKey$1(node, node.key), {
        value: "__proto__"
      });
    }

    function isProtoAssignmentExpression(node) {
      var left = node.left;
      return isMemberExpression(left) && isLiteral(toComputedKey$1(left, left.property), {
        value: "__proto__"
      });
    }

    function buildDefaultsCallExpression(expr, ref, file) {
      return expressionStatement(callExpression(file.addHelper("defaults"), [ref, expr.right]));
    }

    return {
      name: "transform-proto-to-assign",
      visitor: {
        AssignmentExpression: function AssignmentExpression(path, file) {
          if (!isProtoAssignmentExpression(path.node)) return;
          var nodes = [];
          var left = path.node.left.object;
          var temp = path.scope.maybeGenerateMemoised(left);

          if (temp) {
            nodes.push(expressionStatement(assignmentExpression("=", temp, left)));
          }

          nodes.push(buildDefaultsCallExpression(path.node, cloneNode(temp || left), file));
          if (temp) nodes.push(cloneNode(temp));
          path.replaceWithMultiple(nodes);
        },
        ExpressionStatement: function ExpressionStatement(path, file) {
          var expr = path.node.expression;
          if (!isAssignmentExpression(expr, {
            operator: "="
          })) return;

          if (isProtoAssignmentExpression(expr)) {
            path.replaceWith(buildDefaultsCallExpression(expr, expr.left.object, file));
          }
        },
        ObjectExpression: function ObjectExpression(path, file) {
          var proto;
          var node = path.node;
          var properties = node.properties;

          for (var i = 0; i < properties.length; i++) {
            var prop = properties[i];

            if (isProtoKey(prop)) {
              proto = prop.value;
              properties.splice(i, 1);
              break;
            }
          }

          if (proto) {
            var args = [objectExpression([]), proto];
            if (node.properties.length) args.push(node);
            path.replaceWith(callExpression(file.addHelper("extends"), args));
          }
        }
      }
    };
  });

  var _templateObject$6;
  var transformReactConstantElements = declare(function (api, options) {
    api.assertVersion(7);
    var allowMutablePropsOnTags = options.allowMutablePropsOnTags;

    if (allowMutablePropsOnTags != null && !Array.isArray(allowMutablePropsOnTags)) {
      throw new Error(".allowMutablePropsOnTags must be an array, null, or undefined.");
    }

    var HOISTED = new WeakMap();

    function declares(node, scope) {
      if (isJSXIdentifier(node, {
        name: "this"
      }) || isJSXIdentifier(node, {
        name: "arguments"
      }) || isJSXIdentifier(node, {
        name: "super"
      }) || isJSXIdentifier(node, {
        name: "new"
      })) {
        var path = scope.path;
        return path.isFunctionParent() && !path.isArrowFunctionExpression();
      }

      return scope.hasOwnBinding(node.name);
    }

    function isHoistingScope(_ref) {
      var path = _ref.path;
      return path.isFunctionParent() || path.isLoop() || path.isProgram();
    }

    function getHoistingScope(scope) {
      while (!isHoistingScope(scope)) {
        scope = scope.parent;
      }

      return scope;
    }

    var analyzer = {
      enter: function enter(path, state) {
        var stop = function stop() {
          state.isImmutable = false;
          path.stop();
        };

        if (path.isJSXClosingElement()) {
          path.skip();
          return;
        }

        if (path.isJSXIdentifier({
          name: "ref"
        }) && path.parentPath.isJSXAttribute({
          name: path.node
        })) {
          return stop();
        }

        if (path.isJSXIdentifier() || path.isJSXMemberExpression() || path.isJSXNamespacedName()) {
          return;
        }

        if (path.isIdentifier()) {
          var binding = path.scope.getBinding(path.node.name);
          if (binding && binding.constant) return;
        }

        if (!path.isImmutable()) {
          if (path.isPure()) {
            var expressionResult = path.evaluate();

            if (expressionResult.confident) {
              var value = expressionResult.value;
              var isMutable = !state.mutablePropsAllowed && value && typeof value === "object" || typeof value === "function";

              if (!isMutable) {
                path.skip();
                return;
              }
            } else if (isIdentifier(expressionResult.deopt)) {
              return;
            }
          }

          stop();
        }
      },
      ReferencedIdentifier: function ReferencedIdentifier(path, state) {
        var node = path.node;
        var scope = path.scope;

        while (scope) {
          if (scope === state.targetScope) return;
          if (declares(node, scope)) break;
          scope = scope.parent;
        }

        state.targetScope = getHoistingScope(scope);
      }
    };
    return {
      name: "transform-react-constant-elements",
      visitor: {
        JSXElement: function JSXElement(path) {
          var _jsxScope;

          if (HOISTED.has(path.node)) return;
          HOISTED.set(path.node, path.scope);
          var name = path.node.openingElement.name;
          var mutablePropsAllowed = false;

          if (allowMutablePropsOnTags != null) {
            var lastSegment = name;

            while (isJSXMemberExpression(lastSegment)) {
              lastSegment = lastSegment.property;
            }

            var elementName = lastSegment.name;
            mutablePropsAllowed = allowMutablePropsOnTags.includes(elementName);
          }

          var state = {
            isImmutable: true,
            mutablePropsAllowed: mutablePropsAllowed,
            targetScope: path.scope.getProgramParent()
          };
          path.traverse(analyzer, state);
          if (!state.isImmutable) return;
          var targetScope = state.targetScope;
          HOISTED.set(path.node, targetScope);
          var jsxScope;
          var current = path;

          while (!jsxScope && current.parentPath.isJSX()) {
            current = current.parentPath;
            jsxScope = HOISTED.get(current.node);
          }

          (_jsxScope = jsxScope) != null ? _jsxScope : jsxScope = getHoistingScope(path.scope);
          if (targetScope === jsxScope) return;
          var id = path.scope.generateUidBasedOnNode(name);
          targetScope.push({
            id: identifier(id)
          });
          var replacement = template$2.expression.ast(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose(["\n          ", " || (", " = ", ")\n        "])), identifier(id), identifier(id), path.node);

          if (path.parentPath.isJSXElement() || path.parentPath.isJSXAttribute()) {
            replacement = jsxExpressionContainer(replacement);
          }

          path.replaceWith(replacement);
        }
      }
    };
  });

  var transformReactDisplayName = declare(function (api) {
    api.assertVersion(7);

    function addDisplayName(id, call) {
      var props = call.arguments[0].properties;
      var safe = true;

      for (var i = 0; i < props.length; i++) {
        var prop = props[i];
        var key = toComputedKey$1(prop);

        if (isLiteral(key, {
          value: "displayName"
        })) {
          safe = false;
          break;
        }
      }

      if (safe) {
        props.unshift(objectProperty(identifier("displayName"), stringLiteral(id)));
      }
    }

    var isCreateClassCallExpression = buildMatchMemberExpression("React.createClass");

    var isCreateClassAddon = function isCreateClassAddon(callee) {
      return callee.name === "createReactClass";
    };

    function isCreateClass(node) {
      if (!node || !isCallExpression(node)) return false;

      if (!isCreateClassCallExpression(node.callee) && !isCreateClassAddon(node.callee)) {
        return false;
      }

      var args = node.arguments;
      if (args.length !== 1) return false;
      var first = args[0];
      if (!isObjectExpression(first)) return false;
      return true;
    }

    return {
      name: "transform-react-display-name",
      visitor: {
        ExportDefaultDeclaration: function ExportDefaultDeclaration(_ref, state) {
          var node = _ref.node;

          if (isCreateClass(node.declaration)) {
            var filename = state.filename || "unknown";
            var displayName = path$1.basename(filename, path$1.extname(filename));

            if (displayName === "index") {
              displayName = path$1.basename(path$1.dirname(filename));
            }

            addDisplayName(displayName, node.declaration);
          }
        },
        CallExpression: function CallExpression(path) {
          var node = path.node;
          if (!isCreateClass(node)) return;
          var id;
          path.find(function (path) {
            if (path.isAssignmentExpression()) {
              id = path.node.left;
            } else if (path.isObjectProperty()) {
              id = path.node.key;
            } else if (path.isVariableDeclarator()) {
              id = path.node.id;
            } else if (path.isStatement()) {
              return true;
            }

            if (id) return true;
          });
          if (!id) return;

          if (isMemberExpression(id)) {
            id = id.property;
          }

          if (isIdentifier(id)) {
            addDisplayName(id.name, node);
          }
        }
      }
    };
  });

  function helper (opts) {
    var visitor = {};

    visitor.JSXNamespacedName = function (path) {
      if (opts.throwIfNamespace) {
        throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
      }
    };

    visitor.JSXSpreadChild = function (path) {
      throw path.buildCodeFrameError("Spread children are not supported in React.");
    };

    visitor.JSXElement = {
      exit: function exit(path, file) {
        var callExpr = buildElementCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    visitor.JSXFragment = {
      exit: function exit(path, file) {
        if (opts.compat) {
          throw path.buildCodeFrameError("Fragment tags are only supported in React 16 and up.");
        }

        var callExpr = buildFragmentCall(path, file);

        if (callExpr) {
          path.replaceWith(inherits(callExpr, path.node));
        }
      }
    };
    return visitor;

    function convertJSXIdentifier(node, parent) {
      if (isJSXIdentifier(node)) {
        if (node.name === "this" && isReferenced(node, parent)) {
          return thisExpression();
        } else if (isValidIdentifier(node.name, false)) {
          node.type = "Identifier";
        } else {
          return stringLiteral(node.name);
        }
      } else if (isJSXMemberExpression(node)) {
        return memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
      } else if (isJSXNamespacedName(node)) {
        return stringLiteral(node.namespace.name + ":" + node.name.name);
      }

      return node;
    }

    function convertAttributeValue(node) {
      if (isJSXExpressionContainer(node)) {
        return node.expression;
      } else {
        return node;
      }
    }

    function convertAttribute(node) {
      var value = convertAttributeValue(node.value || booleanLiteral(true));

      if (isJSXSpreadAttribute(node)) {
        return spreadElement(node.argument);
      }

      if (isStringLiteral(value) && !isJSXExpressionContainer(node.value)) {
        var _value$extra;

        value.value = value.value.replace(/\n\s+/g, " ");
        (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
      }

      if (isJSXNamespacedName(node.name)) {
        node.name = stringLiteral(node.name.namespace.name + ":" + node.name.name.name);
      } else if (isValidIdentifier(node.name.name, false)) {
        node.name.type = "Identifier";
      } else {
        node.name = stringLiteral(node.name.name);
      }

      return inherits(objectProperty(node.name, value), node);
    }

    function buildElementCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
      var args = [];
      var tagName;

      if (isIdentifier(tagExpr)) {
        tagName = tagExpr.name;
      } else if (isLiteral(tagExpr)) {
        tagName = tagExpr.value;
      }

      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      var attribs = openingPath.node.attributes;

      if (attribs.length) {
        {
          attribs = buildOpeningElementAttributes(attribs, file);
        }
      } else {
        attribs = nullLiteral();
      }

      args.push.apply(args, [attribs].concat(_toConsumableArray(path.node.children)));

      if (opts.post) {
        opts.post(state, file);
      }

      var call = state.call || callExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }

    function pushProps(_props, objs) {
      if (!_props.length) return _props;
      objs.push(objectExpression(_props));
      return [];
    }

    function buildOpeningElementAttributes(attribs, file) {
      var _props = [];
      var objs = [];
      var _file$opts$useSpread = file.opts.useSpread,
          useSpread = _file$opts$useSpread === void 0 ? false : _file$opts$useSpread;

      if (typeof useSpread !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
      }

      var useBuiltIns = file.opts.useBuiltIns || false;

      if (typeof useBuiltIns !== "boolean") {
        throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
      }

      if (useSpread && useBuiltIns) {
        throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
      }

      if (useSpread) {
        var props = attribs.map(convertAttribute);
        return objectExpression(props);
      }

      while (attribs.length) {
        var prop = attribs.shift();

        if (isJSXSpreadAttribute(prop)) {
          _props = pushProps(_props, objs);
          objs.push(prop.argument);
        } else {
          _props.push(convertAttribute(prop));
        }
      }

      pushProps(_props, objs);

      if (objs.length === 1) {
        attribs = objs[0];
      } else {
        if (!isObjectExpression(objs[0])) {
          objs.unshift(objectExpression([]));
        }

        var helper = useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
        attribs = callExpression(helper, objs);
      }

      return attribs;
    }

    function buildFragmentCall(path, file) {
      if (opts.filter && !opts.filter(path.node, file)) return;
      var openingPath = path.get("openingElement");
      openingPath.parent.children = react.buildChildren(openingPath.parent);
      var args = [];
      var tagName = null;
      var tagExpr = file.get("jsxFragIdentifier")();
      var state = {
        tagExpr: tagExpr,
        tagName: tagName,
        args: args,
        pure: false
      };

      if (opts.pre) {
        opts.pre(state, file);
      }

      args.push.apply(args, [nullLiteral()].concat(_toConsumableArray(path.node.children)));

      if (opts.post) {
        opts.post(state, file);
      }

      file.set("usedFragment", true);
      var call = state.call || callExpression(state.callee, args);
      if (state.pure) annotateAsPure(call);
      return call;
    }
  }

  var transformReactInlineElements = declare(function (api) {
    api.assertVersion(7);

    function hasRefOrSpread(attrs) {
      for (var i = 0; i < attrs.length; i++) {
        var attr = attrs[i];
        if (isJSXSpreadAttribute(attr)) return true;
        if (isJSXAttributeOfName(attr, "ref")) return true;
      }

      return false;
    }

    function isJSXAttributeOfName(attr, name) {
      return isJSXAttribute(attr) && isJSXIdentifier(attr.name, {
        name: name
      });
    }

    var visitor = helper({
      filter: function filter(node) {
        return node.openingElement && !hasRefOrSpread(node.openingElement.attributes);
      },
      pre: function pre(state) {
        var tagName = state.tagName;
        var args = state.args;

        if (react.isCompatTag(tagName)) {
          args.push(stringLiteral(tagName));
        } else {
          args.push(state.tagExpr);
        }
      },
      post: function post(state, pass) {
        state.callee = pass.addHelper("jsx");
        var props = state.args[1];
        var hasKey = false;

        if (isObjectExpression(props)) {
          var keyIndex = props.properties.findIndex(function (prop) {
            return isIdentifier(prop.key, {
              name: "key"
            });
          });

          if (keyIndex > -1) {
            state.args.splice(2, 0, props.properties[keyIndex].value);
            props.properties.splice(keyIndex, 1);
            hasKey = true;
          }
        } else if (isNullLiteral(props)) {
          state.args.splice(1, 1, objectExpression([]));
        }

        if (!hasKey && state.args.length > 2) {
          state.args.splice(2, 0, unaryExpression("void", numericLiteral(0)));
        }

        state.pure = true;
      }
    });
    return {
      name: "transform-react-inline-elements",
      visitor: visitor
    };
  });

  var DEFAULT = {
    importSource: "react",
    runtime: "automatic",
    pragma: "React.createElement",
    pragmaFrag: "React.Fragment"
  };
  var JSX_SOURCE_ANNOTATION_REGEX = /\*?\s*@jsxImportSource\s+([^\s]+)/;
  var JSX_RUNTIME_ANNOTATION_REGEX = /\*?\s*@jsxRuntime\s+([^\s]+)/;
  var JSX_ANNOTATION_REGEX = /\*?\s*@jsx\s+([^\s]+)/;
  var JSX_FRAG_ANNOTATION_REGEX = /\*?\s*@jsxFrag\s+([^\s]+)/;

  var get = function get(pass, name) {
    return pass.get("@babel/plugin-react-jsx/" + name);
  };

  var set = function set(pass, name, v) {
    return pass.set("@babel/plugin-react-jsx/" + name, v);
  };

  function createPlugin(_ref) {
    var name = _ref.name,
        development = _ref.development;
    return declare(function (api, options) {
      var PURE_ANNOTATION = options.pure,
          _options$throwIfNames = options.throwIfNamespace,
          throwIfNamespace = _options$throwIfNames === void 0 ? true : _options$throwIfNames,
          filter = options.filter,
          _options$runtime = options.runtime,
          RUNTIME_DEFAULT = _options$runtime === void 0 ? development ? "automatic" : "classic" : _options$runtime,
          _options$importSource = options.importSource,
          IMPORT_SOURCE_DEFAULT = _options$importSource === void 0 ? DEFAULT.importSource : _options$importSource,
          _options$pragma = options.pragma,
          PRAGMA_DEFAULT = _options$pragma === void 0 ? DEFAULT.pragma : _options$pragma,
          _options$pragmaFrag = options.pragmaFrag,
          PRAGMA_FRAG_DEFAULT = _options$pragmaFrag === void 0 ? DEFAULT.pragmaFrag : _options$pragmaFrag;
      {
        var _options$useSpread = options.useSpread,
            useSpread = _options$useSpread === void 0 ? false : _options$useSpread,
            _options$useBuiltIns = options.useBuiltIns,
            useBuiltIns = _options$useBuiltIns === void 0 ? false : _options$useBuiltIns;

        if (RUNTIME_DEFAULT === "classic") {
          if (typeof useSpread !== "boolean") {
            throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useSpread (defaults to false)");
          }

          if (typeof useBuiltIns !== "boolean") {
            throw new Error("transform-react-jsx currently only accepts a boolean option for " + "useBuiltIns (defaults to false)");
          }

          if (useSpread && useBuiltIns) {
            throw new Error("transform-react-jsx currently only accepts useBuiltIns or useSpread " + "but not both");
          }
        }
      }
      var injectMetaPropertiesVisitor = {
        JSXOpeningElement: function JSXOpeningElement(path, state) {
          for (var _iterator = _createForOfIteratorHelperLoose(path.get("attributes")), _step; !(_step = _iterator()).done;) {
            var attr = _step.value;
            if (!attr.isJSXElement()) continue;
            var _name = attr.node.name.name;

            if (_name === "__source" || _name === "__self") {
              throw path.buildCodeFrameError("__source and __self should not be defined in props and are reserved for internal usage.");
            }
          }

          var self = jsxAttribute(jsxIdentifier("__self"), jsxExpressionContainer(thisExpression()));
          var source = jsxAttribute(jsxIdentifier("__source"), jsxExpressionContainer(makeSource(path, state)));
          path.pushContainer("attributes", [self, source]);
        }
      };
      return {
        name: name,
        inherits: syntaxJsx,
        visitor: {
          JSXNamespacedName: function JSXNamespacedName(path) {
            if (throwIfNamespace) {
              throw path.buildCodeFrameError("Namespace tags are not supported by default. React's JSX doesn't support namespace tags. You can set `throwIfNamespace: false` to bypass this warning.");
            }
          },
          JSXSpreadChild: function JSXSpreadChild(path) {
            throw path.buildCodeFrameError("Spread children are not supported in React.");
          },
          Program: {
            enter: function enter(path, state) {
              var file = state.file;
              var runtime = RUNTIME_DEFAULT;
              var source = IMPORT_SOURCE_DEFAULT;
              var pragma = PRAGMA_DEFAULT;
              var pragmaFrag = PRAGMA_FRAG_DEFAULT;
              var sourceSet = !!options.importSource;
              var pragmaSet = !!options.pragma;
              var pragmaFragSet = !!options.pragmaFrag;

              if (file.ast.comments) {
                for (var _iterator2 = _createForOfIteratorHelperLoose(file.ast.comments), _step2; !(_step2 = _iterator2()).done;) {
                  var comment = _step2.value;
                  var sourceMatches = JSX_SOURCE_ANNOTATION_REGEX.exec(comment.value);

                  if (sourceMatches) {
                    source = sourceMatches[1];
                    sourceSet = true;
                  }

                  var runtimeMatches = JSX_RUNTIME_ANNOTATION_REGEX.exec(comment.value);

                  if (runtimeMatches) {
                    runtime = runtimeMatches[1];
                  }

                  var jsxMatches = JSX_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxMatches) {
                    pragma = jsxMatches[1];
                    pragmaSet = true;
                  }

                  var jsxFragMatches = JSX_FRAG_ANNOTATION_REGEX.exec(comment.value);

                  if (jsxFragMatches) {
                    pragmaFrag = jsxFragMatches[1];
                    pragmaFragSet = true;
                  }
                }
              }

              set(state, "runtime", runtime);

              if (runtime === "classic") {
                if (sourceSet) {
                  throw path.buildCodeFrameError("importSource cannot be set when runtime is classic.");
                }

                var createElement = toMemberExpression(pragma);
                var fragment = toMemberExpression(pragmaFrag);
                set(state, "id/createElement", function () {
                  return cloneNode(createElement);
                });
                set(state, "id/fragment", function () {
                  return cloneNode(fragment);
                });
                set(state, "defaultPure", pragma === DEFAULT.pragma);
              } else if (runtime === "automatic") {
                if (pragmaSet || pragmaFragSet) {
                  throw path.buildCodeFrameError("pragma and pragmaFrag cannot be set when runtime is automatic.");
                }

                var define = function define(name, id) {
                  return set(state, name, createImportLazily(state, path, id, source));
                };

                define("id/jsx", development ? "jsxDEV" : "jsx");
                define("id/jsxs", development ? "jsxDEV" : "jsxs");
                define("id/createElement", "createElement");
                define("id/fragment", "Fragment");
                set(state, "defaultPure", source === DEFAULT.importSource);
              } else {
                throw path.buildCodeFrameError("Runtime must be either \"classic\" or \"automatic\".");
              }

              if (development) {
                path.traverse(injectMetaPropertiesVisitor, state);
              }
            }
          },
          JSXElement: {
            exit: function exit(path, file) {
              var callExpr;

              if (get(file, "runtime") === "classic" || shouldUseCreateElement(path)) {
                callExpr = buildCreateElementCall(path, file);
              } else {
                callExpr = buildJSXElementCall(path, file);
              }

              path.replaceWith(inherits(callExpr, path.node));
            }
          },
          JSXFragment: {
            exit: function exit(path, file) {
              var callExpr;

              if (get(file, "runtime") === "classic") {
                callExpr = buildCreateElementFragmentCall(path, file);
              } else {
                callExpr = buildJSXFragmentCall(path, file);
              }

              path.replaceWith(inherits(callExpr, path.node));
            }
          },
          JSXAttribute: function JSXAttribute(path) {
            if (isJSXElement(path.node.value)) {
              path.node.value = jsxExpressionContainer(path.node.value);
            }
          }
        }
      };

      function call(pass, name, args) {
        var node = callExpression(get(pass, "id/" + name)(), args);
        if (PURE_ANNOTATION != null ? PURE_ANNOTATION : get(pass, "defaultPure")) annotateAsPure(node);
        return node;
      }

      function shouldUseCreateElement(path) {
        var openingPath = path.get("openingElement");
        var attributes = openingPath.node.attributes;
        var seenPropsSpread = false;

        for (var i = 0; i < attributes.length; i++) {
          var attr = attributes[i];

          if (seenPropsSpread && isJSXAttribute(attr) && attr.name.name === "key") {
            return true;
          } else if (isJSXSpreadAttribute(attr)) {
            seenPropsSpread = true;
          }
        }

        return false;
      }

      function convertJSXIdentifier(node, parent) {
        if (isJSXIdentifier(node)) {
          if (node.name === "this" && isReferenced(node, parent)) {
            return thisExpression();
          } else if (isValidIdentifier(node.name, false)) {
            node.type = "Identifier";
          } else {
            return stringLiteral(node.name);
          }
        } else if (isJSXMemberExpression(node)) {
          return memberExpression(convertJSXIdentifier(node.object, node), convertJSXIdentifier(node.property, node));
        } else if (isJSXNamespacedName(node)) {
          return stringLiteral(node.namespace.name + ":" + node.name.name);
        }

        return node;
      }

      function convertAttributeValue(node) {
        if (isJSXExpressionContainer(node)) {
          return node.expression;
        } else {
          return node;
        }
      }

      function accumulateAttribute(array, attribute) {
        if (isJSXSpreadAttribute(attribute.node)) {
          var arg = attribute.node.argument;

          if (isObjectExpression(arg)) {
            array.push.apply(array, _toConsumableArray(arg.properties));
          } else {
            array.push(spreadElement(arg));
          }

          return array;
        }

        var value = convertAttributeValue(attribute.node.name.name !== "key" ? attribute.node.value || booleanLiteral(true) : attribute.node.value);

        if (attribute.node.name.name === "key" && value === null) {
          throw attribute.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
        }

        if (isStringLiteral(value) && !isJSXExpressionContainer(attribute.node.value)) {
          var _value$extra;

          value.value = value.value.replace(/\n\s+/g, " ");
          (_value$extra = value.extra) == null ? true : delete _value$extra.raw;
        }

        if (isJSXNamespacedName(attribute.node.name)) {
          attribute.node.name = stringLiteral(attribute.node.name.namespace.name + ":" + attribute.node.name.name.name);
        } else if (isValidIdentifier(attribute.node.name.name, false)) {
          attribute.node.name.type = "Identifier";
        } else {
          attribute.node.name = stringLiteral(attribute.node.name.name);
        }

        array.push(inherits(objectProperty(attribute.node.name, value), attribute.node));
        return array;
      }

      function buildChildrenProperty(children) {
        var childrenNode;

        if (children.length === 1) {
          childrenNode = children[0];
        } else if (children.length > 1) {
          childrenNode = arrayExpression(children);
        } else {
          return undefined;
        }

        return objectProperty(identifier("children"), childrenNode);
      }

      function buildJSXElementCall(path, file) {
        var openingPath = path.get("openingElement");
        var args = [getTag(openingPath)];
        var attribsArray = [];
        var extracted = Object.create(null);

        for (var _iterator3 = _createForOfIteratorHelperLoose(openingPath.get("attributes")), _step3; !(_step3 = _iterator3()).done;) {
          var attr = _step3.value;

          if (attr.isJSXAttribute() && isJSXIdentifier(attr.node.name)) {
            var _name2 = attr.node.name.name;

            switch (_name2) {
              case "__source":
              case "__self":
                if (extracted[_name2]) throw sourceSelfError(path, _name2);

              case "key":
                {
                  var keyValue = convertAttributeValue(attr.node.value);

                  if (keyValue === null) {
                    throw attr.buildCodeFrameError('Please provide an explicit key value. Using "key" as a shorthand for "key={true}" is not allowed.');
                  }

                  extracted[_name2] = keyValue;
                  break;
                }

              default:
                attribsArray.push(attr);
            }
          } else {
            attribsArray.push(attr);
          }
        }

        var children = react.buildChildren(path.node);
        var attribs;

        if (attribsArray.length || children.length) {
          attribs = buildJSXOpeningElementAttributes(attribsArray, file, children);
        } else {
          attribs = objectExpression([]);
        }

        args.push(attribs);

        if (development) {
          var _extracted$key, _extracted$__source, _extracted$__self;

          args.push((_extracted$key = extracted.key) != null ? _extracted$key : path.scope.buildUndefinedNode(), booleanLiteral(children.length > 1), (_extracted$__source = extracted.__source) != null ? _extracted$__source : path.scope.buildUndefinedNode(), (_extracted$__self = extracted.__self) != null ? _extracted$__self : thisExpression());
        } else if (extracted.key !== undefined) {
          args.push(extracted.key);
        }

        return call(file, children.length > 1 ? "jsxs" : "jsx", args);
      }

      function buildJSXOpeningElementAttributes(attribs, file, children) {
        var props = attribs.reduce(accumulateAttribute, []);

        if ((children == null ? void 0 : children.length) > 0) {
          props.push(buildChildrenProperty(children));
        }

        return objectExpression(props);
      }

      function buildJSXFragmentCall(path, file) {
        var args = [get(file, "id/fragment")()];
        var children = react.buildChildren(path.node);
        args.push(objectExpression(children.length > 0 ? [buildChildrenProperty(children)] : []));

        if (development) {
          args.push(path.scope.buildUndefinedNode(), booleanLiteral(children.length > 1));
        }

        return call(file, children.length > 1 ? "jsxs" : "jsx", args);
      }

      function buildCreateElementFragmentCall(path, file) {
        if (filter && !filter(path.node, file)) return;
        return call(file, "createElement", [get(file, "id/fragment")(), nullLiteral()].concat(_toConsumableArray(react.buildChildren(path.node))));
      }

      function buildCreateElementCall(path, file) {
        var openingPath = path.get("openingElement");
        return call(file, "createElement", [getTag(openingPath), buildCreateElementOpeningElementAttributes(file, path, openingPath.get("attributes"))].concat(_toConsumableArray(react.buildChildren(path.node))));
      }

      function getTag(openingPath) {
        var tagExpr = convertJSXIdentifier(openingPath.node.name, openingPath.node);
        var tagName;

        if (isIdentifier(tagExpr)) {
          tagName = tagExpr.name;
        } else if (isLiteral(tagExpr)) {
          tagName = tagExpr.value;
        }

        if (react.isCompatTag(tagName)) {
          return stringLiteral(tagName);
        } else {
          return tagExpr;
        }
      }

      function buildCreateElementOpeningElementAttributes(file, path, attribs) {
        var runtime = get(file, "runtime");
        {
          if (runtime !== "automatic") {
            var objs = [];

            var _props = attribs.reduce(accumulateAttribute, []);

            if (!useSpread) {
              var start = 0;

              _props.forEach(function (prop, i) {
                if (isSpreadElement(prop)) {
                  if (i > start) {
                    objs.push(objectExpression(_props.slice(start, i)));
                  }

                  objs.push(prop.argument);
                  start = i + 1;
                }
              });

              if (_props.length > start) {
                objs.push(objectExpression(_props.slice(start)));
              }
            } else if (_props.length) {
              objs.push(objectExpression(_props));
            }

            if (!objs.length) {
              return nullLiteral();
            }

            if (objs.length === 1) {
              return objs[0];
            }

            if (!isObjectExpression(objs[0])) {
              objs.unshift(objectExpression([]));
            }

            var helper = useBuiltIns ? memberExpression(identifier("Object"), identifier("assign")) : file.addHelper("extends");
            return callExpression(helper, objs);
          }
        }
        var props = [];
        var found = Object.create(null);

        for (var _iterator4 = _createForOfIteratorHelperLoose(attribs), _step4; !(_step4 = _iterator4()).done;) {
          var attr = _step4.value;

          var _name3 = isJSXAttribute(attr) && isJSXIdentifier(attr.name) && attr.name.name;

          if (runtime === "automatic" && (_name3 === "__source" || _name3 === "__self")) {
            if (found[_name3]) throw sourceSelfError(path, _name3);
            found[_name3] = true;
          }

          accumulateAttribute(props, attr);
        }

        return props.length === 1 && isSpreadElement(props[0]) ? props[0].argument : props.length > 0 ? objectExpression(props) : nullLiteral();
      }
    });

    function getSource(source, importName) {
      switch (importName) {
        case "Fragment":
          return source + "/" + (development ? "jsx-dev-runtime" : "jsx-runtime");

        case "jsxDEV":
          return source + "/jsx-dev-runtime";

        case "jsx":
        case "jsxs":
          return source + "/jsx-runtime";

        case "createElement":
          return source;
      }
    }

    function createImportLazily(pass, path, importName, source) {
      return function () {
        var actualSource = getSource(source, importName);

        if (isModule(path)) {
          var reference = get(pass, "imports/" + importName);
          if (reference) return cloneNode(reference);
          reference = addNamed(path, importName, actualSource, {
            importedInterop: "uncompiled",
            importPosition: "after"
          });
          set(pass, "imports/" + importName, reference);
          return reference;
        } else {
          var _reference = get(pass, "requires/" + actualSource);

          if (_reference) {
            _reference = cloneNode(_reference);
          } else {
            _reference = addNamespace(path, actualSource, {
              importedInterop: "uncompiled"
            });
            set(pass, "requires/" + actualSource, _reference);
          }

          return memberExpression(_reference, identifier(importName));
        }
      };
    }
  }

  function toMemberExpression(id) {
    return id.split(".").map(function (name) {
      return identifier(name);
    }).reduce(function (object, property) {
      return memberExpression(object, property);
    });
  }

  function makeSource(path, state) {
    var location = path.node.loc;

    if (!location) {
      return path.scope.buildUndefinedNode();
    }

    if (!state.fileNameIdentifier) {
      var _state$filename = state.filename,
          filename = _state$filename === void 0 ? "" : _state$filename;
      var fileNameIdentifier = path.scope.generateUidIdentifier("_jsxFileName");
      var scope = path.hub.getScope();

      if (scope) {
        scope.push({
          id: fileNameIdentifier,
          init: stringLiteral(filename)
        });
      }

      state.fileNameIdentifier = fileNameIdentifier;
    }

    return makeTrace(cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
  }

  function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
    var fileLineLiteral = lineNumber != null ? numericLiteral(lineNumber) : nullLiteral();
    var fileColumnLiteral = column0Based != null ? numericLiteral(column0Based + 1) : nullLiteral();
    var fileNameProperty = objectProperty(identifier("fileName"), fileNameIdentifier);
    var lineNumberProperty = objectProperty(identifier("lineNumber"), fileLineLiteral);
    var columnNumberProperty = objectProperty(identifier("columnNumber"), fileColumnLiteral);
    return objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
  }

  function sourceSelfError(path, name) {
    var pluginName = "transform-react-jsx-" + name.slice(2);
    return path.buildCodeFrameError("Duplicate " + name + " prop found. You are most likely using the deprecated " + pluginName + " Babel plugin. Both __source and __self are automatically set when using the automatic runtime. Please remove transform-react-jsx-source and transform-react-jsx-self from your Babel config.");
  }

  var transformReactJSX = createPlugin({
    name: "transform-react-jsx",
    development: false
  });

  var transformReactJsxCompat = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-react-jsx-compat",
      manipulateOptions: function manipulateOptions(opts, parserOpts) {
        parserOpts.plugins.push("jsx");
      },
      visitor: helper({
        pre: function pre(state) {
          state.callee = state.tagExpr;
        },
        post: function post(state) {
          if (react.isCompatTag(state.tagName)) {
            state.call = callExpression(memberExpression(memberExpression(identifier("React"), identifier("DOM")), state.tagExpr, isLiteral(state.tagExpr)), state.args);
          }
        },
        compat: true
      })
    };
  });

  var transformReactJSXDevelopment = createPlugin({
    name: "transform-react-jsx/development",
    development: true
  });

  var TRACE_ID$1 = "__self";
  var transformReactJsxSelf = declare(function (api) {
    api.assertVersion(7);
    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(_ref) {
        var node = _ref.node;
        var id = jsxIdentifier(TRACE_ID$1);
        var trace = thisExpression();
        node.attributes.push(jsxAttribute(id, jsxExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-self",
      visitor: {
        Program: function Program(path) {
          path.traverse(visitor);
        }
      }
    };
  });

  var TRACE_ID = "__source";
  var FILE_NAME_VAR = "_jsxFileName";
  var transformReactJsxSource = declare(function (api) {
    api.assertVersion(7);

    function makeTrace(fileNameIdentifier, lineNumber, column0Based) {
      var fileLineLiteral = lineNumber != null ? numericLiteral(lineNumber) : nullLiteral();
      var fileColumnLiteral = column0Based != null ? numericLiteral(column0Based + 1) : nullLiteral();
      var fileNameProperty = objectProperty(identifier("fileName"), fileNameIdentifier);
      var lineNumberProperty = objectProperty(identifier("lineNumber"), fileLineLiteral);
      var columnNumberProperty = objectProperty(identifier("columnNumber"), fileColumnLiteral);
      return objectExpression([fileNameProperty, lineNumberProperty, columnNumberProperty]);
    }

    var visitor = {
      JSXOpeningElement: function JSXOpeningElement(path, state) {
        var id = jsxIdentifier(TRACE_ID);
        var location = path.container.openingElement.loc;

        if (!location) {
          return;
        }

        var attributes = path.container.openingElement.attributes;

        for (var i = 0; i < attributes.length; i++) {
          var name = attributes[i].name;

          if ((name == null ? void 0 : name.name) === TRACE_ID) {
            return;
          }
        }

        if (!state.fileNameIdentifier) {
          var fileName = state.filename || "";
          var fileNameIdentifier = path.scope.generateUidIdentifier(FILE_NAME_VAR);
          var scope = path.hub.getScope();

          if (scope) {
            scope.push({
              id: fileNameIdentifier,
              init: stringLiteral(fileName)
            });
          }

          state.fileNameIdentifier = fileNameIdentifier;
        }

        var trace = makeTrace(cloneNode(state.fileNameIdentifier), location.start.line, location.start.column);
        attributes.push(jsxAttribute(id, jsxExpressionContainer(trace)));
      }
    };
    return {
      name: "transform-react-jsx-source",
      visitor: visitor
    };
  });

  var _typeof_1 = createCommonjsModule(function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        module.exports = _typeof = function _typeof(obj) {
          return typeof obj;
        };

        module.exports["default"] = module.exports, module.exports.__esModule = true;
      } else {
        module.exports = _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };

        module.exports["default"] = module.exports, module.exports.__esModule = true;
      }

      return _typeof(obj);
    }

    module.exports = _typeof;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

  var interopRequireWildcard = createCommonjsModule(function (module) {
    var _typeof = _typeof_1["default"];

    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }

    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }

      if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return {
          "default": obj
        };
      }

      var cache = _getRequireWildcardCache(nodeInterop);

      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }

      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }

      newObj["default"] = obj;

      if (cache) {
        cache.set(obj, newObj);
      }

      return newObj;
    }

    module.exports = _interopRequireWildcard;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

  var interopRequireDefault = createCommonjsModule(function (module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    module.exports = _interopRequireDefault;
    module.exports["default"] = module.exports, module.exports.__esModule = true;
  }, "/$$rollup_base$$/node_modules/@babel/runtime/helpers");

  var wrapWithTypes_1 = wrapWithTypes;
  var getTypes_1 = getTypes;
  var runtimeProperty_1 = runtimeProperty;
  var isReference_1 = isReference;
  var replaceWithOrRemove_1 = replaceWithOrRemove;
  var currentTypes = null;

  function wrapWithTypes(types, fn) {
    return function () {
      var oldTypes = currentTypes;
      currentTypes = types;

      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return fn.apply(this, args);
      } finally {
        currentTypes = oldTypes;
      }
    };
  }

  function getTypes() {
    return currentTypes;
  }

  function runtimeProperty(name) {
    var t = getTypes();
    return t.memberExpression(t.identifier("regeneratorRuntime"), t.identifier(name), false);
  }

  function isReference(path) {
    return path.isReferenced() || path.parentPath.isAssignmentExpression({
      left: path.node
    });
  }

  function replaceWithOrRemove(path, replacement) {
    if (replacement) {
      path.replaceWith(replacement);
    } else {
      path.remove();
    }
  }

  var util$3 = Object.defineProperty({
    wrapWithTypes: wrapWithTypes_1,
    getTypes: getTypes_1,
    runtimeProperty: runtimeProperty_1,
    isReference: isReference_1,
    replaceWithOrRemove: replaceWithOrRemove_1
  }, '__esModule', {
    value: true
  });

  var util$2 = interopRequireWildcard(util$3);

  var hasOwn$3 = Object.prototype.hasOwnProperty;

  var hoist_1 = function hoist_1(funPath) {
    var t = util$2.getTypes();
    t.assertFunction(funPath.node);
    var vars = {};

    function varDeclToExpr(_ref, includeIdentifiers) {
      var vdec = _ref.node,
          scope = _ref.scope;
      t.assertVariableDeclaration(vdec);
      var exprs = [];
      vdec.declarations.forEach(function (dec) {
        vars[dec.id.name] = t.identifier(dec.id.name);
        scope.removeBinding(dec.id.name);

        if (dec.init) {
          exprs.push(t.assignmentExpression("=", dec.id, dec.init));
        } else if (includeIdentifiers) {
          exprs.push(dec.id);
        }
      });
      if (exprs.length === 0) return null;
      if (exprs.length === 1) return exprs[0];
      return t.sequenceExpression(exprs);
    }

    funPath.get("body").traverse({
      VariableDeclaration: {
        exit: function exit(path) {
          var expr = varDeclToExpr(path, false);

          if (expr === null) {
            path.remove();
          } else {
            util$2.replaceWithOrRemove(path, t.expressionStatement(expr));
          }

          path.skip();
        }
      },
      ForStatement: function ForStatement(path) {
        var init = path.get("init");

        if (init.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(init, varDeclToExpr(init, false));
        }
      },
      ForXStatement: function ForXStatement(path) {
        var left = path.get("left");

        if (left.isVariableDeclaration()) {
          util$2.replaceWithOrRemove(left, varDeclToExpr(left, true));
        }
      },
      FunctionDeclaration: function FunctionDeclaration(path) {
        var node = path.node;
        vars[node.id.name] = node.id;
        var assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));

        if (path.parentPath.isBlockStatement()) {
          path.parentPath.unshiftContainer("body", assignment);
          path.remove();
        } else {
          util$2.replaceWithOrRemove(path, assignment);
        }

        path.scope.removeBinding(node.id.name);
        path.skip();
      },
      FunctionExpression: function FunctionExpression(path) {
        path.skip();
      },
      ArrowFunctionExpression: function ArrowFunctionExpression(path) {
        path.skip();
      }
    });
    var paramNames = {};
    funPath.get("params").forEach(function (paramPath) {
      var param = paramPath.node;

      if (t.isIdentifier(param)) {
        paramNames[param.name] = param;
      }
    });
    var declarations = [];
    Object.keys(vars).forEach(function (name) {
      if (!hasOwn$3.call(paramNames, name)) {
        declarations.push(t.variableDeclarator(vars[name], null));
      }
    });

    if (declarations.length === 0) {
      return null;
    }

    return t.variableDeclaration("var", declarations);
  };

  var hoist$2 = {
    hoist: hoist_1
  };

  var _assert$3 = interopRequireDefault(assert_1);

  function Entry$1() {
    _assert$3["default"].ok(this instanceof Entry$1);
  }

  function FunctionEntry(returnLoc) {
    Entry$1.call(this);
    (0, util$3.getTypes)().assertLiteral(returnLoc);
    this.returnLoc = returnLoc;
  }

  (0, util$5.inherits)(FunctionEntry, Entry$1);
  var FunctionEntry_1 = FunctionEntry;

  function LoopEntry(breakLoc, continueLoc, label) {
    Entry$1.call(this);
    var t = (0, util$3.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertLiteral(continueLoc);

    if (label) {
      t.assertIdentifier(label);
    } else {
      label = null;
    }

    this.breakLoc = breakLoc;
    this.continueLoc = continueLoc;
    this.label = label;
  }

  (0, util$5.inherits)(LoopEntry, Entry$1);
  var LoopEntry_1 = LoopEntry;

  function SwitchEntry(breakLoc) {
    Entry$1.call(this);
    (0, util$3.getTypes)().assertLiteral(breakLoc);
    this.breakLoc = breakLoc;
  }

  (0, util$5.inherits)(SwitchEntry, Entry$1);
  var SwitchEntry_1 = SwitchEntry;

  function TryEntry(firstLoc, catchEntry, finallyEntry) {
    Entry$1.call(this);
    var t = (0, util$3.getTypes)();
    t.assertLiteral(firstLoc);

    if (catchEntry) {
      _assert$3["default"].ok(catchEntry instanceof CatchEntry);
    } else {
      catchEntry = null;
    }

    if (finallyEntry) {
      _assert$3["default"].ok(finallyEntry instanceof FinallyEntry);
    } else {
      finallyEntry = null;
    }

    _assert$3["default"].ok(catchEntry || finallyEntry);

    this.firstLoc = firstLoc;
    this.catchEntry = catchEntry;
    this.finallyEntry = finallyEntry;
  }

  (0, util$5.inherits)(TryEntry, Entry$1);
  var TryEntry_1 = TryEntry;

  function CatchEntry(firstLoc, paramId) {
    Entry$1.call(this);
    var t = (0, util$3.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertIdentifier(paramId);
    this.firstLoc = firstLoc;
    this.paramId = paramId;
  }

  (0, util$5.inherits)(CatchEntry, Entry$1);
  var CatchEntry_1 = CatchEntry;

  function FinallyEntry(firstLoc, afterLoc) {
    Entry$1.call(this);
    var t = (0, util$3.getTypes)();
    t.assertLiteral(firstLoc);
    t.assertLiteral(afterLoc);
    this.firstLoc = firstLoc;
    this.afterLoc = afterLoc;
  }

  (0, util$5.inherits)(FinallyEntry, Entry$1);
  var FinallyEntry_1 = FinallyEntry;

  function LabeledEntry(breakLoc, label) {
    Entry$1.call(this);
    var t = (0, util$3.getTypes)();
    t.assertLiteral(breakLoc);
    t.assertIdentifier(label);
    this.breakLoc = breakLoc;
    this.label = label;
  }

  (0, util$5.inherits)(LabeledEntry, Entry$1);
  var LabeledEntry_1 = LabeledEntry;

  function LeapManager(emitter) {
    _assert$3["default"].ok(this instanceof LeapManager);

    _assert$3["default"].ok(emitter instanceof emit.Emitter);

    this.emitter = emitter;
    this.entryStack = [new FunctionEntry(emitter.finalLoc)];
  }

  var LMp = LeapManager.prototype;
  var LeapManager_1 = LeapManager;

  LMp.withEntry = function (entry, callback) {
    _assert$3["default"].ok(entry instanceof Entry$1);

    this.entryStack.push(entry);

    try {
      callback.call(this.emitter);
    } finally {
      var popped = this.entryStack.pop();

      _assert$3["default"].strictEqual(popped, entry);
    }
  };

  LMp._findLeapLocation = function (property, label) {
    for (var i = this.entryStack.length - 1; i >= 0; --i) {
      var entry = this.entryStack[i];
      var loc = entry[property];

      if (loc) {
        if (label) {
          if (entry.label && entry.label.name === label.name) {
            return loc;
          }
        } else if (entry instanceof LabeledEntry) ; else {
          return loc;
        }
      }
    }

    return null;
  };

  LMp.getBreakLoc = function (label) {
    return this._findLeapLocation("breakLoc", label);
  };

  LMp.getContinueLoc = function (label) {
    return this._findLeapLocation("continueLoc", label);
  };

  var leap$1 = {
    FunctionEntry: FunctionEntry_1,
    LoopEntry: LoopEntry_1,
    SwitchEntry: SwitchEntry_1,
    TryEntry: TryEntry_1,
    CatchEntry: CatchEntry_1,
    FinallyEntry: FinallyEntry_1,
    LabeledEntry: LabeledEntry_1,
    LeapManager: LeapManager_1
  };

  var originalObject = Object;
  var originalDefProp = Object.defineProperty;
  var originalCreate = Object.create;

  function defProp(obj, name, value) {
    if (originalDefProp) try {
      originalDefProp.call(originalObject, obj, name, {
        value: value
      });
    } catch (definePropertyIsBrokenInIE8) {
      obj[name] = value;
    } else {
      obj[name] = value;
    }
  }

  function makeSafeToCall(fun) {
    if (fun) {
      defProp(fun, "call", fun.call);
      defProp(fun, "apply", fun.apply);
    }

    return fun;
  }

  makeSafeToCall(originalDefProp);
  makeSafeToCall(originalCreate);
  var hasOwn$2 = makeSafeToCall(Object.prototype.hasOwnProperty);
  var numToStr = makeSafeToCall(Number.prototype.toString);
  var strSlice = makeSafeToCall(String.prototype.slice);

  var cloner = function cloner() {};

  function create(prototype) {
    if (originalCreate) {
      return originalCreate.call(originalObject, prototype);
    }

    cloner.prototype = prototype || null;
    return new cloner();
  }

  var rand = Math.random;
  var uniqueKeys = create(null);

  function makeUniqueKey() {
    do {
      var uniqueKey = internString(strSlice.call(numToStr.call(rand(), 36), 2));
    } while (hasOwn$2.call(uniqueKeys, uniqueKey));

    return uniqueKeys[uniqueKey] = uniqueKey;
  }

  function internString(str) {
    var obj = {};
    obj[str] = true;
    return Object.keys(obj)[0];
  }

  var makeUniqueKey_1 = makeUniqueKey;
  var originalGetOPNs = Object.getOwnPropertyNames;

  Object.getOwnPropertyNames = function getOwnPropertyNames(object) {
    for (var names = originalGetOPNs(object), src = 0, dst = 0, len = names.length; src < len; ++src) {
      if (!hasOwn$2.call(uniqueKeys, names[src])) {
        if (src > dst) {
          names[dst] = names[src];
        }

        ++dst;
      }
    }

    names.length = dst;
    return names;
  };

  function defaultCreatorFn(object) {
    return create(null);
  }

  function makeAccessor(secretCreatorFn) {
    var brand = makeUniqueKey();
    var passkey = create(null);
    secretCreatorFn = secretCreatorFn || defaultCreatorFn;

    function register(object) {
      var secret;

      function vault(key, forget) {
        if (key === passkey) {
          return forget ? secret = null : secret || (secret = secretCreatorFn(object));
        }
      }

      defProp(object, brand, vault);
    }

    function accessor(object) {
      if (!hasOwn$2.call(object, brand)) register(object);
      return object[brand](passkey);
    }

    accessor.forget = function (object) {
      if (hasOwn$2.call(object, brand)) object[brand](passkey, true);
    };

    return accessor;
  }

  var makeAccessor_1 = makeAccessor;
  var _private = {
    makeUniqueKey: makeUniqueKey_1,
    makeAccessor: makeAccessor_1
  };

  var _assert$2 = interopRequireDefault(assert_1);

  var m = (0, _private.makeAccessor)();
  var hasOwn$1 = Object.prototype.hasOwnProperty;

  function makePredicate(propertyName, knownTypes) {
    function onlyChildren(node) {
      var t = (0, util$3.getTypes)();
      t.assertNode(node);
      var result = false;

      function check(child) {
        if (result) ; else if (Array.isArray(child)) {
          child.some(check);
        } else if (t.isNode(child)) {
          _assert$2["default"].strictEqual(result, false);

          result = predicate(child);
        }

        return result;
      }

      var keys = t.VISITOR_KEYS[node.type];

      if (keys) {
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var child = node[key];
          check(child);
        }
      }

      return result;
    }

    function predicate(node) {
      (0, util$3.getTypes)().assertNode(node);
      var meta = m(node);
      if (hasOwn$1.call(meta, propertyName)) return meta[propertyName];
      if (hasOwn$1.call(opaqueTypes, node.type)) return meta[propertyName] = false;
      if (hasOwn$1.call(knownTypes, node.type)) return meta[propertyName] = true;
      return meta[propertyName] = onlyChildren(node);
    }

    predicate.onlyChildren = onlyChildren;
    return predicate;
  }

  var opaqueTypes = {
    FunctionExpression: true,
    ArrowFunctionExpression: true
  };
  var sideEffectTypes = {
    CallExpression: true,
    ForInStatement: true,
    UnaryExpression: true,
    BinaryExpression: true,
    AssignmentExpression: true,
    UpdateExpression: true,
    NewExpression: true
  };
  var leapTypes = {
    YieldExpression: true,
    BreakStatement: true,
    ContinueStatement: true,
    ReturnStatement: true,
    ThrowStatement: true
  };

  for (var type in leapTypes) {
    if (hasOwn$1.call(leapTypes, type)) {
      sideEffectTypes[type] = leapTypes[type];
    }
  }

  var hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
  var containsLeap = makePredicate("containsLeap", leapTypes);
  var meta$1 = {
    hasSideEffects: hasSideEffects,
    containsLeap: containsLeap
  };

  var _assert$1 = interopRequireDefault(assert_1);

  var leap = interopRequireWildcard(leap$1);

  var meta = interopRequireWildcard(meta$1);

  var util$1 = interopRequireWildcard(util$3);

  var hasOwn = Object.prototype.hasOwnProperty;

  function Emitter(contextId) {
    _assert$1["default"].ok(this instanceof Emitter);

    util$1.getTypes().assertIdentifier(contextId);
    this.nextTempId = 0;
    this.contextId = contextId;
    this.listing = [];
    this.marked = [true];
    this.insertedLocs = new Set();
    this.finalLoc = this.loc();
    this.tryEntries = [];
    this.leapManager = new leap.LeapManager(this);
  }

  var Ep = Emitter.prototype;
  var Emitter_1 = Emitter;

  Ep.loc = function () {
    var l = util$1.getTypes().numericLiteral(-1);
    this.insertedLocs.add(l);
    return l;
  };

  Ep.getInsertedLocs = function () {
    return this.insertedLocs;
  };

  Ep.getContextId = function () {
    return util$1.getTypes().clone(this.contextId);
  };

  Ep.mark = function (loc) {
    util$1.getTypes().assertLiteral(loc);
    var index = this.listing.length;

    if (loc.value === -1) {
      loc.value = index;
    } else {
      _assert$1["default"].strictEqual(loc.value, index);
    }

    this.marked[index] = true;
    return loc;
  };

  Ep.emit = function (node) {
    var t = util$1.getTypes();

    if (t.isExpression(node)) {
      node = t.expressionStatement(node);
    }

    t.assertStatement(node);
    this.listing.push(node);
  };

  Ep.emitAssign = function (lhs, rhs) {
    this.emit(this.assign(lhs, rhs));
    return lhs;
  };

  Ep.assign = function (lhs, rhs) {
    var t = util$1.getTypes();
    return t.expressionStatement(t.assignmentExpression("=", t.cloneDeep(lhs), rhs));
  };

  Ep.contextProperty = function (name, computed) {
    var t = util$1.getTypes();
    return t.memberExpression(this.getContextId(), computed ? t.stringLiteral(name) : t.identifier(name), !!computed);
  };

  Ep.stop = function (rval) {
    if (rval) {
      this.setReturnValue(rval);
    }

    this.jump(this.finalLoc);
  };

  Ep.setReturnValue = function (valuePath) {
    util$1.getTypes().assertExpression(valuePath.value);
    this.emitAssign(this.contextProperty("rval"), this.explodeExpression(valuePath));
  };

  Ep.clearPendingException = function (tryLoc, assignee) {
    var t = util$1.getTypes();
    t.assertLiteral(tryLoc);
    var catchCall = t.callExpression(this.contextProperty("catch", true), [t.clone(tryLoc)]);

    if (assignee) {
      this.emitAssign(assignee, catchCall);
    } else {
      this.emit(catchCall);
    }
  };

  Ep.jump = function (toLoc) {
    this.emitAssign(this.contextProperty("next"), toLoc);
    this.emit(util$1.getTypes().breakStatement());
  };

  Ep.jumpIf = function (test, toLoc) {
    var t = util$1.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    this.emit(t.ifStatement(test, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.jumpIfNot = function (test, toLoc) {
    var t = util$1.getTypes();
    t.assertExpression(test);
    t.assertLiteral(toLoc);
    var negatedTest;

    if (t.isUnaryExpression(test) && test.operator === "!") {
      negatedTest = test.argument;
    } else {
      negatedTest = t.unaryExpression("!", test);
    }

    this.emit(t.ifStatement(negatedTest, t.blockStatement([this.assign(this.contextProperty("next"), toLoc), t.breakStatement()])));
  };

  Ep.makeTempVar = function () {
    return this.contextProperty("t" + this.nextTempId++);
  };

  Ep.getContextFunction = function (id) {
    var t = util$1.getTypes();
    return t.functionExpression(id || null, [this.getContextId()], t.blockStatement([this.getDispatchLoop()]), false, false);
  };

  Ep.getDispatchLoop = function () {
    var self = this;
    var t = util$1.getTypes();
    var cases = [];
    var current;
    var alreadyEnded = false;
    self.listing.forEach(function (stmt, i) {
      if (self.marked.hasOwnProperty(i)) {
        cases.push(t.switchCase(t.numericLiteral(i), current = []));
        alreadyEnded = false;
      }

      if (!alreadyEnded) {
        current.push(stmt);
        if (t.isCompletionStatement(stmt)) alreadyEnded = true;
      }
    });
    this.finalLoc.value = this.listing.length;
    cases.push(t.switchCase(this.finalLoc, []), t.switchCase(t.stringLiteral("end"), [t.returnStatement(t.callExpression(this.contextProperty("stop"), []))]));
    return t.whileStatement(t.numericLiteral(1), t.switchStatement(t.assignmentExpression("=", this.contextProperty("prev"), this.contextProperty("next")), cases));
  };

  Ep.getTryLocsList = function () {
    if (this.tryEntries.length === 0) {
      return null;
    }

    var t = util$1.getTypes();
    var lastLocValue = 0;
    return t.arrayExpression(this.tryEntries.map(function (tryEntry) {
      var thisLocValue = tryEntry.firstLoc.value;

      _assert$1["default"].ok(thisLocValue >= lastLocValue, "try entries out of order");

      lastLocValue = thisLocValue;
      var ce = tryEntry.catchEntry;
      var fe = tryEntry.finallyEntry;
      var locs = [tryEntry.firstLoc, ce ? ce.firstLoc : null];

      if (fe) {
        locs[2] = fe.firstLoc;
        locs[3] = fe.afterLoc;
      }

      return t.arrayExpression(locs.map(function (loc) {
        return loc && t.clone(loc);
      }));
    }));
  };

  Ep.explode = function (path, ignoreResult) {
    var t = util$1.getTypes();
    var node = path.node;
    var self = this;
    t.assertNode(node);
    if (t.isDeclaration(node)) throw getDeclError(node);
    if (t.isStatement(node)) return self.explodeStatement(path);
    if (t.isExpression(node)) return self.explodeExpression(path, ignoreResult);

    switch (node.type) {
      case "Program":
        return path.get("body").map(self.explodeStatement, self);

      case "VariableDeclarator":
        throw getDeclError(node);

      case "Property":
      case "SwitchCase":
      case "CatchClause":
        throw new Error(node.type + " nodes should be handled by their parents");

      default:
        throw new Error("unknown Node of type " + JSON.stringify(node.type));
    }
  };

  function getDeclError(node) {
    return new Error("all declarations should have been transformed into " + "assignments before the Exploder began its work: " + JSON.stringify(node));
  }

  Ep.explodeStatement = function (path, labelId) {
    var t = util$1.getTypes();
    var stmt = path.node;
    var self = this;
    var before, after, head;
    t.assertStatement(stmt);

    if (labelId) {
      t.assertIdentifier(labelId);
    } else {
      labelId = null;
    }

    if (t.isBlockStatement(stmt)) {
      path.get("body").forEach(function (path) {
        self.explodeStatement(path);
      });
      return;
    }

    if (!meta.containsLeap(stmt)) {
      self.emit(stmt);
      return;
    }

    switch (stmt.type) {
      case "ExpressionStatement":
        self.explodeExpression(path.get("expression"), true);
        break;

      case "LabeledStatement":
        after = this.loc();
        self.leapManager.withEntry(new leap.LabeledEntry(after, stmt.label), function () {
          self.explodeStatement(path.get("body"), stmt.label);
        });
        self.mark(after);
        break;

      case "WhileStatement":
        before = this.loc();
        after = this.loc();
        self.mark(before);
        self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        self.leapManager.withEntry(new leap.LoopEntry(after, before, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(before);
        self.mark(after);
        break;

      case "DoWhileStatement":
        var first = this.loc();
        var test = this.loc();
        after = this.loc();
        self.mark(first);
        self.leapManager.withEntry(new leap.LoopEntry(after, test, labelId), function () {
          self.explode(path.get("body"));
        });
        self.mark(test);
        self.jumpIf(self.explodeExpression(path.get("test")), first);
        self.mark(after);
        break;

      case "ForStatement":
        head = this.loc();
        var update = this.loc();
        after = this.loc();

        if (stmt.init) {
          self.explode(path.get("init"), true);
        }

        self.mark(head);

        if (stmt.test) {
          self.jumpIfNot(self.explodeExpression(path.get("test")), after);
        }

        self.leapManager.withEntry(new leap.LoopEntry(after, update, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.mark(update);

        if (stmt.update) {
          self.explode(path.get("update"), true);
        }

        self.jump(head);
        self.mark(after);
        break;

      case "TypeCastExpression":
        return self.explodeExpression(path.get("expression"));

      case "ForInStatement":
        head = this.loc();
        after = this.loc();
        var keyIterNextFn = self.makeTempVar();
        self.emitAssign(keyIterNextFn, t.callExpression(util$1.runtimeProperty("keys"), [self.explodeExpression(path.get("right"))]));
        self.mark(head);
        var keyInfoTmpVar = self.makeTempVar();
        self.jumpIf(t.memberExpression(t.assignmentExpression("=", keyInfoTmpVar, t.callExpression(t.cloneDeep(keyIterNextFn), [])), t.identifier("done"), false), after);
        self.emitAssign(stmt.left, t.memberExpression(t.cloneDeep(keyInfoTmpVar), t.identifier("value"), false));
        self.leapManager.withEntry(new leap.LoopEntry(after, head, labelId), function () {
          self.explodeStatement(path.get("body"));
        });
        self.jump(head);
        self.mark(after);
        break;

      case "BreakStatement":
        self.emitAbruptCompletion({
          type: "break",
          target: self.leapManager.getBreakLoc(stmt.label)
        });
        break;

      case "ContinueStatement":
        self.emitAbruptCompletion({
          type: "continue",
          target: self.leapManager.getContinueLoc(stmt.label)
        });
        break;

      case "SwitchStatement":
        var disc = self.emitAssign(self.makeTempVar(), self.explodeExpression(path.get("discriminant")));
        after = this.loc();
        var defaultLoc = this.loc();
        var condition = defaultLoc;
        var caseLocs = [];
        var cases = stmt.cases || [];

        for (var i = cases.length - 1; i >= 0; --i) {
          var c = cases[i];
          t.assertSwitchCase(c);

          if (c.test) {
            condition = t.conditionalExpression(t.binaryExpression("===", t.cloneDeep(disc), c.test), caseLocs[i] = this.loc(), condition);
          } else {
            caseLocs[i] = defaultLoc;
          }
        }

        var discriminant = path.get("discriminant");
        util$1.replaceWithOrRemove(discriminant, condition);
        self.jump(self.explodeExpression(discriminant));
        self.leapManager.withEntry(new leap.SwitchEntry(after), function () {
          path.get("cases").forEach(function (casePath) {
            var i = casePath.key;
            self.mark(caseLocs[i]);
            casePath.get("consequent").forEach(function (path) {
              self.explodeStatement(path);
            });
          });
        });
        self.mark(after);

        if (defaultLoc.value === -1) {
          self.mark(defaultLoc);

          _assert$1["default"].strictEqual(after.value, defaultLoc.value);
        }

        break;

      case "IfStatement":
        var elseLoc = stmt.alternate && this.loc();
        after = this.loc();
        self.jumpIfNot(self.explodeExpression(path.get("test")), elseLoc || after);
        self.explodeStatement(path.get("consequent"));

        if (elseLoc) {
          self.jump(after);
          self.mark(elseLoc);
          self.explodeStatement(path.get("alternate"));
        }

        self.mark(after);
        break;

      case "ReturnStatement":
        self.emitAbruptCompletion({
          type: "return",
          value: self.explodeExpression(path.get("argument"))
        });
        break;

      case "WithStatement":
        throw new Error("WithStatement not supported in generator functions.");

      case "TryStatement":
        after = this.loc();
        var handler = stmt.handler;
        var catchLoc = handler && this.loc();
        var catchEntry = catchLoc && new leap.CatchEntry(catchLoc, handler.param);
        var finallyLoc = stmt.finalizer && this.loc();
        var finallyEntry = finallyLoc && new leap.FinallyEntry(finallyLoc, after);
        var tryEntry = new leap.TryEntry(self.getUnmarkedCurrentLoc(), catchEntry, finallyEntry);
        self.tryEntries.push(tryEntry);
        self.updateContextPrevLoc(tryEntry.firstLoc);
        self.leapManager.withEntry(tryEntry, function () {
          self.explodeStatement(path.get("block"));

          if (catchLoc) {
            if (finallyLoc) {
              self.jump(finallyLoc);
            } else {
              self.jump(after);
            }

            self.updateContextPrevLoc(self.mark(catchLoc));
            var bodyPath = path.get("handler.body");
            var safeParam = self.makeTempVar();
            self.clearPendingException(tryEntry.firstLoc, safeParam);
            bodyPath.traverse(catchParamVisitor, {
              getSafeParam: function getSafeParam() {
                return t.cloneDeep(safeParam);
              },
              catchParamName: handler.param.name
            });
            self.leapManager.withEntry(catchEntry, function () {
              self.explodeStatement(bodyPath);
            });
          }

          if (finallyLoc) {
            self.updateContextPrevLoc(self.mark(finallyLoc));
            self.leapManager.withEntry(finallyEntry, function () {
              self.explodeStatement(path.get("finalizer"));
            });
            self.emit(t.returnStatement(t.callExpression(self.contextProperty("finish"), [finallyEntry.firstLoc])));
          }
        });
        self.mark(after);
        break;

      case "ThrowStatement":
        self.emit(t.throwStatement(self.explodeExpression(path.get("argument"))));
        break;

      default:
        throw new Error("unknown Statement of type " + JSON.stringify(stmt.type));
    }
  };

  var catchParamVisitor = {
    Identifier: function Identifier(path, state) {
      if (path.node.name === state.catchParamName && util$1.isReference(path)) {
        util$1.replaceWithOrRemove(path, state.getSafeParam());
      }
    },
    Scope: function Scope(path, state) {
      if (path.scope.hasOwnBinding(state.catchParamName)) {
        path.skip();
      }
    }
  };

  Ep.emitAbruptCompletion = function (record) {
    if (!isValidCompletion(record)) {
      _assert$1["default"].ok(false, "invalid completion record: " + JSON.stringify(record));
    }

    _assert$1["default"].notStrictEqual(record.type, "normal", "normal completions are not abrupt");

    var t = util$1.getTypes();
    var abruptArgs = [t.stringLiteral(record.type)];

    if (record.type === "break" || record.type === "continue") {
      t.assertLiteral(record.target);
      abruptArgs[1] = this.insertedLocs.has(record.target) ? record.target : t.cloneDeep(record.target);
    } else if (record.type === "return" || record.type === "throw") {
      if (record.value) {
        t.assertExpression(record.value);
        abruptArgs[1] = this.insertedLocs.has(record.value) ? record.value : t.cloneDeep(record.value);
      }
    }

    this.emit(t.returnStatement(t.callExpression(this.contextProperty("abrupt"), abruptArgs)));
  };

  function isValidCompletion(record) {
    var type = record.type;

    if (type === "normal") {
      return !hasOwn.call(record, "target");
    }

    if (type === "break" || type === "continue") {
      return !hasOwn.call(record, "value") && util$1.getTypes().isLiteral(record.target);
    }

    if (type === "return" || type === "throw") {
      return hasOwn.call(record, "value") && !hasOwn.call(record, "target");
    }

    return false;
  }

  Ep.getUnmarkedCurrentLoc = function () {
    return util$1.getTypes().numericLiteral(this.listing.length);
  };

  Ep.updateContextPrevLoc = function (loc) {
    var t = util$1.getTypes();

    if (loc) {
      t.assertLiteral(loc);

      if (loc.value === -1) {
        loc.value = this.listing.length;
      } else {
        _assert$1["default"].strictEqual(loc.value, this.listing.length);
      }
    } else {
      loc = this.getUnmarkedCurrentLoc();
    }

    this.emitAssign(this.contextProperty("prev"), loc);
  };

  Ep.explodeExpression = function (path, ignoreResult) {
    var t = util$1.getTypes();
    var expr = path.node;

    if (expr) {
      t.assertExpression(expr);
    } else {
      return expr;
    }

    var self = this;
    var result;
    var after;

    function finish(expr) {
      t.assertExpression(expr);

      if (ignoreResult) {
        self.emit(expr);
      } else {
        return expr;
      }
    }

    if (!meta.containsLeap(expr)) {
      return finish(expr);
    }

    var hasLeapingChildren = meta.containsLeap.onlyChildren(expr);

    function explodeViaTempVar(tempVar, childPath, ignoreChildResult) {
      _assert$1["default"].ok(!ignoreChildResult || !tempVar, "Ignoring the result of a child expression but forcing it to " + "be assigned to a temporary variable?");

      var result = self.explodeExpression(childPath, ignoreChildResult);

      if (ignoreChildResult) ; else if (tempVar || hasLeapingChildren && !t.isLiteral(result)) {
        result = self.emitAssign(tempVar || self.makeTempVar(), result);
      }

      return result;
    }

    switch (expr.type) {
      case "MemberExpression":
        return finish(t.memberExpression(self.explodeExpression(path.get("object")), expr.computed ? explodeViaTempVar(null, path.get("property")) : expr.property, expr.computed));

      case "CallExpression":
        var calleePath = path.get("callee");
        var argsPath = path.get("arguments");
        var newCallee;
        var newArgs = [];
        var hasLeapingArgs = false;
        argsPath.forEach(function (argPath) {
          hasLeapingArgs = hasLeapingArgs || meta.containsLeap(argPath.node);
        });

        if (t.isMemberExpression(calleePath.node)) {
          if (hasLeapingArgs) {
            var newObject = explodeViaTempVar(self.makeTempVar(), calleePath.get("object"));
            var newProperty = calleePath.node.computed ? explodeViaTempVar(null, calleePath.get("property")) : calleePath.node.property;
            newArgs.unshift(newObject);
            newCallee = t.memberExpression(t.memberExpression(t.cloneDeep(newObject), newProperty, calleePath.node.computed), t.identifier("call"), false);
          } else {
            newCallee = self.explodeExpression(calleePath);
          }
        } else {
          newCallee = explodeViaTempVar(null, calleePath);

          if (t.isMemberExpression(newCallee)) {
            newCallee = t.sequenceExpression([t.numericLiteral(0), t.cloneDeep(newCallee)]);
          }
        }

        argsPath.forEach(function (argPath) {
          newArgs.push(explodeViaTempVar(null, argPath));
        });
        return finish(t.callExpression(newCallee, newArgs.map(function (arg) {
          return t.cloneDeep(arg);
        })));

      case "NewExpression":
        return finish(t.newExpression(explodeViaTempVar(null, path.get("callee")), path.get("arguments").map(function (argPath) {
          return explodeViaTempVar(null, argPath);
        })));

      case "ObjectExpression":
        return finish(t.objectExpression(path.get("properties").map(function (propPath) {
          if (propPath.isObjectProperty()) {
            return t.objectProperty(propPath.node.key, explodeViaTempVar(null, propPath.get("value")), propPath.node.computed);
          } else {
            return propPath.node;
          }
        })));

      case "ArrayExpression":
        return finish(t.arrayExpression(path.get("elements").map(function (elemPath) {
          return explodeViaTempVar(null, elemPath);
        })));

      case "SequenceExpression":
        var lastIndex = expr.expressions.length - 1;
        path.get("expressions").forEach(function (exprPath) {
          if (exprPath.key === lastIndex) {
            result = self.explodeExpression(exprPath, ignoreResult);
          } else {
            self.explodeExpression(exprPath, true);
          }
        });
        return result;

      case "LogicalExpression":
        after = this.loc();

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        var left = explodeViaTempVar(result, path.get("left"));

        if (expr.operator === "&&") {
          self.jumpIfNot(left, after);
        } else {
          _assert$1["default"].strictEqual(expr.operator, "||");

          self.jumpIf(left, after);
        }

        explodeViaTempVar(result, path.get("right"), ignoreResult);
        self.mark(after);
        return result;

      case "ConditionalExpression":
        var elseLoc = this.loc();
        after = this.loc();
        var test = self.explodeExpression(path.get("test"));
        self.jumpIfNot(test, elseLoc);

        if (!ignoreResult) {
          result = self.makeTempVar();
        }

        explodeViaTempVar(result, path.get("consequent"), ignoreResult);
        self.jump(after);
        self.mark(elseLoc);
        explodeViaTempVar(result, path.get("alternate"), ignoreResult);
        self.mark(after);
        return result;

      case "UnaryExpression":
        return finish(t.unaryExpression(expr.operator, self.explodeExpression(path.get("argument")), !!expr.prefix));

      case "BinaryExpression":
        return finish(t.binaryExpression(expr.operator, explodeViaTempVar(null, path.get("left")), explodeViaTempVar(null, path.get("right"))));

      case "AssignmentExpression":
        if (expr.operator === "=") {
          return finish(t.assignmentExpression(expr.operator, self.explodeExpression(path.get("left")), self.explodeExpression(path.get("right"))));
        }

        var lhs = self.explodeExpression(path.get("left"));
        var temp = self.emitAssign(self.makeTempVar(), lhs);
        return finish(t.assignmentExpression("=", t.cloneDeep(lhs), t.assignmentExpression(expr.operator, t.cloneDeep(temp), self.explodeExpression(path.get("right")))));

      case "UpdateExpression":
        return finish(t.updateExpression(expr.operator, self.explodeExpression(path.get("argument")), expr.prefix));

      case "YieldExpression":
        after = this.loc();
        var arg = expr.argument && self.explodeExpression(path.get("argument"));

        if (arg && expr.delegate) {
          var _result = self.makeTempVar();

          var _ret = t.returnStatement(t.callExpression(self.contextProperty("delegateYield"), [arg, t.stringLiteral(_result.property.name), after]));

          _ret.loc = expr.loc;
          self.emit(_ret);
          self.mark(after);
          return _result;
        }

        self.emitAssign(self.contextProperty("next"), after);
        var ret = t.returnStatement(t.cloneDeep(arg) || null);
        ret.loc = expr.loc;
        self.emit(ret);
        self.mark(after);
        return self.contextProperty("sent");

      default:
        throw new Error("unknown Expression of type " + JSON.stringify(expr.type));
    }
  };

  var emit = {
    Emitter: Emitter_1
  };

  var replaceShorthandObjectMethod_1 = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = replaceShorthandObjectMethod;

    var util = interopRequireWildcard(util$3);

    function replaceShorthandObjectMethod(path) {
      var t = util.getTypes();

      if (!path.node || !t.isFunction(path.node)) {
        throw new Error("replaceShorthandObjectMethod can only be called on Function AST node paths.");
      }

      if (!t.isObjectMethod(path.node)) {
        return path;
      }

      if (!path.node.generator) {
        return path;
      }

      var parameters = path.node.params.map(function (param) {
        return t.cloneDeep(param);
      });
      var functionExpression = t.functionExpression(null, parameters, t.cloneDeep(path.node.body), path.node.generator, path.node.async);
      util.replaceWithOrRemove(path, t.objectProperty(t.cloneDeep(path.node.key), functionExpression, path.node.computed, false));
      return path.get("value");
    }
  }, "/$$rollup_base$$/node_modules/regenerator-transform/lib");

  var _assert = interopRequireDefault(assert_1);

  var _replaceShorthandObjectMethod = interopRequireDefault(replaceShorthandObjectMethod_1);

  var util = interopRequireWildcard(util$3);

  var getVisitor = function getVisitor(_ref) {
    var t = _ref.types;
    return {
      Method: function Method(path, state) {
        var node = path.node;
        if (!shouldRegenerate(node, state)) return;
        var container = t.functionExpression(null, [], t.cloneNode(node.body, false), node.generator, node.async);
        path.get("body").set("body", [t.returnStatement(t.callExpression(container, []))]);
        node.async = false;
        node.generator = false;
        path.get("body.body.0.argument.callee").unwrapFunctionEnvironment();
      },
      Function: {
        exit: util.wrapWithTypes(t, function (path, state) {
          var node = path.node;
          if (!shouldRegenerate(node, state)) return;
          path = (0, _replaceShorthandObjectMethod["default"])(path);
          node = path.node;
          var contextId = path.scope.generateUidIdentifier("context");
          var argsId = path.scope.generateUidIdentifier("args");
          path.ensureBlock();
          var bodyBlockPath = path.get("body");

          if (node.async) {
            bodyBlockPath.traverse(awaitVisitor);
          }

          bodyBlockPath.traverse(functionSentVisitor, {
            context: contextId
          });
          var outerBody = [];
          var innerBody = [];
          bodyBlockPath.get("body").forEach(function (childPath) {
            var node = childPath.node;

            if (t.isExpressionStatement(node) && t.isStringLiteral(node.expression)) {
              outerBody.push(node);
            } else if (node && node._blockHoist != null) {
              outerBody.push(node);
            } else {
              innerBody.push(node);
            }
          });

          if (outerBody.length > 0) {
            bodyBlockPath.node.body = innerBody;
          }

          var outerFnExpr = getOuterFnExpr(path);
          t.assertIdentifier(node.id);
          var innerFnId = t.identifier(node.id.name + "$");
          var vars = (0, hoist$2.hoist)(path);
          var context = {
            usesThis: false,
            usesArguments: false,
            getArgsId: function getArgsId() {
              return t.clone(argsId);
            }
          };
          path.traverse(argumentsThisVisitor, context);

          if (context.usesArguments) {
            vars = vars || t.variableDeclaration("var", []);
            var argumentIdentifier = t.identifier("arguments");
            argumentIdentifier._shadowedFunctionLiteral = path;
            vars.declarations.push(t.variableDeclarator(t.clone(argsId), argumentIdentifier));
          }

          var emitter = new emit.Emitter(contextId);
          emitter.explode(path.get("body"));

          if (vars && vars.declarations.length > 0) {
            outerBody.push(vars);
          }

          var wrapArgs = [emitter.getContextFunction(innerFnId)];
          var tryLocsList = emitter.getTryLocsList();

          if (node.generator) {
            wrapArgs.push(outerFnExpr);
          } else if (context.usesThis || tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (context.usesThis) {
            wrapArgs.push(t.thisExpression());
          } else if (tryLocsList || node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (tryLocsList) {
            wrapArgs.push(tryLocsList);
          } else if (node.async) {
            wrapArgs.push(t.nullLiteral());
          }

          if (node.async) {
            var currentScope = path.scope;

            do {
              if (currentScope.hasOwnBinding("Promise")) currentScope.rename("Promise");
            } while (currentScope = currentScope.parent);

            wrapArgs.push(t.identifier("Promise"));
          }

          var wrapCall = t.callExpression(util.runtimeProperty(node.async ? "async" : "wrap"), wrapArgs);
          outerBody.push(t.returnStatement(wrapCall));
          node.body = t.blockStatement(outerBody);
          path.get("body.body").forEach(function (p) {
            return p.scope.registerDeclaration(p);
          });
          var oldDirectives = bodyBlockPath.node.directives;

          if (oldDirectives) {
            node.body.directives = oldDirectives;
          }

          var wasGeneratorFunction = node.generator;

          if (wasGeneratorFunction) {
            node.generator = false;
          }

          if (node.async) {
            node.async = false;
          }

          if (wasGeneratorFunction && t.isExpression(node)) {
            util.replaceWithOrRemove(path, t.callExpression(util.runtimeProperty("mark"), [node]));
            path.addComment("leading", "#__PURE__");
          }

          var insertedLocs = emitter.getInsertedLocs();
          path.traverse({
            NumericLiteral: function NumericLiteral(path) {
              if (!insertedLocs.has(path.node)) {
                return;
              }

              path.replaceWith(t.numericLiteral(path.node.value));
            }
          });
          path.requeue();
        })
      }
    };
  };

  function shouldRegenerate(node, state) {
    if (node.generator) {
      if (node.async) {
        return state.opts.asyncGenerators !== false;
      } else {
        return state.opts.generators !== false;
      }
    } else if (node.async) {
      return state.opts.async !== false;
    } else {
      return false;
    }
  }

  function getOuterFnExpr(funPath) {
    var t = util.getTypes();
    var node = funPath.node;
    t.assertFunction(node);

    if (!node.id) {
      node.id = funPath.scope.parent.generateUidIdentifier("callee");
    }

    if (node.generator && t.isFunctionDeclaration(node)) {
      return getMarkedFunctionId(funPath);
    }

    return t.clone(node.id);
  }

  var getMarkInfo = (0, _private.makeAccessor)();

  function getMarkedFunctionId(funPath) {
    var t = util.getTypes();
    var node = funPath.node;
    t.assertIdentifier(node.id);
    var blockPath = funPath.findParent(function (path) {
      return path.isProgram() || path.isBlockStatement();
    });

    if (!blockPath) {
      return node.id;
    }

    var block = blockPath.node;

    _assert["default"].ok(Array.isArray(block.body));

    var info = getMarkInfo(block);

    if (!info.decl) {
      info.decl = t.variableDeclaration("var", []);
      blockPath.unshiftContainer("body", info.decl);
      info.declPath = blockPath.get("body.0");
    }

    _assert["default"].strictEqual(info.declPath.node, info.decl);

    var markedId = blockPath.scope.generateUidIdentifier("marked");
    var markCallExp = t.callExpression(util.runtimeProperty("mark"), [t.clone(node.id)]);
    var index = info.decl.declarations.push(t.variableDeclarator(markedId, markCallExp)) - 1;
    var markCallExpPath = info.declPath.get("declarations." + index + ".init");

    _assert["default"].strictEqual(markCallExpPath.node, markCallExp);

    markCallExpPath.addComment("leading", "#__PURE__");
    return t.clone(markedId);
  }

  var argumentsThisVisitor = {
    "FunctionExpression|FunctionDeclaration|Method": function FunctionExpressionFunctionDeclarationMethod(path) {
      path.skip();
    },
    Identifier: function Identifier(path, state) {
      if (path.node.name === "arguments" && util.isReference(path)) {
        util.replaceWithOrRemove(path, state.getArgsId());
        state.usesArguments = true;
      }
    },
    ThisExpression: function ThisExpression(path, state) {
      state.usesThis = true;
    }
  };
  var functionSentVisitor = {
    MetaProperty: function MetaProperty(path) {
      var node = path.node;

      if (node.meta.name === "function" && node.property.name === "sent") {
        var t = util.getTypes();
        util.replaceWithOrRemove(path, t.memberExpression(t.clone(this.context), t.identifier("_sent")));
      }
    }
  };
  var awaitVisitor = {
    Function: function Function(path) {
      path.skip();
    },
    AwaitExpression: function AwaitExpression(path) {
      var t = util.getTypes();
      var argument = path.node.argument;
      util.replaceWithOrRemove(path, t.yieldExpression(t.callExpression(util.runtimeProperty("awrap"), [argument]), false));
    }
  };
  var visit = {
    getVisitor: getVisitor
  };

  var lib$b = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = _default;

    function _default(context) {
      var plugin = {
        visitor: (0, visit.getVisitor)(context)
      };
      var version = context && context.version;

      if (version && parseInt(version, 10) >= 7) {
        plugin.name = "regenerator-transform";
      }

      return plugin;
    }
  }, "/$$rollup_base$$/node_modules/regenerator-transform/lib");

  var _transformRegenerator = lib$b["default"];

  var _transformReservedWords = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-reserved-words",
      visitor: {
        "BindingIdentifier|ReferencedIdentifier": function BindingIdentifierReferencedIdentifier(path) {
          if (!isValidES3Identifier(path.node.name)) {
            path.scope.rename(path.node.name);
          }
        }
      }
    };
  });

  var SEMVER_SPEC_VERSION$1 = '2.0.0';
  var MAX_LENGTH$5 = 256;
  var MAX_SAFE_INTEGER$3 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH$1 = 16;
  var constants$1 = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION$1,
    MAX_LENGTH: MAX_LENGTH$5,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$3,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH$1
  };

  var debug$1 = typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1$1 = debug$1;

  var re_1$1 = createCommonjsModule(function (module, exports) {
    var MAX_SAFE_COMPONENT_LENGTH = constants$1.MAX_SAFE_COMPONENT_LENGTH;
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;

    var createToken = function createToken(name, value, isGlobal) {
      var index = R++;
      debug_1$1(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
    createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
    createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
    createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
    createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
    createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
    createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
    createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
    createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
    createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
    createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
    createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
    createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
    createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
    createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
    createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
    createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
    createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
    createToken('STAR', '(<|>)?=?\\s*\\*');
    createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
    createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');
  }, "/$$rollup_base$$/node_modules/semver-BABEL_8_BREAKING-true/internal");

  var opts = ['includePrerelease', 'loose', 'rtl'];

  var parseOptions = function parseOptions(options) {
    return !options ? {} : typeof options !== 'object' ? {
      loose: true
    } : opts.filter(function (k) {
      return options[k];
    }).reduce(function (options, k) {
      options[k] = true;
      return options;
    }, {});
  };

  var parseOptions_1 = parseOptions;

  var numeric$1 = /^[0-9]+$/;

  var compareIdentifiers$3 = function compareIdentifiers(a, b) {
    var anum = numeric$1.test(a);
    var bnum = numeric$1.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers$1 = function rcompareIdentifiers(a, b) {
    return compareIdentifiers$3(b, a);
  };

  var identifiers$1 = {
    compareIdentifiers: compareIdentifiers$3,
    rcompareIdentifiers: rcompareIdentifiers$1
  };

  var MAX_LENGTH$4 = constants$1.MAX_LENGTH,
      MAX_SAFE_INTEGER$2 = constants$1.MAX_SAFE_INTEGER;
  var re$7 = re_1$1.re,
      t$e = re_1$1.t;
  var compareIdentifiers$2 = identifiers$1.compareIdentifiers;

  var SemVer$1 = function () {
    function SemVer(version, options) {
      options = parseOptions_1(options);

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$4) {
        throw new TypeError("version is longer than " + MAX_LENGTH$4 + " characters");
      }

      debug_1$1('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re$7[t$e.LOOSE] : re$7[t$e.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER$2 || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER$2 || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER$2 || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER$2) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1$1('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers$2(this.major, other.major) || compareIdentifiers$2(this.minor, other.minor) || compareIdentifiers$2(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1$1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$2(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1$1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers$2(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$6 = SemVer$1;

  var MAX_LENGTH$3 = constants$1.MAX_LENGTH;
  var re$6 = re_1$1.re,
      t$d = re_1$1.t;

  var parse$1 = function parse(version, options) {
    options = parseOptions_1(options);

    if (version instanceof semver$6) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH$3) {
      return null;
    }

    var r = options.loose ? re$6[t$d.LOOSE] : re$6[t$d.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$6(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1$1 = parse$1;

  var valid$1 = function valid(version, options) {
    var v = parse_1$1(version, options);
    return v ? v.version : null;
  };

  var valid_1 = valid$1;

  var clean = function clean(version, options) {
    var s = parse_1$1(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
  };

  var clean_1 = clean;

  var inc = function inc(version, release, options, identifier) {
    if (typeof options === 'string') {
      identifier = options;
      options = undefined;
    }

    try {
      return new semver$6(version, options).inc(release, identifier).version;
    } catch (er) {
      return null;
    }
  };

  var inc_1 = inc;

  var compare$3 = function compare(a, b, loose) {
    return new semver$6(a, loose).compare(new semver$6(b, loose));
  };

  var compare_1$1 = compare$3;

  var eq$1 = function eq(a, b, loose) {
    return compare_1$1(a, b, loose) === 0;
  };

  var eq_1$1 = eq$1;

  var diff = function diff(version1, version2) {
    if (eq_1$1(version1, version2)) {
      return null;
    } else {
      var v1 = parse_1$1(version1);
      var v2 = parse_1$1(version2);
      var hasPre = v1.prerelease.length || v2.prerelease.length;
      var prefix = hasPre ? 'pre' : '';
      var defaultResult = hasPre ? 'prerelease' : '';

      for (var key in v1) {
        if (key === 'major' || key === 'minor' || key === 'patch') {
          if (v1[key] !== v2[key]) {
            return prefix + key;
          }
        }
      }

      return defaultResult;
    }
  };

  var diff_1 = diff;

  var major = function major(a, loose) {
    return new semver$6(a, loose).major;
  };

  var major_1 = major;

  var minor = function minor(a, loose) {
    return new semver$6(a, loose).minor;
  };

  var minor_1 = minor;

  var patch = function patch(a, loose) {
    return new semver$6(a, loose).patch;
  };

  var patch_1 = patch;

  var prerelease = function prerelease(version, options) {
    var parsed = parse_1$1(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };

  var prerelease_1 = prerelease;

  var rcompare = function rcompare(a, b, loose) {
    return compare_1$1(b, a, loose);
  };

  var rcompare_1 = rcompare;

  var compareLoose = function compareLoose(a, b) {
    return compare_1$1(a, b, true);
  };

  var compareLoose_1 = compareLoose;

  var compareBuild = function compareBuild(a, b, loose) {
    var versionA = new semver$6(a, loose);
    var versionB = new semver$6(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };

  var compareBuild_1 = compareBuild;

  var sort = function sort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1(a, b, loose);
    });
  };

  var sort_1 = sort;

  var rsort = function rsort(list, loose) {
    return list.sort(function (a, b) {
      return compareBuild_1(b, a, loose);
    });
  };

  var rsort_1 = rsort;

  var gt$1 = function gt(a, b, loose) {
    return compare_1$1(a, b, loose) > 0;
  };

  var gt_1$1 = gt$1;

  var lt$1 = function lt(a, b, loose) {
    return compare_1$1(a, b, loose) < 0;
  };

  var lt_1$1 = lt$1;

  var neq$1 = function neq(a, b, loose) {
    return compare_1$1(a, b, loose) !== 0;
  };

  var neq_1$1 = neq$1;

  var gte$1 = function gte(a, b, loose) {
    return compare_1$1(a, b, loose) >= 0;
  };

  var gte_1$1 = gte$1;

  var lte$1 = function lte(a, b, loose) {
    return compare_1$1(a, b, loose) <= 0;
  };

  var lte_1$1 = lte$1;

  var cmp$1 = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1$1(a, b, loose);

      case '!=':
        return neq_1$1(a, b, loose);

      case '>':
        return gt_1$1(a, b, loose);

      case '>=':
        return gte_1$1(a, b, loose);

      case '<':
        return lt_1$1(a, b, loose);

      case '<=':
        return lte_1$1(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1$1 = cmp$1;

  var re$5 = re_1$1.re,
      t$c = re_1$1.t;

  var coerce$1 = function coerce(version, options) {
    if (version instanceof semver$6) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re$5[t$c.COERCE]);
    } else {
      var next;

      while ((next = re$5[t$c.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re$5[t$c.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re$5[t$c.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1$1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1$1 = coerce$1;

  var iterator = function iterator(Yallist) {
    Yallist.prototype[Symbol.iterator] = regenerator.mark(function _callee() {
      var walker;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              walker = this.head;

            case 1:
              if (!walker) {
                _context.next = 7;
                break;
              }

              _context.next = 4;
              return walker.value;

            case 4:
              walker = walker.next;
              _context.next = 1;
              break;

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    });
  };

  var yallist = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;

  function Yallist(list) {
    var self = this;

    if (!(self instanceof Yallist)) {
      self = new Yallist();
    }

    self.tail = null;
    self.head = null;
    self.length = 0;

    if (list && typeof list.forEach === 'function') {
      list.forEach(function (item) {
        self.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l = arguments.length; i < l; i++) {
        self.push(arguments[i]);
      }
    }

    return self;
  }

  Yallist.prototype.removeNode = function (node) {
    if (node.list !== this) {
      throw new Error('removing node which does not belong to this list');
    }

    var next = node.next;
    var prev = node.prev;

    if (next) {
      next.prev = prev;
    }

    if (prev) {
      prev.next = next;
    }

    if (node === this.head) {
      this.head = next;
    }

    if (node === this.tail) {
      this.tail = prev;
    }

    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };

  Yallist.prototype.unshiftNode = function (node) {
    if (node === this.head) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var head = this.head;
    node.list = this;
    node.next = head;

    if (head) {
      head.prev = node;
    }

    this.head = node;

    if (!this.tail) {
      this.tail = node;
    }

    this.length++;
  };

  Yallist.prototype.pushNode = function (node) {
    if (node === this.tail) {
      return;
    }

    if (node.list) {
      node.list.removeNode(node);
    }

    var tail = this.tail;
    node.list = this;
    node.prev = tail;

    if (tail) {
      tail.next = node;
    }

    this.tail = node;

    if (!this.head) {
      this.head = node;
    }

    this.length++;
  };

  Yallist.prototype.push = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      push(this, arguments[i]);
    }

    return this.length;
  };

  Yallist.prototype.unshift = function () {
    for (var i = 0, l = arguments.length; i < l; i++) {
      unshift(this, arguments[i]);
    }

    return this.length;
  };

  Yallist.prototype.pop = function () {
    if (!this.tail) {
      return undefined;
    }

    var res = this.tail.value;
    this.tail = this.tail.prev;

    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }

    this.length--;
    return res;
  };

  Yallist.prototype.shift = function () {
    if (!this.head) {
      return undefined;
    }

    var res = this.head.value;
    this.head = this.head.next;

    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }

    this.length--;
    return res;
  };

  Yallist.prototype.forEach = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.head, i = 0; walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };

  Yallist.prototype.forEachReverse = function (fn, thisp) {
    thisp = thisp || this;

    for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };

  Yallist.prototype.get = function (n) {
    for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
      walker = walker.next;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist.prototype.getReverse = function (n) {
    for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
      walker = walker.prev;
    }

    if (i === n && walker !== null) {
      return walker.value;
    }
  };

  Yallist.prototype.map = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();

    for (var walker = this.head; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }

    return res;
  };

  Yallist.prototype.mapReverse = function (fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();

    for (var walker = this.tail; walker !== null;) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }

    return res;
  };

  Yallist.prototype.reduce = function (fn, initial) {
    var acc;
    var walker = this.head;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = 0; walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }

    return acc;
  };

  Yallist.prototype.reduceReverse = function (fn, initial) {
    var acc;
    var walker = this.tail;

    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError('Reduce of empty list with no initial value');
    }

    for (var i = this.length - 1; walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }

    return acc;
  };

  Yallist.prototype.toArray = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.head; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }

    return arr;
  };

  Yallist.prototype.toArrayReverse = function () {
    var arr = new Array(this.length);

    for (var i = 0, walker = this.tail; walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }

    return arr;
  };

  Yallist.prototype.slice = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
      walker = walker.next;
    }

    for (; walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist.prototype.sliceReverse = function (from, to) {
    to = to || this.length;

    if (to < 0) {
      to += this.length;
    }

    from = from || 0;

    if (from < 0) {
      from += this.length;
    }

    var ret = new Yallist();

    if (to < from || to < 0) {
      return ret;
    }

    if (from < 0) {
      from = 0;
    }

    if (to > this.length) {
      to = this.length;
    }

    for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
      walker = walker.prev;
    }

    for (; walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }

    return ret;
  };

  Yallist.prototype.splice = function (start, deleteCount) {
    if (start > this.length) {
      start = this.length - 1;
    }

    if (start < 0) {
      start = this.length + start;
    }

    for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
      walker = walker.next;
    }

    var ret = [];

    for (var i = 0; walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }

    if (walker === null) {
      walker = this.tail;
    }

    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }

    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      walker = insert(this, walker, i + 2 < 2 || arguments.length <= i + 2 ? undefined : arguments[i + 2]);
    }

    return ret;
  };

  Yallist.prototype.reverse = function () {
    var head = this.head;
    var tail = this.tail;

    for (var walker = head; walker !== null; walker = walker.prev) {
      var p = walker.prev;
      walker.prev = walker.next;
      walker.next = p;
    }

    this.head = tail;
    this.tail = head;
    return this;
  };

  function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

    if (inserted.next === null) {
      self.tail = inserted;
    }

    if (inserted.prev === null) {
      self.head = inserted;
    }

    self.length++;
    return inserted;
  }

  function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);

    if (!self.head) {
      self.head = self.tail;
    }

    self.length++;
  }

  function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);

    if (!self.tail) {
      self.tail = self.head;
    }

    self.length++;
  }

  function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value, prev, next, list);
    }

    this.list = list;
    this.value = value;

    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }

    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  }

  try {
    iterator(Yallist);
  } catch (er) {}

  var MAX = Symbol('max');
  var LENGTH = Symbol('length');
  var LENGTH_CALCULATOR = Symbol('lengthCalculator');
  var ALLOW_STALE = Symbol('allowStale');
  var MAX_AGE = Symbol('maxAge');
  var DISPOSE = Symbol('dispose');
  var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
  var LRU_LIST = Symbol('lruList');
  var CACHE = Symbol('cache');
  var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

  var naiveLength = function naiveLength() {
    return 1;
  };

  var LRUCache = function () {
    function LRUCache(options) {
      if (typeof options === 'number') options = {
        max: options
      };
      if (!options) options = {};
      if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number');
      this[MAX] = options.max || Infinity;
      var lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }

    var _proto = LRUCache.prototype;

    _proto.rforEach = function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };

    _proto.forEach = function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };

    _proto.keys = function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    };

    _proto.values = function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    };

    _proto.reset = function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map();
      this[LRU_LIST] = new yallist();
      this[LENGTH] = 0;
    };

    _proto.dump = function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    };

    _proto.dumpLru = function dumpLru() {
      return this[LRU_LIST];
    };

    _proto.set = function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value;

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge);

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    };

    _proto.has = function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    };

    _proto.get = function get(key) {
      return _get(this, key, true);
    };

    _proto.peek = function peek(key) {
      return _get(this, key, false);
    };

    _proto.pop = function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    };

    _proto.del = function del(key) {
      _del(this, this[CACHE].get(key));
    };

    _proto.load = function load(arr) {
      this.reset();
      var now = Date.now();

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now;

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };

    _proto.prune = function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    };

    _createClass(LRUCache, [{
      key: "max",
      get: function get() {
        return this[MAX];
      },
      set: function set(mL) {
        if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
        this[MAX] = mL || Infinity;
        trim(this);
      }
    }, {
      key: "allowStale",
      get: function get() {
        return this[ALLOW_STALE];
      },
      set: function set(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
    }, {
      key: "maxAge",
      get: function get() {
        return this[MAX_AGE];
      },
      set: function set(mA) {
        if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
        this[MAX_AGE] = mA;
        trim(this);
      }
    }, {
      key: "lengthCalculator",
      get: function get() {
        return this[LENGTH_CALCULATOR];
      },
      set: function set(lC) {
        var _this4 = this;

        if (typeof lC !== 'function') lC = naiveLength;

        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach(function (hit) {
            hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
            _this4[LENGTH] += hit.length;
          });
        }

        trim(this);
      }
    }, {
      key: "length",
      get: function get() {
        return this[LENGTH];
      }
    }, {
      key: "itemCount",
      get: function get() {
        return this[LRU_LIST].length;
      }
    }]);

    return LRUCache;
  }();

  var _get = function _get(self, key, doUse) {
    var node = self[CACHE].get(key);

    if (node) {
      var hit = node.value;

      if (isStale(self, hit)) {
        _del(self, node);

        if (!self[ALLOW_STALE]) return undefined;
      } else {
        if (doUse) {
          if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
          self[LRU_LIST].unshiftNode(node);
        }
      }

      return hit.value;
    }
  };

  var isStale = function isStale(self, hit) {
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    var diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
  };

  var trim = function trim(self) {
    if (self[LENGTH] > self[MAX]) {
      for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
        var prev = walker.prev;

        _del(self, walker);

        walker = prev;
      }
    }
  };

  var _del = function _del(self, node) {
    if (node) {
      var hit = node.value;
      if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
      self[LENGTH] -= hit.length;
      self[CACHE]["delete"](hit.key);
      self[LRU_LIST].removeNode(node);
    }
  };

  var Entry = function Entry(key, value, length, now, maxAge) {
    this.key = key;
    this.value = value;
    this.length = length;
    this.now = now;
    this.maxAge = maxAge || 0;
  };

  var forEachStep = function forEachStep(self, fn, node, thisp) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) hit = undefined;
    }

    if (hit) fn.call(thisp, hit.value, hit.key, self);
  };

  var lruCache = LRUCache;

  var Range = function () {
    function Range(range, options) {
      var _this = this;

      options = parseOptions_1(options);

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return _this.parseRange(range.trim());
      }).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }

      if (this.set.length > 1) {
        var first = this.set[0];
        this.set = this.set.filter(function (c) {
          return !isNullSet(c[0]);
        });
        if (this.set.length === 0) this.set = [first];else if (this.set.length > 1) {
          for (var _iterator = _createForOfIteratorHelperLoose(this.set), _step; !(_step = _iterator()).done;) {
            var c = _step.value;

            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }

      this.format();
    }

    var _proto = Range.prototype;

    _proto.format = function format() {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    _proto.toString = function toString() {
      return this.range;
    };

    _proto.parseRange = function parseRange(range) {
      var _this2 = this;

      range = range.trim();
      var memoOpts = Object.keys(this.options).join(',');
      var memoKey = "parseRange:" + memoOpts + ":" + range;
      var cached = cache.get(memoKey);
      if (cached) return cached;
      var loose = this.options.loose;
      var hr = loose ? re$4[t$b.HYPHENRANGELOOSE] : re$4[t$b.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug_1$1('hyphen replace', range);
      range = range.replace(re$4[t$b.COMPARATORTRIM], comparatorTrimReplace);
      debug_1$1('comparator trim', range, re$4[t$b.COMPARATORTRIM]);
      range = range.replace(re$4[t$b.TILDETRIM], tildeTrimReplace);
      range = range.replace(re$4[t$b.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re$4[t$b.COMPARATORLOOSE] : re$4[t$b.COMPARATOR];
      var rangeList = range.split(' ').map(function (comp) {
        return parseComparator(comp, _this2.options);
      }).join(' ').split(/\s+/).map(function (comp) {
        return replaceGTE0(comp, _this2.options);
      }).filter(this.options.loose ? function (comp) {
        return !!comp.match(compRe);
      } : function () {
        return true;
      }).map(function (comp) {
        return new comparator(comp, _this2.options);
      });
      rangeList.length;
      var rangeMap = new Map();

      for (var _iterator2 = _createForOfIteratorHelperLoose(rangeList), _step2; !(_step2 = _iterator2()).done;) {
        var comp = _step2.value;
        if (isNullSet(comp)) return [comp];
        rangeMap.set(comp.value, comp);
      }

      if (rangeMap.size > 1 && rangeMap.has('')) rangeMap["delete"]('');

      var result = _toConsumableArray(rangeMap.values());

      cache.set(memoKey, result);
      return result;
    };

    _proto.intersects = function intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    _proto.test = function test(version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$6(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    return Range;
  }();

  var range = Range;
  var cache = new lruCache({
    max: 1000
  });
  var re$4 = re_1$1.re,
      t$b = re_1$1.t,
      comparatorTrimReplace = re_1$1.comparatorTrimReplace,
      tildeTrimReplace = re_1$1.tildeTrimReplace,
      caretTrimReplace = re_1$1.caretTrimReplace;

  var isNullSet = function isNullSet(c) {
    return c.value === '<0.0.0-0';
  };

  var isAny = function isAny(c) {
    return c.value === '';
  };

  var isSatisfiable = function isSatisfiable(comparators, options) {
    var result = true;
    var remainingComparators = comparators.slice();
    var testComparator = remainingComparators.pop();

    while (result && remainingComparators.length) {
      result = remainingComparators.every(function (otherComparator) {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }

    return result;
  };

  var parseComparator = function parseComparator(comp, options) {
    debug_1$1('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug_1$1('caret', comp);
    comp = replaceTildes(comp, options);
    debug_1$1('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug_1$1('xrange', comp);
    comp = replaceStars(comp, options);
    debug_1$1('stars', comp);
    return comp;
  };

  var isX = function isX(id) {
    return !id || id.toLowerCase() === 'x' || id === '*';
  };

  var replaceTildes = function replaceTildes(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceTilde(comp, options);
    }).join(' ');
  };

  var replaceTilde = function replaceTilde(comp, options) {
    var r = options.loose ? re$4[t$b.TILDELOOSE] : re$4[t$b.TILDE];
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$1('tilde', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0-0";
      } else if (isX(p)) {
        ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0-0";
      } else if (pr) {
        debug_1$1('replaceTilde pr', pr);
        ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      } else {
        ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$1('tilde return', ret);
      return ret;
    });
  };

  var replaceCarets = function replaceCarets(comp, options) {
    return comp.trim().split(/\s+/).map(function (comp) {
      return replaceCaret(comp, options);
    }).join(' ');
  };

  var replaceCaret = function replaceCaret(comp, options) {
    debug_1$1('caret', comp, options);
    var r = options.loose ? re$4[t$b.CARETLOOSE] : re$4[t$b.CARET];
    var z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, function (_, M, m, p, pr) {
      debug_1$1('caret', comp, _, M, m, p, pr);
      var ret;

      if (isX(M)) {
        ret = '';
      } else if (isX(m)) {
        ret = ">=" + M + ".0.0" + z + " <" + (+M + 1) + ".0.0-0";
      } else if (isX(p)) {
        if (M === '0') {
          ret = ">=" + M + "." + m + ".0" + z + " <" + M + "." + (+m + 1) + ".0-0";
        } else {
          ret = ">=" + M + "." + m + ".0" + z + " <" + (+M + 1) + ".0.0-0";
        }
      } else if (pr) {
        debug_1$1('replaceCaret pr', pr);

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0-0";
        }
      } else {
        debug_1$1('no pr');

        if (M === '0') {
          if (m === '0') {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + m + "." + (+p + 1) + "-0";
          } else {
            ret = ">=" + M + "." + m + "." + p + z + " <" + M + "." + (+m + 1) + ".0-0";
          }
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0-0";
        }
      }

      debug_1$1('caret return', ret);
      return ret;
    });
  };

  var replaceXRanges = function replaceXRanges(comp, options) {
    debug_1$1('replaceXRanges', comp, options);
    return comp.split(/\s+/).map(function (comp) {
      return replaceXRange(comp, options);
    }).join(' ');
  };

  var replaceXRange = function replaceXRange(comp, options) {
    comp = comp.trim();
    var r = options.loose ? re$4[t$b.XRANGELOOSE] : re$4[t$b.XRANGE];
    return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
      debug_1$1('xRange', comp, ret, gtlt, M, m, p, pr);
      var xM = isX(M);
      var xm = xM || isX(m);
      var xp = xm || isX(p);
      var anyX = xp;

      if (gtlt === '=' && anyX) {
        gtlt = '';
      }

      pr = options.includePrerelease ? '-0' : '';

      if (xM) {
        if (gtlt === '>' || gtlt === '<') {
          ret = '<0.0.0-0';
        } else {
          ret = '*';
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m = 0;
        }

        p = 0;

        if (gtlt === '>') {
          gtlt = '>=';

          if (xm) {
            M = +M + 1;
            m = 0;
            p = 0;
          } else {
            m = +m + 1;
            p = 0;
          }
        } else if (gtlt === '<=') {
          gtlt = '<';

          if (xm) {
            M = +M + 1;
          } else {
            m = +m + 1;
          }
        }

        if (gtlt === '<') pr = '-0';
        ret = gtlt + M + "." + m + "." + p + pr;
      } else if (xm) {
        ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0-0";
      } else if (xp) {
        ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0-0";
      }

      debug_1$1('xRange return', ret);
      return ret;
    });
  };

  var replaceStars = function replaceStars(comp, options) {
    debug_1$1('replaceStars', comp, options);
    return comp.trim().replace(re$4[t$b.STAR], '');
  };

  var replaceGTE0 = function replaceGTE0(comp, options) {
    debug_1$1('replaceGTE0', comp, options);
    return comp.trim().replace(re$4[options.includePrerelease ? t$b.GTE0PRE : t$b.GTE0], '');
  };

  var hyphenReplace = function hyphenReplace(incPr) {
    return function ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0" + (incPr ? '-0' : '');
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0" + (incPr ? '-0' : '');
      } else if (fpr) {
        from = ">=" + from;
      } else {
        from = ">=" + from + (incPr ? '-0' : '');
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0-0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0-0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else if (incPr) {
        to = "<" + tM + "." + tm + "." + (+tp + 1) + "-0";
      } else {
        to = "<=" + to;
      }

      return (from + " " + to).trim();
    };
  };

  var testSet = function testSet(set, version, options) {
    for (var i = 0; i < set.length; i++) {
      if (!set[i].test(version)) {
        return false;
      }
    }

    if (version.prerelease.length && !options.includePrerelease) {
      for (var _i = 0; _i < set.length; _i++) {
        debug_1$1(set[_i].semver);

        if (set[_i].semver === comparator.ANY) {
          continue;
        }

        if (set[_i].semver.prerelease.length > 0) {
          var allowed = set[_i].semver;

          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }

      return false;
    }

    return true;
  };

  var ANY$2 = Symbol('SemVer ANY');

  var Comparator = function () {
    function Comparator(comp, options) {
      options = parseOptions_1(options);

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      debug_1$1('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY$2) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug_1$1('comp', this);
    }

    var _proto = Comparator.prototype;

    _proto.parse = function parse(comp) {
      var r = this.options.loose ? re$3[t$a.COMPARATORLOOSE] : re$3[t$a.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY$2;
      } else {
        this.semver = new semver$6(m[2], this.options.loose);
      }
    };

    _proto.toString = function toString() {
      return this.value;
    };

    _proto.test = function test(version) {
      debug_1$1('Comparator.test', version, this.options.loose);

      if (this.semver === ANY$2 || version === ANY$2) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new semver$6(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp_1$1(version, this.operator, this.semver, this.options);
    };

    _proto.intersects = function intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        return new range(comp.value, options).test(this.value);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        return new range(this.value, options).test(comp.semver);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp_1$1(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp_1$1(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    _createClass(Comparator, null, [{
      key: "ANY",
      get: function get() {
        return ANY$2;
      }
    }]);

    return Comparator;
  }();

  var comparator = Comparator;
  var re$3 = re_1$1.re,
      t$a = re_1$1.t;

  var satisfies = function satisfies(version, range$1, options) {
    try {
      range$1 = new range(range$1, options);
    } catch (er) {
      return false;
    }

    return range$1.test(version);
  };

  var satisfies_1 = satisfies;

  var toComparators = function toComparators(range$1, options) {
    return new range(range$1, options).set.map(function (comp) {
      return comp.map(function (c) {
        return c.value;
      }).join(' ').trim().split(' ');
    });
  };

  var toComparators_1 = toComparators;

  var maxSatisfying = function maxSatisfying(versions, range$1, options) {
    var max = null;
    var maxSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range(range$1, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new semver$6(max, options);
        }
      }
    });
    return max;
  };

  var maxSatisfying_1 = maxSatisfying;

  var minSatisfying = function minSatisfying(versions, range$1, options) {
    var min = null;
    var minSV = null;
    var rangeObj = null;

    try {
      rangeObj = new range(range$1, options);
    } catch (er) {
      return null;
    }

    versions.forEach(function (v) {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new semver$6(min, options);
        }
      }
    });
    return min;
  };

  var minSatisfying_1 = minSatisfying;

  var minVersion = function minVersion(range$1, loose) {
    range$1 = new range(range$1, loose);
    var minver = new semver$6('0.0.0');

    if (range$1.test(minver)) {
      return minver;
    }

    minver = new semver$6('0.0.0-0');

    if (range$1.test(minver)) {
      return minver;
    }

    minver = null;

    var _loop = function _loop(i) {
      var comparators = range$1.set[i];
      var setMin = null;
      comparators.forEach(function (comparator) {
        var compver = new semver$6(comparator.semver.version);

        switch (comparator.operator) {
          case '>':
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }

            compver.raw = compver.format();

          case '':
          case '>=':
            if (!setMin || gt_1$1(compver, setMin)) {
              setMin = compver;
            }

            break;

          case '<':
          case '<=':
            break;

          default:
            throw new Error("Unexpected operation: " + comparator.operator);
        }
      });
      if (setMin && (!minver || gt_1$1(minver, setMin))) minver = setMin;
    };

    for (var i = 0; i < range$1.set.length; ++i) {
      _loop(i);
    }

    if (minver && range$1.test(minver)) {
      return minver;
    }

    return null;
  };

  var minVersion_1 = minVersion;

  var validRange = function validRange(range$1, options) {
    try {
      return new range(range$1, options).range || '*';
    } catch (er) {
      return null;
    }
  };

  var valid = validRange;

  var ANY$1 = comparator.ANY;

  var outside = function outside(version, range$1, hilo, options) {
    version = new semver$6(version, options);
    range$1 = new range(range$1, options);
    var gtfn, ltefn, ltfn, comp, ecomp;

    switch (hilo) {
      case '>':
        gtfn = gt_1$1;
        ltefn = lte_1$1;
        ltfn = lt_1$1;
        comp = '>';
        ecomp = '>=';
        break;

      case '<':
        gtfn = lt_1$1;
        ltefn = gte_1$1;
        ltfn = gt_1$1;
        comp = '<';
        ecomp = '<=';
        break;

      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }

    if (satisfies_1(version, range$1, options)) {
      return false;
    }

    var _loop = function _loop(i) {
      var comparators = range$1.set[i];
      var high = null;
      var low = null;
      comparators.forEach(function (comparator$1) {
        if (comparator$1.semver === ANY$1) {
          comparator$1 = new comparator('>=0.0.0');
        }

        high = high || comparator$1;
        low = low || comparator$1;

        if (gtfn(comparator$1.semver, high.semver, options)) {
          high = comparator$1;
        } else if (ltfn(comparator$1.semver, low.semver, options)) {
          low = comparator$1;
        }
      });

      if (high.operator === comp || high.operator === ecomp) {
        return {
          v: false
        };
      }

      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return {
          v: false
        };
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return {
          v: false
        };
      }
    };

    for (var i = 0; i < range$1.set.length; ++i) {
      var _ret = _loop(i);

      if (typeof _ret === "object") return _ret.v;
    }

    return true;
  };

  var outside_1 = outside;

  var gtr = function gtr(version, range, options) {
    return outside_1(version, range, '>', options);
  };

  var gtr_1 = gtr;

  var ltr = function ltr(version, range, options) {
    return outside_1(version, range, '<', options);
  };

  var ltr_1 = ltr;

  var intersects = function intersects(r1, r2, options) {
    r1 = new range(r1, options);
    r2 = new range(r2, options);
    return r1.intersects(r2);
  };

  var intersects_1 = intersects;

  var simplify = function simplify(versions, range, options) {
    var set = [];
    var min = null;
    var prev = null;
    var v = versions.sort(function (a, b) {
      return compare_1$1(a, b, options);
    });

    for (var _iterator = _createForOfIteratorHelperLoose(v), _step; !(_step = _iterator()).done;) {
      var version = _step.value;
      var included = satisfies_1(version, range, options);

      if (included) {
        prev = version;
        if (!min) min = version;
      } else {
        if (prev) {
          set.push([min, prev]);
        }

        prev = null;
        min = null;
      }
    }

    if (min) set.push([min, null]);
    var ranges = [];

    for (var _i = 0, _set = set; _i < _set.length; _i++) {
      var _set$_i = _slicedToArray$2(_set[_i], 2),
          _min = _set$_i[0],
          max = _set$_i[1];

      if (_min === max) ranges.push(_min);else if (!max && _min === v[0]) ranges.push('*');else if (!max) ranges.push(">=" + _min);else if (_min === v[0]) ranges.push("<=" + max);else ranges.push(_min + " - " + max);
    }

    var simplified = ranges.join(' || ');
    var original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };

  var ANY = comparator.ANY;

  var subset = function subset(sub, dom, options) {
    if (sub === dom) return true;
    sub = new range(sub, options);
    dom = new range(dom, options);
    var sawNonNull = false;

    OUTER: for (var _iterator = _createForOfIteratorHelperLoose(sub.set), _step; !(_step = _iterator()).done;) {
      var simpleSub = _step.value;

      for (var _iterator2 = _createForOfIteratorHelperLoose(dom.set), _step2; !(_step2 = _iterator2()).done;) {
        var simpleDom = _step2.value;
        var isSub = simpleSubset(simpleSub, simpleDom, options);
        sawNonNull = sawNonNull || isSub !== null;
        if (isSub) continue OUTER;
      }

      if (sawNonNull) return false;
    }

    return true;
  };

  var simpleSubset = function simpleSubset(sub, dom, options) {
    if (sub === dom) return true;
    if (sub.length === 1 && sub[0].semver === ANY) return dom.length === 1 && dom[0].semver === ANY;
    var eqSet = new Set();
    var gt, lt;

    for (var _iterator3 = _createForOfIteratorHelperLoose(sub), _step3; !(_step3 = _iterator3()).done;) {
      var c = _step3.value;
      if (c.operator === '>' || c.operator === '>=') gt = higherGT(gt, c, options);else if (c.operator === '<' || c.operator === '<=') lt = lowerLT(lt, c, options);else eqSet.add(c.semver);
    }

    if (eqSet.size > 1) return null;
    var gtltComp;

    if (gt && lt) {
      gtltComp = compare_1$1(gt.semver, lt.semver, options);
      if (gtltComp > 0) return null;else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) return null;
    }

    for (var _iterator4 = _createForOfIteratorHelperLoose(eqSet), _step4; !(_step4 = _iterator4()).done;) {
      var eq = _step4.value;
      if (gt && !satisfies_1(eq, String(gt), options)) return null;
      if (lt && !satisfies_1(eq, String(lt), options)) return null;

      for (var _iterator6 = _createForOfIteratorHelperLoose(dom), _step6; !(_step6 = _iterator6()).done;) {
        var _c = _step6.value;
        if (!satisfies_1(eq, String(_c), options)) return false;
      }

      return true;
    }

    var higher, lower;
    var hasDomLT, hasDomGT;

    for (var _iterator5 = _createForOfIteratorHelperLoose(dom), _step5; !(_step5 = _iterator5()).done;) {
      var _c2 = _step5.value;
      hasDomGT = hasDomGT || _c2.operator === '>' || _c2.operator === '>=';
      hasDomLT = hasDomLT || _c2.operator === '<' || _c2.operator === '<=';

      if (gt) {
        if (_c2.operator === '>' || _c2.operator === '>=') {
          higher = higherGT(gt, _c2, options);
          if (higher === _c2 && higher !== gt) return false;
        } else if (gt.operator === '>=' && !satisfies_1(gt.semver, String(_c2), options)) return false;
      }

      if (lt) {
        if (_c2.operator === '<' || _c2.operator === '<=') {
          lower = lowerLT(lt, _c2, options);
          if (lower === _c2 && lower !== lt) return false;
        } else if (lt.operator === '<=' && !satisfies_1(lt.semver, String(_c2), options)) return false;
      }

      if (!_c2.operator && (lt || gt) && gtltComp !== 0) return false;
    }

    if (gt && hasDomLT && !lt && gtltComp !== 0) return false;
    if (lt && hasDomGT && !gt && gtltComp !== 0) return false;
    return true;
  };

  var higherGT = function higherGT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$1(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
  };

  var lowerLT = function lowerLT(a, b, options) {
    if (!a) return b;
    var comp = compare_1$1(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
  };

  var subset_1 = subset;

  ({
    re: re_1$1.re,
    src: re_1$1.src,
    tokens: re_1$1.t,
    SEMVER_SPEC_VERSION: constants$1.SEMVER_SPEC_VERSION,
    SemVer: semver$6,
    compareIdentifiers: identifiers$1.compareIdentifiers,
    rcompareIdentifiers: identifiers$1.rcompareIdentifiers,
    parse: parse_1$1,
    valid: valid_1,
    clean: clean_1,
    inc: inc_1,
    diff: diff_1,
    major: major_1,
    minor: minor_1,
    patch: patch_1,
    prerelease: prerelease_1,
    compare: compare_1$1,
    rcompare: rcompare_1,
    compareLoose: compareLoose_1,
    compareBuild: compareBuild_1,
    sort: sort_1,
    rsort: rsort_1,
    gt: gt_1$1,
    lt: lt_1$1,
    eq: eq_1$1,
    neq: neq_1$1,
    gte: gte_1$1,
    lte: lte_1$1,
    cmp: cmp_1$1,
    coerce: coerce_1$1,
    Comparator: comparator,
    Range: range,
    satisfies: satisfies_1,
    toComparators: toComparators_1,
    maxSatisfying: maxSatisfying_1,
    minSatisfying: minSatisfying_1,
    minVersion: minVersion_1,
    validRange: valid,
    outside: outside_1,
    gtr: gtr_1,
    ltr: ltr_1,
    intersects: intersects_1,
    simplifyRange: simplify,
    subset: subset_1
  });

  var semver$5 = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  }, "/$$rollup_base$$/node_modules/semver-BABEL_8_BREAKING-false");

  var semver$4 = semver$5;

  function hasMinVersion$2(minVersion, runtimeVersion) {
    if (!runtimeVersion) return true;
    if (semver$4.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
    return !semver$4.intersects("<" + minVersion, runtimeVersion) && !semver$4.intersects(">=8.0.0", runtimeVersion);
  }

  function getRuntimePath (moduleName, dirname, absoluteRuntime) {
    if (absoluteRuntime === false) return moduleName;
    throw new Error("The 'absoluteRuntime' option is not supported when using @babel/standalone.");
  }

  var semver$3 = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  }, "/$$rollup_base$$/packages/babel-plugin-transform-runtime/node_modules/babel-plugin-polyfill-corejs2/node_modules/semver");

  var _excluded$1 = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];

  var _templateObject$5, _templateObject2$3, _templateObject3$2;

  var _ref$5 = undefined || babel,
      t$1$3 = _ref$5.types,
      template$1 = _ref$5.template;

  function intersection$3(a, b) {
    var result = new Set();
    a.forEach(function (v) {
      return b.has(v) && result.add(v);
    });
    return result;
  }

  function has$1$1(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  }

  function getType$1(target) {
    return Object.prototype.toString.call(target).slice(8, -1);
  }

  function resolveId$1(path) {
    if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, true)) {
      return path.node.name;
    }

    var _path$evaluate = path.evaluate(),
        deopt = _path$evaluate.deopt;

    if (deopt && deopt.isIdentifier()) {
      return deopt.node.name;
    }
  }

  function resolveKey$1(path, computed) {
    if (computed === void 0) {
      computed = false;
    }

    var node = path.node,
        parent = path.parent,
        scope = path.scope;
    if (path.isStringLiteral()) return node.value;
    var name = node.name;
    var isIdentifier = path.isIdentifier();
    if (isIdentifier && !(computed || parent.computed)) return name;

    if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
      name: "Symbol"
    }) && !scope.hasBinding("Symbol", true)) {
      var sym = resolveKey$1(path.get("property"), path.node.computed);
      if (sym) return "Symbol." + sym;
    }

    if (!isIdentifier || scope.hasBinding(name, true)) {
      var _path$evaluate2 = path.evaluate(),
          value = _path$evaluate2.value;

      if (typeof value === "string") return value;
    }
  }

  function resolveSource$1(obj) {
    if (obj.isMemberExpression() && obj.get("property").isIdentifier({
      name: "prototype"
    })) {
      var _id = resolveId$1(obj.get("object"));

      if (_id) {
        return {
          id: _id,
          placement: "prototype"
        };
      }

      return {
        id: null,
        placement: null
      };
    }

    var id = resolveId$1(obj);

    if (id) {
      return {
        id: id,
        placement: "static"
      };
    }

    var _obj$evaluate = obj.evaluate(),
        value = _obj$evaluate.value;

    if (value !== undefined) {
      return {
        id: getType$1(value),
        placement: "prototype"
      };
    } else if (obj.isRegExpLiteral()) {
      return {
        id: "RegExp",
        placement: "prototype"
      };
    } else if (obj.isFunction()) {
      return {
        id: "Function",
        placement: "prototype"
      };
    }

    return {
      id: null,
      placement: null
    };
  }

  function getImportSource$2(_ref2) {
    var node = _ref2.node;
    if (node.specifiers.length === 0) return node.source.value;
  }

  function getRequireSource$2(_ref3) {
    var node = _ref3.node;
    if (!t$1$3.isExpressionStatement(node)) return;
    var expression = node.expression;
    var isRequire = t$1$3.isCallExpression(expression) && t$1$3.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t$1$3.isStringLiteral(expression.arguments[0]);
    if (isRequire) return expression.arguments[0].value;
  }

  function hoist$1(node) {
    node._blockHoist = 3;
    return node;
  }

  function createUtilsGetter$1(cache) {
    return function (path) {
      var prog = path.findParent(function (p) {
        return p.isProgram();
      });
      return {
        injectGlobalImport: function injectGlobalImport(url) {
          cache.storeAnonymous(prog, url, function (isScript, source) {
            return isScript ? template$1.statement.ast(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose(["require(", ")"])), source) : t$1$3.importDeclaration([], source);
          });
        },
        injectNamedImport: function injectNamedImport(url, name, hint) {
          if (hint === void 0) {
            hint = name;
          }

          return cache.storeNamed(prog, url, name, function (isScript, source, name) {
            var id = prog.scope.generateUidIdentifier(hint);
            return {
              node: isScript ? hoist$1(template$1.statement.ast(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose(["\n                  var ", " = require(", ").", "\n                "])), id, source, name)) : t$1$3.importDeclaration([t$1$3.importSpecifier(id, name)], source),
              name: id.name
            };
          });
        },
        injectDefaultImport: function injectDefaultImport(url, hint) {
          if (hint === void 0) {
            hint = url;
          }

          return cache.storeNamed(prog, url, "default", function (isScript, source) {
            var id = prog.scope.generateUidIdentifier(hint);
            return {
              node: isScript ? hoist$1(template$1.statement.ast(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose(["var ", " = require(", ")"])), id, source)) : t$1$3.importDeclaration([t$1$3.importDefaultSpecifier(id)], source),
              name: id.name
            };
          });
        }
      };
    };
  }

  var _ref4$1 = undefined || babel,
      t$9 = _ref4$1.types;

  var ImportsCache$1 = function () {
    function ImportsCache(resolver) {
      this._imports = new WeakMap();
      this._anonymousImports = new WeakMap();
      this._lastImports = new WeakMap();
      this._resolver = resolver;
    }

    var _proto = ImportsCache.prototype;

    _proto.storeAnonymous = function storeAnonymous(programPath, url, getVal) {
      var key = this._normalizeKey(programPath, url);

      var imports = this._ensure(this._anonymousImports, programPath, Set);

      if (imports.has(key)) return;
      var node = getVal(programPath.node.sourceType === "script", t$9.stringLiteral(this._resolver(url)));
      imports.add(key);

      this._injectImport(programPath, node);
    };

    _proto.storeNamed = function storeNamed(programPath, url, name, getVal) {
      var key = this._normalizeKey(programPath, url, name);

      var imports = this._ensure(this._imports, programPath, Map);

      if (!imports.has(key)) {
        var _getVal = getVal(programPath.node.sourceType === "script", t$9.stringLiteral(this._resolver(url)), t$9.identifier(name)),
            node = _getVal.node,
            id = _getVal.name;

        imports.set(key, id);

        this._injectImport(programPath, node);
      }

      return t$9.identifier(imports.get(key));
    };

    _proto._injectImport = function _injectImport(programPath, node) {
      var lastImport = this._lastImports.get(programPath);

      if (lastImport && lastImport.node && lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {
        lastImport = lastImport.insertAfter(node);
      } else {
        lastImport = programPath.unshiftContainer("body", node);
      }

      lastImport = lastImport[lastImport.length - 1];

      this._lastImports.set(programPath, lastImport);
    };

    _proto._ensure = function _ensure(map, programPath, Collection) {
      var collection = map.get(programPath);

      if (!collection) {
        collection = new Collection();
        map.set(programPath, collection);
      }

      return collection;
    };

    _proto._normalizeKey = function _normalizeKey(programPath, url, name) {
      if (name === void 0) {
        name = "";
      }

      var sourceType = programPath.node.sourceType;
      return (name && sourceType) + "::" + url + "::" + name;
    };

    return ImportsCache;
  }();

  var presetEnvSilentDebugHeader$1 = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";

  function stringifyTargetsMultiline$1(targets) {
    return JSON.stringify(prettifyTargets(targets), null, 2);
  }

  function patternToRegExp$1(pattern) {
    if (pattern instanceof RegExp) return pattern;

    try {
      return new RegExp("^" + pattern + "$");
    } catch (_unused) {
      return null;
    }
  }

  function buildUnusedError$1(label, unused) {
    if (!unused.length) return "";
    return "  - The following \"" + label + "\" patterns didn't match any polyfill:\n" + unused.map(function (original) {
      return "    " + String(original) + "\n";
    }).join("");
  }

  function buldDuplicatesError$1(duplicates) {
    if (!duplicates.size) return "";
    return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
      return "    " + name + "\n";
    }).join("");
  }

  function validateIncludeExclude$1(provider, polyfills, includePatterns, excludePatterns) {
    var current;

    var filter = function filter(pattern) {
      var regexp = patternToRegExp$1(pattern);
      if (!regexp) return false;
      var matched = false;

      for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
        var polyfill = _step.value;

        if (regexp.test(polyfill)) {
          matched = true;
          current.add(polyfill);
        }
      }

      return !matched;
    };

    var include = current = new Set();
    var unusedInclude = Array.from(includePatterns).filter(filter);
    var exclude = current = new Set();
    var unusedExclude = Array.from(excludePatterns).filter(filter);
    var duplicates = intersection$3(include, exclude);

    if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
      throw new Error("Error while validating the \"" + provider + "\" provider options:\n" + buildUnusedError$1("include", unusedInclude) + buildUnusedError$1("exclude", unusedExclude) + buldDuplicatesError$1(duplicates));
    }

    return {
      include: include,
      exclude: exclude
    };
  }

  function applyMissingDependenciesDefaults$1(options, babelApi) {
    var _options$missingDepen = options.missingDependencies,
        missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
    if (missingDependencies === false) return false;
    var caller = babelApi.caller(function (caller) {
      return caller == null ? void 0 : caller.name;
    });
    var _missingDependencies$ = missingDependencies.log,
        log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
        _missingDependencies$2 = missingDependencies.inject,
        inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
        _missingDependencies$3 = missingDependencies.all,
        all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
    return {
      log: log,
      inject: inject,
      all: all
    };
  }

  var usage$1 = function usage(callProvider) {
    function property(object, key, placement, path) {
      return callProvider({
        kind: "property",
        object: object,
        key: key,
        placement: placement
      }, path);
    }

    return {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var name = path.node.name,
            scope = path.scope;
        if (scope.getBindingIdentifier(name)) return;
        callProvider({
          kind: "global",
          name: name
        }, path);
      },
      MemberExpression: function MemberExpression(path) {
        var key = resolveKey$1(path.get("property"), path.node.computed);
        if (!key || key === "prototype") return;
        var object = path.get("object");
        var binding = object.scope.getBinding(object.node.name);
        if (binding && binding.path.isImportNamespaceSpecifier()) return;
        var source = resolveSource$1(object);
        return property(source.id, key, source.placement, path);
      },
      ObjectPattern: function ObjectPattern(path) {
        var parentPath = path.parentPath,
            parent = path.parent;
        var obj;

        if (parentPath.isVariableDeclarator()) {
          obj = parentPath.get("init");
        } else if (parentPath.isAssignmentExpression()) {
          obj = parentPath.get("right");
        } else if (parentPath.isFunction()) {
          var grand = parentPath.parentPath;

          if (grand.isCallExpression() || grand.isNewExpression()) {
            if (grand.node.callee === parent) {
              obj = grand.get("arguments")[path.key];
            }
          }
        }

        var id = null;
        var placement = null;

        if (obj) {
          var _resolveSource = resolveSource$1(obj);

          id = _resolveSource.id;
          placement = _resolveSource.placement;
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;

          if (prop.isObjectProperty()) {
            var key = resolveKey$1(prop.get("key"));
            if (key) property(id, key, placement, prop);
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        var source = resolveSource$1(path.get("right"));
        var key = resolveKey$1(path.get("left"), true);
        if (!key) return;
        callProvider({
          kind: "in",
          object: source.id,
          key: key,
          placement: source.placement
        }, path);
      }
    };
  };

  var entry$1 = function entry(callProvider) {
    return {
      ImportDeclaration: function ImportDeclaration(path) {
        var source = getImportSource$2(path);
        if (!source) return;
        callProvider({
          kind: "import",
          source: source
        }, path);
      },
      Program: function Program(path) {
        path.get("body").forEach(function (bodyPath) {
          var source = getRequireSource$2(bodyPath);
          if (!source) return;
          callProvider({
            kind: "import",
            source: source
          }, bodyPath);
        });
      }
    };
  };

  function resolve$1(dirname, moduleName, absoluteImports) {
    if (absoluteImports === false) return moduleName;
    throw new Error("\"absoluteImports\" is not supported in bundles prepared for the browser.");
  }

  function has$6(basedir, name) {
    return true;
  }

  function logMissing$1(missingDeps) {}

  function laterLogMissing$1(missingDeps) {}

  var PossibleGlobalObjects$1 = new Set(["global", "globalThis", "self", "window"]);

  function createMetaResolver$1(polyfills) {
    var staticP = polyfills["static"],
        instanceP = polyfills.instance,
        globalP = polyfills.global;
    return function (meta) {
      if (meta.kind === "global" && globalP && has$1$1(globalP, meta.name)) {
        return {
          kind: "global",
          desc: globalP[meta.name],
          name: meta.name
        };
      }

      if (meta.kind === "property" || meta.kind === "in") {
        var placement = meta.placement,
            object = meta.object,
            key = meta.key;

        if (object && placement === "static") {
          if (globalP && PossibleGlobalObjects$1.has(object) && has$1$1(globalP, key)) {
            return {
              kind: "global",
              desc: globalP[key],
              name: key
            };
          }

          if (staticP && has$1$1(staticP, object) && has$1$1(staticP[object], key)) {
            return {
              kind: "static",
              desc: staticP[object][key],
              name: object + "$" + key
            };
          }
        }

        if (instanceP && has$1$1(instanceP, key)) {
          return {
            kind: "instance",
            desc: instanceP[key],
            name: "" + key
          };
        }
      }
    };
  }

  var getTargets$1 = getTargets$2["default"] || getTargets$2;

  function resolveOptions$1(options, babelApi) {
    var method = options.method,
        targetsOption = options.targets,
        ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
        configPath = options.configPath,
        debug = options.debug,
        shouldInjectPolyfill = options.shouldInjectPolyfill,
        absoluteImports = options.absoluteImports,
        providerOptions = _objectWithoutProperties(options, _excluded$1);

    var methodName;
    if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
      throw new Error(".method must be a string");
    } else {
      throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + (" or \"usage-pure\" (received " + JSON.stringify(method) + ")"));
    }

    if (typeof shouldInjectPolyfill === "function") {
      if (options.include || options.exclude) {
        throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
      }
    } else if (shouldInjectPolyfill != null) {
      throw new Error(".shouldInjectPolyfill must be a function, or undefined" + (" (received " + JSON.stringify(shouldInjectPolyfill) + ")"));
    }

    if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
      throw new Error(".absoluteImports must be a boolean, a string, or undefined" + (" (received " + JSON.stringify(absoluteImports) + ")"));
    }

    var targets;

    if (targetsOption || configPath || ignoreBrowserslistConfig) {
      var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
        browsers: targetsOption
      } : targetsOption;
      targets = getTargets$1(targetsObj, {
        ignoreBrowserslistConfig: ignoreBrowserslistConfig,
        configPath: configPath
      });
    } else {
      targets = babelApi.targets();
    }

    return {
      method: method,
      methodName: methodName,
      targets: targets,
      absoluteImports: absoluteImports != null ? absoluteImports : false,
      shouldInjectPolyfill: shouldInjectPolyfill,
      debug: !!debug,
      providerOptions: providerOptions
    };
  }

  function instantiateProvider$1(factory, options, missingDependencies, dirname, debugLog, babelApi) {
    var _resolveOptions = resolveOptions$1(options, babelApi),
        method = _resolveOptions.method,
        methodName = _resolveOptions.methodName,
        targets = _resolveOptions.targets,
        _debug = _resolveOptions.debug,
        _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
        providerOptions = _resolveOptions.providerOptions,
        absoluteImports = _resolveOptions.absoluteImports;

    var getUtils = createUtilsGetter$1(new ImportsCache$1(function (moduleName) {
      return resolve$1(dirname, moduleName, absoluteImports);
    }));
    var include, exclude;
    var polyfillsSupport;
    var polyfillsNames;
    var filterPolyfills;
    var depsCache = new Map();
    var api = {
      babel: babelApi,
      getUtils: getUtils,
      method: options.method,
      targets: targets,
      createMetaResolver: createMetaResolver$1,
      shouldInjectPolyfill: function shouldInjectPolyfill(name) {
        if (polyfillsNames === undefined) {
          throw new Error("Internal error in the " + factory.name + " provider: " + "shouldInjectPolyfill() can't be called during initialization.");
        }

        if (!polyfillsNames.has(name)) {
          console.warn("Internal error in the " + provider.name + " provider: " + ("unknown polyfill \"" + name + "\"."));
        }

        if (filterPolyfills && !filterPolyfills(name)) return false;
        var shouldInject = isRequired(name, targets, {
          compatData: polyfillsSupport,
          includes: include,
          excludes: exclude
        });

        if (_shouldInjectPolyfill) {
          shouldInject = _shouldInjectPolyfill(name, shouldInject);

          if (typeof shouldInject !== "boolean") {
            throw new Error(".shouldInjectPolyfill must return a boolean.");
          }
        }

        return shouldInject;
      },
      debug: function debug(name) {
        debugLog().found = true;
        if (!_debug || !name) return;
        if (debugLog().polyfills.has(provider.name)) return;
        debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);
      },
      assertDependency: function assertDependency(name, version) {
        if (version === void 0) {
          version = "*";
        }

        if (missingDependencies === false) return;

        if (absoluteImports) {
          return;
        }

        var dep = version === "*" ? name : name + "@^" + version;
        var found = missingDependencies.all ? false : mapGetOr$1(depsCache, name + " :: " + dirname, function () {
          return has$6();
        });

        if (!found) {
          debugLog().missingDeps.add(dep);
        }
      }
    };
    var provider = factory(api, providerOptions, dirname);

    if (typeof provider[methodName] !== "function") {
      throw new Error("The \"" + (provider.name || factory.name) + "\" provider doesn't " + ("support the \"" + method + "\" polyfilling method."));
    }

    if (Array.isArray(provider.polyfills)) {
      polyfillsNames = new Set(provider.polyfills);
      filterPolyfills = provider.filterPolyfills;
    } else if (provider.polyfills) {
      polyfillsNames = new Set(Object.keys(provider.polyfills));
      polyfillsSupport = provider.polyfills;
      filterPolyfills = provider.filterPolyfills;
    } else {
      polyfillsNames = new Set();
    }

    var _validateIncludeExclu = validateIncludeExclude$1(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);

    include = _validateIncludeExclu.include;
    exclude = _validateIncludeExclu.exclude;
    return {
      debug: _debug,
      method: method,
      targets: targets,
      provider: provider,
      callProvider: function callProvider(payload, path) {
        var utils = getUtils(path);
        provider[methodName](payload, utils, path);
      }
    };
  }

  function definePolyfillProvider$1(factory) {
    return declare(function (babelApi, options, dirname) {
      babelApi.assertVersion(7);
      var traverse = babelApi.traverse;
      var debugLog;
      var missingDependencies = applyMissingDependenciesDefaults$1(options, babelApi);

      var _instantiateProvider = instantiateProvider$1(factory, options, missingDependencies, dirname, function () {
        return debugLog;
      }, babelApi),
          debug = _instantiateProvider.debug,
          method = _instantiateProvider.method,
          targets = _instantiateProvider.targets,
          provider = _instantiateProvider.provider,
          callProvider = _instantiateProvider.callProvider;

      var createVisitor = method === "entry-global" ? entry$1 : usage$1;
      var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);

      if (debug && debug !== presetEnvSilentDebugHeader$1) {
        console.log(provider.name + ": `DEBUG` option");
        console.log("\nUsing targets: " + stringifyTargetsMultiline$1(targets));
        console.log("\nUsing polyfills with `" + method + "` method:");
      }

      return {
        name: "inject-polyfills",
        visitor: visitor,
        pre: function pre() {
          var _provider$pre;

          debugLog = {
            polyfills: new Map(),
            found: false,
            providers: new Set(),
            missingDeps: new Set()
          };
          (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
        },
        post: function post() {
          var _provider$post;

          (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);

          if (missingDependencies !== false) {
            if (missingDependencies.log === "per-file") {
              logMissing$1(debugLog.missingDeps);
            } else {
              laterLogMissing$1(debugLog.missingDeps);
            }
          }

          if (!debug) return;
          if (this.filename) console.log("\n[" + this.filename + "]");

          if (debugLog.polyfills.size === 0) {
            console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the " + provider.name + " polyfill did not add any polyfill." : "The entry point for the " + provider.name + " polyfill has not been found." : "Based on your code and targets, the " + provider.name + " polyfill did not add any polyfill.");
            return;
          }

          if (method === "entry-global") {
            console.log("The " + provider.name + " polyfill entry has been replaced with " + "the following polyfills:");
          } else {
            console.log("The " + provider.name + " polyfill added the following polyfills:");
          }

          for (var _iterator3 = _createForOfIteratorHelperLoose(debugLog.polyfills), _step3; !(_step3 = _iterator3()).done;) {
            var _step3$value = _slicedToArray$2(_step3.value, 2),
                name = _step3$value[0],
                support = _step3$value[1];

            if (support) {
              var filteredTargets = getInclusionReasons(name, targets, support);
              var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
              console.log("  " + name + " " + formattedTargets);
            } else {
              console.log("  " + name);
            }
          }
        }
      };
    });
  }

  function mapGetOr$1(map, key, getDefault) {
    var val = map.get(key);

    if (val === undefined) {
      val = getDefault();
      map.set(key, val);
    }

    return val;
  }

  var define$3 = function define(name, pure, global, meta) {
    if (global === void 0) {
      global = [];
    }

    return {
      name: name,
      pure: pure,
      global: global,
      meta: meta
    };
  };

  var pureAndGlobal$1 = function pureAndGlobal(pure, global, minRuntimeVersion) {
    if (minRuntimeVersion === void 0) {
      minRuntimeVersion = null;
    }

    return define$3(global[0], pure, global, {
      minRuntimeVersion: minRuntimeVersion
    });
  };

  var globalOnly$1 = function globalOnly(global) {
    return define$3(global[0], null, global);
  };

  var pureOnly$1 = function pureOnly(pure, name) {
    return define$3(name, pure, []);
  };

  var ArrayNatureIterators$3 = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
  var CommonIterators$3 = ["es6.string.iterator"].concat(ArrayNatureIterators$3);
  var PromiseDependencies$3 = ["es6.object.to-string", "es6.promise"];
  var BuiltIns$3 = {
    DataView: globalOnly$1(["es6.typed.data-view"]),
    Float32Array: globalOnly$1(["es6.typed.float32-array"]),
    Float64Array: globalOnly$1(["es6.typed.float64-array"]),
    Int8Array: globalOnly$1(["es6.typed.int8-array"]),
    Int16Array: globalOnly$1(["es6.typed.int16-array"]),
    Int32Array: globalOnly$1(["es6.typed.int32-array"]),
    Map: pureAndGlobal$1("map", ["es6.map"].concat(_toConsumableArray(CommonIterators$3))),
    Number: globalOnly$1(["es6.number.constructor"]),
    Promise: pureAndGlobal$1("promise", PromiseDependencies$3),
    RegExp: globalOnly$1(["es6.regexp.constructor"]),
    Set: pureAndGlobal$1("set", ["es6.set"].concat(_toConsumableArray(CommonIterators$3))),
    Symbol: pureAndGlobal$1("symbol", ["es6.symbol"]),
    Uint8Array: globalOnly$1(["es6.typed.uint8-array"]),
    Uint8ClampedArray: globalOnly$1(["es6.typed.uint8-clamped-array"]),
    Uint16Array: globalOnly$1(["es6.typed.uint16-array"]),
    Uint32Array: globalOnly$1(["es6.typed.uint32-array"]),
    WeakMap: pureAndGlobal$1("weak-map", ["es6.weak-map"].concat(_toConsumableArray(CommonIterators$3))),
    WeakSet: pureAndGlobal$1("weak-set", ["es6.weak-set"].concat(_toConsumableArray(CommonIterators$3))),
    setImmediate: pureOnly$1("set-immediate", "web.immediate"),
    clearImmediate: pureOnly$1("clear-immediate", "web.immediate"),
    parseFloat: pureOnly$1("parse-float", "es6.parse-float"),
    parseInt: pureOnly$1("parse-int", "es6.parse-int")
  };
  var InstanceProperties$3 = {
    __defineGetter__: globalOnly$1(["es7.object.define-getter"]),
    __defineSetter__: globalOnly$1(["es7.object.define-setter"]),
    __lookupGetter__: globalOnly$1(["es7.object.lookup-getter"]),
    __lookupSetter__: globalOnly$1(["es7.object.lookup-setter"]),
    anchor: globalOnly$1(["es6.string.anchor"]),
    big: globalOnly$1(["es6.string.big"]),
    bind: globalOnly$1(["es6.function.bind"]),
    blink: globalOnly$1(["es6.string.blink"]),
    bold: globalOnly$1(["es6.string.bold"]),
    codePointAt: globalOnly$1(["es6.string.code-point-at"]),
    copyWithin: globalOnly$1(["es6.array.copy-within"]),
    endsWith: globalOnly$1(["es6.string.ends-with"]),
    entries: globalOnly$1(ArrayNatureIterators$3),
    every: globalOnly$1(["es6.array.every"]),
    fill: globalOnly$1(["es6.array.fill"]),
    filter: globalOnly$1(["es6.array.filter"]),
    "finally": globalOnly$1(["es7.promise.finally"].concat(PromiseDependencies$3)),
    find: globalOnly$1(["es6.array.find"]),
    findIndex: globalOnly$1(["es6.array.find-index"]),
    fixed: globalOnly$1(["es6.string.fixed"]),
    flags: globalOnly$1(["es6.regexp.flags"]),
    flatMap: globalOnly$1(["es7.array.flat-map"]),
    fontcolor: globalOnly$1(["es6.string.fontcolor"]),
    fontsize: globalOnly$1(["es6.string.fontsize"]),
    forEach: globalOnly$1(["es6.array.for-each"]),
    includes: globalOnly$1(["es6.string.includes", "es7.array.includes"]),
    indexOf: globalOnly$1(["es6.array.index-of"]),
    italics: globalOnly$1(["es6.string.italics"]),
    keys: globalOnly$1(ArrayNatureIterators$3),
    lastIndexOf: globalOnly$1(["es6.array.last-index-of"]),
    link: globalOnly$1(["es6.string.link"]),
    map: globalOnly$1(["es6.array.map"]),
    match: globalOnly$1(["es6.regexp.match"]),
    name: globalOnly$1(["es6.function.name"]),
    padStart: globalOnly$1(["es7.string.pad-start"]),
    padEnd: globalOnly$1(["es7.string.pad-end"]),
    reduce: globalOnly$1(["es6.array.reduce"]),
    reduceRight: globalOnly$1(["es6.array.reduce-right"]),
    repeat: globalOnly$1(["es6.string.repeat"]),
    replace: globalOnly$1(["es6.regexp.replace"]),
    search: globalOnly$1(["es6.regexp.search"]),
    small: globalOnly$1(["es6.string.small"]),
    some: globalOnly$1(["es6.array.some"]),
    sort: globalOnly$1(["es6.array.sort"]),
    split: globalOnly$1(["es6.regexp.split"]),
    startsWith: globalOnly$1(["es6.string.starts-with"]),
    strike: globalOnly$1(["es6.string.strike"]),
    sub: globalOnly$1(["es6.string.sub"]),
    sup: globalOnly$1(["es6.string.sup"]),
    toISOString: globalOnly$1(["es6.date.to-iso-string"]),
    toJSON: globalOnly$1(["es6.date.to-json"]),
    toString: globalOnly$1(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
    trim: globalOnly$1(["es6.string.trim"]),
    trimEnd: globalOnly$1(["es7.string.trim-right"]),
    trimLeft: globalOnly$1(["es7.string.trim-left"]),
    trimRight: globalOnly$1(["es7.string.trim-right"]),
    trimStart: globalOnly$1(["es7.string.trim-left"]),
    values: globalOnly$1(ArrayNatureIterators$3)
  };

  if ("es6.array.slice" in corejs2BuiltIns) {
    InstanceProperties$3.slice = globalOnly$1(["es6.array.slice"]);
  }

  var StaticProperties$3 = {
    Array: {
      from: pureAndGlobal$1("array/from", ["es6.symbol", "es6.array.from"].concat(_toConsumableArray(CommonIterators$3))),
      isArray: pureAndGlobal$1("array/is-array", ["es6.array.is-array"]),
      of: pureAndGlobal$1("array/of", ["es6.array.of"])
    },
    Date: {
      now: pureAndGlobal$1("date/now", ["es6.date.now"])
    },
    JSON: {
      stringify: pureOnly$1("json/stringify", "es6.symbol")
    },
    Math: {
      acosh: pureAndGlobal$1("math/acosh", ["es6.math.acosh"], "7.0.1"),
      asinh: pureAndGlobal$1("math/asinh", ["es6.math.asinh"], "7.0.1"),
      atanh: pureAndGlobal$1("math/atanh", ["es6.math.atanh"], "7.0.1"),
      cbrt: pureAndGlobal$1("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
      clz32: pureAndGlobal$1("math/clz32", ["es6.math.clz32"], "7.0.1"),
      cosh: pureAndGlobal$1("math/cosh", ["es6.math.cosh"], "7.0.1"),
      expm1: pureAndGlobal$1("math/expm1", ["es6.math.expm1"], "7.0.1"),
      fround: pureAndGlobal$1("math/fround", ["es6.math.fround"], "7.0.1"),
      hypot: pureAndGlobal$1("math/hypot", ["es6.math.hypot"], "7.0.1"),
      imul: pureAndGlobal$1("math/imul", ["es6.math.imul"], "7.0.1"),
      log1p: pureAndGlobal$1("math/log1p", ["es6.math.log1p"], "7.0.1"),
      log10: pureAndGlobal$1("math/log10", ["es6.math.log10"], "7.0.1"),
      log2: pureAndGlobal$1("math/log2", ["es6.math.log2"], "7.0.1"),
      sign: pureAndGlobal$1("math/sign", ["es6.math.sign"], "7.0.1"),
      sinh: pureAndGlobal$1("math/sinh", ["es6.math.sinh"], "7.0.1"),
      tanh: pureAndGlobal$1("math/tanh", ["es6.math.tanh"], "7.0.1"),
      trunc: pureAndGlobal$1("math/trunc", ["es6.math.trunc"], "7.0.1")
    },
    Number: {
      EPSILON: pureAndGlobal$1("number/epsilon", ["es6.number.epsilon"]),
      MIN_SAFE_INTEGER: pureAndGlobal$1("number/min-safe-integer", ["es6.number.min-safe-integer"]),
      MAX_SAFE_INTEGER: pureAndGlobal$1("number/max-safe-integer", ["es6.number.max-safe-integer"]),
      isFinite: pureAndGlobal$1("number/is-finite", ["es6.number.is-finite"]),
      isInteger: pureAndGlobal$1("number/is-integer", ["es6.number.is-integer"]),
      isSafeInteger: pureAndGlobal$1("number/is-safe-integer", ["es6.number.is-safe-integer"]),
      isNaN: pureAndGlobal$1("number/is-nan", ["es6.number.is-nan"]),
      parseFloat: pureAndGlobal$1("number/parse-float", ["es6.number.parse-float"]),
      parseInt: pureAndGlobal$1("number/parse-int", ["es6.number.parse-int"])
    },
    Object: {
      assign: pureAndGlobal$1("object/assign", ["es6.object.assign"]),
      create: pureAndGlobal$1("object/create", ["es6.object.create"]),
      defineProperties: pureAndGlobal$1("object/define-properties", ["es6.object.define-properties"]),
      defineProperty: pureAndGlobal$1("object/define-property", ["es6.object.define-property"]),
      entries: pureAndGlobal$1("object/entries", ["es7.object.entries"]),
      freeze: pureAndGlobal$1("object/freeze", ["es6.object.freeze"]),
      getOwnPropertyDescriptor: pureAndGlobal$1("object/get-own-property-descriptor", ["es6.object.get-own-property-descriptor"]),
      getOwnPropertyDescriptors: pureAndGlobal$1("object/get-own-property-descriptors", ["es7.object.get-own-property-descriptors"]),
      getOwnPropertyNames: pureAndGlobal$1("object/get-own-property-names", ["es6.object.get-own-property-names"]),
      getOwnPropertySymbols: pureAndGlobal$1("object/get-own-property-symbols", ["es6.symbol"]),
      getPrototypeOf: pureAndGlobal$1("object/get-prototype-of", ["es6.object.get-prototype-of"]),
      is: pureAndGlobal$1("object/is", ["es6.object.is"]),
      isExtensible: pureAndGlobal$1("object/is-extensible", ["es6.object.is-extensible"]),
      isFrozen: pureAndGlobal$1("object/is-frozen", ["es6.object.is-frozen"]),
      isSealed: pureAndGlobal$1("object/is-sealed", ["es6.object.is-sealed"]),
      keys: pureAndGlobal$1("object/keys", ["es6.object.keys"]),
      preventExtensions: pureAndGlobal$1("object/prevent-extensions", ["es6.object.prevent-extensions"]),
      seal: pureAndGlobal$1("object/seal", ["es6.object.seal"]),
      setPrototypeOf: pureAndGlobal$1("object/set-prototype-of", ["es6.object.set-prototype-of"]),
      values: pureAndGlobal$1("object/values", ["es7.object.values"])
    },
    Promise: {
      all: globalOnly$1(CommonIterators$3),
      race: globalOnly$1(CommonIterators$3)
    },
    Reflect: {
      apply: pureAndGlobal$1("reflect/apply", ["es6.reflect.apply"]),
      construct: pureAndGlobal$1("reflect/construct", ["es6.reflect.construct"]),
      defineProperty: pureAndGlobal$1("reflect/define-property", ["es6.reflect.define-property"]),
      deleteProperty: pureAndGlobal$1("reflect/delete-property", ["es6.reflect.delete-property"]),
      get: pureAndGlobal$1("reflect/get", ["es6.reflect.get"]),
      getOwnPropertyDescriptor: pureAndGlobal$1("reflect/get-own-property-descriptor", ["es6.reflect.get-own-property-descriptor"]),
      getPrototypeOf: pureAndGlobal$1("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
      has: pureAndGlobal$1("reflect/has", ["es6.reflect.has"]),
      isExtensible: pureAndGlobal$1("reflect/is-extensible", ["es6.reflect.is-extensible"]),
      ownKeys: pureAndGlobal$1("reflect/own-keys", ["es6.reflect.own-keys"]),
      preventExtensions: pureAndGlobal$1("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
      set: pureAndGlobal$1("reflect/set", ["es6.reflect.set"]),
      setPrototypeOf: pureAndGlobal$1("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
    },
    String: {
      at: pureOnly$1("string/at", "es7.string.at"),
      fromCodePoint: pureAndGlobal$1("string/from-code-point", ["es6.string.from-code-point"]),
      raw: pureAndGlobal$1("string/raw", ["es6.string.raw"])
    },
    Symbol: {
      asyncIterator: globalOnly$1(["es6.symbol", "es7.symbol.async-iterator"]),
      "for": pureOnly$1("symbol/for", "es6.symbol"),
      hasInstance: pureOnly$1("symbol/has-instance", "es6.symbol"),
      isConcatSpreadable: pureOnly$1("symbol/is-concat-spreadable", "es6.symbol"),
      iterator: define$3("es6.symbol", "symbol/iterator", CommonIterators$3),
      keyFor: pureOnly$1("symbol/key-for", "es6.symbol"),
      match: pureAndGlobal$1("symbol/match", ["es6.regexp.match"]),
      replace: pureOnly$1("symbol/replace", "es6.symbol"),
      search: pureOnly$1("symbol/search", "es6.symbol"),
      species: pureOnly$1("symbol/species", "es6.symbol"),
      split: pureOnly$1("symbol/split", "es6.symbol"),
      toPrimitive: pureOnly$1("symbol/to-primitive", "es6.symbol"),
      toStringTag: pureOnly$1("symbol/to-string-tag", "es6.symbol"),
      unscopables: pureOnly$1("symbol/unscopables", "es6.symbol")
    }
  };
  var webPolyfills$1 = {
    "web.timers": {},
    "web.immediate": {},
    "web.dom.iterable": {}
  };
  var purePolyfills$1 = {
    "es6.parse-float": {},
    "es6.parse-int": {},
    "es7.string.at": {}
  };

  function addPlatformSpecificPolyfills$1(targets, method, polyfills) {
    var targetNames = Object.keys(targets);
    var isAnyTarget = !targetNames.length;
    var isWebTarget = targetNames.some(function (name) {
      return name !== "node";
    });
    return Object.assign(Object.assign(Object.assign({}, polyfills), method === "usage-pure" ? purePolyfills$1 : null), isAnyTarget || isWebTarget ? webPolyfills$1 : null);
  }

  function hasMinVersion$1(minVersion, runtimeVersion) {
    if (!runtimeVersion || !minVersion) return true;
    if (semver$3.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
    return !semver$3.intersects("<" + minVersion, runtimeVersion) && !semver$3.intersects(">=8.0.0", runtimeVersion);
  }

  var _ref$4 = undefined || babel,
      t$8 = _ref$4.types;

  var presetEnvCompat$1 = "#__secret_key__@babel/preset-env__compatibility";
  var runtimeCompat$5 = "#__secret_key__@babel/runtime__compatibility";
  var has$5 = Function.call.bind(Object.hasOwnProperty);
  var index$5 = definePolyfillProvider$1(function (api, _ref2) {
    var _ref2$presetEnvCompat = _ref2[presetEnvCompat$1];
    _ref2$presetEnvCompat = _ref2$presetEnvCompat === void 0 ? {} : _ref2$presetEnvCompat;
    var entryInjectRegenerator = _ref2$presetEnvCompat.entryInjectRegenerator,
        _ref2$runtimeCompat = _ref2[runtimeCompat$5];
    _ref2$runtimeCompat = _ref2$runtimeCompat === void 0 ? {} : _ref2$runtimeCompat;
    var useBabelRuntime = _ref2$runtimeCompat.useBabelRuntime,
        runtimeVersion = _ref2$runtimeCompat.runtimeVersion,
        _ref2$runtimeCompat$e = _ref2$runtimeCompat.ext,
        ext = _ref2$runtimeCompat$e === void 0 ? ".js" : _ref2$runtimeCompat$e;
    var resolve = api.createMetaResolver({
      global: BuiltIns$3,
      "static": StaticProperties$3,
      instance: InstanceProperties$3
    });
    var debug = api.debug,
        shouldInjectPolyfill = api.shouldInjectPolyfill,
        method = api.method;
    var polyfills = addPlatformSpecificPolyfills$1(api.targets, method, corejs2BuiltIns);
    var coreJSBase = useBabelRuntime ? useBabelRuntime + "/core-js" : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";

    function inject(name, utils) {
      if (typeof name === "string") {
        if (has$5(polyfills, name) && shouldInjectPolyfill(name)) {
          debug(name);
          utils.injectGlobalImport(coreJSBase + "/" + name + ".js");
        }

        return;
      }

      name.forEach(function (name) {
        return inject(name, utils);
      });
    }

    function maybeInjectPure(desc, hint, utils) {
      var pure = desc.pure,
          meta = desc.meta,
          name = desc.name;
      if (!pure || !shouldInjectPolyfill(name)) return;

      if (runtimeVersion && meta && meta.minRuntimeVersion && !hasMinVersion$1(meta && meta.minRuntimeVersion, runtimeVersion)) {
        return;
      }

      return utils.injectDefaultImport(coreJSBase + "/" + pure + ext, hint);
    }

    return {
      name: "corejs2",
      polyfills: polyfills,
      entryGlobal: function entryGlobal(meta, utils, path) {
        if (meta.kind === "import" && meta.source === "core-js") {
          debug(null);
          inject(Object.keys(polyfills), utils);

          if (entryInjectRegenerator) {
            utils.injectGlobalImport("regenerator-runtime/runtime.js");
          }

          path.remove();
        }
      },
      usageGlobal: function usageGlobal(meta, utils) {
        var resolved = resolve(meta);
        if (!resolved) return;
        var deps = resolved.desc.global;

        if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
          var low = meta.object.toLowerCase();
          deps = deps.filter(function (m) {
            return m.includes(low);
          });
        }

        inject(deps, utils);
      },
      usagePure: function usagePure(meta, utils, path) {
        if (meta.kind === "in") {
          if (meta.key === "Symbol.iterator") {
            path.replaceWith(t$8.callExpression(utils.injectDefaultImport(coreJSBase + "/is-iterable" + ext, "isIterable"), [path.node.right]));
          }

          return;
        }

        if (path.parentPath.isUnaryExpression({
          operator: "delete"
        })) return;

        if (meta.kind === "property") {
          if (!path.isMemberExpression()) return;
          if (!path.isReferenced()) return;

          if (meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
            callee: path.node
          }) && path.parent.arguments.length === 0) {
            path.parentPath.replaceWith(t$8.callExpression(utils.injectDefaultImport(coreJSBase + "/get-iterator" + ext, "getIterator"), [path.node.object]));
            path.skip();
            return;
          }
        }

        var resolved = resolve(meta);
        if (!resolved) return;
        var id = maybeInjectPure(resolved.desc, resolved.name, utils);
        if (id) path.replaceWith(id);
      },
      visitor: method === "usage-global" && {
        YieldExpression: function YieldExpression(path) {
          if (path.node.delegate) {
            inject("web.dom.iterable", api.getUtils(path));
          }
        },
        "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
          CommonIterators$3.forEach(function (name) {
            return inject(name, api.getUtils(path));
          });
        }
      }
    };
  });

  var require$$0$3 = {
  	"es.symbol": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.description": {
  	android: "70",
  	chrome: "70",
  	edge: "74",
  	electron: "5.0",
  	firefox: "63",
  	ios: "12.2",
  	node: "11.0",
  	opera: "57",
  	opera_mobile: "49",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"es.symbol.async-iterator": {
  	android: "63",
  	chrome: "63",
  	edge: "74",
  	electron: "3.0",
  	firefox: "55",
  	ios: "12.0",
  	node: "10.0",
  	opera: "50",
  	opera_mobile: "46",
  	safari: "12.0",
  	samsung: "8.0"
  },
  	"es.symbol.has-instance": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.is-concat-spreadable": {
  	android: "48",
  	chrome: "48",
  	edge: "15",
  	electron: "0.37",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.0",
  	opera: "35",
  	opera_mobile: "35",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.iterator": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "36",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.symbol.match": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.match-all": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.symbol.replace": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.search": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.species": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "41",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.split": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.to-primitive": {
  	android: "47",
  	chrome: "47",
  	edge: "15",
  	electron: "0.36",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.to-string-tag": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.symbol.unscopables": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "48",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.aggregate-error": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0",
  	samsung: "14.0"
  },
  	"es.array.concat": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.copy-within": {
  	android: "45",
  	chrome: "45",
  	edge: "12",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.every": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "1.5"
  },
  	"es.array.fill": {
  	android: "45",
  	chrome: "45",
  	edge: "12",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.filter": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.find": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.find-index": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "48",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.flat": {
  	android: "69",
  	chrome: "69",
  	edge: "74",
  	electron: "4.0",
  	firefox: "62",
  	ios: "12.0",
  	node: "11.0",
  	opera: "56",
  	opera_mobile: "48",
  	safari: "12.0",
  	samsung: "10.0"
  },
  	"es.array.flat-map": {
  	android: "69",
  	chrome: "69",
  	edge: "74",
  	electron: "4.0",
  	firefox: "62",
  	ios: "12.0",
  	node: "11.0",
  	opera: "56",
  	opera_mobile: "48",
  	safari: "12.0",
  	samsung: "10.0"
  },
  	"es.array.for-each": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "1.5"
  },
  	"es.array.from": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "9.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.includes": {
  	android: "53",
  	chrome: "53",
  	edge: "14",
  	electron: "1.4",
  	firefox: "48",
  	ios: "10.0",
  	node: "7.0",
  	opera: "40",
  	opera_mobile: "40",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.array.index-of": {
  	android: "51",
  	chrome: "51",
  	edge: "12",
  	electron: "1.2",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "5.0"
  },
  	"es.array.is-array": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.array.iterator": {
  	android: "66",
  	chrome: "66",
  	edge: "15",
  	electron: "3.0",
  	firefox: "60",
  	ios: "10.0",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "10.0",
  	samsung: "9.0"
  },
  	"es.array.join": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "4",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.array.last-index-of": {
  	android: "51",
  	chrome: "51",
  	edge: "12",
  	electron: "1.2",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "5.0"
  },
  	"es.array.map": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "50",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "25",
  	ios: "9.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.array.reduce": {
  	android: "83",
  	chrome: "83",
  	edge: "12",
  	electron: "9.0",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "6.0",
  	opera: "69",
  	opera_mobile: "59",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "13.0"
  },
  	"es.array.reduce-right": {
  	android: "83",
  	chrome: "83",
  	edge: "12",
  	electron: "9.0",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "6.0",
  	opera: "69",
  	opera_mobile: "59",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "13.0"
  },
  	"es.array.reverse": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "5.5",
  	ios: "12.2",
  	node: "0.0.3",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	rhino: "1.7.13",
  	safari: "12.0.2",
  	samsung: "1.0"
  },
  	"es.array.slice": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.some": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "9.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "8.0",
  	samsung: "1.5"
  },
  	"es.array.sort": {
  	android: "70",
  	chrome: "70",
  	edge: "74",
  	electron: "5.0",
  	firefox: "4",
  	ios: "12.0",
  	node: "11.0",
  	opera: "57",
  	opera_mobile: "49",
  	safari: "12.0",
  	samsung: "10.0"
  },
  	"es.array.species": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "48",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.splice": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.array.unscopables.flat": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.array.unscopables.flat-map": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "67",
  	ios: "13.0",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "13",
  	samsung: "11.0"
  },
  	"es.array-buffer.constructor": {
  	android: "4.4",
  	chrome: "26",
  	edge: "14",
  	electron: "0.20",
  	firefox: "44",
  	ios: "12.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "12.0",
  	samsung: "1.5"
  },
  	"es.array-buffer.is-view": {
  	android: "4.4.3",
  	chrome: "32",
  	edge: "12",
  	electron: "0.20",
  	firefox: "29",
  	ie: "11",
  	ios: "8.0",
  	node: "0.11.9",
  	opera: "19",
  	opera_mobile: "19",
  	safari: "7.1",
  	samsung: "2.0"
  },
  	"es.array-buffer.slice": {
  	android: "4.4.3",
  	chrome: "31",
  	edge: "12",
  	electron: "0.20",
  	firefox: "46",
  	ie: "11",
  	ios: "12.2",
  	node: "0.11.8",
  	opera: "18",
  	opera_mobile: "18",
  	rhino: "1.7.13",
  	safari: "12.1",
  	samsung: "2.0"
  },
  	"es.data-view": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "15",
  	ie: "10",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.date.get-year": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "3",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "3",
  	opera_mobile: "3",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.date.now": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.date.set-year": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "3",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "3",
  	opera_mobile: "3",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.date.to-gmt-string": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "3",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "3",
  	opera_mobile: "3",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.date.to-iso-string": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "7",
  	ie: "9",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.date.to-json": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "10.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "1.5"
  },
  	"es.date.to-primitive": {
  	android: "47",
  	chrome: "47",
  	edge: "15",
  	electron: "0.36",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.date.to-string": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ie: "9",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.escape": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "3",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "3",
  	opera_mobile: "3",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.function.bind": {
  	android: "3.0",
  	chrome: "7",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.101",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	rhino: "1.7.13",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.function.has-instance": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "50",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.function.name": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.global-this": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "65",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"es.json.stringify": {
  	android: "72",
  	chrome: "72",
  	edge: "74",
  	electron: "5.0",
  	firefox: "64",
  	ios: "12.2",
  	node: "12.0",
  	opera: "59",
  	opera_mobile: "51",
  	safari: "12.1",
  	samsung: "11.0"
  },
  	"es.json.to-string-tag": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.map": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.math.acosh": {
  	android: "54",
  	chrome: "54",
  	edge: "13",
  	electron: "1.4",
  	firefox: "25",
  	ios: "8.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "7.1",
  	samsung: "6.0"
  },
  	"es.math.asinh": {
  	android: "38",
  	chrome: "38",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.atanh": {
  	android: "38",
  	chrome: "38",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.cbrt": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.clz32": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.math.cosh": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.expm1": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "46",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.fround": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "26",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.hypot": {
  	android: "78",
  	chrome: "78",
  	edge: "12",
  	electron: "7.0",
  	firefox: "27",
  	ios: "8.0",
  	node: "13.0",
  	opera: "65",
  	opera_mobile: "56",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "12.0"
  },
  	"es.math.imul": {
  	android: "4.4",
  	chrome: "28",
  	edge: "13",
  	electron: "0.20",
  	firefox: "20",
  	ios: "9.0",
  	node: "0.11.1",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.math.log10": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.log1p": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.log2": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.sign": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "9.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.math.sinh": {
  	android: "39",
  	chrome: "39",
  	edge: "13",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "1.0",
  	opera: "26",
  	opera_mobile: "26",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.4"
  },
  	"es.math.tanh": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.math.to-string-tag": {
  	android: "50",
  	chrome: "50",
  	edge: "15",
  	electron: "1.1",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.math.trunc": {
  	android: "38",
  	chrome: "38",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "8.0",
  	node: "0.11.15",
  	opera: "25",
  	opera_mobile: "25",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.number.constructor": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "46",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.number.epsilon": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "25",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.is-finite": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "16",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.number.is-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "16",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.is-nan": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "15",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.number.is-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "32",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.max-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.min-safe-integer": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.number.parse-float": {
  	android: "37",
  	chrome: "35",
  	edge: "13",
  	electron: "0.20",
  	firefox: "39",
  	ios: "11.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "11.0",
  	samsung: "3.0"
  },
  	"es.number.parse-int": {
  	android: "37",
  	chrome: "35",
  	edge: "13",
  	electron: "0.20",
  	firefox: "39",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	safari: "9.0",
  	samsung: "3.0"
  },
  	"es.number.to-fixed": {
  	android: "4.4",
  	chrome: "26",
  	edge: "74",
  	electron: "0.20",
  	firefox: "4",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.number.to-precision": {
  	android: "4.4",
  	chrome: "26",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "8",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.object.assign": {
  	android: "49",
  	chrome: "49",
  	edge: "74",
  	electron: "0.37",
  	firefox: "36",
  	ios: "9.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "9.0",
  	samsung: "5.0"
  },
  	"es.object.create": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "3.2",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "4.0",
  	samsung: "1.0"
  },
  	"es.object.define-getter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.define-properties": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	rhino: "1.7.13",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.object.define-property": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "4",
  	ie: "9",
  	ios: "5.1",
  	node: "0.1.27",
  	opera: "12",
  	opera_mobile: "12",
  	phantom: "2.0",
  	rhino: "1.7.13",
  	safari: "5.1",
  	samsung: "1.0"
  },
  	"es.object.define-setter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.entries": {
  	android: "54",
  	chrome: "54",
  	edge: "14",
  	electron: "1.4",
  	firefox: "47",
  	ios: "10.3",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.1",
  	samsung: "6.0"
  },
  	"es.object.freeze": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.from-entries": {
  	android: "73",
  	chrome: "73",
  	edge: "74",
  	electron: "5.0",
  	firefox: "63",
  	ios: "12.2",
  	node: "12.0",
  	opera: "60",
  	opera_mobile: "52",
  	safari: "12.1",
  	samsung: "11.0"
  },
  	"es.object.get-own-property-descriptor": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.get-own-property-descriptors": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "50",
  	ios: "10.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.object.get-own-property-names": {
  	android: "40",
  	chrome: "40",
  	edge: "13",
  	electron: "0.21",
  	firefox: "34",
  	ios: "9.0",
  	node: "1.0",
  	opera: "27",
  	opera_mobile: "27",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.object.get-prototype-of": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is": {
  	android: "4.1",
  	chrome: "19",
  	edge: "12",
  	electron: "0.20",
  	firefox: "22",
  	ios: "9.0",
  	node: "0.7.3",
  	opera: "15",
  	opera_mobile: "15",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "1.5"
  },
  	"es.object.is-extensible": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is-frozen": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.is-sealed": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.keys": {
  	android: "40",
  	chrome: "40",
  	edge: "13",
  	electron: "0.21",
  	firefox: "35",
  	ios: "9.0",
  	node: "1.0",
  	opera: "27",
  	opera_mobile: "27",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.object.lookup-getter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.lookup-setter": {
  	android: "62",
  	chrome: "62",
  	edge: "16",
  	electron: "3.0",
  	firefox: "48",
  	ios: "8.0",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "8.0"
  },
  	"es.object.prevent-extensions": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.seal": {
  	android: "44",
  	chrome: "44",
  	edge: "13",
  	electron: "0.30",
  	firefox: "35",
  	ios: "9.0",
  	node: "3.0",
  	opera: "31",
  	opera_mobile: "31",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "4.0"
  },
  	"es.object.set-prototype-of": {
  	android: "37",
  	chrome: "34",
  	edge: "12",
  	electron: "0.20",
  	firefox: "31",
  	ie: "11",
  	ios: "9.0",
  	node: "0.11.13",
  	opera: "21",
  	opera_mobile: "21",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "2.0"
  },
  	"es.object.to-string": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.object.values": {
  	android: "54",
  	chrome: "54",
  	edge: "14",
  	electron: "1.4",
  	firefox: "47",
  	ios: "10.3",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.1",
  	samsung: "6.0"
  },
  	"es.parse-float": {
  	android: "37",
  	chrome: "35",
  	edge: "12",
  	electron: "0.20",
  	firefox: "8",
  	ie: "8",
  	ios: "8.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.parse-int": {
  	android: "37",
  	chrome: "35",
  	edge: "12",
  	electron: "0.20",
  	firefox: "21",
  	ie: "9",
  	ios: "8.0",
  	node: "0.11.13",
  	opera: "22",
  	opera_mobile: "22",
  	rhino: "1.7.13",
  	safari: "7.1",
  	samsung: "3.0"
  },
  	"es.promise": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "69",
  	ios: "11.0",
  	node: "10.4",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "11.0",
  	samsung: "9.0"
  },
  	"es.promise.all-settled": {
  	android: "76",
  	chrome: "76",
  	edge: "76",
  	electron: "6.0",
  	firefox: "71",
  	ios: "13.0",
  	node: "12.9",
  	opera: "63",
  	opera_mobile: "54",
  	safari: "13",
  	samsung: "12.0"
  },
  	"es.promise.any": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0",
  	samsung: "14.0"
  },
  	"es.promise.finally": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "69",
  	ios: "13.2.3",
  	node: "10.4",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "13.0.3",
  	samsung: "9.0"
  },
  	"es.reflect.apply": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.construct": {
  	android: "49",
  	chrome: "49",
  	edge: "15",
  	electron: "0.37",
  	firefox: "44",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.define-property": {
  	android: "49",
  	chrome: "49",
  	edge: "13",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.delete-property": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get-own-property-descriptor": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.get-prototype-of": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.has": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.is-extensible": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.own-keys": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.prevent-extensions": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.set": {
  	android: "49",
  	chrome: "49",
  	edge: "74",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.set-prototype-of": {
  	android: "49",
  	chrome: "49",
  	edge: "12",
  	electron: "0.37",
  	firefox: "42",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.reflect.to-string-tag": {
  	android: "86",
  	chrome: "86",
  	edge: "86",
  	electron: "11.0",
  	firefox: "82",
  	ios: "14.0",
  	node: "15.0",
  	opera: "72",
  	opera_mobile: "61",
  	safari: "14.0",
  	samsung: "14.0"
  },
  	"es.regexp.constructor": {
  	android: "64",
  	chrome: "64",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "11.3",
  	node: "10.0",
  	opera: "51",
  	opera_mobile: "47",
  	safari: "11.1",
  	samsung: "9.0"
  },
  	"es.regexp.dot-all": {
  	android: "62",
  	chrome: "62",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "11.3",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "11.1",
  	samsung: "8.0"
  },
  	"es.regexp.exec": {
  	android: "64",
  	chrome: "64",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "11.3",
  	node: "10.0",
  	opera: "51",
  	opera_mobile: "47",
  	safari: "11.1",
  	samsung: "9.0"
  },
  	"es.regexp.flags": {
  	android: "62",
  	chrome: "62",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "11.3",
  	node: "8.10",
  	opera: "49",
  	opera_mobile: "46",
  	safari: "11.1",
  	samsung: "8.0"
  },
  	"es.regexp.sticky": {
  	android: "49",
  	chrome: "49",
  	edge: "13",
  	electron: "0.37",
  	firefox: "3",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.regexp.test": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "46",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.regexp.to-string": {
  	android: "50",
  	chrome: "50",
  	edge: "74",
  	electron: "1.1",
  	firefox: "46",
  	ios: "10.0",
  	node: "6.0",
  	opera: "37",
  	opera_mobile: "37",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.set": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.code-point-at": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "29",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.ends-with": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.from-code-point": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "29",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.includes": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.iterator": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "36",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.match": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.match-all": {
  	android: "80",
  	chrome: "80",
  	edge: "80",
  	electron: "8.0",
  	firefox: "73",
  	ios: "13.4",
  	node: "14.0",
  	opera: "67",
  	opera_mobile: "57",
  	safari: "13.1",
  	samsung: "13.0"
  },
  	"es.string.pad-end": {
  	android: "57",
  	chrome: "57",
  	edge: "15",
  	electron: "1.7",
  	firefox: "48",
  	ios: "11.0",
  	node: "8.0",
  	opera: "44",
  	opera_mobile: "43",
  	rhino: "1.7.13",
  	safari: "11.0",
  	samsung: "7.0"
  },
  	"es.string.pad-start": {
  	android: "57",
  	chrome: "57",
  	edge: "15",
  	electron: "1.7",
  	firefox: "48",
  	ios: "11.0",
  	node: "8.0",
  	opera: "44",
  	opera_mobile: "43",
  	rhino: "1.7.13",
  	safari: "11.0",
  	samsung: "7.0"
  },
  	"es.string.raw": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "34",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.repeat": {
  	android: "41",
  	chrome: "41",
  	edge: "13",
  	electron: "0.21",
  	firefox: "24",
  	ios: "9.0",
  	node: "1.0",
  	opera: "28",
  	opera_mobile: "28",
  	rhino: "1.7.13",
  	safari: "9.0",
  	samsung: "3.4"
  },
  	"es.string.replace": {
  	android: "64",
  	chrome: "64",
  	edge: "74",
  	electron: "3.0",
  	firefox: "78",
  	ios: "14.0",
  	node: "10.0",
  	opera: "51",
  	opera_mobile: "47",
  	safari: "14.0",
  	samsung: "9.0"
  },
  	"es.string.replace-all": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "77",
  	ios: "13.4",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "13.1",
  	samsung: "14.0"
  },
  	"es.string.search": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "49",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.split": {
  	android: "54",
  	chrome: "54",
  	edge: "74",
  	electron: "1.4",
  	firefox: "49",
  	ios: "10.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "10.0",
  	samsung: "6.0"
  },
  	"es.string.starts-with": {
  	android: "51",
  	chrome: "51",
  	edge: "74",
  	electron: "1.2",
  	firefox: "40",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.string.substr": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "4",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "4",
  	opera_mobile: "4",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.string.trim": {
  	android: "59",
  	chrome: "59",
  	edge: "15",
  	electron: "1.8",
  	firefox: "52",
  	ios: "12.2",
  	node: "8.3",
  	opera: "46",
  	opera_mobile: "43",
  	rhino: "1.7.13",
  	safari: "12.1",
  	samsung: "7.0"
  },
  	"es.string.trim-end": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "61",
  	ios: "12.2",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "12.1",
  	samsung: "9.0"
  },
  	"es.string.trim-start": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "61",
  	ios: "12.0",
  	node: "10.0",
  	opera: "53",
  	opera_mobile: "47",
  	safari: "12.0",
  	samsung: "9.0"
  },
  	"es.string.anchor": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.big": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.blink": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.bold": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.fixed": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.fontcolor": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.fontsize": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.italics": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.link": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "17",
  	ios: "6.0",
  	node: "0.1.27",
  	opera: "15",
  	opera_mobile: "15",
  	phantom: "2.0",
  	safari: "6.0",
  	samsung: "1.0"
  },
  	"es.string.small": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.strike": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.sub": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.string.sup": {
  	android: "3.0",
  	chrome: "5",
  	edge: "12",
  	electron: "0.20",
  	firefox: "2",
  	ios: "2.0",
  	node: "0.1.27",
  	opera: "10.50",
  	opera_mobile: "10.50",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "3.1",
  	samsung: "1.0"
  },
  	"es.typed-array.float32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.float64-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.int8-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.int16-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.int32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.uint8-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.uint8-clamped-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.uint16-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.uint32-array": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.copy-within": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "34",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.every": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.fill": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.filter": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.find": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.find-index": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.for-each": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.from": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.includes": {
  	android: "49",
  	chrome: "49",
  	edge: "14",
  	electron: "0.37",
  	firefox: "43",
  	ios: "10.0",
  	node: "6.0",
  	opera: "36",
  	opera_mobile: "36",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.index-of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.iterator": {
  	android: "47",
  	chrome: "47",
  	edge: "13",
  	electron: "0.36",
  	firefox: "37",
  	ios: "10.0",
  	node: "6.0",
  	opera: "34",
  	opera_mobile: "34",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.join": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.last-index-of": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.map": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.of": {
  	android: "54",
  	chrome: "54",
  	edge: "15",
  	electron: "1.4",
  	firefox: "55",
  	ios: "14.0",
  	node: "7.0",
  	opera: "41",
  	opera_mobile: "41",
  	safari: "14.0",
  	samsung: "6.0"
  },
  	"es.typed-array.reduce": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.reduce-right": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.reverse": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.set": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "15",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.typed-array.slice": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "38",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.some": {
  	android: "45",
  	chrome: "45",
  	edge: "13",
  	electron: "0.31",
  	firefox: "37",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.sort": {
  	android: "74",
  	chrome: "74",
  	edge: "74",
  	electron: "6.0",
  	firefox: "67",
  	ios: "14.5",
  	node: "12.0",
  	opera: "61",
  	opera_mobile: "53",
  	safari: "14.1",
  	samsung: "11.0"
  },
  	"es.typed-array.subarray": {
  	android: "4.4",
  	chrome: "26",
  	edge: "13",
  	electron: "0.20",
  	firefox: "15",
  	ios: "8.0",
  	node: "0.11.0",
  	opera: "16",
  	opera_mobile: "16",
  	safari: "7.1",
  	samsung: "1.5"
  },
  	"es.typed-array.to-locale-string": {
  	android: "45",
  	chrome: "45",
  	edge: "74",
  	electron: "0.31",
  	firefox: "51",
  	ios: "10.0",
  	node: "4.0",
  	opera: "32",
  	opera_mobile: "32",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.typed-array.to-string": {
  	android: "51",
  	chrome: "51",
  	edge: "13",
  	electron: "1.2",
  	firefox: "51",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.unescape": {
  	android: "3.0",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "3",
  	ios: "1.0",
  	node: "0.0.3",
  	opera: "3",
  	opera_mobile: "3",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1",
  	samsung: "1.0"
  },
  	"es.weak-map": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"es.weak-set": {
  	android: "51",
  	chrome: "51",
  	edge: "15",
  	electron: "1.2",
  	firefox: "53",
  	ios: "10.0",
  	node: "6.5",
  	opera: "38",
  	opera_mobile: "38",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "5.0"
  },
  	"esnext.aggregate-error": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0",
  	samsung: "14.0"
  },
  	"esnext.array.at": {
  	android: "92",
  	chrome: "92",
  	edge: "92",
  	electron: "14.0",
  	firefox: "90",
  	opera: "78"
  },
  	"esnext.array.filter-out": {
  },
  	"esnext.array.find-last": {
  },
  	"esnext.array.find-last-index": {
  },
  	"esnext.array.is-template-object": {
  },
  	"esnext.array.last-index": {
  },
  	"esnext.array.last-item": {
  },
  	"esnext.array.unique-by": {
  },
  	"esnext.async-iterator.constructor": {
  },
  	"esnext.async-iterator.as-indexed-pairs": {
  },
  	"esnext.async-iterator.drop": {
  },
  	"esnext.async-iterator.every": {
  },
  	"esnext.async-iterator.filter": {
  },
  	"esnext.async-iterator.find": {
  },
  	"esnext.async-iterator.flat-map": {
  },
  	"esnext.async-iterator.for-each": {
  },
  	"esnext.async-iterator.from": {
  },
  	"esnext.async-iterator.map": {
  },
  	"esnext.async-iterator.reduce": {
  },
  	"esnext.async-iterator.some": {
  },
  	"esnext.async-iterator.take": {
  },
  	"esnext.async-iterator.to-array": {
  },
  	"esnext.bigint.range": {
  },
  	"esnext.composite-key": {
  },
  	"esnext.composite-symbol": {
  },
  	"esnext.global-this": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "65",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"esnext.iterator.constructor": {
  },
  	"esnext.iterator.as-indexed-pairs": {
  },
  	"esnext.iterator.drop": {
  },
  	"esnext.iterator.every": {
  },
  	"esnext.iterator.filter": {
  },
  	"esnext.iterator.find": {
  },
  	"esnext.iterator.flat-map": {
  },
  	"esnext.iterator.for-each": {
  },
  	"esnext.iterator.from": {
  },
  	"esnext.iterator.map": {
  },
  	"esnext.iterator.reduce": {
  },
  	"esnext.iterator.some": {
  },
  	"esnext.iterator.take": {
  },
  	"esnext.iterator.to-array": {
  },
  	"esnext.map.delete-all": {
  },
  	"esnext.map.emplace": {
  },
  	"esnext.map.every": {
  },
  	"esnext.map.filter": {
  },
  	"esnext.map.find": {
  },
  	"esnext.map.find-key": {
  },
  	"esnext.map.from": {
  },
  	"esnext.map.group-by": {
  },
  	"esnext.map.includes": {
  },
  	"esnext.map.key-by": {
  },
  	"esnext.map.key-of": {
  },
  	"esnext.map.map-keys": {
  },
  	"esnext.map.map-values": {
  },
  	"esnext.map.merge": {
  },
  	"esnext.map.of": {
  },
  	"esnext.map.reduce": {
  },
  	"esnext.map.some": {
  },
  	"esnext.map.update": {
  },
  	"esnext.map.update-or-insert": {
  },
  	"esnext.map.upsert": {
  },
  	"esnext.math.clamp": {
  },
  	"esnext.math.deg-per-rad": {
  },
  	"esnext.math.degrees": {
  },
  	"esnext.math.fscale": {
  },
  	"esnext.math.iaddh": {
  },
  	"esnext.math.imulh": {
  },
  	"esnext.math.isubh": {
  },
  	"esnext.math.rad-per-deg": {
  },
  	"esnext.math.radians": {
  },
  	"esnext.math.scale": {
  },
  	"esnext.math.seeded-prng": {
  },
  	"esnext.math.signbit": {
  },
  	"esnext.math.umulh": {
  },
  	"esnext.number.from-string": {
  },
  	"esnext.number.range": {
  },
  	"esnext.object.has-own": {
  },
  	"esnext.object.iterate-entries": {
  },
  	"esnext.object.iterate-keys": {
  },
  	"esnext.object.iterate-values": {
  },
  	"esnext.observable": {
  },
  	"esnext.promise.all-settled": {
  	android: "76",
  	chrome: "76",
  	edge: "76",
  	electron: "6.0",
  	firefox: "71",
  	ios: "13.0",
  	node: "12.9",
  	opera: "63",
  	opera_mobile: "54",
  	safari: "13",
  	samsung: "12.0"
  },
  	"esnext.promise.any": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "79",
  	ios: "14.0",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "14.0",
  	samsung: "14.0"
  },
  	"esnext.promise.try": {
  },
  	"esnext.reflect.define-metadata": {
  },
  	"esnext.reflect.delete-metadata": {
  },
  	"esnext.reflect.get-metadata": {
  },
  	"esnext.reflect.get-metadata-keys": {
  },
  	"esnext.reflect.get-own-metadata": {
  },
  	"esnext.reflect.get-own-metadata-keys": {
  },
  	"esnext.reflect.has-metadata": {
  },
  	"esnext.reflect.has-own-metadata": {
  },
  	"esnext.reflect.metadata": {
  },
  	"esnext.set.add-all": {
  },
  	"esnext.set.delete-all": {
  },
  	"esnext.set.difference": {
  },
  	"esnext.set.every": {
  },
  	"esnext.set.filter": {
  },
  	"esnext.set.find": {
  },
  	"esnext.set.from": {
  },
  	"esnext.set.intersection": {
  },
  	"esnext.set.is-disjoint-from": {
  },
  	"esnext.set.is-subset-of": {
  },
  	"esnext.set.is-superset-of": {
  },
  	"esnext.set.join": {
  },
  	"esnext.set.map": {
  },
  	"esnext.set.of": {
  },
  	"esnext.set.reduce": {
  },
  	"esnext.set.some": {
  },
  	"esnext.set.symmetric-difference": {
  },
  	"esnext.set.union": {
  },
  	"esnext.string.at": {
  },
  	"esnext.string.code-points": {
  },
  	"esnext.string.match-all": {
  	android: "80",
  	chrome: "80",
  	edge: "80",
  	electron: "8.0",
  	firefox: "73",
  	ios: "13.4",
  	node: "14.0",
  	opera: "67",
  	opera_mobile: "57",
  	safari: "13.1",
  	samsung: "13.0"
  },
  	"esnext.string.replace-all": {
  	android: "85",
  	chrome: "85",
  	edge: "85",
  	electron: "10.0",
  	firefox: "77",
  	ios: "13.4",
  	node: "15.0",
  	opera: "71",
  	opera_mobile: "60",
  	safari: "13.1",
  	samsung: "14.0"
  },
  	"esnext.symbol.async-dispose": {
  },
  	"esnext.symbol.dispose": {
  },
  	"esnext.symbol.matcher": {
  },
  	"esnext.symbol.metadata": {
  },
  	"esnext.symbol.observable": {
  },
  	"esnext.symbol.pattern-match": {
  },
  	"esnext.symbol.replace-all": {
  },
  	"esnext.typed-array.at": {
  	android: "92",
  	chrome: "92",
  	edge: "92",
  	electron: "14.0",
  	firefox: "90",
  	opera: "78"
  },
  	"esnext.typed-array.filter-out": {
  },
  	"esnext.typed-array.find-last": {
  },
  	"esnext.typed-array.find-last-index": {
  },
  	"esnext.typed-array.unique-by": {
  },
  	"esnext.weak-map.delete-all": {
  },
  	"esnext.weak-map.from": {
  },
  	"esnext.weak-map.of": {
  },
  	"esnext.weak-map.emplace": {
  },
  	"esnext.weak-map.upsert": {
  },
  	"esnext.weak-set.add-all": {
  },
  	"esnext.weak-set.delete-all": {
  },
  	"esnext.weak-set.from": {
  },
  	"esnext.weak-set.of": {
  },
  	"web.dom-collections.for-each": {
  	android: "58",
  	chrome: "58",
  	edge: "16",
  	electron: "1.7",
  	firefox: "50",
  	ios: "10.0",
  	node: "0.0.1",
  	opera: "45",
  	opera_mobile: "43",
  	rhino: "1.7.13",
  	safari: "10.0",
  	samsung: "7.0"
  },
  	"web.dom-collections.iterator": {
  	android: "66",
  	chrome: "66",
  	edge: "74",
  	electron: "3.0",
  	firefox: "60",
  	ios: "13.4",
  	node: "0.0.1",
  	opera: "53",
  	opera_mobile: "47",
  	rhino: "1.7.13",
  	safari: "13.1",
  	samsung: "9.0"
  },
  	"web.immediate": {
  	ie: "10",
  	node: "0.9.1"
  },
  	"web.queue-microtask": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "69",
  	ios: "12.2",
  	node: "12.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "12.1",
  	samsung: "10.0"
  },
  	"web.timers": {
  	android: "1.5",
  	chrome: "1",
  	edge: "12",
  	electron: "0.20",
  	firefox: "1",
  	ie: "10",
  	ios: "1.0",
  	node: "0.0.1",
  	opera: "7",
  	opera_mobile: "7",
  	phantom: "1.9",
  	rhino: "1.7.13",
  	safari: "1.0",
  	samsung: "1.0"
  },
  	"web.url": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "57",
  	ios: "14.0",
  	node: "10.0",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "14.0",
  	samsung: "9.0"
  },
  	"web.url.to-json": {
  	android: "71",
  	chrome: "71",
  	edge: "74",
  	electron: "5.0",
  	firefox: "57",
  	ios: "14.0",
  	node: "10.0",
  	opera: "58",
  	opera_mobile: "50",
  	safari: "14.0",
  	samsung: "10.0"
  },
  	"web.url-search-params": {
  	android: "67",
  	chrome: "67",
  	edge: "74",
  	electron: "4.0",
  	firefox: "57",
  	ios: "14.0",
  	node: "10.0",
  	opera: "54",
  	opera_mobile: "48",
  	safari: "14.0",
  	samsung: "9.0"
  }
  };

  var data$1 = require$$0$3;

  var debug = typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG) ? function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_console = console).error.apply(_console, ['SEMVER'].concat(args));
  } : function () {};
  var debug_1 = debug;

  var SEMVER_SPEC_VERSION = '2.0.0';
  var MAX_LENGTH$2 = 256;
  var MAX_SAFE_INTEGER$1 = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var constants = {
    SEMVER_SPEC_VERSION: SEMVER_SPEC_VERSION,
    MAX_LENGTH: MAX_LENGTH$2,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER$1,
    MAX_SAFE_COMPONENT_LENGTH: MAX_SAFE_COMPONENT_LENGTH
  };

  var re_1 = createCommonjsModule(function (module, exports) {
    var MAX_SAFE_COMPONENT_LENGTH = constants.MAX_SAFE_COMPONENT_LENGTH;
    exports = module.exports = {};
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;

    var createToken = function createToken(name, value, isGlobal) {
      var index = R++;
      debug_1(index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    };

    createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
    createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+');
    createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*');
    createToken('MAINVERSION', "(" + src[t.NUMERICIDENTIFIER] + ")\\." + ("(" + src[t.NUMERICIDENTIFIER] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIER] + ")"));
    createToken('MAINVERSIONLOOSE', "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\." + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.") + ("(" + src[t.NUMERICIDENTIFIERLOOSE] + ")"));
    createToken('PRERELEASEIDENTIFIER', "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASEIDENTIFIERLOOSE', "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")");
    createToken('PRERELEASE', "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))");
    createToken('PRERELEASELOOSE', "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))");
    createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+');
    createToken('BUILD', "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))");
    createToken('FULLPLAIN', "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?");
    createToken('FULL', "^" + src[t.FULLPLAIN] + "$");
    createToken('LOOSEPLAIN', "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?");
    createToken('LOOSE', "^" + src[t.LOOSEPLAIN] + "$");
    createToken('GTLT', '((?:<|>)?=?)');
    createToken('XRANGEIDENTIFIERLOOSE', src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*");
    createToken('XRANGEIDENTIFIER', src[t.NUMERICIDENTIFIER] + "|x|X|\\*");
    createToken('XRANGEPLAIN', "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")") + ("(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGEPLAINLOOSE', "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")" + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")") + ("(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?") + ")?)?");
    createToken('XRANGE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$");
    createToken('XRANGELOOSE', "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COERCE', "" + ('(^|[^\\d])' + '(\\d{1,') + MAX_SAFE_COMPONENT_LENGTH + "})" + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + ("(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?") + "(?:$|[^\\d])");
    createToken('COERCERTL', src[t.COERCE], true);
    createToken('LONETILDE', '(?:~>?)');
    createToken('TILDETRIM', "(\\s*)" + src[t.LONETILDE] + "\\s+", true);
    exports.tildeTrimReplace = '$1~';
    createToken('TILDE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$");
    createToken('TILDELOOSE', "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('LONECARET', '(?:\\^)');
    createToken('CARETTRIM', "(\\s*)" + src[t.LONECARET] + "\\s+", true);
    exports.caretTrimReplace = '$1^';
    createToken('CARET', "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$");
    createToken('CARETLOOSE', "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$");
    createToken('COMPARATORLOOSE', "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$");
    createToken('COMPARATOR', "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$");
    createToken('COMPARATORTRIM', "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")", true);
    exports.comparatorTrimReplace = '$1$2$3';
    createToken('HYPHENRANGE', "^\\s*(" + src[t.XRANGEPLAIN] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAIN] + ")") + "\\s*$");
    createToken('HYPHENRANGELOOSE', "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")" + "\\s+-\\s+" + ("(" + src[t.XRANGEPLAINLOOSE] + ")") + "\\s*$");
    createToken('STAR', '(<|>)?=?\\s*\\*');
  }, "/$$rollup_base$$/node_modules/core-js-compat/node_modules/semver/internal");

  var numeric = /^[0-9]+$/;

  var compareIdentifiers$1 = function compareIdentifiers(a, b) {
    var anum = numeric.test(a);
    var bnum = numeric.test(b);

    if (anum && bnum) {
      a = +a;
      b = +b;
    }

    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };

  var rcompareIdentifiers = function rcompareIdentifiers(a, b) {
    return compareIdentifiers$1(b, a);
  };

  var identifiers = {
    compareIdentifiers: compareIdentifiers$1,
    rcompareIdentifiers: rcompareIdentifiers
  };

  var MAX_LENGTH$1 = constants.MAX_LENGTH,
      MAX_SAFE_INTEGER = constants.MAX_SAFE_INTEGER;
  var re$2 = re_1.re,
      t$7 = re_1.t;
  var compareIdentifiers = identifiers.compareIdentifiers;

  var SemVer = function () {
    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError("Invalid Version: " + version);
      }

      if (version.length > MAX_LENGTH$1) {
        throw new TypeError("version is longer than " + MAX_LENGTH$1 + " characters");
      }

      debug_1('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      var m = version.trim().match(options.loose ? re$2[t$7.LOOSE] : re$2[t$7.FULL]);

      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    var _proto = SemVer.prototype;

    _proto.format = function format() {
      this.version = this.major + "." + this.minor + "." + this.patch;

      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join('.');
      }

      return this.version;
    };

    _proto.toString = function toString() {
      return this.version;
    };

    _proto.compare = function compare(other) {
      debug_1('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        if (typeof other === 'string' && other === this.version) {
          return 0;
        }

        other = new SemVer(other, this.options);
      }

      if (other.version === this.version) {
        return 0;
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    _proto.compareMain = function compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    _proto.comparePre = function comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    _proto.compareBuild = function compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug_1('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    _proto.inc = function inc(release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error("invalid increment argument: " + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    return SemVer;
  }();

  var semver$2 = SemVer;

  var compare$2 = function compare(a, b, loose) {
    return new semver$2(a, loose).compare(new semver$2(b, loose));
  };

  var compare_1 = compare$2;

  var eq = function eq(a, b, loose) {
    return compare_1(a, b, loose) === 0;
  };

  var eq_1 = eq;

  var neq = function neq(a, b, loose) {
    return compare_1(a, b, loose) !== 0;
  };

  var neq_1 = neq;

  var gt = function gt(a, b, loose) {
    return compare_1(a, b, loose) > 0;
  };

  var gt_1 = gt;

  var gte = function gte(a, b, loose) {
    return compare_1(a, b, loose) >= 0;
  };

  var gte_1 = gte;

  var lt = function lt(a, b, loose) {
    return compare_1(a, b, loose) < 0;
  };

  var lt_1 = lt;

  var lte = function lte(a, b, loose) {
    return compare_1(a, b, loose) <= 0;
  };

  var lte_1 = lte;

  var cmp = function cmp(a, op, b, loose) {
    switch (op) {
      case '===':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a === b;

      case '!==':
        if (typeof a === 'object') a = a.version;
        if (typeof b === 'object') b = b.version;
        return a !== b;

      case '':
      case '=':
      case '==':
        return eq_1(a, b, loose);

      case '!=':
        return neq_1(a, b, loose);

      case '>':
        return gt_1(a, b, loose);

      case '>=':
        return gte_1(a, b, loose);

      case '<':
        return lt_1(a, b, loose);

      case '<=':
        return lte_1(a, b, loose);

      default:
        throw new TypeError("Invalid operator: " + op);
    }
  };

  var cmp_1 = cmp;

  var MAX_LENGTH = constants.MAX_LENGTH;
  var re$1 = re_1.re,
      t$6 = re_1.t;

  var parse = function parse(version, options) {
    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false
      };
    }

    if (version instanceof semver$2) {
      return version;
    }

    if (typeof version !== 'string') {
      return null;
    }

    if (version.length > MAX_LENGTH) {
      return null;
    }

    var r = options.loose ? re$1[t$6.LOOSE] : re$1[t$6.FULL];

    if (!r.test(version)) {
      return null;
    }

    try {
      return new semver$2(version, options);
    } catch (er) {
      return null;
    }
  };

  var parse_1 = parse;

  var re = re_1.re,
      t$5 = re_1.t;

  var coerce = function coerce(version, options) {
    if (version instanceof semver$2) {
      return version;
    }

    if (typeof version === 'number') {
      version = String(version);
    }

    if (typeof version !== 'string') {
      return null;
    }

    options = options || {};
    var match = null;

    if (!options.rtl) {
      match = version.match(re[t$5.COERCE]);
    } else {
      var next;

      while ((next = re[t$5.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }

        re[t$5.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
      }

      re[t$5.COERCERTL].lastIndex = -1;
    }

    if (match === null) return null;
    return parse_1(match[2] + "." + (match[3] || '0') + "." + (match[4] || '0'), options);
  };

  var coerce_1 = coerce;

  var has$4 = Function.call.bind({}.hasOwnProperty);

  function compare$1(a, operator, b) {
    return cmp_1(coerce_1(a), operator, coerce_1(b));
  }

  function intersection$2(list, order) {
    var set = list instanceof Set ? list : new Set(list);
    return order.filter(function (name) {
      return set.has(name);
    });
  }

  function sortObjectByKey(object, fn) {
    return Object.keys(object).sort(fn).reduce(function (memo, key) {
      memo[key] = object[key];
      return memo;
    }, {});
  }

  var helpers = {
    compare: compare$1,
    has: has$4,
    intersection: intersection$2,
    semver: coerce_1,
    sortObjectByKey: sortObjectByKey
  };

  var modulesByVersions = {
  	"3.0": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.now",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.map.delete-all",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.dispose",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"3.1": [
  	"es.string.match-all",
  	"es.symbol.match-all",
  	"esnext.symbol.replace-all"
  ],
  	"3.2": [
  	"es.promise.all-settled",
  	"esnext.array.is-template-object",
  	"esnext.map.update-or-insert",
  	"esnext.symbol.async-dispose"
  ],
  	"3.3": [
  	"es.global-this",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.upsert",
  	"esnext.weak-map.upsert"
  ],
  	"3.4": [
  	"es.json.stringify"
  ],
  	"3.5": [
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"3.6": [
  	"es.regexp.sticky",
  	"es.regexp.test"
  ],
  	"3.7": [
  	"es.aggregate-error",
  	"es.promise.any",
  	"es.reflect.to-string-tag",
  	"es.string.replace-all",
  	"esnext.map.emplace",
  	"esnext.weak-map.emplace"
  ],
  	"3.8": [
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.unique-by",
  	"esnext.bigint.range",
  	"esnext.number.range",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out"
  ],
  	"3.9": [
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by"
  ],
  	"3.11": [
  	"esnext.object.has-own"
  ],
  	"3.12": [
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata"
  ],
  	"3.15": [
  	"es.date.get-year",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.escape",
  	"es.regexp.dot-all",
  	"es.string.substr",
  	"es.unescape"
  ]
  };

  var modules = [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.escape",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.unescape",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ];

  var compare = helpers.compare,
      intersection$1 = helpers.intersection,
      semver$1 = helpers.semver;

  var getModulesListForTargetVersion$2 = function getModulesListForTargetVersion(raw) {
    var corejs = semver$1(raw);

    if (corejs.major !== 3) {
      throw RangeError('This version of `core-js-compat` works only with `core-js@3`.');
    }

    var result = [];

    for (var _i = 0, _Object$keys = Object.keys(modulesByVersions); _i < _Object$keys.length; _i++) {
      var version = _Object$keys[_i];

      if (compare(version, '<=', corejs)) {
        result.push.apply(result, _toConsumableArray(modulesByVersions[version]));
      }
    }

    return intersection$1(result, modules);
  };

  var getModulesListForTargetVersion$1 = getModulesListForTargetVersion$2;

  var require$$0$2 = {
  	"core-js": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.escape",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.unescape",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/es": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.escape",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.unescape",
  	"es.weak-map",
  	"es.weak-set"
  ],
  	"core-js/es/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.string.iterator"
  ],
  	"core-js/es/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/es/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/es/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/es/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/es/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/every": [
  	"es.array.every"
  ],
  	"core-js/es/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/array/find": [
  	"es.array.find"
  ],
  	"core-js/es/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/es/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/es/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/es/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/join": [
  	"es.array.join"
  ],
  	"core-js/es/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/array/map": [
  	"es.array.map"
  ],
  	"core-js/es/array/of": [
  	"es.array.of"
  ],
  	"core-js/es/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/array/some": [
  	"es.array.some"
  ],
  	"core-js/es/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/es/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/array/virtual/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/es/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/es/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/es/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/es/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/es/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/es/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/es/date": [
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/es/date/get-year": [
  	"es.date.get-year"
  ],
  	"core-js/es/date/now": [
  	"es.date.now"
  ],
  	"core-js/es/date/set-year": [
  	"es.date.set-year"
  ],
  	"core-js/es/date/to-gmt-string": [
  	"es.date.to-gmt-string"
  ],
  	"core-js/es/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/es/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/es/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/es/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/es/escape": [
  	"es.escape"
  ],
  	"core-js/es/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/es/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/es/function/name": [
  	"es.function.name"
  ],
  	"core-js/es/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/es/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/global-this": [
  	"es.global-this"
  ],
  	"core-js/es/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/es/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/es/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/es/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/instance/entries": [
  	"es.array.iterator"
  ],
  	"core-js/es/instance/every": [
  	"es.array.every"
  ],
  	"core-js/es/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/es/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/es/instance/find": [
  	"es.array.find"
  ],
  	"core-js/es/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/es/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/es/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/es/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/es/instance/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/es/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/es/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/es/instance/keys": [
  	"es.array.iterator"
  ],
  	"core-js/es/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/es/instance/map": [
  	"es.array.map"
  ],
  	"core-js/es/instance/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/es/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/es/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/es/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/es/instance/some": [
  	"es.array.some"
  ],
  	"core-js/es/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/es/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/es/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/instance/values": [
  	"es.array.iterator"
  ],
  	"core-js/es/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/es/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/es/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/es/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc"
  ],
  	"core-js/es/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/es/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/es/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/es/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/es/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/es/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/es/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/es/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/es/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/es/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/es/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/es/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/es/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/es/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/es/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/es/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/es/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/es/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/es/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/es/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/es/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/es/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/es/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/es/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/es/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/es/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/es/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/es/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/es/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/es/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/es/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/es/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/es/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/es/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/es/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/es/object/create": [
  	"es.object.create"
  ],
  	"core-js/es/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/es/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/es/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/es/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/es/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/es/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/es/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/es/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/es/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/es/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/es/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/es/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/es/object/is": [
  	"es.object.is"
  ],
  	"core-js/es/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/es/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/es/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/es/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/es/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/es/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/es/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/es/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/es/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/es/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/object/values": [
  	"es.object.values"
  ],
  	"core-js/es/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/es/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/es/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/es/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/es/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/es/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/es/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/es/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/es/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/es/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/es/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/es/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/es/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/es/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/es/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/es/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/es/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/es/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/es/regexp/dot-all": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec"
  ],
  	"core-js/es/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/es/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/es/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/es/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/es/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/es/regexp/sticky": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.sticky"
  ],
  	"core-js/es/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/es/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/es/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/es/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/es/string/big": [
  	"es.string.big"
  ],
  	"core-js/es/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/es/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/es/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/es/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/es/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/es/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/es/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/es/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/es/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/es/string/link": [
  	"es.string.link"
  ],
  	"core-js/es/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/es/string/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/es/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/es/string/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/es/string/small": [
  	"es.string.small"
  ],
  	"core-js/es/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/es/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/es/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/es/string/substr": [
  	"es.string.substr"
  ],
  	"core-js/es/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/es/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/es/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/es/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/es/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/es/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/es/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/es/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/es/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/es/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/es/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/es/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/es/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/es/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/es/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/es/string/virtual/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/es/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/es/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/es/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/es/string/virtual/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/es/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/es/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/es/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/es/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/es/string/virtual/substr": [
  	"es.string.substr"
  ],
  	"core-js/es/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/es/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/es/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/es/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/es/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/es/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/es/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/es/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/es/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/es/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/es/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/es/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/es/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/es/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/es/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/es/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/es/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/es/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/es/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/es/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/es/typed-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/es/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/es/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/es/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/es/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/es/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/es/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/es/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/es/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/es/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/es/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/es/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/es/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/es/typed-array/methods": [
  	"es.object.to-string",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/es/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/es/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/es/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/es/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/es/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/es/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/es/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/es/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/es/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/es/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/es/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/es/unescape": [
  	"es.unescape"
  ],
  	"core-js/es/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/es/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.escape",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.unescape",
  	"es.weak-map",
  	"es.weak-set",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/features/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.map",
  	"es.string.iterator",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/features/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/features/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/features/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/features/array/at": [
  	"esnext.array.at"
  ],
  	"core-js/features/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/every": [
  	"es.array.every"
  ],
  	"core-js/features/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/array/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/array/find": [
  	"es.array.find"
  ],
  	"core-js/features/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/array/find-last": [
  	"esnext.array.find-last"
  ],
  	"core-js/features/array/find-last-index": [
  	"esnext.array.find-last-index"
  ],
  	"core-js/features/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/features/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/features/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/features/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/features/array/is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/features/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/join": [
  	"es.array.join"
  ],
  	"core-js/features/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/last-index": [
  	"esnext.array.last-index"
  ],
  	"core-js/features/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/array/last-item": [
  	"esnext.array.last-item"
  ],
  	"core-js/features/array/map": [
  	"es.array.map"
  ],
  	"core-js/features/array/of": [
  	"es.array.of"
  ],
  	"core-js/features/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/array/some": [
  	"es.array.some"
  ],
  	"core-js/features/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/array/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.map",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/virtual/at": [
  	"esnext.array.at"
  ],
  	"core-js/features/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/features/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/array/virtual/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/features/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/array/virtual/find-last": [
  	"esnext.array.find-last"
  ],
  	"core-js/features/array/virtual/find-last-index": [
  	"esnext.array.find-last-index"
  ],
  	"core-js/features/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/features/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/features/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/features/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/features/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/features/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/features/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/array/virtual/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/features/async-iterator": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/as-indexed-pairs": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/drop": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.drop",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/every": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.every",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/filter": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.filter",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/find": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.find",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/flat-map": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.flat-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/for-each": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/from": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/map": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/reduce": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.reduce",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/some": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.some",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/take": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.take",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/async-iterator/to-array": [
  	"es.object.to-string",
  	"es.promise",
  	"es.string.iterator",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/bigint": [
  	"esnext.bigint.range"
  ],
  	"core-js/features/bigint/range": [
  	"esnext.bigint.range"
  ],
  	"core-js/features/clear-immediate": [
  	"web.immediate"
  ],
  	"core-js/features/composite-key": [
  	"esnext.composite-key"
  ],
  	"core-js/features/composite-symbol": [
  	"es.symbol",
  	"esnext.composite-symbol"
  ],
  	"core-js/features/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/features/date": [
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/features/date/get-year": [
  	"es.date.get-year"
  ],
  	"core-js/features/date/now": [
  	"es.date.now"
  ],
  	"core-js/features/date/set-year": [
  	"es.date.set-year"
  ],
  	"core-js/features/date/to-gmt-string": [
  	"es.date.to-gmt-string"
  ],
  	"core-js/features/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/features/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/features/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/features/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/features/dom-collections": [
  	"es.array.iterator",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/dom-collections/for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/features/dom-collections/iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/escape": [
  	"es.escape"
  ],
  	"core-js/features/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/features/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/features/function/name": [
  	"es.function.name"
  ],
  	"core-js/features/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/features/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/get-iterator": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/get-iterator-method": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/global-this": [
  	"es.global-this",
  	"esnext.global-this"
  ],
  	"core-js/features/instance/at": [
  	"esnext.array.at",
  	"esnext.string.at"
  ],
  	"core-js/features/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/features/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/instance/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/features/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/features/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/instance/entries": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/every": [
  	"es.array.every"
  ],
  	"core-js/features/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/features/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/features/instance/filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/features/instance/find": [
  	"es.array.find"
  ],
  	"core-js/features/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/features/instance/find-last": [
  	"esnext.array.find-last"
  ],
  	"core-js/features/instance/find-last-index": [
  	"esnext.array.find-last-index"
  ],
  	"core-js/features/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/features/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/features/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/features/instance/for-each": [
  	"es.array.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/features/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/features/instance/keys": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/features/instance/map": [
  	"es.array.map"
  ],
  	"core-js/features/instance/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/features/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/features/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/features/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/features/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/features/instance/some": [
  	"es.array.some"
  ],
  	"core-js/features/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/features/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/features/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/instance/unique-by": [
  	"es.map",
  	"esnext.array.unique-by"
  ],
  	"core-js/features/instance/values": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/is-iterable": [
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/as-indexed-pairs": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/drop": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.drop",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/every": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.every",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/filter": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.filter",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/find": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.find",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/flat-map": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.flat-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/for-each": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/from": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/map": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/reduce": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.reduce",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/some": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.some",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/take": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.take",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/iterator/to-array": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.iterator.constructor",
  	"esnext.iterator.to-array",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/features/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/features/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/features/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/delete-all": [
  	"es.map",
  	"esnext.map.delete-all"
  ],
  	"core-js/features/map/emplace": [
  	"es.map",
  	"esnext.map.emplace"
  ],
  	"core-js/features/map/every": [
  	"es.map",
  	"esnext.map.every"
  ],
  	"core-js/features/map/filter": [
  	"es.map",
  	"esnext.map.filter"
  ],
  	"core-js/features/map/find": [
  	"es.map",
  	"esnext.map.find"
  ],
  	"core-js/features/map/find-key": [
  	"es.map",
  	"esnext.map.find-key"
  ],
  	"core-js/features/map/from": [
  	"es.map",
  	"es.string.iterator",
  	"esnext.map.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/group-by": [
  	"es.map",
  	"esnext.map.group-by"
  ],
  	"core-js/features/map/includes": [
  	"es.map",
  	"esnext.map.includes"
  ],
  	"core-js/features/map/key-by": [
  	"es.map",
  	"esnext.map.key-by"
  ],
  	"core-js/features/map/key-of": [
  	"es.map",
  	"esnext.map.key-of"
  ],
  	"core-js/features/map/map-keys": [
  	"es.map",
  	"esnext.map.map-keys"
  ],
  	"core-js/features/map/map-values": [
  	"es.map",
  	"esnext.map.map-values"
  ],
  	"core-js/features/map/merge": [
  	"es.map",
  	"esnext.map.merge"
  ],
  	"core-js/features/map/of": [
  	"es.map",
  	"es.string.iterator",
  	"esnext.map.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/map/reduce": [
  	"es.map",
  	"esnext.map.reduce"
  ],
  	"core-js/features/map/some": [
  	"es.map",
  	"esnext.map.some"
  ],
  	"core-js/features/map/update": [
  	"es.map",
  	"esnext.map.update"
  ],
  	"core-js/features/map/update-or-insert": [
  	"es.map",
  	"esnext.map.update-or-insert"
  ],
  	"core-js/features/map/upsert": [
  	"es.map",
  	"esnext.map.upsert"
  ],
  	"core-js/features/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh"
  ],
  	"core-js/features/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/features/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/features/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/features/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/features/math/clamp": [
  	"esnext.math.clamp"
  ],
  	"core-js/features/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/features/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/features/math/deg-per-rad": [
  	"esnext.math.deg-per-rad"
  ],
  	"core-js/features/math/degrees": [
  	"esnext.math.degrees"
  ],
  	"core-js/features/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/features/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/features/math/fscale": [
  	"esnext.math.fscale"
  ],
  	"core-js/features/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/features/math/iaddh": [
  	"esnext.math.iaddh"
  ],
  	"core-js/features/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/features/math/imulh": [
  	"esnext.math.imulh"
  ],
  	"core-js/features/math/isubh": [
  	"esnext.math.isubh"
  ],
  	"core-js/features/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/features/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/features/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/features/math/rad-per-deg": [
  	"esnext.math.rad-per-deg"
  ],
  	"core-js/features/math/radians": [
  	"esnext.math.radians"
  ],
  	"core-js/features/math/scale": [
  	"esnext.math.scale"
  ],
  	"core-js/features/math/seeded-prng": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/features/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/features/math/signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/features/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/features/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/features/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/features/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/features/math/umulh": [
  	"esnext.math.umulh"
  ],
  	"core-js/features/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"esnext.number.from-string",
  	"esnext.number.range"
  ],
  	"core-js/features/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/features/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/features/number/from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/features/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/features/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/features/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/features/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/features/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/features/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/features/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/features/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/features/number/range": [
  	"esnext.number.range"
  ],
  	"core-js/features/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/features/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/features/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/features/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/features/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/features/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"core-js/features/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/features/object/create": [
  	"es.object.create"
  ],
  	"core-js/features/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/features/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/features/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/features/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/features/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/features/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/features/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/features/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/features/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/features/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/features/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/features/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/features/object/has-own": [
  	"esnext.object.has-own"
  ],
  	"core-js/features/object/is": [
  	"es.object.is"
  ],
  	"core-js/features/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/features/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/features/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/features/object/iterate-entries": [
  	"esnext.object.iterate-entries"
  ],
  	"core-js/features/object/iterate-keys": [
  	"esnext.object.iterate-keys"
  ],
  	"core-js/features/object/iterate-values": [
  	"esnext.object.iterate-values"
  ],
  	"core-js/features/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/features/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/features/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/features/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/features/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/features/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/features/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/object/values": [
  	"es.object.values"
  ],
  	"core-js/features/observable": [
  	"es.object.to-string",
  	"es.string.iterator",
  	"esnext.observable",
  	"esnext.symbol.observable",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/features/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/features/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled",
  	"es.string.iterator",
  	"esnext.promise.all-settled",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"esnext.promise.any",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/features/promise/try": [
  	"es.promise",
  	"esnext.promise.try"
  ],
  	"core-js/features/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/features/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata"
  ],
  	"core-js/features/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/features/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/features/reflect/define-metadata": [
  	"esnext.reflect.define-metadata"
  ],
  	"core-js/features/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/features/reflect/delete-metadata": [
  	"esnext.reflect.delete-metadata"
  ],
  	"core-js/features/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/features/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/features/reflect/get-metadata": [
  	"esnext.reflect.get-metadata"
  ],
  	"core-js/features/reflect/get-metadata-keys": [
  	"esnext.reflect.get-metadata-keys"
  ],
  	"core-js/features/reflect/get-own-metadata": [
  	"esnext.reflect.get-own-metadata"
  ],
  	"core-js/features/reflect/get-own-metadata-keys": [
  	"esnext.reflect.get-own-metadata-keys"
  ],
  	"core-js/features/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/features/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/features/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/features/reflect/has-metadata": [
  	"esnext.reflect.has-metadata"
  ],
  	"core-js/features/reflect/has-own-metadata": [
  	"esnext.reflect.has-own-metadata"
  ],
  	"core-js/features/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/features/reflect/metadata": [
  	"esnext.reflect.metadata"
  ],
  	"core-js/features/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/features/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/features/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/features/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/features/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/features/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/features/regexp/dot-all": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec"
  ],
  	"core-js/features/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/features/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/features/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/features/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/features/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/features/regexp/sticky": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.sticky"
  ],
  	"core-js/features/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/features/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/features/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set-immediate": [
  	"web.immediate"
  ],
  	"core-js/features/set-interval": [
  	"web.timers"
  ],
  	"core-js/features/set-timeout": [
  	"web.timers"
  ],
  	"core-js/features/set/add-all": [
  	"es.set",
  	"esnext.set.add-all"
  ],
  	"core-js/features/set/delete-all": [
  	"es.set",
  	"esnext.set.delete-all"
  ],
  	"core-js/features/set/difference": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.difference",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/every": [
  	"es.set",
  	"esnext.set.every"
  ],
  	"core-js/features/set/filter": [
  	"es.set",
  	"esnext.set.filter"
  ],
  	"core-js/features/set/find": [
  	"es.set",
  	"esnext.set.find"
  ],
  	"core-js/features/set/from": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/intersection": [
  	"es.set",
  	"esnext.set.intersection"
  ],
  	"core-js/features/set/is-disjoint-from": [
  	"es.set",
  	"esnext.set.is-disjoint-from"
  ],
  	"core-js/features/set/is-subset-of": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.is-subset-of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/is-superset-of": [
  	"es.set",
  	"esnext.set.is-superset-of"
  ],
  	"core-js/features/set/join": [
  	"es.set",
  	"esnext.set.join"
  ],
  	"core-js/features/set/map": [
  	"es.set",
  	"esnext.set.map"
  ],
  	"core-js/features/set/of": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/reduce": [
  	"es.set",
  	"esnext.set.reduce"
  ],
  	"core-js/features/set/some": [
  	"es.set",
  	"esnext.set.some"
  ],
  	"core-js/features/set/symmetric-difference": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.symmetric-difference",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/set/union": [
  	"es.set",
  	"es.string.iterator",
  	"esnext.set.union",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/features/string/at": [
  	"esnext.string.at"
  ],
  	"core-js/features/string/big": [
  	"es.string.big"
  ],
  	"core-js/features/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/features/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/features/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/string/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/features/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/features/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/features/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/features/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/features/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/features/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/features/string/link": [
  	"es.string.link"
  ],
  	"core-js/features/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/features/string/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/features/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/features/string/replace-all": [
  	"es.string.replace-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/features/string/small": [
  	"es.string.small"
  ],
  	"core-js/features/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/features/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/features/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/features/string/substr": [
  	"es.string.substr"
  ],
  	"core-js/features/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/features/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/features/string/virtual/at": [
  	"esnext.string.at"
  ],
  	"core-js/features/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/features/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/features/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/features/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/features/string/virtual/code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/features/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/features/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/features/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/features/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/features/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/features/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/features/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/features/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/features/string/virtual/match-all": [
  	"es.string.match-all",
  	"esnext.string.match-all"
  ],
  	"core-js/features/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/features/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/features/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/features/string/virtual/replace-all": [
  	"es.string.replace-all",
  	"esnext.string.replace-all"
  ],
  	"core-js/features/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/features/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/features/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/features/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/features/string/virtual/substr": [
  	"es.string.substr"
  ],
  	"core-js/features/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/features/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/features/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/features/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/features/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/features/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/features/symbol/async-dispose": [
  	"esnext.symbol.async-dispose"
  ],
  	"core-js/features/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/features/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/features/symbol/dispose": [
  	"esnext.symbol.dispose"
  ],
  	"core-js/features/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/features/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/features/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/features/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/features/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/features/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/features/symbol/matcher": [
  	"esnext.symbol.matcher"
  ],
  	"core-js/features/symbol/metadata": [
  	"esnext.symbol.metadata"
  ],
  	"core-js/features/symbol/observable": [
  	"esnext.symbol.observable"
  ],
  	"core-js/features/symbol/pattern-match": [
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/features/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/features/symbol/replace-all": [
  	"esnext.symbol.replace-all"
  ],
  	"core-js/features/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/features/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/features/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/features/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/features/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/features/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/features/typed-array": [
  	"es.map",
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by"
  ],
  	"core-js/features/typed-array/at": [
  	"esnext.typed-array.at"
  ],
  	"core-js/features/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/features/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/features/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/features/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/features/typed-array/filter-out": [
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/features/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/features/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/features/typed-array/find-last": [
  	"esnext.typed-array.find-last"
  ],
  	"core-js/features/typed-array/find-last-index": [
  	"esnext.typed-array.find-last-index"
  ],
  	"core-js/features/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/features/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/features/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/features/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/features/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/features/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/features/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/features/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/features/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/features/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/features/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/features/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/features/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/features/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/features/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/features/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/features/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/features/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/features/typed-array/unique-by": [
  	"es.map",
  	"esnext.typed-array.unique-by"
  ],
  	"core-js/features/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/features/unescape": [
  	"es.unescape"
  ],
  	"core-js/features/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/features/url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/features/url/to-json": [
  	"web.url.to-json"
  ],
  	"core-js/features/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/delete-all": [
  	"es.weak-map",
  	"esnext.weak-map.delete-all"
  ],
  	"core-js/features/weak-map/emplace": [
  	"es.weak-map",
  	"esnext.weak-map.emplace"
  ],
  	"core-js/features/weak-map/from": [
  	"es.string.iterator",
  	"es.weak-map",
  	"esnext.weak-map.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/of": [
  	"es.string.iterator",
  	"es.weak-map",
  	"esnext.weak-map.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-map/upsert": [
  	"es.weak-map",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/features/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-set/add-all": [
  	"es.weak-set",
  	"esnext.weak-set.add-all"
  ],
  	"core-js/features/weak-set/delete-all": [
  	"es.weak-set",
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/features/weak-set/from": [
  	"es.string.iterator",
  	"es.weak-set",
  	"esnext.weak-set.from",
  	"web.dom-collections.iterator"
  ],
  	"core-js/features/weak-set/of": [
  	"es.string.iterator",
  	"es.weak-set",
  	"esnext.weak-set.of",
  	"web.dom-collections.iterator"
  ],
  	"core-js/modules/es.aggregate-error": [
  	"es.aggregate-error"
  ],
  	"core-js/modules/es.array-buffer.constructor": [
  	"es.array-buffer.constructor"
  ],
  	"core-js/modules/es.array-buffer.is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/modules/es.array-buffer.slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/modules/es.array.concat": [
  	"es.array.concat"
  ],
  	"core-js/modules/es.array.copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/modules/es.array.every": [
  	"es.array.every"
  ],
  	"core-js/modules/es.array.fill": [
  	"es.array.fill"
  ],
  	"core-js/modules/es.array.filter": [
  	"es.array.filter"
  ],
  	"core-js/modules/es.array.find": [
  	"es.array.find"
  ],
  	"core-js/modules/es.array.find-index": [
  	"es.array.find-index"
  ],
  	"core-js/modules/es.array.flat": [
  	"es.array.flat"
  ],
  	"core-js/modules/es.array.flat-map": [
  	"es.array.flat-map"
  ],
  	"core-js/modules/es.array.for-each": [
  	"es.array.for-each"
  ],
  	"core-js/modules/es.array.from": [
  	"es.array.from"
  ],
  	"core-js/modules/es.array.includes": [
  	"es.array.includes"
  ],
  	"core-js/modules/es.array.index-of": [
  	"es.array.index-of"
  ],
  	"core-js/modules/es.array.is-array": [
  	"es.array.is-array"
  ],
  	"core-js/modules/es.array.iterator": [
  	"es.array.iterator"
  ],
  	"core-js/modules/es.array.join": [
  	"es.array.join"
  ],
  	"core-js/modules/es.array.last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/modules/es.array.map": [
  	"es.array.map"
  ],
  	"core-js/modules/es.array.of": [
  	"es.array.of"
  ],
  	"core-js/modules/es.array.reduce": [
  	"es.array.reduce"
  ],
  	"core-js/modules/es.array.reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/modules/es.array.reverse": [
  	"es.array.reverse"
  ],
  	"core-js/modules/es.array.slice": [
  	"es.array.slice"
  ],
  	"core-js/modules/es.array.some": [
  	"es.array.some"
  ],
  	"core-js/modules/es.array.sort": [
  	"es.array.sort"
  ],
  	"core-js/modules/es.array.species": [
  	"es.array.species"
  ],
  	"core-js/modules/es.array.splice": [
  	"es.array.splice"
  ],
  	"core-js/modules/es.array.unscopables.flat": [
  	"es.array.unscopables.flat"
  ],
  	"core-js/modules/es.array.unscopables.flat-map": [
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/modules/es.data-view": [
  	"es.data-view"
  ],
  	"core-js/modules/es.date.get-year": [
  	"es.date.get-year"
  ],
  	"core-js/modules/es.date.now": [
  	"es.date.now"
  ],
  	"core-js/modules/es.date.set-year": [
  	"es.date.set-year"
  ],
  	"core-js/modules/es.date.to-gmt-string": [
  	"es.date.to-gmt-string"
  ],
  	"core-js/modules/es.date.to-iso-string": [
  	"es.date.to-iso-string"
  ],
  	"core-js/modules/es.date.to-json": [
  	"es.date.to-json"
  ],
  	"core-js/modules/es.date.to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/modules/es.date.to-string": [
  	"es.date.to-string"
  ],
  	"core-js/modules/es.escape": [
  	"es.escape"
  ],
  	"core-js/modules/es.function.bind": [
  	"es.function.bind"
  ],
  	"core-js/modules/es.function.has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/modules/es.function.name": [
  	"es.function.name"
  ],
  	"core-js/modules/es.global-this": [
  	"es.global-this"
  ],
  	"core-js/modules/es.json.stringify": [
  	"es.json.stringify"
  ],
  	"core-js/modules/es.json.to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/modules/es.map": [
  	"es.map"
  ],
  	"core-js/modules/es.math.acosh": [
  	"es.math.acosh"
  ],
  	"core-js/modules/es.math.asinh": [
  	"es.math.asinh"
  ],
  	"core-js/modules/es.math.atanh": [
  	"es.math.atanh"
  ],
  	"core-js/modules/es.math.cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/modules/es.math.clz32": [
  	"es.math.clz32"
  ],
  	"core-js/modules/es.math.cosh": [
  	"es.math.cosh"
  ],
  	"core-js/modules/es.math.expm1": [
  	"es.math.expm1"
  ],
  	"core-js/modules/es.math.fround": [
  	"es.math.fround"
  ],
  	"core-js/modules/es.math.hypot": [
  	"es.math.hypot"
  ],
  	"core-js/modules/es.math.imul": [
  	"es.math.imul"
  ],
  	"core-js/modules/es.math.log10": [
  	"es.math.log10"
  ],
  	"core-js/modules/es.math.log1p": [
  	"es.math.log1p"
  ],
  	"core-js/modules/es.math.log2": [
  	"es.math.log2"
  ],
  	"core-js/modules/es.math.sign": [
  	"es.math.sign"
  ],
  	"core-js/modules/es.math.sinh": [
  	"es.math.sinh"
  ],
  	"core-js/modules/es.math.tanh": [
  	"es.math.tanh"
  ],
  	"core-js/modules/es.math.to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/modules/es.math.trunc": [
  	"es.math.trunc"
  ],
  	"core-js/modules/es.number.constructor": [
  	"es.number.constructor"
  ],
  	"core-js/modules/es.number.epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/modules/es.number.is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/modules/es.number.is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/modules/es.number.is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/modules/es.number.is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/modules/es.number.max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/modules/es.number.min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/modules/es.number.parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/modules/es.number.parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/modules/es.number.to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/modules/es.number.to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/modules/es.object.assign": [
  	"es.object.assign"
  ],
  	"core-js/modules/es.object.create": [
  	"es.object.create"
  ],
  	"core-js/modules/es.object.define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/modules/es.object.define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/modules/es.object.define-property": [
  	"es.object.define-property"
  ],
  	"core-js/modules/es.object.define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/modules/es.object.entries": [
  	"es.object.entries"
  ],
  	"core-js/modules/es.object.freeze": [
  	"es.object.freeze"
  ],
  	"core-js/modules/es.object.from-entries": [
  	"es.object.from-entries"
  ],
  	"core-js/modules/es.object.get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/modules/es.object.get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/modules/es.object.get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/modules/es.object.get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/modules/es.object.is": [
  	"es.object.is"
  ],
  	"core-js/modules/es.object.is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/modules/es.object.is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/modules/es.object.is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/modules/es.object.keys": [
  	"es.object.keys"
  ],
  	"core-js/modules/es.object.lookup-getter": [
  	"es.object.lookup-getter"
  ],
  	"core-js/modules/es.object.lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/modules/es.object.prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/modules/es.object.seal": [
  	"es.object.seal"
  ],
  	"core-js/modules/es.object.set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/modules/es.object.to-string": [
  	"es.object.to-string"
  ],
  	"core-js/modules/es.object.values": [
  	"es.object.values"
  ],
  	"core-js/modules/es.parse-float": [
  	"es.parse-float"
  ],
  	"core-js/modules/es.parse-int": [
  	"es.parse-int"
  ],
  	"core-js/modules/es.promise": [
  	"es.promise"
  ],
  	"core-js/modules/es.promise.all-settled": [
  	"es.promise.all-settled"
  ],
  	"core-js/modules/es.promise.any": [
  	"es.promise.any"
  ],
  	"core-js/modules/es.promise.finally": [
  	"es.promise.finally"
  ],
  	"core-js/modules/es.reflect.apply": [
  	"es.reflect.apply"
  ],
  	"core-js/modules/es.reflect.construct": [
  	"es.reflect.construct"
  ],
  	"core-js/modules/es.reflect.define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/modules/es.reflect.delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/modules/es.reflect.get": [
  	"es.reflect.get"
  ],
  	"core-js/modules/es.reflect.get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/modules/es.reflect.get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/modules/es.reflect.has": [
  	"es.reflect.has"
  ],
  	"core-js/modules/es.reflect.is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/modules/es.reflect.own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/modules/es.reflect.prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/modules/es.reflect.set": [
  	"es.reflect.set"
  ],
  	"core-js/modules/es.reflect.set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/modules/es.reflect.to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/modules/es.regexp.constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/modules/es.regexp.dot-all": [
  	"es.regexp.dot-all"
  ],
  	"core-js/modules/es.regexp.exec": [
  	"es.regexp.exec"
  ],
  	"core-js/modules/es.regexp.flags": [
  	"es.regexp.flags"
  ],
  	"core-js/modules/es.regexp.sticky": [
  	"es.regexp.sticky"
  ],
  	"core-js/modules/es.regexp.test": [
  	"es.regexp.test"
  ],
  	"core-js/modules/es.regexp.to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/modules/es.set": [
  	"es.set"
  ],
  	"core-js/modules/es.string.anchor": [
  	"es.string.anchor"
  ],
  	"core-js/modules/es.string.big": [
  	"es.string.big"
  ],
  	"core-js/modules/es.string.blink": [
  	"es.string.blink"
  ],
  	"core-js/modules/es.string.bold": [
  	"es.string.bold"
  ],
  	"core-js/modules/es.string.code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/modules/es.string.ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/modules/es.string.fixed": [
  	"es.string.fixed"
  ],
  	"core-js/modules/es.string.fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/modules/es.string.fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/modules/es.string.from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/modules/es.string.includes": [
  	"es.string.includes"
  ],
  	"core-js/modules/es.string.italics": [
  	"es.string.italics"
  ],
  	"core-js/modules/es.string.iterator": [
  	"es.string.iterator"
  ],
  	"core-js/modules/es.string.link": [
  	"es.string.link"
  ],
  	"core-js/modules/es.string.match": [
  	"es.string.match"
  ],
  	"core-js/modules/es.string.match-all": [
  	"es.string.match-all"
  ],
  	"core-js/modules/es.string.pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/modules/es.string.pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/modules/es.string.raw": [
  	"es.string.raw"
  ],
  	"core-js/modules/es.string.repeat": [
  	"es.string.repeat"
  ],
  	"core-js/modules/es.string.replace": [
  	"es.string.replace"
  ],
  	"core-js/modules/es.string.replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/modules/es.string.search": [
  	"es.string.search"
  ],
  	"core-js/modules/es.string.small": [
  	"es.string.small"
  ],
  	"core-js/modules/es.string.split": [
  	"es.string.split"
  ],
  	"core-js/modules/es.string.starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/modules/es.string.strike": [
  	"es.string.strike"
  ],
  	"core-js/modules/es.string.sub": [
  	"es.string.sub"
  ],
  	"core-js/modules/es.string.substr": [
  	"es.string.substr"
  ],
  	"core-js/modules/es.string.sup": [
  	"es.string.sup"
  ],
  	"core-js/modules/es.string.trim": [
  	"es.string.trim"
  ],
  	"core-js/modules/es.string.trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/modules/es.string.trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/modules/es.symbol": [
  	"es.symbol"
  ],
  	"core-js/modules/es.symbol.async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/modules/es.symbol.description": [
  	"es.symbol.description"
  ],
  	"core-js/modules/es.symbol.has-instance": [
  	"es.symbol.has-instance"
  ],
  	"core-js/modules/es.symbol.is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable"
  ],
  	"core-js/modules/es.symbol.iterator": [
  	"es.symbol.iterator"
  ],
  	"core-js/modules/es.symbol.match": [
  	"es.symbol.match"
  ],
  	"core-js/modules/es.symbol.match-all": [
  	"es.symbol.match-all"
  ],
  	"core-js/modules/es.symbol.replace": [
  	"es.symbol.replace"
  ],
  	"core-js/modules/es.symbol.search": [
  	"es.symbol.search"
  ],
  	"core-js/modules/es.symbol.species": [
  	"es.symbol.species"
  ],
  	"core-js/modules/es.symbol.split": [
  	"es.symbol.split"
  ],
  	"core-js/modules/es.symbol.to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/modules/es.symbol.to-string-tag": [
  	"es.symbol.to-string-tag"
  ],
  	"core-js/modules/es.symbol.unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/modules/es.typed-array.copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/modules/es.typed-array.every": [
  	"es.typed-array.every"
  ],
  	"core-js/modules/es.typed-array.fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/modules/es.typed-array.filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/modules/es.typed-array.find": [
  	"es.typed-array.find"
  ],
  	"core-js/modules/es.typed-array.find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/modules/es.typed-array.float32-array": [
  	"es.typed-array.float32-array"
  ],
  	"core-js/modules/es.typed-array.float64-array": [
  	"es.typed-array.float64-array"
  ],
  	"core-js/modules/es.typed-array.for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/modules/es.typed-array.from": [
  	"es.typed-array.from"
  ],
  	"core-js/modules/es.typed-array.includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/modules/es.typed-array.index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/modules/es.typed-array.int16-array": [
  	"es.typed-array.int16-array"
  ],
  	"core-js/modules/es.typed-array.int32-array": [
  	"es.typed-array.int32-array"
  ],
  	"core-js/modules/es.typed-array.int8-array": [
  	"es.typed-array.int8-array"
  ],
  	"core-js/modules/es.typed-array.iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/modules/es.typed-array.join": [
  	"es.typed-array.join"
  ],
  	"core-js/modules/es.typed-array.last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/modules/es.typed-array.map": [
  	"es.typed-array.map"
  ],
  	"core-js/modules/es.typed-array.of": [
  	"es.typed-array.of"
  ],
  	"core-js/modules/es.typed-array.reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/modules/es.typed-array.reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/modules/es.typed-array.reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/modules/es.typed-array.set": [
  	"es.typed-array.set"
  ],
  	"core-js/modules/es.typed-array.slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/modules/es.typed-array.some": [
  	"es.typed-array.some"
  ],
  	"core-js/modules/es.typed-array.sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/modules/es.typed-array.subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/modules/es.typed-array.to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/modules/es.typed-array.to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/modules/es.typed-array.uint16-array": [
  	"es.typed-array.uint16-array"
  ],
  	"core-js/modules/es.typed-array.uint32-array": [
  	"es.typed-array.uint32-array"
  ],
  	"core-js/modules/es.typed-array.uint8-array": [
  	"es.typed-array.uint8-array"
  ],
  	"core-js/modules/es.typed-array.uint8-clamped-array": [
  	"es.typed-array.uint8-clamped-array"
  ],
  	"core-js/modules/es.unescape": [
  	"es.unescape"
  ],
  	"core-js/modules/es.weak-map": [
  	"es.weak-map"
  ],
  	"core-js/modules/es.weak-set": [
  	"es.weak-set"
  ],
  	"core-js/modules/esnext.aggregate-error": [
  	"esnext.aggregate-error"
  ],
  	"core-js/modules/esnext.array.at": [
  	"esnext.array.at"
  ],
  	"core-js/modules/esnext.array.filter-out": [
  	"esnext.array.filter-out"
  ],
  	"core-js/modules/esnext.array.find-last": [
  	"esnext.array.find-last"
  ],
  	"core-js/modules/esnext.array.find-last-index": [
  	"esnext.array.find-last-index"
  ],
  	"core-js/modules/esnext.array.is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/modules/esnext.array.last-index": [
  	"esnext.array.last-index"
  ],
  	"core-js/modules/esnext.array.last-item": [
  	"esnext.array.last-item"
  ],
  	"core-js/modules/esnext.array.unique-by": [
  	"esnext.array.unique-by"
  ],
  	"core-js/modules/esnext.async-iterator.as-indexed-pairs": [
  	"esnext.async-iterator.as-indexed-pairs"
  ],
  	"core-js/modules/esnext.async-iterator.constructor": [
  	"esnext.async-iterator.constructor"
  ],
  	"core-js/modules/esnext.async-iterator.drop": [
  	"esnext.async-iterator.drop"
  ],
  	"core-js/modules/esnext.async-iterator.every": [
  	"esnext.async-iterator.every"
  ],
  	"core-js/modules/esnext.async-iterator.filter": [
  	"esnext.async-iterator.filter"
  ],
  	"core-js/modules/esnext.async-iterator.find": [
  	"esnext.async-iterator.find"
  ],
  	"core-js/modules/esnext.async-iterator.flat-map": [
  	"esnext.async-iterator.flat-map"
  ],
  	"core-js/modules/esnext.async-iterator.for-each": [
  	"esnext.async-iterator.for-each"
  ],
  	"core-js/modules/esnext.async-iterator.from": [
  	"esnext.async-iterator.from"
  ],
  	"core-js/modules/esnext.async-iterator.map": [
  	"esnext.async-iterator.map"
  ],
  	"core-js/modules/esnext.async-iterator.reduce": [
  	"esnext.async-iterator.reduce"
  ],
  	"core-js/modules/esnext.async-iterator.some": [
  	"esnext.async-iterator.some"
  ],
  	"core-js/modules/esnext.async-iterator.take": [
  	"esnext.async-iterator.take"
  ],
  	"core-js/modules/esnext.async-iterator.to-array": [
  	"esnext.async-iterator.to-array"
  ],
  	"core-js/modules/esnext.bigint.range": [
  	"esnext.bigint.range"
  ],
  	"core-js/modules/esnext.composite-key": [
  	"esnext.composite-key"
  ],
  	"core-js/modules/esnext.composite-symbol": [
  	"esnext.composite-symbol"
  ],
  	"core-js/modules/esnext.global-this": [
  	"esnext.global-this"
  ],
  	"core-js/modules/esnext.iterator.as-indexed-pairs": [
  	"esnext.iterator.as-indexed-pairs"
  ],
  	"core-js/modules/esnext.iterator.constructor": [
  	"esnext.iterator.constructor"
  ],
  	"core-js/modules/esnext.iterator.drop": [
  	"esnext.iterator.drop"
  ],
  	"core-js/modules/esnext.iterator.every": [
  	"esnext.iterator.every"
  ],
  	"core-js/modules/esnext.iterator.filter": [
  	"esnext.iterator.filter"
  ],
  	"core-js/modules/esnext.iterator.find": [
  	"esnext.iterator.find"
  ],
  	"core-js/modules/esnext.iterator.flat-map": [
  	"esnext.iterator.flat-map"
  ],
  	"core-js/modules/esnext.iterator.for-each": [
  	"esnext.iterator.for-each"
  ],
  	"core-js/modules/esnext.iterator.from": [
  	"esnext.iterator.from"
  ],
  	"core-js/modules/esnext.iterator.map": [
  	"esnext.iterator.map"
  ],
  	"core-js/modules/esnext.iterator.reduce": [
  	"esnext.iterator.reduce"
  ],
  	"core-js/modules/esnext.iterator.some": [
  	"esnext.iterator.some"
  ],
  	"core-js/modules/esnext.iterator.take": [
  	"esnext.iterator.take"
  ],
  	"core-js/modules/esnext.iterator.to-array": [
  	"esnext.iterator.to-array"
  ],
  	"core-js/modules/esnext.map.delete-all": [
  	"esnext.map.delete-all"
  ],
  	"core-js/modules/esnext.map.emplace": [
  	"esnext.map.emplace"
  ],
  	"core-js/modules/esnext.map.every": [
  	"esnext.map.every"
  ],
  	"core-js/modules/esnext.map.filter": [
  	"esnext.map.filter"
  ],
  	"core-js/modules/esnext.map.find": [
  	"esnext.map.find"
  ],
  	"core-js/modules/esnext.map.find-key": [
  	"esnext.map.find-key"
  ],
  	"core-js/modules/esnext.map.from": [
  	"esnext.map.from"
  ],
  	"core-js/modules/esnext.map.group-by": [
  	"esnext.map.group-by"
  ],
  	"core-js/modules/esnext.map.includes": [
  	"esnext.map.includes"
  ],
  	"core-js/modules/esnext.map.key-by": [
  	"esnext.map.key-by"
  ],
  	"core-js/modules/esnext.map.key-of": [
  	"esnext.map.key-of"
  ],
  	"core-js/modules/esnext.map.map-keys": [
  	"esnext.map.map-keys"
  ],
  	"core-js/modules/esnext.map.map-values": [
  	"esnext.map.map-values"
  ],
  	"core-js/modules/esnext.map.merge": [
  	"esnext.map.merge"
  ],
  	"core-js/modules/esnext.map.of": [
  	"esnext.map.of"
  ],
  	"core-js/modules/esnext.map.reduce": [
  	"esnext.map.reduce"
  ],
  	"core-js/modules/esnext.map.some": [
  	"esnext.map.some"
  ],
  	"core-js/modules/esnext.map.update": [
  	"esnext.map.update"
  ],
  	"core-js/modules/esnext.map.update-or-insert": [
  	"esnext.map.update-or-insert"
  ],
  	"core-js/modules/esnext.map.upsert": [
  	"esnext.map.upsert"
  ],
  	"core-js/modules/esnext.math.clamp": [
  	"esnext.math.clamp"
  ],
  	"core-js/modules/esnext.math.deg-per-rad": [
  	"esnext.math.deg-per-rad"
  ],
  	"core-js/modules/esnext.math.degrees": [
  	"esnext.math.degrees"
  ],
  	"core-js/modules/esnext.math.fscale": [
  	"esnext.math.fscale"
  ],
  	"core-js/modules/esnext.math.iaddh": [
  	"esnext.math.iaddh"
  ],
  	"core-js/modules/esnext.math.imulh": [
  	"esnext.math.imulh"
  ],
  	"core-js/modules/esnext.math.isubh": [
  	"esnext.math.isubh"
  ],
  	"core-js/modules/esnext.math.rad-per-deg": [
  	"esnext.math.rad-per-deg"
  ],
  	"core-js/modules/esnext.math.radians": [
  	"esnext.math.radians"
  ],
  	"core-js/modules/esnext.math.scale": [
  	"esnext.math.scale"
  ],
  	"core-js/modules/esnext.math.seeded-prng": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/modules/esnext.math.signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/modules/esnext.math.umulh": [
  	"esnext.math.umulh"
  ],
  	"core-js/modules/esnext.number.from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/modules/esnext.number.range": [
  	"esnext.number.range"
  ],
  	"core-js/modules/esnext.object.has-own": [
  	"esnext.object.has-own"
  ],
  	"core-js/modules/esnext.object.iterate-entries": [
  	"esnext.object.iterate-entries"
  ],
  	"core-js/modules/esnext.object.iterate-keys": [
  	"esnext.object.iterate-keys"
  ],
  	"core-js/modules/esnext.object.iterate-values": [
  	"esnext.object.iterate-values"
  ],
  	"core-js/modules/esnext.observable": [
  	"esnext.observable"
  ],
  	"core-js/modules/esnext.promise.all-settled": [
  	"esnext.promise.all-settled"
  ],
  	"core-js/modules/esnext.promise.any": [
  	"esnext.promise.any"
  ],
  	"core-js/modules/esnext.promise.try": [
  	"esnext.promise.try"
  ],
  	"core-js/modules/esnext.reflect.define-metadata": [
  	"esnext.reflect.define-metadata"
  ],
  	"core-js/modules/esnext.reflect.delete-metadata": [
  	"esnext.reflect.delete-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-metadata": [
  	"esnext.reflect.get-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-metadata-keys": [
  	"esnext.reflect.get-metadata-keys"
  ],
  	"core-js/modules/esnext.reflect.get-own-metadata": [
  	"esnext.reflect.get-own-metadata"
  ],
  	"core-js/modules/esnext.reflect.get-own-metadata-keys": [
  	"esnext.reflect.get-own-metadata-keys"
  ],
  	"core-js/modules/esnext.reflect.has-metadata": [
  	"esnext.reflect.has-metadata"
  ],
  	"core-js/modules/esnext.reflect.has-own-metadata": [
  	"esnext.reflect.has-own-metadata"
  ],
  	"core-js/modules/esnext.reflect.metadata": [
  	"esnext.reflect.metadata"
  ],
  	"core-js/modules/esnext.set.add-all": [
  	"esnext.set.add-all"
  ],
  	"core-js/modules/esnext.set.delete-all": [
  	"esnext.set.delete-all"
  ],
  	"core-js/modules/esnext.set.difference": [
  	"esnext.set.difference"
  ],
  	"core-js/modules/esnext.set.every": [
  	"esnext.set.every"
  ],
  	"core-js/modules/esnext.set.filter": [
  	"esnext.set.filter"
  ],
  	"core-js/modules/esnext.set.find": [
  	"esnext.set.find"
  ],
  	"core-js/modules/esnext.set.from": [
  	"esnext.set.from"
  ],
  	"core-js/modules/esnext.set.intersection": [
  	"esnext.set.intersection"
  ],
  	"core-js/modules/esnext.set.is-disjoint-from": [
  	"esnext.set.is-disjoint-from"
  ],
  	"core-js/modules/esnext.set.is-subset-of": [
  	"esnext.set.is-subset-of"
  ],
  	"core-js/modules/esnext.set.is-superset-of": [
  	"esnext.set.is-superset-of"
  ],
  	"core-js/modules/esnext.set.join": [
  	"esnext.set.join"
  ],
  	"core-js/modules/esnext.set.map": [
  	"esnext.set.map"
  ],
  	"core-js/modules/esnext.set.of": [
  	"esnext.set.of"
  ],
  	"core-js/modules/esnext.set.reduce": [
  	"esnext.set.reduce"
  ],
  	"core-js/modules/esnext.set.some": [
  	"esnext.set.some"
  ],
  	"core-js/modules/esnext.set.symmetric-difference": [
  	"esnext.set.symmetric-difference"
  ],
  	"core-js/modules/esnext.set.union": [
  	"esnext.set.union"
  ],
  	"core-js/modules/esnext.string.at": [
  	"esnext.string.at"
  ],
  	"core-js/modules/esnext.string.at-alternative": [
  	"esnext.string.at-alternative"
  ],
  	"core-js/modules/esnext.string.code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/modules/esnext.string.match-all": [
  	"esnext.string.match-all"
  ],
  	"core-js/modules/esnext.string.replace-all": [
  	"esnext.string.replace-all"
  ],
  	"core-js/modules/esnext.symbol.async-dispose": [
  	"esnext.symbol.async-dispose"
  ],
  	"core-js/modules/esnext.symbol.dispose": [
  	"esnext.symbol.dispose"
  ],
  	"core-js/modules/esnext.symbol.matcher": [
  	"esnext.symbol.matcher"
  ],
  	"core-js/modules/esnext.symbol.metadata": [
  	"esnext.symbol.metadata"
  ],
  	"core-js/modules/esnext.symbol.observable": [
  	"esnext.symbol.observable"
  ],
  	"core-js/modules/esnext.symbol.pattern-match": [
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/modules/esnext.symbol.replace-all": [
  	"esnext.symbol.replace-all"
  ],
  	"core-js/modules/esnext.typed-array.at": [
  	"esnext.typed-array.at"
  ],
  	"core-js/modules/esnext.typed-array.filter-out": [
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/modules/esnext.typed-array.find-last": [
  	"esnext.typed-array.find-last"
  ],
  	"core-js/modules/esnext.typed-array.find-last-index": [
  	"esnext.typed-array.find-last-index"
  ],
  	"core-js/modules/esnext.typed-array.unique-by": [
  	"esnext.typed-array.unique-by"
  ],
  	"core-js/modules/esnext.weak-map.delete-all": [
  	"esnext.weak-map.delete-all"
  ],
  	"core-js/modules/esnext.weak-map.emplace": [
  	"esnext.weak-map.emplace"
  ],
  	"core-js/modules/esnext.weak-map.from": [
  	"esnext.weak-map.from"
  ],
  	"core-js/modules/esnext.weak-map.of": [
  	"esnext.weak-map.of"
  ],
  	"core-js/modules/esnext.weak-map.upsert": [
  	"esnext.weak-map.upsert"
  ],
  	"core-js/modules/esnext.weak-set.add-all": [
  	"esnext.weak-set.add-all"
  ],
  	"core-js/modules/esnext.weak-set.delete-all": [
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/modules/esnext.weak-set.from": [
  	"esnext.weak-set.from"
  ],
  	"core-js/modules/esnext.weak-set.of": [
  	"esnext.weak-set.of"
  ],
  	"core-js/modules/web.dom-collections.for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/modules/web.dom-collections.iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/modules/web.immediate": [
  	"web.immediate"
  ],
  	"core-js/modules/web.queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/modules/web.timers": [
  	"web.timers"
  ],
  	"core-js/modules/web.url": [
  	"web.url"
  ],
  	"core-js/modules/web.url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/modules/web.url.to-json": [
  	"web.url.to-json"
  ],
  	"core-js/proposals": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/proposals/accessible-object-hasownproperty": [
  	"esnext.object.has-own"
  ],
  	"core-js/proposals/array-filtering": [
  	"esnext.array.filter-out",
  	"esnext.typed-array.filter-out"
  ],
  	"core-js/proposals/array-find-from-last": [
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index"
  ],
  	"core-js/proposals/array-is-template-object": [
  	"esnext.array.is-template-object"
  ],
  	"core-js/proposals/array-last": [
  	"esnext.array.last-index",
  	"esnext.array.last-item"
  ],
  	"core-js/proposals/array-unique": [
  	"es.map",
  	"esnext.array.unique-by",
  	"esnext.typed-array.unique-by"
  ],
  	"core-js/proposals/collection-methods": [
  	"esnext.map.delete-all",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all"
  ],
  	"core-js/proposals/collection-of-from": [
  	"esnext.map.from",
  	"esnext.map.of",
  	"esnext.set.from",
  	"esnext.set.of",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of"
  ],
  	"core-js/proposals/decorators": [
  	"esnext.symbol.metadata"
  ],
  	"core-js/proposals/efficient-64-bit-arithmetic": [
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.umulh"
  ],
  	"core-js/proposals/global-this": [
  	"esnext.global-this"
  ],
  	"core-js/proposals/iterator-helpers": [
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array"
  ],
  	"core-js/proposals/keys-composition": [
  	"esnext.composite-key",
  	"esnext.composite-symbol"
  ],
  	"core-js/proposals/map-update-or-insert": [
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/proposals/map-upsert": [
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/proposals/math-extensions": [
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale"
  ],
  	"core-js/proposals/math-signbit": [
  	"esnext.math.signbit"
  ],
  	"core-js/proposals/number-from-string": [
  	"esnext.number.from-string"
  ],
  	"core-js/proposals/number-range": [
  	"esnext.bigint.range",
  	"esnext.number.range"
  ],
  	"core-js/proposals/object-iteration": [
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values"
  ],
  	"core-js/proposals/observable": [
  	"esnext.observable",
  	"esnext.symbol.observable"
  ],
  	"core-js/proposals/pattern-matching": [
  	"esnext.symbol.matcher",
  	"esnext.symbol.pattern-match"
  ],
  	"core-js/proposals/promise-all-settled": [
  	"esnext.promise.all-settled"
  ],
  	"core-js/proposals/promise-any": [
  	"esnext.aggregate-error",
  	"esnext.promise.any"
  ],
  	"core-js/proposals/promise-try": [
  	"esnext.promise.try"
  ],
  	"core-js/proposals/reflect-metadata": [
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata"
  ],
  	"core-js/proposals/relative-indexing-method": [
  	"esnext.array.at",
  	"esnext.typed-array.at"
  ],
  	"core-js/proposals/seeded-random": [
  	"esnext.math.seeded-prng"
  ],
  	"core-js/proposals/set-methods": [
  	"esnext.set.difference",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union"
  ],
  	"core-js/proposals/string-at": [
  	"esnext.string.at"
  ],
  	"core-js/proposals/string-code-points": [
  	"esnext.string.code-points"
  ],
  	"core-js/proposals/string-match-all": [
  	"esnext.string.match-all"
  ],
  	"core-js/proposals/string-replace-all": [
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/proposals/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/proposals/using-statement": [
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose"
  ],
  	"core-js/stable": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.aggregate-error",
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.data-view",
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string",
  	"es.escape",
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name",
  	"es.global-this",
  	"es.json.stringify",
  	"es.json.to-string-tag",
  	"es.map",
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc",
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.parse-float",
  	"es.parse-int",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag",
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.set",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string",
  	"es.unescape",
  	"es.weak-map",
  	"es.weak-set",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stable/aggregate-error": [
  	"es.aggregate-error",
  	"es.string.iterator",
  	"esnext.aggregate-error",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/array": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.from",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.is-array",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.of",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map",
  	"es.string.iterator"
  ],
  	"core-js/stable/array-buffer": [
  	"es.array-buffer.constructor",
  	"es.array-buffer.is-view",
  	"es.array-buffer.slice",
  	"es.object.to-string"
  ],
  	"core-js/stable/array-buffer/constructor": [
  	"es.array-buffer.constructor",
  	"es.object.to-string"
  ],
  	"core-js/stable/array-buffer/is-view": [
  	"es.array-buffer.is-view"
  ],
  	"core-js/stable/array-buffer/slice": [
  	"es.array-buffer.slice"
  ],
  	"core-js/stable/array/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/array/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/array/entries": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/every": [
  	"es.array.every"
  ],
  	"core-js/stable/array/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/array/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/array/find": [
  	"es.array.find"
  ],
  	"core-js/stable/array/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/array/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/array/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/stable/array/from": [
  	"es.array.from",
  	"es.string.iterator"
  ],
  	"core-js/stable/array/includes": [
  	"es.array.includes"
  ],
  	"core-js/stable/array/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/array/is-array": [
  	"es.array.is-array"
  ],
  	"core-js/stable/array/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/join": [
  	"es.array.join"
  ],
  	"core-js/stable/array/keys": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/array/map": [
  	"es.array.map"
  ],
  	"core-js/stable/array/of": [
  	"es.array.of"
  ],
  	"core-js/stable/array/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/array/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/array/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/array/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/array/some": [
  	"es.array.some"
  ],
  	"core-js/stable/array/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/array/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/array/values": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual": [
  	"es.array.concat",
  	"es.array.copy-within",
  	"es.array.every",
  	"es.array.fill",
  	"es.array.filter",
  	"es.array.find",
  	"es.array.find-index",
  	"es.array.flat",
  	"es.array.flat-map",
  	"es.array.for-each",
  	"es.array.includes",
  	"es.array.index-of",
  	"es.array.iterator",
  	"es.array.join",
  	"es.array.last-index-of",
  	"es.array.map",
  	"es.array.reduce",
  	"es.array.reduce-right",
  	"es.array.reverse",
  	"es.array.slice",
  	"es.array.some",
  	"es.array.sort",
  	"es.array.species",
  	"es.array.splice",
  	"es.array.unscopables.flat",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/virtual/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/array/virtual/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/array/virtual/entries": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/every": [
  	"es.array.every"
  ],
  	"core-js/stable/array/virtual/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/array/virtual/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/array/virtual/find": [
  	"es.array.find"
  ],
  	"core-js/stable/array/virtual/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/array/virtual/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/array/virtual/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/array/virtual/for-each": [
  	"es.array.for-each"
  ],
  	"core-js/stable/array/virtual/includes": [
  	"es.array.includes"
  ],
  	"core-js/stable/array/virtual/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/array/virtual/iterator": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/join": [
  	"es.array.join"
  ],
  	"core-js/stable/array/virtual/keys": [
  	"es.array.iterator"
  ],
  	"core-js/stable/array/virtual/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/array/virtual/map": [
  	"es.array.map"
  ],
  	"core-js/stable/array/virtual/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/array/virtual/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/array/virtual/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/array/virtual/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/array/virtual/some": [
  	"es.array.some"
  ],
  	"core-js/stable/array/virtual/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/array/virtual/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/array/virtual/values": [
  	"es.array.iterator"
  ],
  	"core-js/stable/clear-immediate": [
  	"web.immediate"
  ],
  	"core-js/stable/data-view": [
  	"es.data-view",
  	"es.object.to-string"
  ],
  	"core-js/stable/date": [
  	"es.date.get-year",
  	"es.date.now",
  	"es.date.set-year",
  	"es.date.to-gmt-string",
  	"es.date.to-iso-string",
  	"es.date.to-json",
  	"es.date.to-primitive",
  	"es.date.to-string"
  ],
  	"core-js/stable/date/get-year": [
  	"es.date.get-year"
  ],
  	"core-js/stable/date/now": [
  	"es.date.now"
  ],
  	"core-js/stable/date/set-year": [
  	"es.date.set-year"
  ],
  	"core-js/stable/date/to-gmt-string": [
  	"es.date.to-gmt-string"
  ],
  	"core-js/stable/date/to-iso-string": [
  	"es.date.to-iso-string",
  	"es.date.to-json"
  ],
  	"core-js/stable/date/to-json": [
  	"es.date.to-json"
  ],
  	"core-js/stable/date/to-primitive": [
  	"es.date.to-primitive"
  ],
  	"core-js/stable/date/to-string": [
  	"es.date.to-string"
  ],
  	"core-js/stable/dom-collections": [
  	"es.array.iterator",
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/dom-collections/for-each": [
  	"web.dom-collections.for-each"
  ],
  	"core-js/stable/dom-collections/iterator": [
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/escape": [
  	"es.escape"
  ],
  	"core-js/stable/function": [
  	"es.function.bind",
  	"es.function.has-instance",
  	"es.function.name"
  ],
  	"core-js/stable/function/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/function/has-instance": [
  	"es.function.has-instance"
  ],
  	"core-js/stable/function/name": [
  	"es.function.name"
  ],
  	"core-js/stable/function/virtual": [
  	"es.function.bind"
  ],
  	"core-js/stable/function/virtual/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/global-this": [
  	"es.global-this"
  ],
  	"core-js/stable/instance/bind": [
  	"es.function.bind"
  ],
  	"core-js/stable/instance/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/instance/concat": [
  	"es.array.concat"
  ],
  	"core-js/stable/instance/copy-within": [
  	"es.array.copy-within"
  ],
  	"core-js/stable/instance/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/instance/entries": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/every": [
  	"es.array.every"
  ],
  	"core-js/stable/instance/fill": [
  	"es.array.fill"
  ],
  	"core-js/stable/instance/filter": [
  	"es.array.filter"
  ],
  	"core-js/stable/instance/find": [
  	"es.array.find"
  ],
  	"core-js/stable/instance/find-index": [
  	"es.array.find-index"
  ],
  	"core-js/stable/instance/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/stable/instance/flat": [
  	"es.array.flat",
  	"es.array.unscopables.flat"
  ],
  	"core-js/stable/instance/flat-map": [
  	"es.array.flat-map",
  	"es.array.unscopables.flat-map"
  ],
  	"core-js/stable/instance/for-each": [
  	"es.array.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/includes": [
  	"es.array.includes",
  	"es.string.includes"
  ],
  	"core-js/stable/instance/index-of": [
  	"es.array.index-of"
  ],
  	"core-js/stable/instance/keys": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/instance/last-index-of": [
  	"es.array.last-index-of"
  ],
  	"core-js/stable/instance/map": [
  	"es.array.map"
  ],
  	"core-js/stable/instance/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/instance/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/instance/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/instance/reduce": [
  	"es.array.reduce"
  ],
  	"core-js/stable/instance/reduce-right": [
  	"es.array.reduce-right"
  ],
  	"core-js/stable/instance/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/instance/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/instance/reverse": [
  	"es.array.reverse"
  ],
  	"core-js/stable/instance/slice": [
  	"es.array.slice"
  ],
  	"core-js/stable/instance/some": [
  	"es.array.some"
  ],
  	"core-js/stable/instance/sort": [
  	"es.array.sort"
  ],
  	"core-js/stable/instance/splice": [
  	"es.array.splice"
  ],
  	"core-js/stable/instance/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/instance/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/instance/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/instance/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/instance/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/instance/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/instance/values": [
  	"es.array.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/json": [
  	"es.json.stringify",
  	"es.json.to-string-tag"
  ],
  	"core-js/stable/json/stringify": [
  	"es.json.stringify"
  ],
  	"core-js/stable/json/to-string-tag": [
  	"es.json.to-string-tag"
  ],
  	"core-js/stable/map": [
  	"es.map",
  	"es.object.to-string",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/math": [
  	"es.math.acosh",
  	"es.math.asinh",
  	"es.math.atanh",
  	"es.math.cbrt",
  	"es.math.clz32",
  	"es.math.cosh",
  	"es.math.expm1",
  	"es.math.fround",
  	"es.math.hypot",
  	"es.math.imul",
  	"es.math.log10",
  	"es.math.log1p",
  	"es.math.log2",
  	"es.math.sign",
  	"es.math.sinh",
  	"es.math.tanh",
  	"es.math.to-string-tag",
  	"es.math.trunc"
  ],
  	"core-js/stable/math/acosh": [
  	"es.math.acosh"
  ],
  	"core-js/stable/math/asinh": [
  	"es.math.asinh"
  ],
  	"core-js/stable/math/atanh": [
  	"es.math.atanh"
  ],
  	"core-js/stable/math/cbrt": [
  	"es.math.cbrt"
  ],
  	"core-js/stable/math/clz32": [
  	"es.math.clz32"
  ],
  	"core-js/stable/math/cosh": [
  	"es.math.cosh"
  ],
  	"core-js/stable/math/expm1": [
  	"es.math.expm1"
  ],
  	"core-js/stable/math/fround": [
  	"es.math.fround"
  ],
  	"core-js/stable/math/hypot": [
  	"es.math.hypot"
  ],
  	"core-js/stable/math/imul": [
  	"es.math.imul"
  ],
  	"core-js/stable/math/log10": [
  	"es.math.log10"
  ],
  	"core-js/stable/math/log1p": [
  	"es.math.log1p"
  ],
  	"core-js/stable/math/log2": [
  	"es.math.log2"
  ],
  	"core-js/stable/math/sign": [
  	"es.math.sign"
  ],
  	"core-js/stable/math/sinh": [
  	"es.math.sinh"
  ],
  	"core-js/stable/math/tanh": [
  	"es.math.tanh"
  ],
  	"core-js/stable/math/to-string-tag": [
  	"es.math.to-string-tag"
  ],
  	"core-js/stable/math/trunc": [
  	"es.math.trunc"
  ],
  	"core-js/stable/number": [
  	"es.number.constructor",
  	"es.number.epsilon",
  	"es.number.is-finite",
  	"es.number.is-integer",
  	"es.number.is-nan",
  	"es.number.is-safe-integer",
  	"es.number.max-safe-integer",
  	"es.number.min-safe-integer",
  	"es.number.parse-float",
  	"es.number.parse-int",
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/constructor": [
  	"es.number.constructor"
  ],
  	"core-js/stable/number/epsilon": [
  	"es.number.epsilon"
  ],
  	"core-js/stable/number/is-finite": [
  	"es.number.is-finite"
  ],
  	"core-js/stable/number/is-integer": [
  	"es.number.is-integer"
  ],
  	"core-js/stable/number/is-nan": [
  	"es.number.is-nan"
  ],
  	"core-js/stable/number/is-safe-integer": [
  	"es.number.is-safe-integer"
  ],
  	"core-js/stable/number/max-safe-integer": [
  	"es.number.max-safe-integer"
  ],
  	"core-js/stable/number/min-safe-integer": [
  	"es.number.min-safe-integer"
  ],
  	"core-js/stable/number/parse-float": [
  	"es.number.parse-float"
  ],
  	"core-js/stable/number/parse-int": [
  	"es.number.parse-int"
  ],
  	"core-js/stable/number/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/stable/number/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/virtual": [
  	"es.number.to-fixed",
  	"es.number.to-precision"
  ],
  	"core-js/stable/number/virtual/to-fixed": [
  	"es.number.to-fixed"
  ],
  	"core-js/stable/number/virtual/to-precision": [
  	"es.number.to-precision"
  ],
  	"core-js/stable/object": [
  	"es.symbol",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.assign",
  	"es.object.create",
  	"es.object.define-getter",
  	"es.object.define-properties",
  	"es.object.define-property",
  	"es.object.define-setter",
  	"es.object.entries",
  	"es.object.freeze",
  	"es.object.from-entries",
  	"es.object.get-own-property-descriptor",
  	"es.object.get-own-property-descriptors",
  	"es.object.get-own-property-names",
  	"es.object.get-prototype-of",
  	"es.object.is",
  	"es.object.is-extensible",
  	"es.object.is-frozen",
  	"es.object.is-sealed",
  	"es.object.keys",
  	"es.object.lookup-getter",
  	"es.object.lookup-setter",
  	"es.object.prevent-extensions",
  	"es.object.seal",
  	"es.object.set-prototype-of",
  	"es.object.to-string",
  	"es.object.values",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/object/assign": [
  	"es.object.assign"
  ],
  	"core-js/stable/object/create": [
  	"es.object.create"
  ],
  	"core-js/stable/object/define-getter": [
  	"es.object.define-getter"
  ],
  	"core-js/stable/object/define-properties": [
  	"es.object.define-properties"
  ],
  	"core-js/stable/object/define-property": [
  	"es.object.define-property"
  ],
  	"core-js/stable/object/define-setter": [
  	"es.object.define-setter"
  ],
  	"core-js/stable/object/entries": [
  	"es.object.entries"
  ],
  	"core-js/stable/object/freeze": [
  	"es.object.freeze"
  ],
  	"core-js/stable/object/from-entries": [
  	"es.array.iterator",
  	"es.object.from-entries"
  ],
  	"core-js/stable/object/get-own-property-descriptor": [
  	"es.object.get-own-property-descriptor"
  ],
  	"core-js/stable/object/get-own-property-descriptors": [
  	"es.object.get-own-property-descriptors"
  ],
  	"core-js/stable/object/get-own-property-names": [
  	"es.object.get-own-property-names"
  ],
  	"core-js/stable/object/get-own-property-symbols": [
  	"es.symbol"
  ],
  	"core-js/stable/object/get-prototype-of": [
  	"es.object.get-prototype-of"
  ],
  	"core-js/stable/object/is": [
  	"es.object.is"
  ],
  	"core-js/stable/object/is-extensible": [
  	"es.object.is-extensible"
  ],
  	"core-js/stable/object/is-frozen": [
  	"es.object.is-frozen"
  ],
  	"core-js/stable/object/is-sealed": [
  	"es.object.is-sealed"
  ],
  	"core-js/stable/object/keys": [
  	"es.object.keys"
  ],
  	"core-js/stable/object/lookup-getter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/stable/object/lookup-setter": [
  	"es.object.lookup-setter"
  ],
  	"core-js/stable/object/prevent-extensions": [
  	"es.object.prevent-extensions"
  ],
  	"core-js/stable/object/seal": [
  	"es.object.seal"
  ],
  	"core-js/stable/object/set-prototype-of": [
  	"es.object.set-prototype-of"
  ],
  	"core-js/stable/object/to-string": [
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/object/values": [
  	"es.object.values"
  ],
  	"core-js/stable/parse-float": [
  	"es.parse-float"
  ],
  	"core-js/stable/parse-int": [
  	"es.parse-int"
  ],
  	"core-js/stable/promise": [
  	"es.aggregate-error",
  	"es.object.to-string",
  	"es.promise",
  	"es.promise.all-settled",
  	"es.promise.any",
  	"es.promise.finally",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/promise/all-settled": [
  	"es.promise",
  	"es.promise.all-settled",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/promise/any": [
  	"es.aggregate-error",
  	"es.promise",
  	"es.promise.any",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/promise/finally": [
  	"es.promise",
  	"es.promise.finally"
  ],
  	"core-js/stable/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/stable/reflect": [
  	"es.reflect.apply",
  	"es.reflect.construct",
  	"es.reflect.define-property",
  	"es.reflect.delete-property",
  	"es.reflect.get",
  	"es.reflect.get-own-property-descriptor",
  	"es.reflect.get-prototype-of",
  	"es.reflect.has",
  	"es.reflect.is-extensible",
  	"es.reflect.own-keys",
  	"es.reflect.prevent-extensions",
  	"es.reflect.set",
  	"es.reflect.set-prototype-of",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/reflect/apply": [
  	"es.reflect.apply"
  ],
  	"core-js/stable/reflect/construct": [
  	"es.reflect.construct"
  ],
  	"core-js/stable/reflect/define-property": [
  	"es.reflect.define-property"
  ],
  	"core-js/stable/reflect/delete-property": [
  	"es.reflect.delete-property"
  ],
  	"core-js/stable/reflect/get": [
  	"es.reflect.get"
  ],
  	"core-js/stable/reflect/get-own-property-descriptor": [
  	"es.reflect.get-own-property-descriptor"
  ],
  	"core-js/stable/reflect/get-prototype-of": [
  	"es.reflect.get-prototype-of"
  ],
  	"core-js/stable/reflect/has": [
  	"es.reflect.has"
  ],
  	"core-js/stable/reflect/is-extensible": [
  	"es.reflect.is-extensible"
  ],
  	"core-js/stable/reflect/own-keys": [
  	"es.reflect.own-keys"
  ],
  	"core-js/stable/reflect/prevent-extensions": [
  	"es.reflect.prevent-extensions"
  ],
  	"core-js/stable/reflect/set": [
  	"es.reflect.set"
  ],
  	"core-js/stable/reflect/set-prototype-of": [
  	"es.reflect.set-prototype-of"
  ],
  	"core-js/stable/reflect/to-string-tag": [
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/regexp": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec",
  	"es.regexp.flags",
  	"es.regexp.sticky",
  	"es.regexp.test",
  	"es.regexp.to-string",
  	"es.string.match",
  	"es.string.replace",
  	"es.string.search",
  	"es.string.split"
  ],
  	"core-js/stable/regexp/constructor": [
  	"es.regexp.constructor"
  ],
  	"core-js/stable/regexp/dot-all": [
  	"es.regexp.constructor",
  	"es.regexp.dot-all",
  	"es.regexp.exec"
  ],
  	"core-js/stable/regexp/flags": [
  	"es.regexp.flags"
  ],
  	"core-js/stable/regexp/match": [
  	"es.string.match"
  ],
  	"core-js/stable/regexp/replace": [
  	"es.string.replace"
  ],
  	"core-js/stable/regexp/search": [
  	"es.string.search"
  ],
  	"core-js/stable/regexp/split": [
  	"es.string.split"
  ],
  	"core-js/stable/regexp/sticky": [
  	"es.regexp.constructor",
  	"es.regexp.exec",
  	"es.regexp.sticky"
  ],
  	"core-js/stable/regexp/test": [
  	"es.regexp.exec",
  	"es.regexp.test"
  ],
  	"core-js/stable/regexp/to-string": [
  	"es.regexp.to-string"
  ],
  	"core-js/stable/set": [
  	"es.object.to-string",
  	"es.set",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/set-immediate": [
  	"web.immediate"
  ],
  	"core-js/stable/set-interval": [
  	"web.timers"
  ],
  	"core-js/stable/set-timeout": [
  	"web.timers"
  ],
  	"core-js/stable/string": [
  	"es.regexp.exec",
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.from-code-point",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.raw",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/stable/string/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/stable/string/big": [
  	"es.string.big"
  ],
  	"core-js/stable/string/blink": [
  	"es.string.blink"
  ],
  	"core-js/stable/string/bold": [
  	"es.string.bold"
  ],
  	"core-js/stable/string/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/string/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/string/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/stable/string/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/stable/string/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/stable/string/from-code-point": [
  	"es.string.from-code-point"
  ],
  	"core-js/stable/string/includes": [
  	"es.string.includes"
  ],
  	"core-js/stable/string/italics": [
  	"es.string.italics"
  ],
  	"core-js/stable/string/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/stable/string/link": [
  	"es.string.link"
  ],
  	"core-js/stable/string/match": [
  	"es.regexp.exec",
  	"es.string.match"
  ],
  	"core-js/stable/string/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/string/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/string/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/string/raw": [
  	"es.string.raw"
  ],
  	"core-js/stable/string/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/string/replace": [
  	"es.regexp.exec",
  	"es.string.replace"
  ],
  	"core-js/stable/string/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/string/search": [
  	"es.regexp.exec",
  	"es.string.search"
  ],
  	"core-js/stable/string/small": [
  	"es.string.small"
  ],
  	"core-js/stable/string/split": [
  	"es.regexp.exec",
  	"es.string.split"
  ],
  	"core-js/stable/string/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/string/strike": [
  	"es.string.strike"
  ],
  	"core-js/stable/string/sub": [
  	"es.string.sub"
  ],
  	"core-js/stable/string/substr": [
  	"es.string.substr"
  ],
  	"core-js/stable/string/sup": [
  	"es.string.sup"
  ],
  	"core-js/stable/string/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/string/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/virtual": [
  	"es.string.code-point-at",
  	"es.string.ends-with",
  	"es.string.includes",
  	"es.string.iterator",
  	"es.string.match",
  	"es.string.match-all",
  	"es.string.pad-end",
  	"es.string.pad-start",
  	"es.string.repeat",
  	"es.string.replace",
  	"es.string.replace-all",
  	"es.string.search",
  	"es.string.split",
  	"es.string.starts-with",
  	"es.string.substr",
  	"es.string.trim",
  	"es.string.trim-end",
  	"es.string.trim-start",
  	"es.string.anchor",
  	"es.string.big",
  	"es.string.blink",
  	"es.string.bold",
  	"es.string.fixed",
  	"es.string.fontcolor",
  	"es.string.fontsize",
  	"es.string.italics",
  	"es.string.link",
  	"es.string.small",
  	"es.string.strike",
  	"es.string.sub",
  	"es.string.sup"
  ],
  	"core-js/stable/string/virtual/anchor": [
  	"es.string.anchor"
  ],
  	"core-js/stable/string/virtual/big": [
  	"es.string.big"
  ],
  	"core-js/stable/string/virtual/blink": [
  	"es.string.blink"
  ],
  	"core-js/stable/string/virtual/bold": [
  	"es.string.bold"
  ],
  	"core-js/stable/string/virtual/code-point-at": [
  	"es.string.code-point-at"
  ],
  	"core-js/stable/string/virtual/ends-with": [
  	"es.string.ends-with"
  ],
  	"core-js/stable/string/virtual/fixed": [
  	"es.string.fixed"
  ],
  	"core-js/stable/string/virtual/fontcolor": [
  	"es.string.fontcolor"
  ],
  	"core-js/stable/string/virtual/fontsize": [
  	"es.string.fontsize"
  ],
  	"core-js/stable/string/virtual/includes": [
  	"es.string.includes"
  ],
  	"core-js/stable/string/virtual/italics": [
  	"es.string.italics"
  ],
  	"core-js/stable/string/virtual/iterator": [
  	"es.string.iterator"
  ],
  	"core-js/stable/string/virtual/link": [
  	"es.string.link"
  ],
  	"core-js/stable/string/virtual/match-all": [
  	"es.string.match-all"
  ],
  	"core-js/stable/string/virtual/pad-end": [
  	"es.string.pad-end"
  ],
  	"core-js/stable/string/virtual/pad-start": [
  	"es.string.pad-start"
  ],
  	"core-js/stable/string/virtual/repeat": [
  	"es.string.repeat"
  ],
  	"core-js/stable/string/virtual/replace-all": [
  	"es.string.replace-all"
  ],
  	"core-js/stable/string/virtual/small": [
  	"es.string.small"
  ],
  	"core-js/stable/string/virtual/starts-with": [
  	"es.string.starts-with"
  ],
  	"core-js/stable/string/virtual/strike": [
  	"es.string.strike"
  ],
  	"core-js/stable/string/virtual/sub": [
  	"es.string.sub"
  ],
  	"core-js/stable/string/virtual/substr": [
  	"es.string.substr"
  ],
  	"core-js/stable/string/virtual/sup": [
  	"es.string.sup"
  ],
  	"core-js/stable/string/virtual/trim": [
  	"es.string.trim"
  ],
  	"core-js/stable/string/virtual/trim-end": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/virtual/trim-left": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/string/virtual/trim-right": [
  	"es.string.trim-end"
  ],
  	"core-js/stable/string/virtual/trim-start": [
  	"es.string.trim-start"
  ],
  	"core-js/stable/symbol": [
  	"es.symbol",
  	"es.symbol.description",
  	"es.symbol.async-iterator",
  	"es.symbol.has-instance",
  	"es.symbol.is-concat-spreadable",
  	"es.symbol.iterator",
  	"es.symbol.match",
  	"es.symbol.match-all",
  	"es.symbol.replace",
  	"es.symbol.search",
  	"es.symbol.species",
  	"es.symbol.split",
  	"es.symbol.to-primitive",
  	"es.symbol.to-string-tag",
  	"es.symbol.unscopables",
  	"es.array.concat",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/symbol/async-iterator": [
  	"es.symbol.async-iterator"
  ],
  	"core-js/stable/symbol/description": [
  	"es.symbol.description"
  ],
  	"core-js/stable/symbol/for": [
  	"es.symbol"
  ],
  	"core-js/stable/symbol/has-instance": [
  	"es.symbol.has-instance",
  	"es.function.has-instance"
  ],
  	"core-js/stable/symbol/is-concat-spreadable": [
  	"es.symbol.is-concat-spreadable",
  	"es.array.concat"
  ],
  	"core-js/stable/symbol/iterator": [
  	"es.symbol.iterator",
  	"es.string.iterator",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/symbol/key-for": [
  	"es.symbol"
  ],
  	"core-js/stable/symbol/match": [
  	"es.symbol.match",
  	"es.string.match"
  ],
  	"core-js/stable/symbol/match-all": [
  	"es.symbol.match-all",
  	"es.string.match-all"
  ],
  	"core-js/stable/symbol/replace": [
  	"es.symbol.replace",
  	"es.string.replace"
  ],
  	"core-js/stable/symbol/search": [
  	"es.symbol.search",
  	"es.string.search"
  ],
  	"core-js/stable/symbol/species": [
  	"es.symbol.species"
  ],
  	"core-js/stable/symbol/split": [
  	"es.symbol.split",
  	"es.string.split"
  ],
  	"core-js/stable/symbol/to-primitive": [
  	"es.symbol.to-primitive"
  ],
  	"core-js/stable/symbol/to-string-tag": [
  	"es.symbol.to-string-tag",
  	"es.json.to-string-tag",
  	"es.math.to-string-tag",
  	"es.object.to-string",
  	"es.reflect.to-string-tag"
  ],
  	"core-js/stable/symbol/unscopables": [
  	"es.symbol.unscopables"
  ],
  	"core-js/stable/typed-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.float64-array",
  	"es.typed-array.int8-array",
  	"es.typed-array.int16-array",
  	"es.typed-array.int32-array",
  	"es.typed-array.uint8-array",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.uint16-array",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/copy-within": [
  	"es.typed-array.copy-within"
  ],
  	"core-js/stable/typed-array/entries": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/every": [
  	"es.typed-array.every"
  ],
  	"core-js/stable/typed-array/fill": [
  	"es.typed-array.fill"
  ],
  	"core-js/stable/typed-array/filter": [
  	"es.typed-array.filter"
  ],
  	"core-js/stable/typed-array/find": [
  	"es.typed-array.find"
  ],
  	"core-js/stable/typed-array/find-index": [
  	"es.typed-array.find-index"
  ],
  	"core-js/stable/typed-array/float32-array": [
  	"es.object.to-string",
  	"es.typed-array.float32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/float64-array": [
  	"es.object.to-string",
  	"es.typed-array.float64-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/for-each": [
  	"es.typed-array.for-each"
  ],
  	"core-js/stable/typed-array/from": [
  	"es.typed-array.from"
  ],
  	"core-js/stable/typed-array/includes": [
  	"es.typed-array.includes"
  ],
  	"core-js/stable/typed-array/index-of": [
  	"es.typed-array.index-of"
  ],
  	"core-js/stable/typed-array/int16-array": [
  	"es.object.to-string",
  	"es.typed-array.int16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/int32-array": [
  	"es.object.to-string",
  	"es.typed-array.int32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/int8-array": [
  	"es.object.to-string",
  	"es.typed-array.int8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/iterator": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/join": [
  	"es.typed-array.join"
  ],
  	"core-js/stable/typed-array/keys": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/typed-array/last-index-of": [
  	"es.typed-array.last-index-of"
  ],
  	"core-js/stable/typed-array/map": [
  	"es.typed-array.map"
  ],
  	"core-js/stable/typed-array/of": [
  	"es.typed-array.of"
  ],
  	"core-js/stable/typed-array/reduce": [
  	"es.typed-array.reduce"
  ],
  	"core-js/stable/typed-array/reduce-right": [
  	"es.typed-array.reduce-right"
  ],
  	"core-js/stable/typed-array/reverse": [
  	"es.typed-array.reverse"
  ],
  	"core-js/stable/typed-array/set": [
  	"es.typed-array.set"
  ],
  	"core-js/stable/typed-array/slice": [
  	"es.typed-array.slice"
  ],
  	"core-js/stable/typed-array/some": [
  	"es.typed-array.some"
  ],
  	"core-js/stable/typed-array/sort": [
  	"es.typed-array.sort"
  ],
  	"core-js/stable/typed-array/subarray": [
  	"es.typed-array.subarray"
  ],
  	"core-js/stable/typed-array/to-locale-string": [
  	"es.typed-array.to-locale-string"
  ],
  	"core-js/stable/typed-array/to-string": [
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint16-array": [
  	"es.object.to-string",
  	"es.typed-array.uint16-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint32-array": [
  	"es.object.to-string",
  	"es.typed-array.uint32-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint8-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/uint8-clamped-array": [
  	"es.object.to-string",
  	"es.typed-array.uint8-clamped-array",
  	"es.typed-array.copy-within",
  	"es.typed-array.every",
  	"es.typed-array.fill",
  	"es.typed-array.filter",
  	"es.typed-array.find",
  	"es.typed-array.find-index",
  	"es.typed-array.for-each",
  	"es.typed-array.from",
  	"es.typed-array.includes",
  	"es.typed-array.index-of",
  	"es.typed-array.iterator",
  	"es.typed-array.join",
  	"es.typed-array.last-index-of",
  	"es.typed-array.map",
  	"es.typed-array.of",
  	"es.typed-array.reduce",
  	"es.typed-array.reduce-right",
  	"es.typed-array.reverse",
  	"es.typed-array.set",
  	"es.typed-array.slice",
  	"es.typed-array.some",
  	"es.typed-array.sort",
  	"es.typed-array.subarray",
  	"es.typed-array.to-locale-string",
  	"es.typed-array.to-string"
  ],
  	"core-js/stable/typed-array/values": [
  	"es.typed-array.iterator"
  ],
  	"core-js/stable/unescape": [
  	"es.unescape"
  ],
  	"core-js/stable/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stable/url-search-params": [
  	"web.url-search-params"
  ],
  	"core-js/stable/url/to-json": [
  	"web.url.to-json"
  ],
  	"core-js/stable/weak-map": [
  	"es.object.to-string",
  	"es.weak-map",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stable/weak-set": [
  	"es.object.to-string",
  	"es.weak-set",
  	"web.dom-collections.iterator"
  ],
  	"core-js/stage": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stage/0": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/stage/1": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of"
  ],
  	"core-js/stage/2": [
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.emplace",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.object.has-own",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.set.difference",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.metadata",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert"
  ],
  	"core-js/stage/3": [
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.global-this",
  	"esnext.object.has-own",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at"
  ],
  	"core-js/stage/4": [
  	"esnext.aggregate-error",
  	"esnext.global-this",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.replace-all"
  ],
  	"core-js/stage/pre": [
  	"es.map",
  	"esnext.aggregate-error",
  	"esnext.array.at",
  	"esnext.array.filter-out",
  	"esnext.array.find-last",
  	"esnext.array.find-last-index",
  	"esnext.array.is-template-object",
  	"esnext.array.last-index",
  	"esnext.array.last-item",
  	"esnext.array.unique-by",
  	"esnext.async-iterator.constructor",
  	"esnext.async-iterator.as-indexed-pairs",
  	"esnext.async-iterator.drop",
  	"esnext.async-iterator.every",
  	"esnext.async-iterator.filter",
  	"esnext.async-iterator.find",
  	"esnext.async-iterator.flat-map",
  	"esnext.async-iterator.for-each",
  	"esnext.async-iterator.from",
  	"esnext.async-iterator.map",
  	"esnext.async-iterator.reduce",
  	"esnext.async-iterator.some",
  	"esnext.async-iterator.take",
  	"esnext.async-iterator.to-array",
  	"esnext.bigint.range",
  	"esnext.composite-key",
  	"esnext.composite-symbol",
  	"esnext.global-this",
  	"esnext.iterator.constructor",
  	"esnext.iterator.as-indexed-pairs",
  	"esnext.iterator.drop",
  	"esnext.iterator.every",
  	"esnext.iterator.filter",
  	"esnext.iterator.find",
  	"esnext.iterator.flat-map",
  	"esnext.iterator.for-each",
  	"esnext.iterator.from",
  	"esnext.iterator.map",
  	"esnext.iterator.reduce",
  	"esnext.iterator.some",
  	"esnext.iterator.take",
  	"esnext.iterator.to-array",
  	"esnext.map.delete-all",
  	"esnext.map.emplace",
  	"esnext.map.every",
  	"esnext.map.filter",
  	"esnext.map.find",
  	"esnext.map.find-key",
  	"esnext.map.from",
  	"esnext.map.group-by",
  	"esnext.map.includes",
  	"esnext.map.key-by",
  	"esnext.map.key-of",
  	"esnext.map.map-keys",
  	"esnext.map.map-values",
  	"esnext.map.merge",
  	"esnext.map.of",
  	"esnext.map.reduce",
  	"esnext.map.some",
  	"esnext.map.update",
  	"esnext.map.update-or-insert",
  	"esnext.map.upsert",
  	"esnext.math.clamp",
  	"esnext.math.deg-per-rad",
  	"esnext.math.degrees",
  	"esnext.math.fscale",
  	"esnext.math.iaddh",
  	"esnext.math.imulh",
  	"esnext.math.isubh",
  	"esnext.math.rad-per-deg",
  	"esnext.math.radians",
  	"esnext.math.scale",
  	"esnext.math.seeded-prng",
  	"esnext.math.signbit",
  	"esnext.math.umulh",
  	"esnext.number.from-string",
  	"esnext.number.range",
  	"esnext.object.has-own",
  	"esnext.object.iterate-entries",
  	"esnext.object.iterate-keys",
  	"esnext.object.iterate-values",
  	"esnext.observable",
  	"esnext.promise.all-settled",
  	"esnext.promise.any",
  	"esnext.promise.try",
  	"esnext.reflect.define-metadata",
  	"esnext.reflect.delete-metadata",
  	"esnext.reflect.get-metadata",
  	"esnext.reflect.get-metadata-keys",
  	"esnext.reflect.get-own-metadata",
  	"esnext.reflect.get-own-metadata-keys",
  	"esnext.reflect.has-metadata",
  	"esnext.reflect.has-own-metadata",
  	"esnext.reflect.metadata",
  	"esnext.set.add-all",
  	"esnext.set.delete-all",
  	"esnext.set.difference",
  	"esnext.set.every",
  	"esnext.set.filter",
  	"esnext.set.find",
  	"esnext.set.from",
  	"esnext.set.intersection",
  	"esnext.set.is-disjoint-from",
  	"esnext.set.is-subset-of",
  	"esnext.set.is-superset-of",
  	"esnext.set.join",
  	"esnext.set.map",
  	"esnext.set.of",
  	"esnext.set.reduce",
  	"esnext.set.some",
  	"esnext.set.symmetric-difference",
  	"esnext.set.union",
  	"esnext.string.at",
  	"esnext.string.code-points",
  	"esnext.string.match-all",
  	"esnext.string.replace-all",
  	"esnext.symbol.async-dispose",
  	"esnext.symbol.dispose",
  	"esnext.symbol.matcher",
  	"esnext.symbol.metadata",
  	"esnext.symbol.observable",
  	"esnext.symbol.pattern-match",
  	"esnext.symbol.replace-all",
  	"esnext.typed-array.at",
  	"esnext.typed-array.filter-out",
  	"esnext.typed-array.find-last",
  	"esnext.typed-array.find-last-index",
  	"esnext.typed-array.unique-by",
  	"esnext.weak-map.delete-all",
  	"esnext.weak-map.from",
  	"esnext.weak-map.of",
  	"esnext.weak-map.emplace",
  	"esnext.weak-map.upsert",
  	"esnext.weak-set.add-all",
  	"esnext.weak-set.delete-all",
  	"esnext.weak-set.from",
  	"esnext.weak-set.of",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web": [
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator",
  	"web.immediate",
  	"web.queue-microtask",
  	"web.timers",
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web/dom-collections": [
  	"web.dom-collections.for-each",
  	"web.dom-collections.iterator"
  ],
  	"core-js/web/immediate": [
  	"web.immediate"
  ],
  	"core-js/web/queue-microtask": [
  	"web.queue-microtask"
  ],
  	"core-js/web/timers": [
  	"web.timers"
  ],
  	"core-js/web/url": [
  	"web.url",
  	"web.url.to-json",
  	"web.url-search-params"
  ],
  	"core-js/web/url-search-params": [
  	"web.url-search-params"
  ]
  };

  var entries$1 = require$$0$2;

  var corejs3ShippedProposalsList$1 = new Set(["esnext.global-this", "esnext.string.match-all"]);
  var polyfillsOrder$1 = {};
  Object.keys(data$1).forEach(function (name, index) {
    polyfillsOrder$1[name] = index;
  });

  var define$2 = function define(pure, global, name, exclude) {
    if (name === void 0) {
      name = global[0];
    }

    return {
      name: name,
      pure: pure,
      global: global.sort(function (a, b) {
        return polyfillsOrder$1[a] - polyfillsOrder$1[b];
      }),
      exclude: exclude
    };
  };

  var typed$1 = function typed(name) {
    return define$2(null, [name].concat(TypedArrayDependencies$1));
  };

  var ArrayNatureIterators$2 = ["es.array.iterator", "web.dom-collections.iterator"];
  var CommonIterators$2 = ["es.string.iterator"].concat(ArrayNatureIterators$2);
  var ArrayNatureIteratorsWithTag$1 = ["es.object.to-string"].concat(ArrayNatureIterators$2);
  var CommonIteratorsWithTag$1 = ["es.object.to-string"].concat(_toConsumableArray(CommonIterators$2));
  var TypedArrayDependencies$1 = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
  var TypedArrayStaticMethods$1 = {
    from: define$2(null, ["es.typed-array.from"]),
    of: define$2(null, ["es.typed-array.of"])
  };
  var PromiseDependencies$2 = ["es.promise", "es.object.to-string"];
  var PromiseDependenciesWithIterators$1 = [].concat(PromiseDependencies$2, _toConsumableArray(CommonIterators$2));
  var SymbolDependencies$1 = ["es.symbol", "es.symbol.description", "es.object.to-string"];
  var MapDependencies$1 = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
  var SetDependencies$1 = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
  var WeakMapDependencies$1 = ["es.weak-map", "esnext.weak-map.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
  var WeakSetDependencies$1 = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
  var URLSearchParamsDependencies$1 = ["web.url"].concat(_toConsumableArray(CommonIteratorsWithTag$1));
  var BuiltIns$2 = {
    AggregateError: define$2("aggregate-error", ["esnext.aggregate-error"].concat(_toConsumableArray(CommonIterators$2))),
    ArrayBuffer: define$2(null, ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"]),
    DataView: define$2(null, ["es.data-view", "es.array-buffer.slice", "es.object.to-string"]),
    Date: define$2(null, ["es.date.to-string"]),
    Float32Array: typed$1("es.typed-array.float32-array"),
    Float64Array: typed$1("es.typed-array.float64-array"),
    Int8Array: typed$1("es.typed-array.int8-array"),
    Int16Array: typed$1("es.typed-array.int16-array"),
    Int32Array: typed$1("es.typed-array.int32-array"),
    Uint8Array: typed$1("es.typed-array.uint8-array"),
    Uint8ClampedArray: typed$1("es.typed-array.uint8-clamped-array"),
    Uint16Array: typed$1("es.typed-array.uint16-array"),
    Uint32Array: typed$1("es.typed-array.uint32-array"),
    Map: define$2("map/index", MapDependencies$1),
    Number: define$2(null, ["es.number.constructor"]),
    Observable: define$2("observable/index", ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(_toConsumableArray(CommonIteratorsWithTag$1))),
    Promise: define$2("promise/index", PromiseDependencies$2),
    RegExp: define$2(null, ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"]),
    Set: define$2("set/index", SetDependencies$1),
    Symbol: define$2("symbol/index", SymbolDependencies$1),
    URL: define$2("url/index", ["web.url"].concat(_toConsumableArray(URLSearchParamsDependencies$1))),
    URLSearchParams: define$2("url-search-params/index", URLSearchParamsDependencies$1),
    WeakMap: define$2("weak-map/index", WeakMapDependencies$1),
    WeakSet: define$2("weak-set/index", WeakSetDependencies$1),
    clearImmediate: define$2("clear-immediate", ["web.immediate"]),
    compositeKey: define$2("composite-key", ["esnext.composite-key"]),
    compositeSymbol: define$2("composite-symbol", ["esnext.composite-symbol"]),
    fetch: define$2(null, PromiseDependencies$2),
    globalThis: define$2("global-this", ["es.global-this"]),
    parseFloat: define$2("parse-float", ["es.parse-float"]),
    parseInt: define$2("parse-int", ["es.parse-int"]),
    queueMicrotask: define$2("queue-microtask", ["web.queue-microtask"]),
    setImmediate: define$2("set-immediate", ["web.immediate"]),
    setInterval: define$2("set-interval", ["web.timers"]),
    setTimeout: define$2("set-timeout", ["web.timers"])
  };
  var StaticProperties$2 = {
    Array: {
      from: define$2("array/from", ["es.array.from", "es.string.iterator"]),
      isArray: define$2("array/is-array", ["es.array.is-array"]),
      of: define$2("array/of", ["es.array.of"])
    },
    ArrayBuffer: {
      isView: define$2(null, ["es.array-buffer.is-view"])
    },
    Date: {
      now: define$2("date/now", ["es.date.now"])
    },
    JSON: {
      stringify: define$2("json/stringify", [], "es.symbol")
    },
    Math: {
      DEG_PER_RAD: define$2("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
      RAD_PER_DEG: define$2("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
      acosh: define$2("math/acosh", ["es.math.acosh"]),
      asinh: define$2("math/asinh", ["es.math.asinh"]),
      atanh: define$2("math/atanh", ["es.math.atanh"]),
      cbrt: define$2("math/cbrt", ["es.math.cbrt"]),
      clamp: define$2("math/clamp", ["esnext.math.clamp"]),
      clz32: define$2("math/clz32", ["es.math.clz32"]),
      cosh: define$2("math/cosh", ["es.math.cosh"]),
      degrees: define$2("math/degrees", ["esnext.math.degrees"]),
      expm1: define$2("math/expm1", ["es.math.expm1"]),
      fround: define$2("math/fround", ["es.math.fround"]),
      fscale: define$2("math/fscale", ["esnext.math.fscale"]),
      hypot: define$2("math/hypot", ["es.math.hypot"]),
      iaddh: define$2("math/iaddh", ["esnext.math.iaddh"]),
      imul: define$2("math/imul", ["es.math.imul"]),
      imulh: define$2("math/imulh", ["esnext.math.imulh"]),
      isubh: define$2("math/isubh", ["esnext.math.isubh"]),
      log10: define$2("math/log10", ["es.math.log10"]),
      log1p: define$2("math/log1p", ["es.math.log1p"]),
      log2: define$2("math/log2", ["es.math.log2"]),
      radians: define$2("math/radians", ["esnext.math.radians"]),
      scale: define$2("math/scale", ["esnext.math.scale"]),
      seededPRNG: define$2("math/seeded-prng", ["esnext.math.seeded-prng"]),
      sign: define$2("math/sign", ["es.math.sign"]),
      signbit: define$2("math/signbit", ["esnext.math.signbit"]),
      sinh: define$2("math/sinh", ["es.math.sinh"]),
      tanh: define$2("math/tanh", ["es.math.tanh"]),
      trunc: define$2("math/trunc", ["es.math.trunc"]),
      umulh: define$2("math/umulh", ["esnext.math.umulh"])
    },
    Map: {
      from: define$2(null, ["esnext.map.from"].concat(_toConsumableArray(MapDependencies$1))),
      groupBy: define$2(null, ["esnext.map.group-by"].concat(_toConsumableArray(MapDependencies$1))),
      keyBy: define$2(null, ["esnext.map.key-by"].concat(_toConsumableArray(MapDependencies$1))),
      of: define$2(null, ["esnext.map.of"].concat(_toConsumableArray(MapDependencies$1)))
    },
    Number: {
      EPSILON: define$2("number/epsilon", ["es.number.epsilon"]),
      MAX_SAFE_INTEGER: define$2("number/max-safe-integer", ["es.number.max-safe-integer"]),
      MIN_SAFE_INTEGER: define$2("number/min-safe-integer", ["es.number.min-safe-integer"]),
      fromString: define$2("number/from-string", ["esnext.number.from-string"]),
      isFinite: define$2("number/is-finite", ["es.number.is-finite"]),
      isInteger: define$2("number/is-integer", ["es.number.is-integer"]),
      isNaN: define$2("number/is-nan", ["es.number.is-nan"]),
      isSafeInteger: define$2("number/is-safe-integer", ["es.number.is-safe-integer"]),
      parseFloat: define$2("number/parse-float", ["es.number.parse-float"]),
      parseInt: define$2("number/parse-int", ["es.number.parse-int"])
    },
    Object: {
      assign: define$2("object/assign", ["es.object.assign"]),
      create: define$2("object/create", ["es.object.create"]),
      defineProperties: define$2("object/define-properties", ["es.object.define-properties"]),
      defineProperty: define$2("object/define-property", ["es.object.define-property"]),
      entries: define$2("object/entries", ["es.object.entries"]),
      freeze: define$2("object/freeze", ["es.object.freeze"]),
      fromEntries: define$2("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
      getOwnPropertyDescriptor: define$2("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
      getOwnPropertyDescriptors: define$2("object/get-own-property-descriptors", ["es.object.get-own-property-descriptors"]),
      getOwnPropertyNames: define$2("object/get-own-property-names", ["es.object.get-own-property-names"]),
      getOwnPropertySymbols: define$2("object/get-own-property-symbols", ["es.symbol"]),
      getPrototypeOf: define$2("object/get-prototype-of", ["es.object.get-prototype-of"]),
      is: define$2("object/is", ["es.object.is"]),
      isExtensible: define$2("object/is-extensible", ["es.object.is-extensible"]),
      isFrozen: define$2("object/is-frozen", ["es.object.is-frozen"]),
      isSealed: define$2("object/is-sealed", ["es.object.is-sealed"]),
      keys: define$2("object/keys", ["es.object.keys"]),
      preventExtensions: define$2("object/prevent-extensions", ["es.object.prevent-extensions"]),
      seal: define$2("object/seal", ["es.object.seal"]),
      setPrototypeOf: define$2("object/set-prototype-of", ["es.object.set-prototype-of"]),
      values: define$2("object/values", ["es.object.values"])
    },
    Promise: {
      all: define$2(null, PromiseDependenciesWithIterators$1),
      allSettled: define$2(null, ["es.promise.all-settled"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
      any: define$2(null, ["esnext.promise.any"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1))),
      race: define$2(null, PromiseDependenciesWithIterators$1),
      "try": define$2(null, ["esnext.promise.try"].concat(_toConsumableArray(PromiseDependenciesWithIterators$1)))
    },
    Reflect: {
      apply: define$2("reflect/apply", ["es.reflect.apply"]),
      construct: define$2("reflect/construct", ["es.reflect.construct"]),
      defineMetadata: define$2("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
      defineProperty: define$2("reflect/define-property", ["es.reflect.define-property"]),
      deleteMetadata: define$2("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
      deleteProperty: define$2("reflect/delete-property", ["es.reflect.delete-property"]),
      get: define$2("reflect/get", ["es.reflect.get"]),
      getMetadata: define$2("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
      getMetadataKeys: define$2("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
      getOwnMetadata: define$2("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
      getOwnMetadataKeys: define$2("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
      getOwnPropertyDescriptor: define$2("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
      getPrototypeOf: define$2("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
      has: define$2("reflect/has", ["es.reflect.has"]),
      hasMetadata: define$2("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
      hasOwnMetadata: define$2("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
      isExtensible: define$2("reflect/is-extensible", ["es.reflect.is-extensible"]),
      metadata: define$2("reflect/metadata", ["esnext.reflect.metadata"]),
      ownKeys: define$2("reflect/own-keys", ["es.reflect.own-keys"]),
      preventExtensions: define$2("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
      set: define$2("reflect/set", ["es.reflect.set"]),
      setPrototypeOf: define$2("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
    },
    Set: {
      from: define$2(null, ["esnext.set.from"].concat(_toConsumableArray(SetDependencies$1))),
      of: define$2(null, ["esnext.set.of"].concat(_toConsumableArray(SetDependencies$1)))
    },
    String: {
      fromCodePoint: define$2("string/from-code-point", ["es.string.from-code-point"]),
      raw: define$2("string/raw", ["es.string.raw"])
    },
    Symbol: {
      asyncIterator: define$2("symbol/async-iterator", ["es.symbol.async-iterator"]),
      dispose: define$2("symbol/dispose", ["esnext.symbol.dispose"]),
      "for": define$2("symbol/for", [], "es.symbol"),
      hasInstance: define$2("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
      isConcatSpreadable: define$2("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
      iterator: define$2("symbol/iterator", ["es.symbol.iterator"].concat(_toConsumableArray(CommonIteratorsWithTag$1))),
      keyFor: define$2("symbol/key-for", [], "es.symbol"),
      match: define$2("symbol/match", ["es.symbol.match", "es.string.match"]),
      observable: define$2("symbol/observable", ["esnext.symbol.observable"]),
      patternMatch: define$2("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
      replace: define$2("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
      search: define$2("symbol/search", ["es.symbol.search", "es.string.search"]),
      species: define$2("symbol/species", ["es.symbol.species", "es.array.species"]),
      split: define$2("symbol/split", ["es.symbol.split", "es.string.split"]),
      toPrimitive: define$2("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
      toStringTag: define$2("symbol/to-string-tag", ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"]),
      unscopables: define$2("symbol/unscopables", ["es.symbol.unscopables"])
    },
    WeakMap: {
      from: define$2(null, ["esnext.weak-map.from"].concat(_toConsumableArray(WeakMapDependencies$1))),
      of: define$2(null, ["esnext.weak-map.of"].concat(_toConsumableArray(WeakMapDependencies$1)))
    },
    WeakSet: {
      from: define$2(null, ["esnext.weak-set.from"].concat(_toConsumableArray(WeakSetDependencies$1))),
      of: define$2(null, ["esnext.weak-set.of"].concat(_toConsumableArray(WeakSetDependencies$1)))
    },
    Int8Array: TypedArrayStaticMethods$1,
    Uint8Array: TypedArrayStaticMethods$1,
    Uint8ClampedArray: TypedArrayStaticMethods$1,
    Int16Array: TypedArrayStaticMethods$1,
    Uint16Array: TypedArrayStaticMethods$1,
    Int32Array: TypedArrayStaticMethods$1,
    Uint32Array: TypedArrayStaticMethods$1,
    Float32Array: TypedArrayStaticMethods$1,
    Float64Array: TypedArrayStaticMethods$1
  };
  var InstanceProperties$2 = {
    at: define$2("instance/at", ["esnext.string.at"]),
    anchor: define$2(null, ["es.string.anchor"]),
    big: define$2(null, ["es.string.big"]),
    bind: define$2("instance/bind", ["es.function.bind"]),
    blink: define$2(null, ["es.string.blink"]),
    bold: define$2(null, ["es.string.bold"]),
    codePointAt: define$2("instance/code-point-at", ["es.string.code-point-at"]),
    codePoints: define$2("instance/code-points", ["esnext.string.code-points"]),
    concat: define$2("instance/concat", ["es.array.concat"], undefined, ["String"]),
    copyWithin: define$2("instance/copy-within", ["es.array.copy-within"]),
    description: define$2(null, ["es.symbol", "es.symbol.description"]),
    endsWith: define$2("instance/ends-with", ["es.string.ends-with"]),
    entries: define$2("instance/entries", ArrayNatureIteratorsWithTag$1),
    every: define$2("instance/every", ["es.array.every"]),
    exec: define$2(null, ["es.regexp.exec"]),
    fill: define$2("instance/fill", ["es.array.fill"]),
    filter: define$2("instance/filter", ["es.array.filter"]),
    "finally": define$2(null, ["es.promise.finally"].concat(PromiseDependencies$2)),
    find: define$2("instance/find", ["es.array.find"]),
    findIndex: define$2("instance/find-index", ["es.array.find-index"]),
    fixed: define$2(null, ["es.string.fixed"]),
    flags: define$2("instance/flags", ["es.regexp.flags"]),
    flatMap: define$2("instance/flat-map", ["es.array.flat-map", "es.array.unscopables.flat-map"]),
    flat: define$2("instance/flat", ["es.array.flat"]),
    fontcolor: define$2(null, ["es.string.fontcolor"]),
    fontsize: define$2(null, ["es.string.fontsize"]),
    forEach: define$2("instance/for-each", ["es.array.for-each", "web.dom-collections.for-each"]),
    includes: define$2("instance/includes", ["es.array.includes", "es.string.includes"]),
    indexOf: define$2("instance/index-of", ["es.array.index-of"]),
    italic: define$2(null, ["es.string.italics"]),
    join: define$2(null, ["es.array.join"]),
    keys: define$2("instance/keys", ArrayNatureIteratorsWithTag$1),
    lastIndex: define$2(null, ["esnext.array.last-index"]),
    lastIndexOf: define$2("instance/last-index-of", ["es.array.last-index-of"]),
    lastItem: define$2(null, ["esnext.array.last-item"]),
    link: define$2(null, ["es.string.link"]),
    map: define$2("instance/map", ["es.array.map"]),
    match: define$2(null, ["es.string.match", "es.regexp.exec"]),
    matchAll: define$2("instance/match-all", ["es.string.match-all"]),
    name: define$2(null, ["es.function.name"]),
    padEnd: define$2("instance/pad-end", ["es.string.pad-end"]),
    padStart: define$2("instance/pad-start", ["es.string.pad-start"]),
    reduce: define$2("instance/reduce", ["es.array.reduce"]),
    reduceRight: define$2("instance/reduce-right", ["es.array.reduce-right"]),
    repeat: define$2("instance/repeat", ["es.string.repeat"]),
    replace: define$2(null, ["es.string.replace", "es.regexp.exec"]),
    replaceAll: define$2("instance/replace-all", ["esnext.string.replace-all"]),
    reverse: define$2("instance/reverse", ["es.array.reverse"]),
    search: define$2(null, ["es.string.search", "es.regexp.exec"]),
    slice: define$2("instance/slice", ["es.array.slice"]),
    small: define$2(null, ["es.string.small"]),
    some: define$2("instance/some", ["es.array.some"]),
    sort: define$2("instance/sort", ["es.array.sort"]),
    splice: define$2("instance/splice", ["es.array.splice"]),
    split: define$2(null, ["es.string.split", "es.regexp.exec"]),
    startsWith: define$2("instance/starts-with", ["es.string.starts-with"]),
    strike: define$2(null, ["es.string.strike"]),
    sub: define$2(null, ["es.string.sub"]),
    sup: define$2(null, ["es.string.sup"]),
    toFixed: define$2(null, ["es.number.to-fixed"]),
    toISOString: define$2(null, ["es.date.to-iso-string"]),
    toJSON: define$2(null, ["es.date.to-json", "web.url.to-json"]),
    toPrecision: define$2(null, ["es.number.to-precision"]),
    toString: define$2(null, ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"]),
    trim: define$2("instance/trim", ["es.string.trim"]),
    trimEnd: define$2("instance/trim-end", ["es.string.trim-end"]),
    trimLeft: define$2("instance/trim-left", ["es.string.trim-start"]),
    trimRight: define$2("instance/trim-right", ["es.string.trim-end"]),
    trimStart: define$2("instance/trim-start", ["es.string.trim-start"]),
    values: define$2("instance/values", ArrayNatureIteratorsWithTag$1),
    __defineGetter__: define$2(null, ["es.object.define-getter"]),
    __defineSetter__: define$2(null, ["es.object.define-setter"]),
    __lookupGetter__: define$2(null, ["es.object.lookup-getter"]),
    __lookupSetter__: define$2(null, ["es.object.lookup-setter"])
  };
  var CommonInstanceDependencies$1 = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);

  var _ref$3 = undefined || babel,
      t$1$2 = _ref$3.types;

  function callMethod$1(path, id) {
    var object = path.node.object;
    var context1, context2;

    if (t$1$2.isIdentifier(object)) {
      context1 = object;
      context2 = t$1$2.cloneNode(object);
    } else {
      context1 = path.scope.generateDeclaredUidIdentifier("context");
      context2 = t$1$2.assignmentExpression("=", t$1$2.cloneNode(context1), object);
    }

    path.replaceWith(t$1$2.memberExpression(t$1$2.callExpression(id, [context2]), t$1$2.identifier("call")));
    path.parentPath.unshiftContainer("arguments", context1);
  }

  function isCoreJSSource$1(source) {
    if (typeof source === "string") {
      source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
    }

    return hasOwnProperty.call(entries$1, source) && entries$1[source];
  }

  function coreJSModule$1(name) {
    return "core-js/modules/" + name + ".js";
  }

  function coreJSPureHelper$1(name, useBabelRuntime, ext) {
    return useBabelRuntime ? useBabelRuntime + "/core-js/" + name + ext : "core-js-pure/features/" + name + ".js";
  }

  var _ref2$1 = undefined || babel,
      t$4 = _ref2$1.types;

  var runtimeCompat$4 = "#__secret_key__@babel/runtime__compatibility";

  var esnextFallback$1 = function esnextFallback(name, cb) {
    if (cb(name)) return true;
    if (!name.startsWith("es.")) return false;
    var fallback = "esnext." + name.slice(3);
    if (!data$1[fallback]) return false;
    return cb(fallback);
  };

  var index$4 = definePolyfillProvider$1(function (_ref3, _ref4) {
    var getUtils = _ref3.getUtils,
        method = _ref3.method,
        shouldInjectPolyfill = _ref3.shouldInjectPolyfill,
        createMetaResolver = _ref3.createMetaResolver,
        debug = _ref3.debug,
        babel = _ref3.babel;
    var _ref4$version = _ref4.version,
        version = _ref4$version === void 0 ? 3 : _ref4$version,
        proposals = _ref4.proposals,
        shippedProposals = _ref4.shippedProposals,
        _ref4$runtimeCompat = _ref4[runtimeCompat$4];
    _ref4$runtimeCompat = _ref4$runtimeCompat === void 0 ? {} : _ref4$runtimeCompat;
    var useBabelRuntime = _ref4$runtimeCompat.useBabelRuntime,
        _ref4$runtimeCompat$e = _ref4$runtimeCompat.ext,
        ext = _ref4$runtimeCompat$e === void 0 ? ".js" : _ref4$runtimeCompat$e;
    var isWebpack = babel.caller(function (caller) {
      return (caller == null ? void 0 : caller.name) === "babel-loader";
    });
    var resolve = createMetaResolver({
      global: BuiltIns$2,
      "static": StaticProperties$2,
      instance: InstanceProperties$2
    });
    var available = new Set(getModulesListForTargetVersion$1(version));
    var coreJSPureBase = useBabelRuntime ? proposals ? useBabelRuntime + "/core-js" : useBabelRuntime + "/core-js-stable" : proposals ? "core-js-pure/features" : "core-js-pure/stable";

    function maybeInjectGlobalImpl(name, utils) {
      if (shouldInjectPolyfill(name)) {
        debug(name);
        utils.injectGlobalImport(coreJSModule$1(name));
        return true;
      }

      return false;
    }

    function maybeInjectGlobal(names, utils, fallback) {
      if (fallback === void 0) {
        fallback = true;
      }

      for (var _iterator = _createForOfIteratorHelperLoose(names), _step; !(_step = _iterator()).done;) {
        var name = _step.value;

        if (fallback) {
          esnextFallback$1(name, function (name) {
            return maybeInjectGlobalImpl(name, utils);
          });
        } else {
          maybeInjectGlobalImpl(name, utils);
        }
      }
    }

    function maybeInjectPure(desc, hint, utils, object) {
      if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback$1(desc.name, shouldInjectPolyfill)) {
        return utils.injectDefaultImport(coreJSPureBase + "/" + desc.pure + ext, hint);
      }
    }

    return {
      name: "corejs3",
      polyfills: data$1,
      filterPolyfills: function filterPolyfills(name) {
        if (!available.has(name)) return false;
        if (proposals || method === "entry-global") return true;

        if (shippedProposals && corejs3ShippedProposalsList$1.has(name)) {
          return true;
        }

        return !name.startsWith("esnext.");
      },
      entryGlobal: function entryGlobal(meta, utils, path) {
        if (meta.kind !== "import") return;
        var modules = isCoreJSSource$1(meta.source);
        if (!modules) return;

        if (modules.length === 1 && meta.source === coreJSModule$1(modules[0]) && shouldInjectPolyfill(modules[0])) {
          debug(null);
          return;
        }

        maybeInjectGlobal(modules, utils, false);
        path.remove();
      },
      usageGlobal: function usageGlobal(meta, utils) {
        var resolved = resolve(meta);
        if (!resolved) return;
        var deps = resolved.desc.global;

        if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
          var low = meta.object.toLowerCase();
          deps = deps.filter(function (m) {
            return m.includes(low) || CommonInstanceDependencies$1.has(m);
          });
        }

        maybeInjectGlobal(deps, utils);
      },
      usagePure: function usagePure(meta, utils, path) {
        if (meta.kind === "in") {
          if (meta.key === "Symbol.iterator") {
            path.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("is-iterable", useBabelRuntime, ext), "isIterable"), [path.node.right]));
          }

          return;
        }

        if (path.parentPath.isUnaryExpression({
          operator: "delete"
        })) return;
        var isCall;

        if (meta.kind === "property") {
          if (!path.isMemberExpression()) return;
          if (!path.isReferenced()) return;
          isCall = path.parentPath.isCallExpression({
            callee: path.node
          });

          if (meta.key === "Symbol.iterator") {
            if (!shouldInjectPolyfill("es.symbol.iterator")) return;

            if (isCall) {
              if (path.parent.arguments.length === 0) {
                path.parentPath.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("get-iterator", useBabelRuntime, ext), "getIterator"), [path.node.object]));
                path.skip();
              } else {
                callMethod$1(path, utils.injectDefaultImport(coreJSPureHelper$1("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"));
              }
            } else {
              path.replaceWith(t$4.callExpression(utils.injectDefaultImport(coreJSPureHelper$1("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [path.node.object]));
            }

            return;
          }
        }

        var resolved = resolve(meta);
        if (!resolved) return;

        if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index") {
          resolved = Object.assign(Object.assign({}, resolved), {}, {
            desc: Object.assign(Object.assign({}, resolved.desc), {}, {
              pure: resolved.desc.pure.slice(0, -6)
            })
          });
        }

        if (resolved.kind === "global") {
          var id = maybeInjectPure(resolved.desc, resolved.name, utils);
          if (id) path.replaceWith(id);
        } else if (resolved.kind === "static") {
          var _id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);

          if (_id) path.replaceWith(_id);
        } else if (resolved.kind === "instance") {
          var _id2 = maybeInjectPure(resolved.desc, resolved.name + "InstanceProperty", utils, meta.object);

          if (!_id2) return;

          if (isCall) {
            callMethod$1(path, _id2);
          } else {
            path.replaceWith(t$4.callExpression(_id2, [path.node.object]));
          }
        }
      },
      visitor: method === "usage-global" && {
        CallExpression: function CallExpression(path) {
          if (path.get("callee").isImport()) {
            var utils = getUtils(path);

            if (isWebpack) {
              maybeInjectGlobal(PromiseDependenciesWithIterators$1, utils);
            } else {
              maybeInjectGlobal(PromiseDependencies$2, utils);
            }
          }
        },
        Function: function Function(path) {
          if (path.node.async) {
            maybeInjectGlobal(PromiseDependencies$2, getUtils(path));
          }
        },
        "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
          maybeInjectGlobal(CommonIterators$2, getUtils(path));
        },
        SpreadElement: function SpreadElement(path) {
          if (!path.parentPath.isObjectExpression()) {
            maybeInjectGlobal(CommonIterators$2, getUtils(path));
          }
        },
        YieldExpression: function YieldExpression(path) {
          if (path.node.delegate) {
            maybeInjectGlobal(CommonIterators$2, getUtils(path));
          }
        }
      }
    };
  });

  var runtimeCompat$3 = "#__secret_key__@babel/runtime__compatibility";
  var index$3 = definePolyfillProvider$1(function (_ref, options) {
    var debug = _ref.debug;
    var _options$runtimeCompa = options[runtimeCompat$3];
    _options$runtimeCompa = _options$runtimeCompa === void 0 ? {} : _options$runtimeCompa;
    var useBabelRuntime = _options$runtimeCompa.useBabelRuntime;
    var pureName = useBabelRuntime ? useBabelRuntime + "/regenerator" : "regenerator-runtime";
    return {
      name: "regenerator",
      polyfills: ["regenerator-runtime"],
      usageGlobal: function usageGlobal(meta, utils) {
        if (isRegenerator$1(meta)) {
          debug("regenerator-runtime");
          utils.injectGlobalImport("regenerator-runtime/runtime.js");
        }
      },
      usagePure: function usagePure(meta, utils, path) {
        if (isRegenerator$1(meta)) {
          path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
        }
      }
    };
  });

  var isRegenerator$1 = function isRegenerator(meta) {
    return meta.kind === "global" && meta.name === "regeneratorRuntime";
  };

  var pluginCorejs2 = index$5["default"] || index$5;
  var pluginCorejs3 = index$4["default"] || index$4;
  var pluginRegenerator$1 = index$3["default"] || index$3;
  var pluginsCompat = "#__secret_key__@babel/runtime__compatibility";

  function supportsStaticESM$1(caller) {
    return !!(caller != null && caller.supportsStaticESM);
  }

  var transformRuntime = declare(function (api, options, dirname) {
    var _createCorejsPlgin, _createRegeneratorPlu, _createCorejsPlgin2, _createRegeneratorPlu2, _createRegeneratorPlu3;

    api.assertVersion(7);
    var corejs = options.corejs,
        _options$helpers = options.helpers,
        useRuntimeHelpers = _options$helpers === void 0 ? true : _options$helpers,
        _options$regenerator = options.regenerator,
        useRuntimeRegenerator = _options$regenerator === void 0 ? true : _options$regenerator,
        _options$useESModules = options.useESModules,
        useESModules = _options$useESModules === void 0 ? false : _options$useESModules,
        _options$version = options.version,
        runtimeVersion = _options$version === void 0 ? "7.0.0-beta.0" : _options$version,
        _options$absoluteRunt = options.absoluteRuntime,
        absoluteRuntime = _options$absoluteRunt === void 0 ? false : _options$absoluteRunt;
    var proposals = false;
    var rawVersion;

    if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var corejsVersion = rawVersion ? Number(rawVersion) : false;

    if (![false, 2, 3].includes(corejsVersion)) {
      throw new Error("The `core-js` version must be false, 2 or 3, but got " + JSON.stringify(rawVersion) + ".");
    }

    if (proposals && (!corejsVersion || corejsVersion < 3)) {
      throw new Error("The 'proposals' option is only supported when using 'corejs: 3'");
    }

    if (typeof useRuntimeRegenerator !== "boolean") {
      throw new Error("The 'regenerator' option must be undefined, or a boolean.");
    }

    if (typeof useRuntimeHelpers !== "boolean") {
      throw new Error("The 'helpers' option must be undefined, or a boolean.");
    }

    if (typeof useESModules !== "boolean" && useESModules !== "auto") {
      throw new Error("The 'useESModules' option must be undefined, or a boolean, or 'auto'.");
    }

    if (typeof absoluteRuntime !== "boolean" && typeof absoluteRuntime !== "string") {
      throw new Error("The 'absoluteRuntime' option must be undefined, a boolean, or a string.");
    }

    if (typeof runtimeVersion !== "string") {
      throw new Error("The 'version' option must be a version string.");
    }

    var DUAL_MODE_RUNTIME = "7.13.0";
    var supportsCJSDefault = hasMinVersion$2(DUAL_MODE_RUNTIME, runtimeVersion);

    function has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }

    if (has(options, "useBuiltIns")) {
      if (options.useBuiltIns) {
        throw new Error("The 'useBuiltIns' option has been removed. The @babel/runtime " + "module now uses builtins by default.");
      } else {
        throw new Error("The 'useBuiltIns' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "polyfill")) {
      if (options.polyfill === false) {
        throw new Error("The 'polyfill' option has been removed. The @babel/runtime " + "module now skips polyfilling by default.");
      } else {
        throw new Error("The 'polyfill' option has been removed. Use the 'corejs'" + "option to polyfill with `core-js` via @babel/runtime.");
      }
    }

    if (has(options, "moduleName")) {
      throw new Error("The 'moduleName' option has been removed. @babel/transform-runtime " + "no longer supports arbitrary runtimes. If you were using this to " + "set an absolute path for Babel's standard runtimes, please use the " + "'absoluteRuntime' option.");
    }

    var esModules = useESModules === "auto" ? api.caller(supportsStaticESM$1) : useESModules;
    var injectCoreJS2 = corejsVersion === 2;
    var injectCoreJS3 = corejsVersion === 3;
    var moduleName = injectCoreJS3 ? "@babel/runtime-corejs3" : injectCoreJS2 ? "@babel/runtime-corejs2" : "@babel/runtime";
    var HEADER_HELPERS = ["interopRequireWildcard", "interopRequireDefault"];
    var modulePath = getRuntimePath(moduleName, dirname, absoluteRuntime);

    function createCorejsPlgin(plugin, options, regeneratorPlugin) {
      return function (api, _, filename) {
        return Object.assign({}, plugin(api, options, filename), {
          inherits: regeneratorPlugin
        });
      };
    }

    function createRegeneratorPlugin(options) {
      if (!useRuntimeRegenerator) return undefined;
      return function (api, _, filename) {
        return pluginRegenerator$1(api, options, filename);
      };
    }

    var corejsExt = absoluteRuntime ? ".js" : "";
    return {
      name: "transform-runtime",
      inherits: injectCoreJS2 ? createCorejsPlgin(pluginCorejs2, (_createCorejsPlgin = {
        method: "usage-pure"
      }, _createCorejsPlgin[pluginsCompat] = {
        runtimeVersion: runtimeVersion,
        useBabelRuntime: modulePath,
        ext: corejsExt
      }, _createCorejsPlgin), createRegeneratorPlugin((_createRegeneratorPlu = {
        method: "usage-pure"
      }, _createRegeneratorPlu[pluginsCompat] = {
        useBabelRuntime: modulePath
      }, _createRegeneratorPlu))) : injectCoreJS3 ? createCorejsPlgin(pluginCorejs3, (_createCorejsPlgin2 = {
        method: "usage-pure",
        version: 3,
        proposals: proposals
      }, _createCorejsPlgin2[pluginsCompat] = {
        useBabelRuntime: modulePath,
        ext: corejsExt
      }, _createCorejsPlgin2), createRegeneratorPlugin((_createRegeneratorPlu2 = {
        method: "usage-pure"
      }, _createRegeneratorPlu2[pluginsCompat] = {
        useBabelRuntime: modulePath
      }, _createRegeneratorPlu2))) : createRegeneratorPlugin((_createRegeneratorPlu3 = {
        method: "usage-pure"
      }, _createRegeneratorPlu3[pluginsCompat] = {
        useBabelRuntime: modulePath
      }, _createRegeneratorPlu3)),
      pre: function pre(file) {
        if (!useRuntimeHelpers) return;
        file.set("helperGenerator", function (name) {
          if (file.availableHelper && !file.availableHelper(name, runtimeVersion)) {
            return;
          }

          var isInteropHelper = HEADER_HELPERS.indexOf(name) !== -1;
          var blockHoist = isInteropHelper && !isModule(file.path) ? 4 : undefined;
          var helpersDir = esModules && file.path.node.sourceType === "module" ? "helpers/esm" : "helpers";
          return addDefaultImport(modulePath + "/" + helpersDir + "/" + name, name, blockHoist, true);
        });
        var cache = new Map();

        function addDefaultImport(source, nameHint, blockHoist, isHelper) {
          if (isHelper === void 0) {
            isHelper = false;
          }

          var cacheKey = isModule(file.path);
          var key = source + ":" + nameHint + ":" + (cacheKey || "");
          var cached = cache.get(key);

          if (cached) {
            cached = cloneNode(cached);
          } else {
            cached = addDefault(file.path, source, {
              importedInterop: isHelper && supportsCJSDefault ? "compiled" : "uncompiled",
              nameHint: nameHint,
              blockHoist: blockHoist
            });
            cache.set(key, cached);
          }

          return cached;
        }
      }
    };
  });

  var _transformShorthandProperties = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-shorthand-properties",
      visitor: {
        ObjectMethod: function ObjectMethod(path) {
          var node = path.node;

          if (node.kind === "method") {
            var func = functionExpression(null, node.params, node.body, node.generator, node.async);
            func.returnType = node.returnType;
            var computedKey = toComputedKey$1(node);

            if (isStringLiteral(computedKey, {
              value: "__proto__"
            })) {
              path.replaceWith(objectProperty(computedKey, func, true));
            } else {
              path.replaceWith(objectProperty(node.key, func, node.computed));
            }
          }
        },
        ObjectProperty: function ObjectProperty(path) {
          var node = path.node;

          if (node.shorthand) {
            var computedKey = toComputedKey$1(node);

            if (isStringLiteral(computedKey, {
              value: "__proto__"
            })) {
              path.replaceWith(objectProperty(computedKey, node.value, true));
            } else {
              node.shorthand = false;
            }
          }
        }
      }
    };
  });

  var _transformSpread = declare(function (api, options) {
    var _api$assumption, _options$allowArrayLi;

    api.assertVersion(7);
    var iterableIsArray = (_api$assumption = api.assumption("iterableIsArray")) != null ? _api$assumption : options.loose;
    var arrayLikeIsIterable = (_options$allowArrayLi = options.allowArrayLike) != null ? _options$allowArrayLi : api.assumption("arrayLikeIsIterable");

    function getSpreadLiteral(spread, scope) {
      if (iterableIsArray && !isIdentifier(spread.argument, {
        name: "arguments"
      })) {
        return spread.argument;
      } else {
        return scope.toArray(spread.argument, true, arrayLikeIsIterable);
      }
    }

    function hasHole(spread) {
      return spread.elements.some(function (el) {
        return el === null;
      });
    }

    function hasSpread(nodes) {
      for (var i = 0; i < nodes.length; i++) {
        if (isSpreadElement(nodes[i])) {
          return true;
        }
      }

      return false;
    }

    function push(_props, nodes) {
      if (!_props.length) return _props;
      nodes.push(arrayExpression(_props));
      return [];
    }

    function build(props, scope, file) {
      var nodes = [];
      var _props = [];

      for (var _iterator = _createForOfIteratorHelperLoose(props), _step; !(_step = _iterator()).done;) {
        var prop = _step.value;

        if (isSpreadElement(prop)) {
          _props = push(_props, nodes);
          var spreadLiteral = getSpreadLiteral(prop, scope);

          if (isArrayExpression(spreadLiteral) && hasHole(spreadLiteral)) {
            spreadLiteral = callExpression(file.addHelper("arrayWithoutHoles"), [spreadLiteral]);
          }

          nodes.push(spreadLiteral);
        } else {
          _props.push(prop);
        }
      }

      push(_props, nodes);
      return nodes;
    }

    return {
      name: "transform-spread",
      visitor: {
        ArrayExpression: function ArrayExpression(path) {
          var node = path.node,
              scope = path.scope;
          var elements = node.elements;
          if (!hasSpread(elements)) return;
          var nodes = build(elements, scope, this);
          var first = nodes[0];

          if (nodes.length === 1 && first !== elements[0].argument) {
            path.replaceWith(first);
            return;
          }

          if (!isArrayExpression(first)) {
            first = arrayExpression([]);
          } else {
            nodes.shift();
          }

          path.replaceWith(callExpression(memberExpression(first, identifier("concat")), nodes));
        },
        CallExpression: function CallExpression(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var calleePath = skipTransparentExprWrappers(path.get("callee"));

          if (calleePath.isSuper()) {
            throw path.buildCodeFrameError("It's not possible to compile spread arguments in `super()` without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
          }

          var contextLiteral = scope.buildUndefinedNode();
          node.arguments = [];
          var nodes;

          if (args.length === 1 && args[0].argument.name === "arguments") {
            nodes = [args[0].argument];
          } else {
            nodes = build(args, scope, this);
          }

          var first = nodes.shift();

          if (nodes.length) {
            node.arguments.push(callExpression(memberExpression(first, identifier("concat")), nodes));
          } else {
            node.arguments.push(first);
          }

          var callee = calleePath.node;

          if (calleePath.isMemberExpression()) {
            var temp = scope.maybeGenerateMemoised(callee.object);

            if (temp) {
              callee.object = assignmentExpression("=", temp, callee.object);
              contextLiteral = temp;
            } else {
              contextLiteral = cloneNode(callee.object);
            }
          }

          node.callee = memberExpression(node.callee, identifier("apply"));

          if (isSuper(contextLiteral)) {
            contextLiteral = thisExpression();
          }

          node.arguments.unshift(cloneNode(contextLiteral));
        },
        NewExpression: function NewExpression(path) {
          var node = path.node,
              scope = path.scope;
          var args = node.arguments;
          if (!hasSpread(args)) return;
          var nodes = build(args, scope, this);
          var first = nodes.shift();

          if (nodes.length) {
            args = callExpression(memberExpression(first, identifier("concat")), nodes);
          } else {
            args = first;
          }

          path.replaceWith(callExpression(path.hub.addHelper("construct"), [node.callee, args]));
        }
      }
    };
  });

  var _transformStickyRegex = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-sticky-regex",
      visitor: {
        RegExpLiteral: function RegExpLiteral(path) {
          var node = path.node;
          if (!node.flags.includes("y")) return;
          path.replaceWith(newExpression(identifier("RegExp"), [stringLiteral(node.pattern), stringLiteral(node.flags)]));
        }
      }
    };
  });

  var transformStrictMode = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-strict-mode",
      visitor: {
        Program: function Program(path) {
          var node = path.node;

          for (var _i = 0, _arr = node.directives; _i < _arr.length; _i++) {
            var directive$1 = _arr[_i];
            if (directive$1.value.value === "use strict") return;
          }

          path.unshiftContainer("directives", directive(directiveLiteral("use strict")));
        }
      }
    };
  });

  var _templateObject$4;
  var _transformTemplateLiterals = declare(function (api, options) {
    var _api$assumption, _api$assumption2;

    api.assertVersion(7);
    var ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
    var mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
    var helperName = "taggedTemplateLiteral";
    if (mutableTemplateObject) helperName += "Loose";

    function buildConcatCallExpressions(items) {
      var avail = true;
      return items.reduce(function (left, right) {
        var canBeInserted = isLiteral(right);

        if (!canBeInserted && avail) {
          canBeInserted = true;
          avail = false;
        }

        if (canBeInserted && isCallExpression(left)) {
          left.arguments.push(right);
          return left;
        }

        return callExpression(memberExpression(left, identifier("concat")), [right]);
      });
    }

    return {
      name: "transform-template-literals",
      visitor: {
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          var node = path.node;
          var quasi = node.quasi;
          var strings = [];
          var raws = [];
          var isStringsRawEqual = true;

          for (var _i = 0, _arr = quasi.quasis; _i < _arr.length; _i++) {
            var elem = _arr[_i];
            var _elem$value = elem.value,
                raw = _elem$value.raw,
                cooked = _elem$value.cooked;
            var value = cooked == null ? path.scope.buildUndefinedNode() : stringLiteral(cooked);
            strings.push(value);
            raws.push(stringLiteral(raw));

            if (raw !== cooked) {
              isStringsRawEqual = false;
            }
          }

          var helperArgs = [arrayExpression(strings)];

          if (!isStringsRawEqual) {
            helperArgs.push(arrayExpression(raws));
          }

          var tmp = path.scope.generateUidIdentifier("templateObject");
          path.scope.getProgramParent().push({
            id: cloneNode(tmp)
          });
          path.replaceWith(callExpression(node.tag, [template$2.expression.ast(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose(["\n              ", " || (\n                ", " = ", "(", ")\n              )\n            "])), cloneNode(tmp), tmp, this.addHelper(helperName), helperArgs)].concat(_toConsumableArray(quasi.expressions))));
        },
        TemplateLiteral: function TemplateLiteral(path) {
          var nodes = [];
          var expressions = path.get("expressions");
          var index = 0;

          for (var _i2 = 0, _arr2 = path.node.quasis; _i2 < _arr2.length; _i2++) {
            var elem = _arr2[_i2];

            if (elem.value.cooked) {
              nodes.push(stringLiteral(elem.value.cooked));
            }

            if (index < expressions.length) {
              var expr = expressions[index++];
              var node = expr.node;

              if (!isStringLiteral(node, {
                value: ""
              })) {
                nodes.push(node);
              }
            }
          }

          if (!isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && isStringLiteral(nodes[1]))) {
            nodes.unshift(stringLiteral(""));
          }

          var root = nodes[0];

          if (ignoreToPrimitiveHint) {
            for (var i = 1; i < nodes.length; i++) {
              root = binaryExpression("+", root, nodes[i]);
            }
          } else if (nodes.length > 1) {
            root = buildConcatCallExpressions(nodes);
          }

          path.replaceWith(root);
        }
      }
    };
  });

  var _transformTypeofSymbol = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-typeof-symbol",
      visitor: {
        Scope: function Scope(_ref) {
          var scope = _ref.scope;

          if (!scope.getBinding("Symbol")) {
            return;
          }

          scope.rename("Symbol");
        },
        UnaryExpression: function UnaryExpression(path) {
          var node = path.node,
              parent = path.parent;
          if (node.operator !== "typeof") return;

          if (path.parentPath.isBinaryExpression() && EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {
            var opposite = path.getOpposite();

            if (opposite.isLiteral() && opposite.node.value !== "symbol" && opposite.node.value !== "object") {
              return;
            }
          }

          var isUnderHelper = path.findParent(function (path) {
            if (path.isFunction()) {
              var _path$get;

              return ((_path$get = path.get("body.directives.0")) == null ? void 0 : _path$get.node.value.value) === "@babel/helpers - typeof";
            }
          });
          if (isUnderHelper) return;
          var helper = this.addHelper("typeof");
          isUnderHelper = path.findParent(function (path) {
            return path.isVariableDeclarator() && path.node.id === helper || path.isFunctionDeclaration() && path.node.id && path.node.id.name === helper.name;
          });

          if (isUnderHelper) {
            return;
          }

          var call = callExpression(helper, [node.argument]);
          var arg = path.get("argument");

          if (arg.isIdentifier() && !path.scope.hasBinding(arg.node.name, true)) {
            var unary = unaryExpression("typeof", cloneNode(node.argument));
            path.replaceWith(conditionalExpression(binaryExpression("===", unary, stringLiteral("undefined")), stringLiteral("undefined"), call));
          } else {
            path.replaceWith(call);
          }
        }
      }
    };
  });

  function transpileEnum(path, t) {
    var node = path.node;

    if (node["const"]) {
      throw path.buildCodeFrameError("'const' enums are not supported.");
    }

    if (node.declare) {
      path.remove();
      return;
    }

    var name = node.id.name;
    var fill = enumFill(path, t, node.id);

    switch (path.parent.type) {
      case "BlockStatement":
      case "ExportNamedDeclaration":
      case "Program":
        {
          path.insertAfter(fill);

          if (seen(path.parentPath)) {
            path.remove();
          } else {
            var isGlobal = t.isProgram(path.parent);
            path.scope.registerDeclaration(path.replaceWith(makeVar(node.id, t, isGlobal ? "var" : "let"))[0]);
          }

          break;
        }

      default:
        throw new Error("Unexpected enum parent '" + path.parent.type);
    }

    function seen(parentPath) {
      if (parentPath.isExportDeclaration()) {
        return seen(parentPath.parentPath);
      }

      if (parentPath.getData(name)) {
        return true;
      } else {
        parentPath.setData(name, true);
        return false;
      }
    }
  }

  function makeVar(id, t, kind) {
    return t.variableDeclaration(kind, [t.variableDeclarator(id)]);
  }

  var buildEnumWrapper = template$2("\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n");
  var buildStringAssignment = template$2("\n  ENUM[\"NAME\"] = VALUE;\n");
  var buildNumericAssignment = template$2("\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n");

  var buildEnumMember = function buildEnumMember(isString, options) {
    return (isString ? buildStringAssignment : buildNumericAssignment)(options);
  };

  function enumFill(path, t, id) {
    var x = translateEnumValues(path, t);
    var assignments = x.map(function (_ref) {
      var _ref2 = _slicedToArray$2(_ref, 2),
          memberName = _ref2[0],
          memberValue = _ref2[1];

      return buildEnumMember(t.isStringLiteral(memberValue), {
        ENUM: t.cloneNode(id),
        NAME: memberName,
        VALUE: memberValue
      });
    });
    return buildEnumWrapper({
      ID: t.cloneNode(id),
      ASSIGNMENTS: assignments
    });
  }

  function translateEnumValues(path, t) {
    var seen = Object.create(null);
    var prev = -1;
    return path.node.members.map(function (member) {
      var name = t.isIdentifier(member.id) ? member.id.name : member.id.value;
      var initializer = member.initializer;
      var value;

      if (initializer) {
        var constValue = evaluate(initializer, seen);

        if (constValue !== undefined) {
          seen[name] = constValue;

          if (typeof constValue === "number") {
            value = t.numericLiteral(constValue);
            prev = constValue;
          } else {
            assert_1(typeof constValue === "string");
            value = t.stringLiteral(constValue);
            prev = undefined;
          }
        } else {
          value = initializer;
          prev = undefined;
        }
      } else {
        if (prev !== undefined) {
          prev++;
          value = t.numericLiteral(prev);
          seen[name] = prev;
        } else {
          throw path.buildCodeFrameError("Enum member must have initializer.");
        }
      }

      return [name, value];
    });
  }

  function evaluate(expr, seen) {
    return evalConstant(expr);

    function evalConstant(expr) {
      switch (expr.type) {
        case "StringLiteral":
          return expr.value;

        case "UnaryExpression":
          return evalUnaryExpression(expr);

        case "BinaryExpression":
          return evalBinaryExpression(expr);

        case "NumericLiteral":
          return expr.value;

        case "ParenthesizedExpression":
          return evalConstant(expr.expression);

        case "Identifier":
          return seen[expr.name];

        case "TemplateLiteral":
          if (expr.quasis.length === 1) {
            return expr.quasis[0].value.cooked;
          }

        default:
          return undefined;
      }
    }

    function evalUnaryExpression(_ref3) {
      var argument = _ref3.argument,
          operator = _ref3.operator;
      var value = evalConstant(argument);

      if (value === undefined) {
        return undefined;
      }

      switch (operator) {
        case "+":
          return value;

        case "-":
          return -value;

        case "~":
          return ~value;

        default:
          return undefined;
      }
    }

    function evalBinaryExpression(expr) {
      var left = evalConstant(expr.left);

      if (left === undefined) {
        return undefined;
      }

      var right = evalConstant(expr.right);

      if (right === undefined) {
        return undefined;
      }

      switch (expr.operator) {
        case "|":
          return left | right;

        case "&":
          return left & right;

        case ">>":
          return left >> right;

        case ">>>":
          return left >>> right;

        case "<<":
          return left << right;

        case "^":
          return left ^ right;

        case "*":
          return left * right;

        case "/":
          return left / right;

        case "+":
          return left + right;

        case "-":
          return left - right;

        case "%":
          return left % right;

        default:
          return undefined;
      }
    }
  }

  var _templateObject$3, _templateObject2$2;
  function transpileNamespace(path, t, allowNamespaces) {
    if (path.node.declare || path.node.id.type === "StringLiteral") {
      path.remove();
      return;
    }

    if (!allowNamespaces) {
      throw path.hub.file.buildCodeFrameError(path.node.id, "Namespace not marked type-only declare." + " Non-declarative namespaces are only supported experimentally in Babel." + " To enable and review caveats see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }

    var name = path.node.id.name;
    var value = handleNested(path, t, t.cloneDeep(path.node));
    var bound = path.scope.hasOwnBinding(name);

    if (path.parent.type === "ExportNamedDeclaration") {
      if (!bound) {
        path.parentPath.insertAfter(value);
        path.replaceWith(getDeclaration(t, name));
        path.scope.registerDeclaration(path.parentPath);
      } else {
        path.parentPath.replaceWith(value);
      }
    } else if (bound) {
      path.replaceWith(value);
    } else {
      path.scope.registerDeclaration(path.replaceWithMultiple([getDeclaration(t, name), value])[0]);
    }
  }

  function getDeclaration(t, name) {
    return t.variableDeclaration("let", [t.variableDeclarator(t.identifier(name))]);
  }

  function getMemberExpression(t, name, itemName) {
    return t.memberExpression(t.identifier(name), t.identifier(itemName));
  }

  function handleVariableDeclaration(node, name, hub) {
    if (node.kind !== "const") {
      throw hub.file.buildCodeFrameError(node, "Namespaces exporting non-const are not supported by Babel." + " Change to const or see:" + " https://babeljs.io/docs/en/babel-plugin-transform-typescript");
    }

    var declarations = node.declarations;

    if (declarations.every(function (declarator) {
      return isIdentifier(declarator.id);
    })) {
      for (var _iterator = _createForOfIteratorHelperLoose(declarations), _step; !(_step = _iterator()).done;) {
        var declarator = _step.value;
        declarator.init = assignmentExpression("=", getMemberExpression(t$p, name, declarator.id.name), declarator.init);
      }

      return [node];
    }

    var bindingIdentifiers = getBindingIdentifiers$1(node);
    var assignments = [];

    for (var idName in bindingIdentifiers) {
      assignments.push(assignmentExpression("=", getMemberExpression(t$p, name, idName), cloneNode(bindingIdentifiers[idName])));
    }

    return [node, expressionStatement(sequenceExpression(assignments))];
  }

  function handleNested(path, t, node, parentExport) {
    var names = new Set();
    var realName = node.id;
    var name = path.scope.generateUid(realName.name);
    var namespaceTopLevel = node.body.body;

    for (var i = 0; i < namespaceTopLevel.length; i++) {
      var subNode = namespaceTopLevel[i];

      switch (subNode.type) {
        case "TSModuleDeclaration":
          {
            var transformed = handleNested(path, t, subNode);
            var moduleName = subNode.id.name;

            if (names.has(moduleName)) {
              namespaceTopLevel[i] = transformed;
            } else {
              names.add(moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, moduleName), transformed);
            }

            continue;
          }

        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          names.add(subNode.id.name);
          continue;

        case "VariableDeclaration":
          {
            for (var _name in t.getBindingIdentifiers(subNode)) {
              names.add(_name);
            }

            continue;
          }

        default:
          continue;

        case "ExportNamedDeclaration":
      }

      switch (subNode.declaration.type) {
        case "TSEnumDeclaration":
        case "FunctionDeclaration":
        case "ClassDeclaration":
          {
            var itemName = subNode.declaration.id.name;
            names.add(itemName);
            namespaceTopLevel.splice(i++, 1, subNode.declaration, t.expressionStatement(t.assignmentExpression("=", getMemberExpression(t, name, itemName), t.identifier(itemName))));
            break;
          }

        case "VariableDeclaration":
          {
            var nodes = handleVariableDeclaration(subNode.declaration, name, path.hub);
            namespaceTopLevel.splice.apply(namespaceTopLevel, [i, nodes.length].concat(_toConsumableArray(nodes)));
            i += nodes.length - 1;
            break;
          }

        case "TSModuleDeclaration":
          {
            var _transformed = handleNested(path, t, subNode.declaration, t.identifier(name));

            var _moduleName = subNode.declaration.id.name;

            if (names.has(_moduleName)) {
              namespaceTopLevel[i] = _transformed;
            } else {
              names.add(_moduleName);
              namespaceTopLevel.splice(i++, 1, getDeclaration(t, _moduleName), _transformed);
            }
          }
      }
    }

    var fallthroughValue = t.objectExpression([]);

    if (parentExport) {
      var memberExpr = t.memberExpression(parentExport, realName);
      fallthroughValue = template$2.expression.ast(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose(["\n      ", " ||\n        (", " = ", ")\n    "])), t.cloneNode(memberExpr), t.cloneNode(memberExpr), fallthroughValue);
    }

    return template$2.statement.ast(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose(["\n    (function (", ") {\n      ", "\n    })(", " || (", " = ", "));\n  "])), t.identifier(name), namespaceTopLevel, realName, t.cloneNode(realName), fallthroughValue);
  }

  var _templateObject$2;

  function isInType(path) {
    switch (path.parent.type) {
      case "TSTypeReference":
      case "TSQualifiedName":
      case "TSExpressionWithTypeArguments":
      case "TSTypeQuery":
        return true;

      case "ExportSpecifier":
        return path.parentPath.parent.exportKind === "type";

      default:
        return false;
    }
  }

  var GLOBAL_TYPES = new WeakMap();
  var NEEDS_EXPLICIT_ESM = new WeakMap();
  var PARSED_PARAMS = new WeakSet();

  function isGlobalType(path, name) {
    var program = path.find(function (path) {
      return path.isProgram();
    }).node;
    if (path.scope.hasOwnBinding(name)) return false;
    if (GLOBAL_TYPES.get(program).has(name)) return true;
    console.warn("The exported identifier \"" + name + "\" is not declared in Babel's scope tracker\n" + "as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\n" + "never encountered it as a TypeScript type declaration.\n" + "It will be treated as a JavaScript value.\n\n" + "This problem is likely caused by another plugin injecting\n" + ("\"" + name + "\" without registering it in the scope tracker. If you are the author\n") + " of that plugin, please use \"scope.registerDeclaration(declarationPath)\".");
    return false;
  }

  function registerGlobalType(programScope, name) {
    GLOBAL_TYPES.get(programScope.path.node).add(name);
  }

  var transformTypeScript = declare(function (api, opts) {
    api.assertVersion(7);
    var JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+([^\s]+)/;
    var _opts$allowNamespaces = opts.allowNamespaces,
        allowNamespaces = _opts$allowNamespaces === void 0 ? true : _opts$allowNamespaces,
        _opts$jsxPragma = opts.jsxPragma,
        jsxPragma = _opts$jsxPragma === void 0 ? "React.createElement" : _opts$jsxPragma,
        _opts$jsxPragmaFrag = opts.jsxPragmaFrag,
        jsxPragmaFrag = _opts$jsxPragmaFrag === void 0 ? "React.Fragment" : _opts$jsxPragmaFrag,
        _opts$onlyRemoveTypeI = opts.onlyRemoveTypeImports,
        onlyRemoveTypeImports = _opts$onlyRemoveTypeI === void 0 ? false : _opts$onlyRemoveTypeI;
    {
      var _opts$allowDeclareFie = opts.allowDeclareFields,
          allowDeclareFields = _opts$allowDeclareFie === void 0 ? false : _opts$allowDeclareFie;
    }
    var classMemberVisitors = {
      field: function field(path) {
        var node = path.node;
        {
          if (!allowDeclareFields && node.declare) {
            throw path.buildCodeFrameError("The 'declare' modifier is only allowed when the 'allowDeclareFields' option of " + "@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.");
          }
        }

        if (node.declare) {
          if (node.value) {
            throw path.buildCodeFrameError("Fields with the 'declare' modifier cannot be initialized here, but only in the constructor");
          }

          if (!node.decorators) {
            path.remove();
          }
        } else if (node.definite) {
          if (node.value) {
            throw path.buildCodeFrameError("Definitely assigned fields cannot be initialized here, but only in the constructor");
          }

          {
            if (!allowDeclareFields && !node.decorators) {
              path.remove();
            }
          }
        } else {
          if (!allowDeclareFields && !node.value && !node.decorators && !isClassPrivateProperty(node)) {
            path.remove();
          }
        }

        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.readonly) node.readonly = null;
        if (node.optional) node.optional = null;
        if (node.typeAnnotation) node.typeAnnotation = null;
        if (node.definite) node.definite = null;
        if (node.declare) node.declare = null;
        if (node.override) node.override = null;
      },
      method: function method(_ref) {
        var node = _ref.node;
        if (node.accessibility) node.accessibility = null;
        if (node["abstract"]) node["abstract"] = null;
        if (node.optional) node.optional = null;
        if (node.override) node.override = null;
      },
      constructor: function constructor(path, classPath) {
        if (path.node.accessibility) path.node.accessibility = null;
        var parameterProperties = [];

        for (var _iterator = _createForOfIteratorHelperLoose(path.node.params), _step; !(_step = _iterator()).done;) {
          var param = _step.value;

          if (param.type === "TSParameterProperty" && !PARSED_PARAMS.has(param.parameter)) {
            PARSED_PARAMS.add(param.parameter);
            parameterProperties.push(param.parameter);
          }
        }

        if (parameterProperties.length) {
          var assigns = parameterProperties.map(function (p) {
            var id;

            if (isIdentifier(p)) {
              id = p;
            } else if (isAssignmentPattern(p) && isIdentifier(p.left)) {
              id = p.left;
            } else {
              throw path.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
            }

            return template$2.statement.ast(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose(["\n              this.", " = ", ""])), cloneNode(id), cloneNode(id));
          });
          injectInitialization(classPath, path, assigns);
        }
      }
    };
    return {
      name: "transform-typescript",
      inherits: syntaxTypescript,
      visitor: {
        Pattern: visitPattern,
        Identifier: visitPattern,
        RestElement: visitPattern,
        Program: {
          enter: function enter(path, state) {
            var file = state.file;
            var fileJsxPragma = null;
            var fileJsxPragmaFrag = null;

            if (!GLOBAL_TYPES.has(path.node)) {
              GLOBAL_TYPES.set(path.node, new Set());
            }

            if (file.ast.comments) {
              for (var _iterator2 = _createForOfIteratorHelperLoose(file.ast.comments), _step2; !(_step2 = _iterator2()).done;) {
                var comment = _step2.value;
                var jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);

                if (jsxMatches) {
                  if (jsxMatches[1]) {
                    fileJsxPragmaFrag = jsxMatches[2];
                  } else {
                    fileJsxPragma = jsxMatches[2];
                  }
                }
              }
            }

            var pragmaImportName = fileJsxPragma || jsxPragma;

            if (pragmaImportName) {
              var _pragmaImportName$spl = pragmaImportName.split(".");

              var _pragmaImportName$spl2 = _slicedToArray$2(_pragmaImportName$spl, 1);

              pragmaImportName = _pragmaImportName$spl2[0];
            }

            var pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;

            if (pragmaFragImportName) {
              var _pragmaFragImportName = pragmaFragImportName.split(".");

              var _pragmaFragImportName2 = _slicedToArray$2(_pragmaFragImportName, 1);

              pragmaFragImportName = _pragmaFragImportName2[0];
            }

            for (var _iterator3 = _createForOfIteratorHelperLoose(path.get("body")), _step3; !(_step3 = _iterator3()).done;) {
              var stmt = _step3.value;

              if (stmt.isImportDeclaration()) {
                if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                  NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
                }

                if (stmt.node.importKind === "type") {
                  stmt.remove();
                  continue;
                }

                if (onlyRemoveTypeImports) {
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                } else {
                  if (stmt.node.specifiers.length === 0) {
                    NEEDS_EXPLICIT_ESM.set(path.node, false);
                    continue;
                  }

                  var allElided = true;
                  var importsToRemove = [];

                  for (var _iterator4 = _createForOfIteratorHelperLoose(stmt.node.specifiers), _step4; !(_step4 = _iterator4()).done;) {
                    var specifier = _step4.value;
                    var binding = stmt.scope.getBinding(specifier.local.name);

                    if (binding && isImportTypeOnly({
                      binding: binding,
                      programPath: path,
                      pragmaImportName: pragmaImportName,
                      pragmaFragImportName: pragmaFragImportName
                    })) {
                      importsToRemove.push(binding.path);
                    } else {
                      allElided = false;
                      NEEDS_EXPLICIT_ESM.set(path.node, false);
                    }
                  }

                  if (allElided) {
                    stmt.remove();
                  } else {
                    for (var _iterator5 = _createForOfIteratorHelperLoose(importsToRemove), _step5; !(_step5 = _iterator5()).done;) {
                      var importPath = _step5.value;
                      importPath.remove();
                    }
                  }
                }

                continue;
              }

              if (stmt.isExportDeclaration()) {
                stmt = stmt.get("declaration");
              }

              if (stmt.isVariableDeclaration({
                declare: true
              })) {
                for (var _i = 0, _Object$keys = Object.keys(stmt.getBindingIdentifiers()); _i < _Object$keys.length; _i++) {
                  var name = _Object$keys[_i];
                  registerGlobalType(path.scope, name);
                }
              } else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
                declare: true
              }) || stmt.isTSEnumDeclaration({
                declare: true
              }) || stmt.isTSModuleDeclaration({
                declare: true
              }) && stmt.get("id").isIdentifier()) {
                registerGlobalType(path.scope, stmt.node.id.name);
              }
            }
          },
          exit: function exit(path) {
            if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
              path.pushContainer("body", exportNamedDeclaration());
            }
          }
        },
        ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {
          if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
          }

          if (path.node.exportKind === "type") {
            path.remove();
            return;
          }

          if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(function (_ref2) {
            var local = _ref2.local;
            return isGlobalType(path, local.name);
          })) {
            path.remove();
            return;
          }

          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
        },
        ExportSpecifier: function ExportSpecifier(path) {
          if (!path.parent.source && isGlobalType(path, path.node.local.name)) {
            path.remove();
          }
        },
        ExportDefaultDeclaration: function ExportDefaultDeclaration(path, state) {
          if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
            NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
          }

          if (isIdentifier(path.node.declaration) && isGlobalType(path, path.node.declaration.name)) {
            path.remove();
            return;
          }

          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
        },
        TSDeclareFunction: function TSDeclareFunction(path) {
          path.remove();
        },
        TSDeclareMethod: function TSDeclareMethod(path) {
          path.remove();
        },
        VariableDeclaration: function VariableDeclaration(path) {
          if (path.node.declare) {
            path.remove();
          }
        },
        VariableDeclarator: function VariableDeclarator(_ref3) {
          var node = _ref3.node;
          if (node.definite) node.definite = null;
        },
        TSIndexSignature: function TSIndexSignature(path) {
          path.remove();
        },
        ClassDeclaration: function ClassDeclaration(path) {
          var node = path.node;

          if (node.declare) {
            path.remove();
            return;
          }
        },
        Class: function Class(path) {
          var node = path.node;
          if (node.typeParameters) node.typeParameters = null;
          if (node.superTypeParameters) node.superTypeParameters = null;
          if (node["implements"]) node["implements"] = null;
          if (node["abstract"]) node["abstract"] = null;
          path.get("body.body").forEach(function (child) {
            if (child.isClassMethod() || child.isClassPrivateMethod()) {
              if (child.node.kind === "constructor") {
                classMemberVisitors.constructor(child, path);
              } else {
                classMemberVisitors.method(child);
              }
            } else if (child.isClassProperty() || child.isClassPrivateProperty()) {
              classMemberVisitors.field(child);
            }
          });
        },
        Function: function Function(path) {
          var node = path.node,
              scope = path.scope;
          if (node.typeParameters) node.typeParameters = null;
          if (node.returnType) node.returnType = null;
          var params = node.params;

          if (params.length > 0 && isIdentifier(params[0], {
            name: "this"
          })) {
            params.shift();
          }

          var paramsPath = path.get("params");

          for (var _iterator6 = _createForOfIteratorHelperLoose(paramsPath), _step6; !(_step6 = _iterator6()).done;) {
            var p = _step6.value;

            if (p.type === "TSParameterProperty") {
              p.replaceWith(p.get("parameter"));
              scope.registerBinding("param", p);
            }
          }
        },
        TSModuleDeclaration: function TSModuleDeclaration(path) {
          transpileNamespace(path, t$p, allowNamespaces);
        },
        TSInterfaceDeclaration: function TSInterfaceDeclaration(path) {
          path.remove();
        },
        TSTypeAliasDeclaration: function TSTypeAliasDeclaration(path) {
          path.remove();
        },
        TSEnumDeclaration: function TSEnumDeclaration(path) {
          transpileEnum(path, t$p);
        },
        TSImportEqualsDeclaration: function TSImportEqualsDeclaration(path) {
          throw path.buildCodeFrameError("`import =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using " + "`import <moduleName> from '<moduleName>';` alongside " + "Typescript's --allowSyntheticDefaultImports option.");
        },
        TSExportAssignment: function TSExportAssignment(path) {
          throw path.buildCodeFrameError("`export =` is not supported by @babel/plugin-transform-typescript\n" + "Please consider using `export <value>;`.");
        },
        TSTypeAssertion: function TSTypeAssertion(path) {
          path.replaceWith(path.node.expression);
        },
        TSAsExpression: function TSAsExpression(path) {
          var node = path.node;

          do {
            node = node.expression;
          } while (isTSAsExpression(node));

          path.replaceWith(node);
        },
        TSNonNullExpression: function TSNonNullExpression(path) {
          path.replaceWith(path.node.expression);
        },
        CallExpression: function CallExpression(path) {
          path.node.typeParameters = null;
        },
        OptionalCallExpression: function OptionalCallExpression(path) {
          path.node.typeParameters = null;
        },
        NewExpression: function NewExpression(path) {
          path.node.typeParameters = null;
        },
        JSXOpeningElement: function JSXOpeningElement(path) {
          path.node.typeParameters = null;
        },
        TaggedTemplateExpression: function TaggedTemplateExpression(path) {
          path.node.typeParameters = null;
        }
      }
    };

    function visitPattern(_ref4) {
      var node = _ref4.node;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (isIdentifier(node) && node.optional) node.optional = null;
    }

    function isImportTypeOnly(_ref5) {
      var binding = _ref5.binding,
          programPath = _ref5.programPath,
          pragmaImportName = _ref5.pragmaImportName,
          pragmaFragImportName = _ref5.pragmaFragImportName;

      for (var _iterator7 = _createForOfIteratorHelperLoose(binding.referencePaths), _step7; !(_step7 = _iterator7()).done;) {
        var path = _step7.value;

        if (!isInType(path)) {
          return false;
        }
      }

      if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
        return true;
      }

      var sourceFileHasJsx = false;
      programPath.traverse({
        "JSXElement|JSXFragment": function JSXElementJSXFragment(path) {
          sourceFileHasJsx = true;
          path.stop();
        }
      });
      return !sourceFileHasJsx;
    }
  });

  var _transformUnicodeEscapes = declare(function (api) {
    api.assertVersion(7);
    var surrogate = /[\ud800-\udfff]/g;
    var unicodeEscape = /(\\+)u\{([0-9a-fA-F]+)\}/g;

    function escape(code) {
      var str = code.toString(16);

      while (str.length < 4) {
        str = "0" + str;
      }

      return "\\u" + str;
    }

    function replacer(match, backslashes, code) {
      if (backslashes.length % 2 === 0) {
        return match;
      }

      var _char = String.fromCodePoint(parseInt(code, 16));

      var escaped = backslashes.slice(0, -1) + escape(_char.charCodeAt(0));
      return _char.length === 1 ? escaped : escaped + escape(_char.charCodeAt(1));
    }

    function replaceUnicodeEscapes(str) {
      return str.replace(unicodeEscape, replacer);
    }

    function getUnicodeEscape(str) {
      var match;

      while (match = unicodeEscape.exec(str)) {
        if (match[1].length % 2 === 0) continue;
        unicodeEscape.lastIndex = 0;
        return match[0];
      }

      return null;
    }

    return {
      name: "transform-unicode-escapes",
      manipulateOptions: function manipulateOptions(_ref) {
        var _generatorOpts$jsescO, _generatorOpts$jsescO2;

        var generatorOpts = _ref.generatorOpts;

        if (!generatorOpts.jsescOption) {
          generatorOpts.jsescOption = {};
        }

        (_generatorOpts$jsescO2 = (_generatorOpts$jsescO = generatorOpts.jsescOption).minimal) != null ? _generatorOpts$jsescO2 : _generatorOpts$jsescO.minimal = false;
      },
      visitor: {
        Identifier: function Identifier(path) {
          var node = path.node,
              key = path.key;
          var name = node.name;
          var replaced = name.replace(surrogate, function (c) {
            return "_u" + c.charCodeAt(0).toString(16);
          });
          if (name === replaced) return;
          var str = inherits(stringLiteral(name), node);

          if (key === "key") {
            path.replaceWith(str);
            return;
          }

          var parentPath = path.parentPath,
              scope = path.scope;

          if (parentPath.isMemberExpression({
            property: node
          }) || parentPath.isOptionalMemberExpression({
            property: node
          })) {
            parentPath.node.computed = true;
            path.replaceWith(str);
            return;
          }

          var binding = scope.getBinding(name);

          if (binding) {
            scope.rename(name, scope.generateUid(replaced));
            return;
          }

          throw path.buildCodeFrameError("Can't reference '" + name + "' as a bare identifier");
        },
        "StringLiteral|DirectiveLiteral": function StringLiteralDirectiveLiteral(path) {
          var node = path.node;
          var extra = node.extra;
          if (extra != null && extra.raw) extra.raw = replaceUnicodeEscapes(extra.raw);
        },
        TemplateElement: function TemplateElement(path) {
          var node = path.node,
              parentPath = path.parentPath;
          var value = node.value;
          var firstEscape = getUnicodeEscape(value.raw);
          if (!firstEscape) return;
          var grandParent = parentPath.parentPath;

          if (grandParent.isTaggedTemplateExpression()) {
            throw path.buildCodeFrameError("Can't replace Unicode escape '" + firstEscape + "' inside tagged template literals. You can enable '@babel/plugin-transform-template-literals' to compile them to classic strings.");
          }

          value.raw = replaceUnicodeEscapes(value.raw);
        }
      }
    };
  });

  var _transformUnicodeRegex = declare(function (api) {
    api.assertVersion(7);
    return createRegExpFeaturePlugin({
      name: "transform-unicode-regex",
      feature: "unicodeFlag"
    });
  });

  var all = {
    "external-helpers": externalHelpers,
    "syntax-async-generators": lib$q,
    "syntax-class-properties": lib$p,
    "syntax-class-static-block": _syntaxClassStaticBlock,
    "syntax-decimal": syntaxDecimal,
    "syntax-decorators": syntaxDecorators,
    "syntax-do-expressions": syntaxDoExpressions,
    "syntax-export-default-from": syntaxExportDefaultFrom,
    "syntax-flow": syntaxFlow,
    "syntax-function-bind": syntaxFunctionBind,
    "syntax-function-sent": syntaxFunctionSent,
    "syntax-module-blocks": syntaxModuleBlocks,
    "syntax-import-meta": lib$o,
    "syntax-jsx": syntaxJsx,
    "syntax-import-assertions": syntaxImportAssertions,
    "syntax-object-rest-spread": lib$n,
    "syntax-optional-catch-binding": lib$m,
    "syntax-pipeline-operator": syntaxPipelineOperator,
    "syntax-record-and-tuple": syntaxRecordAndTuple,
    "syntax-top-level-await": _syntaxTopLevelAwait,
    "syntax-typescript": syntaxTypescript,
    "proposal-async-generator-functions": _proposalAsyncGeneratorFunctions,
    "proposal-class-properties": _proposalClassProperties,
    "proposal-class-static-block": _proposalClassStaticBlock,
    "proposal-decorators": proposalDecorators,
    "proposal-do-expressions": proposalDoExpressions,
    "proposal-dynamic-import": _proposalDynamicImport,
    "proposal-export-default-from": proposalExportDefaultFrom,
    "proposal-export-namespace-from": _proposalExportNamespaceFrom,
    "proposal-function-bind": proposalFunctionBind,
    "proposal-function-sent": proposalFunctionSent,
    "proposal-json-strings": _proposalJsonStrings,
    "proposal-logical-assignment-operators": _proposalLogicalAssignmentOperators,
    "proposal-nullish-coalescing-operator": _proposalNullishCoalescingOperator,
    "proposal-numeric-separator": _proposalNumericSeparator,
    "proposal-object-rest-spread": _proposalObjectRestSpread,
    "proposal-optional-catch-binding": _proposalOptionalCatchBinding,
    "proposal-optional-chaining": _proposalOptionalChaining,
    "proposal-pipeline-operator": proposalPipelineOperator,
    "proposal-private-methods": _proposalPrivateMethods,
    "proposal-private-property-in-object": _proposalPrivatePropertyInObject,
    "proposal-throw-expressions": proposalThrowExpressions,
    "proposal-unicode-property-regex": _proposalUnicodePropertyRegex,
    "transform-async-to-generator": _transformAsyncToGenerator,
    "transform-arrow-functions": _transformArrowFunctions,
    "transform-block-scoped-functions": _transformBlockScopedFunctions,
    "transform-block-scoping": _transformBlockScoping,
    "transform-classes": _transformClasses,
    "transform-computed-properties": _transformComputedProperties,
    "transform-destructuring": _transformDestructuring,
    "transform-dotall-regex": _transformDotallRegex,
    "transform-duplicate-keys": _transformDuplicateKeys,
    "transform-exponentiation-operator": transformExponentialOperator,
    "transform-flow-comments": transformFlowComments,
    "transform-flow-strip-types": transformFlowStripTypes,
    "transform-for-of": _transformForOf,
    "transform-function-name": _transformFunctionName,
    "transform-instanceof": transformInstanceof,
    "transform-jscript": transformJscript,
    "transform-literals": _transformLiterals,
    "transform-member-expression-literals": _transformMemberExpressionLiterals,
    "transform-modules-amd": _transformModulesAmd,
    "transform-modules-commonjs": _transformModulesCommonjs,
    "transform-modules-systemjs": _transformModulesSystemjs,
    "transform-modules-umd": _transformModulesUmd,
    "transform-named-capturing-groups-regex": _transformNamedCapturingGroupsRegex,
    "transform-new-target": _transformNewTarget,
    "transform-object-assign": transformObjectAssign,
    "transform-object-super": _transformObjectSuper,
    "transform-object-set-prototype-of-to-assign": transformObjectSetPrototypeOfToAssign,
    "transform-parameters": _transformParameters,
    "transform-property-literals": _transformPropertyLiterals,
    "transform-property-mutators": transformPropertyMutators,
    "transform-proto-to-assign": transformProtoToAssign,
    "transform-react-constant-elements": transformReactConstantElements,
    "transform-react-display-name": transformReactDisplayName,
    "transform-react-inline-elements": transformReactInlineElements,
    "transform-react-jsx": transformReactJSX,
    "transform-react-jsx-compat": transformReactJsxCompat,
    "transform-react-jsx-development": transformReactJSXDevelopment,
    "transform-react-jsx-self": transformReactJsxSelf,
    "transform-react-jsx-source": transformReactJsxSource,
    "transform-regenerator": _transformRegenerator,
    "transform-reserved-words": _transformReservedWords,
    "transform-runtime": transformRuntime,
    "transform-shorthand-properties": _transformShorthandProperties,
    "transform-spread": _transformSpread,
    "transform-sticky-regex": _transformStickyRegex,
    "transform-strict-mode": transformStrictMode,
    "transform-template-literals": _transformTemplateLiterals,
    "transform-typeof-symbol": _transformTypeofSymbol,
    "transform-typescript": transformTypeScript,
    "transform-unicode-escapes": _transformUnicodeEscapes,
    "transform-unicode-regex": _transformUnicodeRegex
  };

  var preset2015 = (function (_, opts) {
    var loose = false;
    var modules = "commonjs";
    var spec = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
      if (opts.modules !== undefined) modules = opts.modules;
      if (opts.spec !== undefined) spec = opts.spec;
    }

    var optsLoose = {
      loose: loose
    };
    return {
      plugins: [[_transformTemplateLiterals, {
        loose: loose,
        spec: spec
      }], _transformLiterals, _transformFunctionName, [_transformArrowFunctions, {
        spec: spec
      }], _transformBlockScopedFunctions, [_transformClasses, optsLoose], _transformObjectSuper, _transformShorthandProperties, _transformDuplicateKeys, [_transformComputedProperties, optsLoose], [_transformForOf, optsLoose], _transformStickyRegex, _transformUnicodeEscapes, _transformUnicodeRegex, [_transformSpread, optsLoose], [_transformParameters, optsLoose], [_transformDestructuring, optsLoose], _transformBlockScoping, _transformTypeofSymbol, transformInstanceof, (modules === "commonjs" || modules === "cjs") && [_transformModulesCommonjs, optsLoose], modules === "systemjs" && [_transformModulesSystemjs, optsLoose], modules === "amd" && [_transformModulesAmd, optsLoose], modules === "umd" && [_transformModulesUmd, optsLoose], [_transformRegenerator, {
        async: false,
        asyncGenerators: false
      }]].filter(Boolean)
    };
  });

  var presetStage3 = (function (_, opts) {
    var loose = false;

    if (opts !== undefined) {
      if (opts.loose !== undefined) loose = opts.loose;
    }

    return {
      plugins: [syntaxImportAssertions, lib$o, _syntaxTopLevelAwait, _proposalExportNamespaceFrom, _proposalLogicalAssignmentOperators, [_proposalOptionalChaining, {
        loose: loose
      }], [_proposalNullishCoalescingOperator, {
        loose: loose
      }], [_proposalClassProperties, {
        loose: loose
      }], _proposalJsonStrings, _proposalNumericSeparator, [_proposalPrivateMethods, {
        loose: loose
      }]]
    };
  });

  var presetStage2 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport;
    return {
      presets: [[presetStage3, {
        loose: loose,
        useBuiltIns: useBuiltIns
      }]],
      plugins: [_proposalClassStaticBlock, [proposalDecorators, {
        legacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }], proposalFunctionSent, _proposalPrivatePropertyInObject, proposalThrowExpressions]
    };
  });

  var presetStage1 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
        _opts$recordAndTupleS = _opts.recordAndTupleSyntax,
        recordAndTupleSyntax = _opts$recordAndTupleS === void 0 ? "hash" : _opts$recordAndTupleS;
    return {
      presets: [[presetStage2, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport
      }]],
      plugins: [syntaxDecimal, [syntaxRecordAndTuple, {
        syntaxType: recordAndTupleSyntax
      }], syntaxModuleBlocks, proposalExportDefaultFrom, [proposalPipelineOperator, {
        proposal: pipelineProposal
      }], proposalDoExpressions]
    };
  });

  var presetStage0 = (function (_, opts) {
    if (opts === void 0) {
      opts = {};
    }

    var _opts = opts,
        _opts$loose = _opts.loose,
        loose = _opts$loose === void 0 ? false : _opts$loose,
        _opts$useBuiltIns = _opts.useBuiltIns,
        useBuiltIns = _opts$useBuiltIns === void 0 ? false : _opts$useBuiltIns,
        _opts$decoratorsLegac = _opts.decoratorsLegacy,
        decoratorsLegacy = _opts$decoratorsLegac === void 0 ? false : _opts$decoratorsLegac,
        decoratorsBeforeExport = _opts.decoratorsBeforeExport,
        _opts$pipelineProposa = _opts.pipelineProposal,
        pipelineProposal = _opts$pipelineProposa === void 0 ? "minimal" : _opts$pipelineProposa,
        _opts$importAssertion = _opts.importAssertionsVersion,
        importAssertionsVersion = _opts$importAssertion === void 0 ? "september-2020" : _opts$importAssertion;
    return {
      presets: [[presetStage1, {
        loose: loose,
        useBuiltIns: useBuiltIns,
        decoratorsLegacy: decoratorsLegacy,
        decoratorsBeforeExport: decoratorsBeforeExport,
        pipelineProposal: pipelineProposal,
        importAssertionsVersion: importAssertionsVersion
      }]],
      plugins: [proposalFunctionBind]
    };
  });

  var logPlugin = function logPlugin(item, targetVersions, list) {
    var filteredList = getInclusionReasons(item, targetVersions, list);
    var support = list[item];

    if (!support) {
      console.log("  " + item);
      return;
    }

    var formattedTargets = "{";
    var first = true;

    for (var _i = 0, _Object$keys = Object.keys(filteredList); _i < _Object$keys.length; _i++) {
      var target = _Object$keys[_i];
      if (!first) formattedTargets += ",";
      first = false;
      formattedTargets += " " + target;
      if (support[target]) formattedTargets += " < " + support[target];
    }

    formattedTargets += " }";
    console.log("  " + item + " " + formattedTargets);
  };

  var defaultExcludesForLooseMode = ["transform-typeof-symbol"];
  function getOptionSpecificExcludesFor (_ref) {
    var loose = _ref.loose;
    return loose ? defaultExcludesForLooseMode : null;
  }

  var lib$a = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-async-generators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("asyncGenerators");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-async-generators/lib");

  var lib$9 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-class-properties",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("classProperties", "classPrivateProperties", "classPrivateMethods");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-class-properties/lib");

  var lib$8 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-dynamic-import",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("dynamicImport");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-dynamic-import/lib");

  var lib$7 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-export-namespace-from",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("exportNamespaceFrom");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-export-namespace-from/lib");

  var lib$6 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-json-strings",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("jsonStrings");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-json-strings/lib");

  var lib$5 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-logical-assignment-operators",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("logicalAssignment");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-logical-assignment-operators/lib");

  var lib$4 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-nullish-coalescing-operator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("nullishCoalescingOperator");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-nullish-coalescing-operator/lib");

  var lib$3 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-numeric-separator",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("numericSeparator");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-numeric-separator/lib");

  var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-object-rest-spread",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("objectRestSpread");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-object-rest-spread/lib");

  var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-catch-binding",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalCatchBinding");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-optional-catch-binding/lib");

  var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _default = (0, _helperPluginUtils.declare)(function (api) {
      api.assertVersion(7);
      return {
        name: "syntax-optional-chaining",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
          parserOpts.plugins.push("optionalChaining");
        }
      };
    });

    exports["default"] = _default;
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/plugin-syntax-optional-chaining/lib");

  var transformAsyncArrowsInClass = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;
    var OPTS = {
      allowInsertArrow: false,
      specCompliant: false
    };

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-async-arrows-in-class",
        visitor: {
          ArrowFunctionExpression: function ArrowFunctionExpression(path) {
            if (path.node.async && path.findParent(t.isClassMethod)) {
              path.arrowFunctionToExpression(OPTS);
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-async-arrows-in-class");

  var transformEdgeDefaultParameters = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;

      var isArrowParent = function isArrowParent(p) {
        return p.parentKey === "params" && p.parentPath && t.isArrowFunctionExpression(p.parentPath);
      };

      return {
        name: "transform-edge-default-parameters",
        visitor: {
          AssignmentPattern: function AssignmentPattern(path) {
            var arrowArgParent = path.find(isArrowParent);

            if (arrowArgParent && path.parent.shorthand) {
              path.parent.shorthand = false;
              (path.parent.extra || {}).shorthand = false;
              path.scope.rename(path.parent.key.name);
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-edge-default-parameters");

  var transformEdgeFunctionName = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-edge-function-name",
        visitor: {
          FunctionExpression: {
            exit: function exit(path) {
              if (!path.node.id && t.isIdentifier(path.parent.id)) {
                var id = t.cloneNode(path.parent.id);
                var binding = path.scope.getBinding(id.name);

                if (binding == null ? void 0 : binding.constantViolations.length) {
                  path.scope.rename(id.name);
                }

                path.node.id = id;
              }
            }
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-edge-function-name");

  var transformTaggedTemplateCaching = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    var _default = function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-tagged-template-caching",
        visitor: {
          TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
            var processed = state.get("processed");

            if (!processed) {
              processed = new Map();
              state.set("processed", processed);
            }

            if (processed.has(path.node)) return path.skip();
            var expressions = path.node.quasi.expressions;
            var identity = state.get("identity");

            if (!identity) {
              identity = path.scope.getProgramParent().generateDeclaredUidIdentifier("_");
              state.set("identity", identity);
              var binding = path.scope.getBinding(identity.name);
              binding.path.get("init").replaceWith(t.arrowFunctionExpression([t.identifier("t")], t.identifier("t")));
            }

            var template = t.taggedTemplateExpression(identity, t.templateLiteral(path.node.quasi.quasis, expressions.map(function () {
              return t.numericLiteral(0);
            })));
            processed.set(template, true);
            var ident = path.scope.getProgramParent().generateDeclaredUidIdentifier("t");
            path.scope.getBinding(ident.name).path.parent.kind = "let";
            var inlineCache = t.logicalExpression("||", ident, t.assignmentExpression("=", ident, template));
            var node = t.callExpression(path.node.tag, [inlineCache].concat(_toConsumableArray(expressions)));
            path.replaceWith(node);
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-tagged-template-caching");

  var transformSafariBlockShadowing = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = _default;

    function _default(_ref) {
      var t = _ref.types;
      return {
        name: "transform-safari-block-shadowing",
        visitor: {
          VariableDeclarator: function VariableDeclarator(path) {
            var kind = path.parent.kind;
            if (kind !== "let" && kind !== "const") return;
            var block = path.scope.block;
            if (t.isFunction(block) || t.isProgram(block)) return;
            var bindings = t.getOuterBindingIdentifiers(path.node.id);

            for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {
              var name = _Object$keys[_i];
              var scope = path.scope;
              if (!scope.hasOwnBinding(name)) continue;

              while (scope = scope.parent) {
                if (scope.hasOwnBinding(name)) {
                  path.scope.rename(name);
                  break;
                }

                if (t.isFunction(scope.block) || t.isProgram(scope.block)) {
                  break;
                }
              }
            }
          }
        }
      };
    }

    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-safari-block-shadowing");

  var transformSafariForShadowing = createCommonjsModule(function (module, exports) {

    exports.__esModule = true;
    exports["default"] = void 0;

    function handle(declaration) {
      if (!declaration.isVariableDeclaration()) return;
      var fn = declaration.getFunctionParent();
      var name = declaration.node.declarations[0].id.name;

      if (fn && fn.scope.hasOwnBinding(name) && fn.scope.getOwnBinding(name).kind === "param") {
        declaration.scope.rename(name);
      }
    }

    var _default = function _default() {
      return {
        name: "transform-safari-for-shadowing",
        visitor: {
          ForXStatement: function ForXStatement(path) {
            handle(path.get("left"));
          },
          ForStatement: function ForStatement(path) {
            handle(path.get("init"));
          }
        }
      };
    };

    exports["default"] = _default;
    module.exports = exports["default"];
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/@babel/preset-modules/lib/plugins/transform-safari-for-shadowing");

  function matchAffectedArguments(argumentNodes) {
    var spreadIndex = argumentNodes.findIndex(function (node) {
      return isSpreadElement(node);
    });
    return spreadIndex >= 0 && spreadIndex !== argumentNodes.length - 1;
  }

  function shouldTransform(path) {
    var optionalPath = path;
    var chains = [];

    while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
      var _optionalPath = optionalPath,
          node = _optionalPath.node;
      chains.push(node);

      if (optionalPath.isOptionalMemberExpression()) {
        optionalPath = skipTransparentExprWrappers(optionalPath.get("object"));
      } else if (optionalPath.isOptionalCallExpression()) {
        optionalPath = skipTransparentExprWrappers(optionalPath.get("callee"));
      }
    }

    for (var i = 0; i < chains.length; i++) {
      var _node = chains[i];

      if (isOptionalCallExpression(_node) && matchAffectedArguments(_node.arguments)) {
        if (_node.optional) {
          return true;
        }

        var callee = chains[i + 1];

        if (isOptionalMemberExpression(callee, {
          optional: true
        })) {
          return true;
        }
      }
    }

    return false;
  }

  var bugfixV8SpreadParametersInOptionalChaining = declare(function (api) {
    api.assertVersion(7);
    var noDocumentAll = api.assumption("noDocumentAll");
    var pureGetters = api.assumption("pureGetters");
    return {
      name: "bugfix-v8-spread-parameters-in-optional-chaining",
      visitor: {
        "OptionalCallExpression|OptionalMemberExpression": function OptionalCallExpressionOptionalMemberExpression(path) {
          if (shouldTransform(path)) {
            transform$1(path, {
              noDocumentAll: noDocumentAll,
              pureGetters: pureGetters
            });
          }
        }
      }
    };
  });

  var availablePlugins$1 = {
    "bugfix/transform-async-arrows-in-class": function bugfixTransformAsyncArrowsInClass() {
      return transformAsyncArrowsInClass;
    },
    "bugfix/transform-edge-default-parameters": function bugfixTransformEdgeDefaultParameters() {
      return transformEdgeDefaultParameters;
    },
    "bugfix/transform-edge-function-name": function bugfixTransformEdgeFunctionName() {
      return transformEdgeFunctionName;
    },
    "bugfix/transform-safari-block-shadowing": function bugfixTransformSafariBlockShadowing() {
      return transformSafariBlockShadowing;
    },
    "bugfix/transform-safari-for-shadowing": function bugfixTransformSafariForShadowing() {
      return transformSafariForShadowing;
    },
    "bugfix/transform-tagged-template-caching": function bugfixTransformTaggedTemplateCaching() {
      return transformTaggedTemplateCaching;
    },
    "bugfix/transform-v8-spread-parameters-in-optional-chaining": function bugfixTransformV8SpreadParametersInOptionalChaining() {
      return bugfixV8SpreadParametersInOptionalChaining;
    },
    "proposal-async-generator-functions": function proposalAsyncGeneratorFunctions() {
      return _proposalAsyncGeneratorFunctions;
    },
    "proposal-class-properties": function proposalClassProperties() {
      return _proposalClassProperties;
    },
    "proposal-class-static-block": function proposalClassStaticBlock() {
      return _proposalClassStaticBlock;
    },
    "proposal-dynamic-import": function proposalDynamicImport() {
      return _proposalDynamicImport;
    },
    "proposal-export-namespace-from": function proposalExportNamespaceFrom() {
      return _proposalExportNamespaceFrom;
    },
    "proposal-json-strings": function proposalJsonStrings() {
      return _proposalJsonStrings;
    },
    "proposal-logical-assignment-operators": function proposalLogicalAssignmentOperators() {
      return _proposalLogicalAssignmentOperators;
    },
    "proposal-nullish-coalescing-operator": function proposalNullishCoalescingOperator() {
      return _proposalNullishCoalescingOperator;
    },
    "proposal-numeric-separator": function proposalNumericSeparator() {
      return _proposalNumericSeparator;
    },
    "proposal-object-rest-spread": function proposalObjectRestSpread() {
      return _proposalObjectRestSpread;
    },
    "proposal-optional-catch-binding": function proposalOptionalCatchBinding() {
      return _proposalOptionalCatchBinding;
    },
    "proposal-optional-chaining": function proposalOptionalChaining() {
      return _proposalOptionalChaining;
    },
    "proposal-private-methods": function proposalPrivateMethods() {
      return _proposalPrivateMethods;
    },
    "proposal-private-property-in-object": function proposalPrivatePropertyInObject() {
      return _proposalPrivatePropertyInObject;
    },
    "proposal-unicode-property-regex": function proposalUnicodePropertyRegex() {
      return _proposalUnicodePropertyRegex;
    },
    "syntax-async-generators": function syntaxAsyncGenerators() {
      return lib$a;
    },
    "syntax-class-properties": function syntaxClassProperties() {
      return lib$9;
    },
    "syntax-class-static-block": function syntaxClassStaticBlock() {
      return _syntaxClassStaticBlock;
    },
    "syntax-dynamic-import": function syntaxDynamicImport() {
      return lib$8;
    },
    "syntax-export-namespace-from": function syntaxExportNamespaceFrom() {
      return lib$7;
    },
    "syntax-json-strings": function syntaxJsonStrings() {
      return lib$6;
    },
    "syntax-logical-assignment-operators": function syntaxLogicalAssignmentOperators() {
      return lib$5;
    },
    "syntax-nullish-coalescing-operator": function syntaxNullishCoalescingOperator() {
      return lib$4;
    },
    "syntax-numeric-separator": function syntaxNumericSeparator() {
      return lib$3;
    },
    "syntax-object-rest-spread": function syntaxObjectRestSpread() {
      return lib$2;
    },
    "syntax-optional-catch-binding": function syntaxOptionalCatchBinding() {
      return lib$1;
    },
    "syntax-optional-chaining": function syntaxOptionalChaining() {
      return lib;
    },
    "syntax-private-property-in-object": function syntaxPrivatePropertyInObject() {
      return _syntaxPrivatePropertyInObject;
    },
    "syntax-top-level-await": function syntaxTopLevelAwait() {
      return _syntaxTopLevelAwait;
    },
    "transform-arrow-functions": function transformArrowFunctions() {
      return _transformArrowFunctions;
    },
    "transform-async-to-generator": function transformAsyncToGenerator() {
      return _transformAsyncToGenerator;
    },
    "transform-block-scoped-functions": function transformBlockScopedFunctions() {
      return _transformBlockScopedFunctions;
    },
    "transform-block-scoping": function transformBlockScoping() {
      return _transformBlockScoping;
    },
    "transform-classes": function transformClasses() {
      return _transformClasses;
    },
    "transform-computed-properties": function transformComputedProperties() {
      return _transformComputedProperties;
    },
    "transform-destructuring": function transformDestructuring() {
      return _transformDestructuring;
    },
    "transform-dotall-regex": function transformDotallRegex() {
      return _transformDotallRegex;
    },
    "transform-duplicate-keys": function transformDuplicateKeys() {
      return _transformDuplicateKeys;
    },
    "transform-exponentiation-operator": function transformExponentiationOperator() {
      return transformExponentialOperator;
    },
    "transform-for-of": function transformForOf() {
      return _transformForOf;
    },
    "transform-function-name": function transformFunctionName() {
      return _transformFunctionName;
    },
    "transform-literals": function transformLiterals() {
      return _transformLiterals;
    },
    "transform-member-expression-literals": function transformMemberExpressionLiterals() {
      return _transformMemberExpressionLiterals;
    },
    "transform-modules-amd": function transformModulesAmd() {
      return _transformModulesAmd;
    },
    "transform-modules-commonjs": function transformModulesCommonjs() {
      return _transformModulesCommonjs;
    },
    "transform-modules-systemjs": function transformModulesSystemjs() {
      return _transformModulesSystemjs;
    },
    "transform-modules-umd": function transformModulesUmd() {
      return _transformModulesUmd;
    },
    "transform-named-capturing-groups-regex": function transformNamedCapturingGroupsRegex() {
      return _transformNamedCapturingGroupsRegex;
    },
    "transform-new-target": function transformNewTarget() {
      return _transformNewTarget;
    },
    "transform-object-super": function transformObjectSuper() {
      return _transformObjectSuper;
    },
    "transform-parameters": function transformParameters() {
      return _transformParameters;
    },
    "transform-property-literals": function transformPropertyLiterals() {
      return _transformPropertyLiterals;
    },
    "transform-regenerator": function transformRegenerator() {
      return _transformRegenerator;
    },
    "transform-reserved-words": function transformReservedWords() {
      return _transformReservedWords;
    },
    "transform-shorthand-properties": function transformShorthandProperties() {
      return _transformShorthandProperties;
    },
    "transform-spread": function transformSpread() {
      return _transformSpread;
    },
    "transform-sticky-regex": function transformStickyRegex() {
      return _transformStickyRegex;
    },
    "transform-template-literals": function transformTemplateLiterals() {
      return _transformTemplateLiterals;
    },
    "transform-typeof-symbol": function transformTypeofSymbol() {
      return _transformTypeofSymbol;
    },
    "transform-unicode-escapes": function transformUnicodeEscapes() {
      return _transformUnicodeEscapes;
    },
    "transform-unicode-regex": function transformUnicodeRegex() {
      return _transformUnicodeRegex;
    }
  };
  var minVersions = {
    "proposal-class-static-block": "7.12.0",
    "proposal-private-property-in-object": "7.10.0"
  };

  var has$3 = Function.call.bind(Object.hasOwnProperty);
  function removeUnnecessaryItems(items, overlapping) {
    items.forEach(function (item) {
      var _overlapping$item;

      (_overlapping$item = overlapping[item]) == null ? void 0 : _overlapping$item.forEach(function (name) {
        return items["delete"](name);
      });
    });
  }
  function removeUnsupportedItems(items, babelVersion) {
    items.forEach(function (item) {
      if (has$3(minVersions, item) && semver$4.lt(babelVersion, minVersions[item])) {
        items["delete"](item);
      }
    });
  }

  var moduleTransformations = {
    auto: "transform-modules-commonjs",
    amd: "transform-modules-amd",
    commonjs: "transform-modules-commonjs",
    cjs: "transform-modules-commonjs",
    systemjs: "transform-modules-systemjs",
    umd: "transform-modules-umd"
  };

  var require$$0$1 = {
  	"transform-async-to-generator": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "10.1",
  	node: "7.6",
  	ios: "10.3",
  	samsung: "6",
  	electron: "1.6"
  },
  	"bugfix/transform-async-arrows-in-class": {
  	chrome: "55",
  	opera: "42",
  	edge: "15",
  	firefox: "52",
  	safari: "11",
  	node: "7.6",
  	ios: "11",
  	samsung: "6",
  	electron: "1.6"
  },
  	"transform-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "15",
  	firefox: "53",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-edge-default-parameters": {
  	chrome: "49",
  	opera: "36",
  	edge: "18",
  	firefox: "52",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "14",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"bugfix/transform-edge-function-name": {
  	chrome: "51",
  	opera: "38",
  	edge: "79",
  	firefox: "53",
  	safari: "10",
  	node: "6.5",
  	ios: "10",
  	samsung: "5",
  	electron: "1.2"
  },
  	"transform-block-scoping": {
  	chrome: "49",
  	opera: "36",
  	edge: "14",
  	firefox: "51",
  	safari: "10",
  	node: "6",
  	ios: "10",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-safari-block-shadowing": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "44",
  	safari: "11",
  	node: "6",
  	ie: "11",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"bugfix/transform-safari-for-shadowing": {
  	chrome: "49",
  	opera: "36",
  	edge: "12",
  	firefox: "4",
  	safari: "11",
  	node: "6",
  	ie: "11",
  	ios: "11",
  	samsung: "5",
  	electron: "0.37"
  },
  	"transform-template-literals": {
  	chrome: "41",
  	opera: "28",
  	edge: "13",
  	firefox: "34",
  	safari: "9",
  	node: "4",
  	ios: "9",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"bugfix/transform-tagged-template-caching": {
  	chrome: "41",
  	opera: "28",
  	edge: "12",
  	firefox: "34",
  	safari: "13",
  	node: "4",
  	ios: "13",
  	samsung: "3.4",
  	electron: "0.21"
  },
  	"proposal-optional-chaining": {
  	chrome: "80",
  	opera: "67",
  	edge: "80",
  	firefox: "74",
  	safari: "13.1",
  	node: "14",
  	ios: "13.4",
  	samsung: "13",
  	electron: "8.0"
  },
  	"bugfix/transform-v8-spread-parameters-in-optional-chaining": {
  	firefox: "74",
  	safari: "13.1",
  	ios: "13.4"
  }
  };

  var pluginBugfixes = require$$0$1;

  var pluginsFiltered = {};
  var bugfixPluginsFiltered = {};

  for (var _i = 0, _Object$keys = Object.keys(plugins); _i < _Object$keys.length; _i++) {
    var plugin = _Object$keys[_i];

    if (Object.hasOwnProperty.call(availablePlugins$1, plugin)) {
      pluginsFiltered[plugin] = plugins[plugin];
    }
  }

  for (var _i2 = 0, _Object$keys2 = Object.keys(pluginBugfixes); _i2 < _Object$keys2.length; _i2++) {
    var _plugin = _Object$keys2[_i2];

    if (Object.hasOwnProperty.call(availablePlugins$1, _plugin)) {
      bugfixPluginsFiltered[_plugin] = pluginBugfixes[_plugin];
    }
  }

  pluginsFiltered["proposal-class-properties"] = pluginsFiltered["proposal-private-methods"];

  var TopLevelOptions = {
    bugfixes: "bugfixes",
    configPath: "configPath",
    corejs: "corejs",
    debug: "debug",
    exclude: "exclude",
    forceAllTransforms: "forceAllTransforms",
    ignoreBrowserslistConfig: "ignoreBrowserslistConfig",
    include: "include",
    loose: "loose",
    modules: "modules",
    shippedProposals: "shippedProposals",
    spec: "spec",
    targets: "targets",
    useBuiltIns: "useBuiltIns",
    browserslistEnv: "browserslistEnv"
  };
  var ModulesOption = {
    "false": false,
    auto: "auto",
    amd: "amd",
    commonjs: "commonjs",
    cjs: "cjs",
    systemjs: "systemjs",
    umd: "umd"
  };
  var UseBuiltInsOption = {
    "false": false,
    entry: "entry",
    usage: "usage"
  };

  var corejs2DefaultWebIncludes = ["web.timers", "web.immediate", "web.dom.iterable"];
  var v$1 = new OptionValidator("@babel/preset-env");
  var allPluginsList = Object.keys(pluginsFiltered);
  var modulePlugins = ["proposal-dynamic-import"].concat(_toConsumableArray(Object.keys(moduleTransformations).map(function (m) {
    return moduleTransformations[m];
  })));

  var getValidIncludesAndExcludes = function getValidIncludesAndExcludes(type, corejs) {
    return new Set([].concat(_toConsumableArray(allPluginsList), _toConsumableArray(type === "exclude" ? modulePlugins : []), _toConsumableArray(corejs ? corejs == 2 ? [].concat(_toConsumableArray(Object.keys(corejs2BuiltIns)), corejs2DefaultWebIncludes) : Object.keys(require$$0$3) : [])));
  };

  var pluginToRegExp = function pluginToRegExp(plugin) {
    if (plugin instanceof RegExp) return plugin;

    try {
      return new RegExp("^" + normalizePluginName(plugin) + "$");
    } catch (e) {
      return null;
    }
  };

  var selectPlugins = function selectPlugins(regexp, type, corejs) {
    return Array.from(getValidIncludesAndExcludes(type, corejs)).filter(function (item) {
      return regexp instanceof RegExp && regexp.test(item);
    });
  };

  var flatten = function flatten(array) {
    var _ref;

    return (_ref = []).concat.apply(_ref, _toConsumableArray(array));
  };

  var expandIncludesAndExcludes = function expandIncludesAndExcludes(plugins, type, corejs) {
    if (plugins === void 0) {
      plugins = [];
    }

    if (plugins.length === 0) return [];
    var selectedPlugins = plugins.map(function (plugin) {
      return selectPlugins(pluginToRegExp(plugin), type, corejs);
    });
    var invalidRegExpList = plugins.filter(function (p, i) {
      return selectedPlugins[i].length === 0;
    });
    v$1.invariant(invalidRegExpList.length === 0, "The plugins/built-ins '" + invalidRegExpList.join(", ") + "' passed to the '" + type + "' option are not\n    valid. Please check data/[plugin-features|built-in-features].js in babel-preset-env");
    return flatten(selectedPlugins);
  };

  var normalizePluginName = function normalizePluginName(plugin) {
    return plugin.replace(/^(@babel\/|babel-)(plugin-)?/, "");
  };
  var checkDuplicateIncludeExcludes = function checkDuplicateIncludeExcludes(include, exclude) {
    if (include === void 0) {
      include = [];
    }

    if (exclude === void 0) {
      exclude = [];
    }

    var duplicates = include.filter(function (opt) {
      return exclude.indexOf(opt) >= 0;
    });
    v$1.invariant(duplicates.length === 0, "The plugins/built-ins '" + duplicates.join(", ") + "' were found in both the \"include\" and\n    \"exclude\" options.");
  };

  var normalizeTargets = function normalizeTargets(targets) {
    if (typeof targets === "string" || Array.isArray(targets)) {
      return {
        browsers: targets
      };
    }

    return Object.assign({}, targets);
  };

  var validateModulesOption = function validateModulesOption(modulesOpt) {
    if (modulesOpt === void 0) {
      modulesOpt = ModulesOption.auto;
    }

    v$1.invariant(ModulesOption[modulesOpt.toString()] || modulesOpt === ModulesOption["false"], "The 'modules' option must be one of \n" + " - 'false' to indicate no module processing\n" + " - a specific module type: 'commonjs', 'amd', 'umd', 'systemjs'" + " - 'auto' (default) which will automatically select 'false' if the current\n" + "   process is known to support ES module syntax, or \"commonjs\" otherwise\n");
    return modulesOpt;
  };
  var validateUseBuiltInsOption = function validateUseBuiltInsOption(builtInsOpt) {
    if (builtInsOpt === void 0) {
      builtInsOpt = false;
    }

    v$1.invariant(UseBuiltInsOption[builtInsOpt.toString()] || builtInsOpt === UseBuiltInsOption["false"], "The 'useBuiltIns' option must be either\n    'false' (default) to indicate no polyfill,\n    '\"entry\"' to indicate replacing the entry polyfill, or\n    '\"usage\"' to import only used polyfills per file");
    return builtInsOpt;
  };
  function normalizeCoreJSOption(corejs, useBuiltIns) {
    var proposals = false;
    var rawVersion;

    if (useBuiltIns && corejs === undefined) {
      rawVersion = 2;
      console.warn("\nWARNING (@babel/preset-env): We noticed you're using the `useBuiltIns` option without declaring a " + "core-js version. Currently, we assume version 2.x when no version " + "is passed. Since this default version will likely change in future " + "versions of Babel, we recommend explicitly setting the core-js version " + "you are using via the `corejs` option.\n" + "\nYou should also be sure that the version you pass to the `corejs` " + "option matches the version specified in your `package.json`'s " + "`dependencies` section. If it doesn't, you need to run one of the " + "following commands:\n\n" + "  npm install --save core-js@2    npm install --save core-js@3\n" + "  yarn add core-js@2              yarn add core-js@3\n\n" + "More info about useBuiltIns: https://babeljs.io/docs/en/babel-preset-env#usebuiltins\n" + "More info about core-js: https://babeljs.io/docs/en/babel-preset-env#corejs");
    } else if (typeof corejs === "object" && corejs !== null) {
      rawVersion = corejs.version;
      proposals = Boolean(corejs.proposals);
    } else {
      rawVersion = corejs;
    }

    var version = rawVersion ? semver$4.coerce(String(rawVersion)) : false;

    if (!useBuiltIns && version) {
      console.warn("\nWARNING (@babel/preset-env): The `corejs` option only has an effect when the `useBuiltIns` option is not `false`\n");
    }

    if (useBuiltIns && (!version || version.major < 2 || version.major > 3)) {
      throw new RangeError("Invalid Option: The version passed to `corejs` is invalid. Currently, " + "only core-js@2 and core-js@3 are supported.");
    }

    return {
      version: version,
      proposals: proposals
    };
  }
  function normalizeOptions$3(opts) {
    v$1.validateTopLevelOptions(opts, TopLevelOptions);
    var useBuiltIns = validateUseBuiltInsOption(opts.useBuiltIns);
    var corejs = normalizeCoreJSOption(opts.corejs, useBuiltIns);
    var include = expandIncludesAndExcludes(opts.include, TopLevelOptions.include, !!corejs.version && corejs.version.major);
    var exclude = expandIncludesAndExcludes(opts.exclude, TopLevelOptions.exclude, !!corejs.version && corejs.version.major);
    checkDuplicateIncludeExcludes(include, exclude);
    return {
      bugfixes: v$1.validateBooleanOption(TopLevelOptions.bugfixes, opts.bugfixes, false),
      configPath: v$1.validateStringOption(TopLevelOptions.configPath, opts.configPath, browser$6.cwd()),
      corejs: corejs,
      debug: v$1.validateBooleanOption(TopLevelOptions.debug, opts.debug, false),
      include: include,
      exclude: exclude,
      forceAllTransforms: v$1.validateBooleanOption(TopLevelOptions.forceAllTransforms, opts.forceAllTransforms, false),
      ignoreBrowserslistConfig: v$1.validateBooleanOption(TopLevelOptions.ignoreBrowserslistConfig, opts.ignoreBrowserslistConfig, false),
      loose: v$1.validateBooleanOption(TopLevelOptions.loose, opts.loose),
      modules: validateModulesOption(opts.modules),
      shippedProposals: v$1.validateBooleanOption(TopLevelOptions.shippedProposals, opts.shippedProposals, false),
      spec: v$1.validateBooleanOption(TopLevelOptions.spec, opts.spec, false),
      targets: normalizeTargets(opts.targets),
      useBuiltIns: useBuiltIns,
      browserslistEnv: v$1.validateStringOption(TopLevelOptions.browserslistEnv, opts.browserslistEnv)
    };
  }

  var proposalPlugins = new Set(["proposal-class-static-block", "proposal-private-property-in-object"]);
  var pluginSyntaxObject = {
    "proposal-async-generator-functions": "syntax-async-generators",
    "proposal-class-properties": "syntax-class-properties",
    "proposal-class-static-block": "syntax-class-static-block",
    "proposal-json-strings": "syntax-json-strings",
    "proposal-nullish-coalescing-operator": "syntax-nullish-coalescing-operator",
    "proposal-numeric-separator": "syntax-numeric-separator",
    "proposal-object-rest-spread": "syntax-object-rest-spread",
    "proposal-optional-catch-binding": "syntax-optional-catch-binding",
    "proposal-optional-chaining": "syntax-optional-chaining",
    "proposal-private-methods": "syntax-class-properties",
    "proposal-private-property-in-object": "syntax-private-property-in-object",
    "proposal-unicode-property-regex": null
  };
  var pluginSyntaxEntries = Object.keys(pluginSyntaxObject).map(function (key) {
    return [key, pluginSyntaxObject[key]];
  });
  var pluginSyntaxMap = new Map(pluginSyntaxEntries);
  var shippedProposals = {
    pluginSyntaxMap: pluginSyntaxMap,
    proposalPlugins: proposalPlugins
  };

  var require$$0 = {
  	"transform-async-to-generator": [
  	"bugfix/transform-async-arrows-in-class"
  ],
  	"transform-parameters": [
  	"bugfix/transform-edge-default-parameters"
  ],
  	"transform-function-name": [
  	"bugfix/transform-edge-function-name"
  ],
  	"transform-block-scoping": [
  	"bugfix/transform-safari-block-shadowing",
  	"bugfix/transform-safari-for-shadowing"
  ],
  	"transform-template-literals": [
  	"bugfix/transform-tagged-template-caching"
  ],
  	"proposal-optional-chaining": [
  	"bugfix/transform-v8-spread-parameters-in-optional-chaining"
  ]
  };

  var overlappingPlugins = require$$0;

  function getImportSource$1(_ref) {
    var node = _ref.node;
    if (node.specifiers.length === 0) return node.source.value;
  }
  function getRequireSource$1(_ref2) {
    var node = _ref2.node;
    if (!isExpressionStatement(node)) return;
    var expression = node.expression;
    var isRequire = isCallExpression(expression) && isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && isStringLiteral(expression.arguments[0]);
    if (isRequire) return expression.arguments[0].value;
  }
  function isPolyfillSource(source) {
    return source === "@babel/polyfill" || source === "core-js";
  }

  function isRegeneratorSource(source) {
    return source === "regenerator-runtime/runtime" || source === "regenerator-runtime/runtime.js";
  }

  function removeRegeneratorEntryPlugin () {
    var visitor = {
      ImportDeclaration: function ImportDeclaration(path) {
        if (isRegeneratorSource(getImportSource$1(path))) {
          this.regeneratorImportExcluded = true;
          path.remove();
        }
      },
      Program: function Program(path) {
        var _this = this;

        path.get("body").forEach(function (bodyPath) {
          if (isRegeneratorSource(getRequireSource$1(bodyPath))) {
            _this.regeneratorImportExcluded = true;
            bodyPath.remove();
          }
        });
      }
    };
    return {
      name: "preset-env/remove-regenerator",
      visitor: visitor,
      pre: function pre() {
        this.regeneratorImportExcluded = false;
      },
      post: function post() {
        if (this.opts.debug && this.regeneratorImportExcluded) {
          var filename = this.file.opts.filename;

          if (browser$6.env.BABEL_ENV === "test") {
            filename = filename.replace(/\\/g, "/");
          }

          console.log("\n[" + filename + "] Based on your targets, regenerator-runtime import excluded.");
        }
      }
    };
  }

  var _templateObject$1, _templateObject2$1, _templateObject3$1, _templateObject4;
  var BABEL_POLYFILL_DEPRECATION = "\n  `@babel/polyfill` is deprecated. Please, use required parts of `core-js`\n  and `regenerator-runtime/runtime` separately";
  var NO_DIRECT_POLYFILL_IMPORT = "\n  When setting `useBuiltIns: 'usage'`, polyfills are automatically imported when needed.\n  Please remove the direct import of `SPECIFIER` or use `useBuiltIns: 'entry'` instead.";
  function legacyBabelPolyfillPlugin (_ref, _ref2) {
    var template = _ref.template;
    var regenerator = _ref2.regenerator,
        deprecated = _ref2.deprecated,
        usage = _ref2.usage;
    return {
      name: "preset-env/replace-babel-polyfill",
      visitor: {
        ImportDeclaration: function ImportDeclaration(path) {
          var src = getImportSource$1(path);

          if (usage && isPolyfillSource(src)) {
            console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
            if (!deprecated) path.remove();
          } else if (src === "@babel/polyfill") {
            if (deprecated) {
              console.warn(BABEL_POLYFILL_DEPRECATION);
            } else if (regenerator) {
              path.replaceWithMultiple(template.ast(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose(["\n              import \"core-js\";\n              import \"regenerator-runtime/runtime.js\";\n            "]))));
            } else {
              path.replaceWith(template.ast(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose(["\n              import \"core-js\";\n            "]))));
            }
          }
        },
        Program: function Program(path) {
          path.get("body").forEach(function (bodyPath) {
            var src = getRequireSource$1(bodyPath);

            if (usage && isPolyfillSource(src)) {
              console.warn(NO_DIRECT_POLYFILL_IMPORT.replace("SPECIFIER", src));
              if (!deprecated) bodyPath.remove();
            } else if (src === "@babel/polyfill") {
              if (deprecated) {
                console.warn(BABEL_POLYFILL_DEPRECATION);
              } else if (regenerator) {
                bodyPath.replaceWithMultiple(template.ast(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose(["\n                require(\"core-js\");\n                require(\"regenerator-runtime/runtime.js\");\n              "]))));
              } else {
                bodyPath.replaceWith(template.ast(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose(["\n                require(\"core-js\");\n              "]))));
              }
            }
          });
        }
      }
    };
  }

  var semver = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;

    if (typeof browser$6 === 'object' && browser$6.env && browser$6.env.NODE_DEBUG && /\bsemver\b/i.test(browser$6.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    }

    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    }

    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+';
    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';
    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')';
    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))';
    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+';
    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))';
    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$';
    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)';
    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g');
    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$';
    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$';
    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')';
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3';
    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$';
    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*';

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      }

      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult;
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a === b;

        case '!==':
          if (typeof a === 'object') a = a.version;
          if (typeof b === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      }

      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || typeof options !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(' ');
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };

    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    }

    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    }

    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    }

    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    }

    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        }

        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            ret = '<0.0.0-0';
          } else {
            ret = '*';
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    }

    function replaceStars(comp, options) {
      debug('replaceStars', comp, options);
      return comp.trim().replace(re[t.STAR], '');
    }

    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    }

    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }

        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              break;

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    }

    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    }

    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }

      if (satisfies(version, range, options)) {
        return false;
      }

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }

        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }

        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  }, "/$$rollup_base$$/packages/babel-preset-env/node_modules/babel-plugin-polyfill-corejs2/node_modules/semver");

  var _excluded = ["method", "targets", "ignoreBrowserslistConfig", "configPath", "debug", "shouldInjectPolyfill", "absoluteImports"];

  var _templateObject, _templateObject2, _templateObject3;

  var _ref$2 = undefined || babel,
      t$1$1 = _ref$2.types,
      template = _ref$2.template;

  function intersection(a, b) {
    var result = new Set();
    a.forEach(function (v) {
      return b.has(v) && result.add(v);
    });
    return result;
  }

  function has$1(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  }

  function getType(target) {
    return Object.prototype.toString.call(target).slice(8, -1);
  }

  function resolveId(path) {
    if (path.isIdentifier() && !path.scope.hasBinding(path.node.name, true)) {
      return path.node.name;
    }

    var _path$evaluate = path.evaluate(),
        deopt = _path$evaluate.deopt;

    if (deopt && deopt.isIdentifier()) {
      return deopt.node.name;
    }
  }

  function resolveKey(path, computed) {
    if (computed === void 0) {
      computed = false;
    }

    var node = path.node,
        parent = path.parent,
        scope = path.scope;
    if (path.isStringLiteral()) return node.value;
    var name = node.name;
    var isIdentifier = path.isIdentifier();
    if (isIdentifier && !(computed || parent.computed)) return name;

    if (computed && path.isMemberExpression() && path.get("object").isIdentifier({
      name: "Symbol"
    }) && !scope.hasBinding("Symbol", true)) {
      var sym = resolveKey(path.get("property"), path.node.computed);
      if (sym) return "Symbol." + sym;
    }

    if (!isIdentifier || scope.hasBinding(name, true)) {
      var _path$evaluate2 = path.evaluate(),
          value = _path$evaluate2.value;

      if (typeof value === "string") return value;
    }
  }

  function resolveSource(obj) {
    if (obj.isMemberExpression() && obj.get("property").isIdentifier({
      name: "prototype"
    })) {
      var _id = resolveId(obj.get("object"));

      if (_id) {
        return {
          id: _id,
          placement: "prototype"
        };
      }

      return {
        id: null,
        placement: null
      };
    }

    var id = resolveId(obj);

    if (id) {
      return {
        id: id,
        placement: "static"
      };
    }

    var _obj$evaluate = obj.evaluate(),
        value = _obj$evaluate.value;

    if (value !== undefined) {
      return {
        id: getType(value),
        placement: "prototype"
      };
    } else if (obj.isRegExpLiteral()) {
      return {
        id: "RegExp",
        placement: "prototype"
      };
    } else if (obj.isFunction()) {
      return {
        id: "Function",
        placement: "prototype"
      };
    }

    return {
      id: null,
      placement: null
    };
  }

  function getImportSource(_ref2) {
    var node = _ref2.node;
    if (node.specifiers.length === 0) return node.source.value;
  }

  function getRequireSource(_ref3) {
    var node = _ref3.node;
    if (!t$1$1.isExpressionStatement(node)) return;
    var expression = node.expression;
    var isRequire = t$1$1.isCallExpression(expression) && t$1$1.isIdentifier(expression.callee) && expression.callee.name === "require" && expression.arguments.length === 1 && t$1$1.isStringLiteral(expression.arguments[0]);
    if (isRequire) return expression.arguments[0].value;
  }

  function hoist(node) {
    node._blockHoist = 3;
    return node;
  }

  function createUtilsGetter(cache) {
    return function (path) {
      var prog = path.findParent(function (p) {
        return p.isProgram();
      });
      return {
        injectGlobalImport: function injectGlobalImport(url) {
          cache.storeAnonymous(prog, url, function (isScript, source) {
            return isScript ? template.statement.ast(_templateObject || (_templateObject = _taggedTemplateLiteralLoose(["require(", ")"])), source) : t$1$1.importDeclaration([], source);
          });
        },
        injectNamedImport: function injectNamedImport(url, name, hint) {
          if (hint === void 0) {
            hint = name;
          }

          return cache.storeNamed(prog, url, name, function (isScript, source, name) {
            var id = prog.scope.generateUidIdentifier(hint);
            return {
              node: isScript ? hoist(template.statement.ast(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose(["\n                  var ", " = require(", ").", "\n                "])), id, source, name)) : t$1$1.importDeclaration([t$1$1.importSpecifier(id, name)], source),
              name: id.name
            };
          });
        },
        injectDefaultImport: function injectDefaultImport(url, hint) {
          if (hint === void 0) {
            hint = url;
          }

          return cache.storeNamed(prog, url, "default", function (isScript, source) {
            var id = prog.scope.generateUidIdentifier(hint);
            return {
              node: isScript ? hoist(template.statement.ast(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose(["var ", " = require(", ")"])), id, source)) : t$1$1.importDeclaration([t$1$1.importDefaultSpecifier(id)], source),
              name: id.name
            };
          });
        }
      };
    };
  }

  var _ref4 = undefined || babel,
      t$3 = _ref4.types;

  var ImportsCache = function () {
    function ImportsCache(resolver) {
      this._imports = new WeakMap();
      this._anonymousImports = new WeakMap();
      this._lastImports = new WeakMap();
      this._resolver = resolver;
    }

    var _proto = ImportsCache.prototype;

    _proto.storeAnonymous = function storeAnonymous(programPath, url, getVal) {
      var key = this._normalizeKey(programPath, url);

      var imports = this._ensure(this._anonymousImports, programPath, Set);

      if (imports.has(key)) return;
      var node = getVal(programPath.node.sourceType === "script", t$3.stringLiteral(this._resolver(url)));
      imports.add(key);

      this._injectImport(programPath, node);
    };

    _proto.storeNamed = function storeNamed(programPath, url, name, getVal) {
      var key = this._normalizeKey(programPath, url, name);

      var imports = this._ensure(this._imports, programPath, Map);

      if (!imports.has(key)) {
        var _getVal = getVal(programPath.node.sourceType === "script", t$3.stringLiteral(this._resolver(url)), t$3.identifier(name)),
            node = _getVal.node,
            id = _getVal.name;

        imports.set(key, id);

        this._injectImport(programPath, node);
      }

      return t$3.identifier(imports.get(key));
    };

    _proto._injectImport = function _injectImport(programPath, node) {
      var lastImport = this._lastImports.get(programPath);

      if (lastImport && lastImport.node && lastImport.parent === programPath.node && lastImport.container === programPath.node.body) {
        lastImport = lastImport.insertAfter(node);
      } else {
        lastImport = programPath.unshiftContainer("body", node);
      }

      lastImport = lastImport[lastImport.length - 1];

      this._lastImports.set(programPath, lastImport);
    };

    _proto._ensure = function _ensure(map, programPath, Collection) {
      var collection = map.get(programPath);

      if (!collection) {
        collection = new Collection();
        map.set(programPath, collection);
      }

      return collection;
    };

    _proto._normalizeKey = function _normalizeKey(programPath, url, name) {
      if (name === void 0) {
        name = "";
      }

      var sourceType = programPath.node.sourceType;
      return (name && sourceType) + "::" + url + "::" + name;
    };

    return ImportsCache;
  }();

  var presetEnvSilentDebugHeader = "#__secret_key__@babel/preset-env__don't_log_debug_header_and_resolved_targets";

  function stringifyTargetsMultiline(targets) {
    return JSON.stringify(prettifyTargets(targets), null, 2);
  }

  function patternToRegExp(pattern) {
    if (pattern instanceof RegExp) return pattern;

    try {
      return new RegExp("^" + pattern + "$");
    } catch (_unused) {
      return null;
    }
  }

  function buildUnusedError(label, unused) {
    if (!unused.length) return "";
    return "  - The following \"" + label + "\" patterns didn't match any polyfill:\n" + unused.map(function (original) {
      return "    " + String(original) + "\n";
    }).join("");
  }

  function buldDuplicatesError(duplicates) {
    if (!duplicates.size) return "";
    return "  - The following polyfills were matched both by \"include\" and \"exclude\" patterns:\n" + Array.from(duplicates, function (name) {
      return "    " + name + "\n";
    }).join("");
  }

  function validateIncludeExclude(provider, polyfills, includePatterns, excludePatterns) {
    var current;

    var filter = function filter(pattern) {
      var regexp = patternToRegExp(pattern);
      if (!regexp) return false;
      var matched = false;

      for (var _iterator = _createForOfIteratorHelperLoose(polyfills), _step; !(_step = _iterator()).done;) {
        var polyfill = _step.value;

        if (regexp.test(polyfill)) {
          matched = true;
          current.add(polyfill);
        }
      }

      return !matched;
    };

    var include = current = new Set();
    var unusedInclude = Array.from(includePatterns).filter(filter);
    var exclude = current = new Set();
    var unusedExclude = Array.from(excludePatterns).filter(filter);
    var duplicates = intersection(include, exclude);

    if (duplicates.size > 0 || unusedInclude.length > 0 || unusedExclude.length > 0) {
      throw new Error("Error while validating the \"" + provider + "\" provider options:\n" + buildUnusedError("include", unusedInclude) + buildUnusedError("exclude", unusedExclude) + buldDuplicatesError(duplicates));
    }

    return {
      include: include,
      exclude: exclude
    };
  }

  function applyMissingDependenciesDefaults(options, babelApi) {
    var _options$missingDepen = options.missingDependencies,
        missingDependencies = _options$missingDepen === void 0 ? {} : _options$missingDepen;
    if (missingDependencies === false) return false;
    var caller = babelApi.caller(function (caller) {
      return caller == null ? void 0 : caller.name;
    });
    var _missingDependencies$ = missingDependencies.log,
        log = _missingDependencies$ === void 0 ? "deferred" : _missingDependencies$,
        _missingDependencies$2 = missingDependencies.inject,
        inject = _missingDependencies$2 === void 0 ? caller === "rollup-plugin-babel" ? "throw" : "import" : _missingDependencies$2,
        _missingDependencies$3 = missingDependencies.all,
        all = _missingDependencies$3 === void 0 ? false : _missingDependencies$3;
    return {
      log: log,
      inject: inject,
      all: all
    };
  }

  var usage = function usage(callProvider) {
    function property(object, key, placement, path) {
      return callProvider({
        kind: "property",
        object: object,
        key: key,
        placement: placement
      }, path);
    }

    return {
      ReferencedIdentifier: function ReferencedIdentifier(path) {
        var name = path.node.name,
            scope = path.scope;
        if (scope.getBindingIdentifier(name)) return;
        callProvider({
          kind: "global",
          name: name
        }, path);
      },
      MemberExpression: function MemberExpression(path) {
        var key = resolveKey(path.get("property"), path.node.computed);
        if (!key || key === "prototype") return;
        var object = path.get("object");
        var binding = object.scope.getBinding(object.node.name);
        if (binding && binding.path.isImportNamespaceSpecifier()) return;
        var source = resolveSource(object);
        return property(source.id, key, source.placement, path);
      },
      ObjectPattern: function ObjectPattern(path) {
        var parentPath = path.parentPath,
            parent = path.parent;
        var obj;

        if (parentPath.isVariableDeclarator()) {
          obj = parentPath.get("init");
        } else if (parentPath.isAssignmentExpression()) {
          obj = parentPath.get("right");
        } else if (parentPath.isFunction()) {
          var grand = parentPath.parentPath;

          if (grand.isCallExpression() || grand.isNewExpression()) {
            if (grand.node.callee === parent) {
              obj = grand.get("arguments")[path.key];
            }
          }
        }

        var id = null;
        var placement = null;

        if (obj) {
          var _resolveSource = resolveSource(obj);

          id = _resolveSource.id;
          placement = _resolveSource.placement;
        }

        for (var _iterator2 = _createForOfIteratorHelperLoose(path.get("properties")), _step2; !(_step2 = _iterator2()).done;) {
          var prop = _step2.value;

          if (prop.isObjectProperty()) {
            var key = resolveKey(prop.get("key"));
            if (key) property(id, key, placement, prop);
          }
        }
      },
      BinaryExpression: function BinaryExpression(path) {
        if (path.node.operator !== "in") return;
        var source = resolveSource(path.get("right"));
        var key = resolveKey(path.get("left"), true);
        if (!key) return;
        callProvider({
          kind: "in",
          object: source.id,
          key: key,
          placement: source.placement
        }, path);
      }
    };
  };

  var entry = function entry(callProvider) {
    return {
      ImportDeclaration: function ImportDeclaration(path) {
        var source = getImportSource(path);
        if (!source) return;
        callProvider({
          kind: "import",
          source: source
        }, path);
      },
      Program: function Program(path) {
        path.get("body").forEach(function (bodyPath) {
          var source = getRequireSource(bodyPath);
          if (!source) return;
          callProvider({
            kind: "import",
            source: source
          }, bodyPath);
        });
      }
    };
  };

  function resolve(dirname, moduleName, absoluteImports) {
    if (absoluteImports === false) return moduleName;
    throw new Error("\"absoluteImports\" is not supported in bundles prepared for the browser.");
  }

  function has$2(basedir, name) {
    return true;
  }

  function logMissing(missingDeps) {}

  function laterLogMissing(missingDeps) {}

  var PossibleGlobalObjects = new Set(["global", "globalThis", "self", "window"]);

  function createMetaResolver(polyfills) {
    var staticP = polyfills["static"],
        instanceP = polyfills.instance,
        globalP = polyfills.global;
    return function (meta) {
      if (meta.kind === "global" && globalP && has$1(globalP, meta.name)) {
        return {
          kind: "global",
          desc: globalP[meta.name],
          name: meta.name
        };
      }

      if (meta.kind === "property" || meta.kind === "in") {
        var placement = meta.placement,
            object = meta.object,
            key = meta.key;

        if (object && placement === "static") {
          if (globalP && PossibleGlobalObjects.has(object) && has$1(globalP, key)) {
            return {
              kind: "global",
              desc: globalP[key],
              name: key
            };
          }

          if (staticP && has$1(staticP, object) && has$1(staticP[object], key)) {
            return {
              kind: "static",
              desc: staticP[object][key],
              name: object + "$" + key
            };
          }
        }

        if (instanceP && has$1(instanceP, key)) {
          return {
            kind: "instance",
            desc: instanceP[key],
            name: "" + key
          };
        }
      }
    };
  }

  var getTargets = getTargets$2["default"] || getTargets$2;

  function resolveOptions(options, babelApi) {
    var method = options.method,
        targetsOption = options.targets,
        ignoreBrowserslistConfig = options.ignoreBrowserslistConfig,
        configPath = options.configPath,
        debug = options.debug,
        shouldInjectPolyfill = options.shouldInjectPolyfill,
        absoluteImports = options.absoluteImports,
        providerOptions = _objectWithoutProperties(options, _excluded);

    var methodName;
    if (method === "usage-global") methodName = "usageGlobal";else if (method === "entry-global") methodName = "entryGlobal";else if (method === "usage-pure") methodName = "usagePure";else if (typeof method !== "string") {
      throw new Error(".method must be a string");
    } else {
      throw new Error(".method must be one of \"entry-global\", \"usage-global\"" + (" or \"usage-pure\" (received " + JSON.stringify(method) + ")"));
    }

    if (typeof shouldInjectPolyfill === "function") {
      if (options.include || options.exclude) {
        throw new Error(".include and .exclude are not supported when using the" + " .shouldInjectPolyfill function.");
      }
    } else if (shouldInjectPolyfill != null) {
      throw new Error(".shouldInjectPolyfill must be a function, or undefined" + (" (received " + JSON.stringify(shouldInjectPolyfill) + ")"));
    }

    if (absoluteImports != null && typeof absoluteImports !== "boolean" && typeof absoluteImports !== "string") {
      throw new Error(".absoluteImports must be a boolean, a string, or undefined" + (" (received " + JSON.stringify(absoluteImports) + ")"));
    }

    var targets;

    if (targetsOption || configPath || ignoreBrowserslistConfig) {
      var targetsObj = typeof targetsOption === "string" || Array.isArray(targetsOption) ? {
        browsers: targetsOption
      } : targetsOption;
      targets = getTargets(targetsObj, {
        ignoreBrowserslistConfig: ignoreBrowserslistConfig,
        configPath: configPath
      });
    } else {
      targets = babelApi.targets();
    }

    return {
      method: method,
      methodName: methodName,
      targets: targets,
      absoluteImports: absoluteImports != null ? absoluteImports : false,
      shouldInjectPolyfill: shouldInjectPolyfill,
      debug: !!debug,
      providerOptions: providerOptions
    };
  }

  function instantiateProvider(factory, options, missingDependencies, dirname, debugLog, babelApi) {
    var _resolveOptions = resolveOptions(options, babelApi),
        method = _resolveOptions.method,
        methodName = _resolveOptions.methodName,
        targets = _resolveOptions.targets,
        _debug = _resolveOptions.debug,
        _shouldInjectPolyfill = _resolveOptions.shouldInjectPolyfill,
        providerOptions = _resolveOptions.providerOptions,
        absoluteImports = _resolveOptions.absoluteImports;

    var getUtils = createUtilsGetter(new ImportsCache(function (moduleName) {
      return resolve(dirname, moduleName, absoluteImports);
    }));
    var include, exclude;
    var polyfillsSupport;
    var polyfillsNames;
    var filterPolyfills;
    var depsCache = new Map();
    var api = {
      babel: babelApi,
      getUtils: getUtils,
      method: options.method,
      targets: targets,
      createMetaResolver: createMetaResolver,
      shouldInjectPolyfill: function shouldInjectPolyfill(name) {
        if (polyfillsNames === undefined) {
          throw new Error("Internal error in the " + factory.name + " provider: " + "shouldInjectPolyfill() can't be called during initialization.");
        }

        if (!polyfillsNames.has(name)) {
          console.warn("Internal error in the " + provider.name + " provider: " + ("unknown polyfill \"" + name + "\"."));
        }

        if (filterPolyfills && !filterPolyfills(name)) return false;
        var shouldInject = isRequired(name, targets, {
          compatData: polyfillsSupport,
          includes: include,
          excludes: exclude
        });

        if (_shouldInjectPolyfill) {
          shouldInject = _shouldInjectPolyfill(name, shouldInject);

          if (typeof shouldInject !== "boolean") {
            throw new Error(".shouldInjectPolyfill must return a boolean.");
          }
        }

        return shouldInject;
      },
      debug: function debug(name) {
        debugLog().found = true;
        if (!_debug || !name) return;
        if (debugLog().polyfills.has(provider.name)) return;
        debugLog().polyfills.set(name, polyfillsSupport && name && polyfillsSupport[name]);
      },
      assertDependency: function assertDependency(name, version) {
        if (version === void 0) {
          version = "*";
        }

        if (missingDependencies === false) return;

        if (absoluteImports) {
          return;
        }

        var dep = version === "*" ? name : name + "@^" + version;
        var found = missingDependencies.all ? false : mapGetOr(depsCache, name + " :: " + dirname, function () {
          return has$2();
        });

        if (!found) {
          debugLog().missingDeps.add(dep);
        }
      }
    };
    var provider = factory(api, providerOptions, dirname);

    if (typeof provider[methodName] !== "function") {
      throw new Error("The \"" + (provider.name || factory.name) + "\" provider doesn't " + ("support the \"" + method + "\" polyfilling method."));
    }

    if (Array.isArray(provider.polyfills)) {
      polyfillsNames = new Set(provider.polyfills);
      filterPolyfills = provider.filterPolyfills;
    } else if (provider.polyfills) {
      polyfillsNames = new Set(Object.keys(provider.polyfills));
      polyfillsSupport = provider.polyfills;
      filterPolyfills = provider.filterPolyfills;
    } else {
      polyfillsNames = new Set();
    }

    var _validateIncludeExclu = validateIncludeExclude(provider.name || factory.name, polyfillsNames, providerOptions.include || [], providerOptions.exclude || []);

    include = _validateIncludeExclu.include;
    exclude = _validateIncludeExclu.exclude;
    return {
      debug: _debug,
      method: method,
      targets: targets,
      provider: provider,
      callProvider: function callProvider(payload, path) {
        var utils = getUtils(path);
        provider[methodName](payload, utils, path);
      }
    };
  }

  function definePolyfillProvider(factory) {
    return declare(function (babelApi, options, dirname) {
      babelApi.assertVersion(7);
      var traverse = babelApi.traverse;
      var debugLog;
      var missingDependencies = applyMissingDependenciesDefaults(options, babelApi);

      var _instantiateProvider = instantiateProvider(factory, options, missingDependencies, dirname, function () {
        return debugLog;
      }, babelApi),
          debug = _instantiateProvider.debug,
          method = _instantiateProvider.method,
          targets = _instantiateProvider.targets,
          provider = _instantiateProvider.provider,
          callProvider = _instantiateProvider.callProvider;

      var createVisitor = method === "entry-global" ? entry : usage;
      var visitor = provider.visitor ? traverse.visitors.merge([createVisitor(callProvider), provider.visitor]) : createVisitor(callProvider);

      if (debug && debug !== presetEnvSilentDebugHeader) {
        console.log(provider.name + ": `DEBUG` option");
        console.log("\nUsing targets: " + stringifyTargetsMultiline(targets));
        console.log("\nUsing polyfills with `" + method + "` method:");
      }

      return {
        name: "inject-polyfills",
        visitor: visitor,
        pre: function pre() {
          var _provider$pre;

          debugLog = {
            polyfills: new Map(),
            found: false,
            providers: new Set(),
            missingDeps: new Set()
          };
          (_provider$pre = provider.pre) == null ? void 0 : _provider$pre.apply(this, arguments);
        },
        post: function post() {
          var _provider$post;

          (_provider$post = provider.post) == null ? void 0 : _provider$post.apply(this, arguments);

          if (missingDependencies !== false) {
            if (missingDependencies.log === "per-file") {
              logMissing(debugLog.missingDeps);
            } else {
              laterLogMissing(debugLog.missingDeps);
            }
          }

          if (!debug) return;
          if (this.filename) console.log("\n[" + this.filename + "]");

          if (debugLog.polyfills.size === 0) {
            console.log(method === "entry-global" ? debugLog.found ? "Based on your targets, the " + provider.name + " polyfill did not add any polyfill." : "The entry point for the " + provider.name + " polyfill has not been found." : "Based on your code and targets, the " + provider.name + " polyfill did not add any polyfill.");
            return;
          }

          if (method === "entry-global") {
            console.log("The " + provider.name + " polyfill entry has been replaced with " + "the following polyfills:");
          } else {
            console.log("The " + provider.name + " polyfill added the following polyfills:");
          }

          for (var _iterator3 = _createForOfIteratorHelperLoose(debugLog.polyfills), _step3; !(_step3 = _iterator3()).done;) {
            var _step3$value = _slicedToArray$2(_step3.value, 2),
                name = _step3$value[0],
                support = _step3$value[1];

            if (support) {
              var filteredTargets = getInclusionReasons(name, targets, support);
              var formattedTargets = JSON.stringify(filteredTargets).replace(/,/g, ", ").replace(/^\{"/, '{ "').replace(/"\}$/, '" }');
              console.log("  " + name + " " + formattedTargets);
            } else {
              console.log("  " + name);
            }
          }
        }
      };
    });
  }

  function mapGetOr(map, key, getDefault) {
    var val = map.get(key);

    if (val === undefined) {
      val = getDefault();
      map.set(key, val);
    }

    return val;
  }

  var define$1 = function define(name, pure, global, meta) {
    if (global === void 0) {
      global = [];
    }

    return {
      name: name,
      pure: pure,
      global: global,
      meta: meta
    };
  };

  var pureAndGlobal = function pureAndGlobal(pure, global, minRuntimeVersion) {
    if (minRuntimeVersion === void 0) {
      minRuntimeVersion = null;
    }

    return define$1(global[0], pure, global, {
      minRuntimeVersion: minRuntimeVersion
    });
  };

  var globalOnly = function globalOnly(global) {
    return define$1(global[0], null, global);
  };

  var pureOnly = function pureOnly(pure, name) {
    return define$1(name, pure, []);
  };

  var ArrayNatureIterators$1 = ["es6.object.to-string", "es6.array.iterator", "web.dom.iterable"];
  var CommonIterators$1 = ["es6.string.iterator"].concat(ArrayNatureIterators$1);
  var PromiseDependencies$1 = ["es6.object.to-string", "es6.promise"];
  var BuiltIns$1 = {
    DataView: globalOnly(["es6.typed.data-view"]),
    Float32Array: globalOnly(["es6.typed.float32-array"]),
    Float64Array: globalOnly(["es6.typed.float64-array"]),
    Int8Array: globalOnly(["es6.typed.int8-array"]),
    Int16Array: globalOnly(["es6.typed.int16-array"]),
    Int32Array: globalOnly(["es6.typed.int32-array"]),
    Map: pureAndGlobal("map", ["es6.map"].concat(_toConsumableArray(CommonIterators$1))),
    Number: globalOnly(["es6.number.constructor"]),
    Promise: pureAndGlobal("promise", PromiseDependencies$1),
    RegExp: globalOnly(["es6.regexp.constructor"]),
    Set: pureAndGlobal("set", ["es6.set"].concat(_toConsumableArray(CommonIterators$1))),
    Symbol: pureAndGlobal("symbol", ["es6.symbol"]),
    Uint8Array: globalOnly(["es6.typed.uint8-array"]),
    Uint8ClampedArray: globalOnly(["es6.typed.uint8-clamped-array"]),
    Uint16Array: globalOnly(["es6.typed.uint16-array"]),
    Uint32Array: globalOnly(["es6.typed.uint32-array"]),
    WeakMap: pureAndGlobal("weak-map", ["es6.weak-map"].concat(_toConsumableArray(CommonIterators$1))),
    WeakSet: pureAndGlobal("weak-set", ["es6.weak-set"].concat(_toConsumableArray(CommonIterators$1))),
    setImmediate: pureOnly("set-immediate", "web.immediate"),
    clearImmediate: pureOnly("clear-immediate", "web.immediate"),
    parseFloat: pureOnly("parse-float", "es6.parse-float"),
    parseInt: pureOnly("parse-int", "es6.parse-int")
  };
  var InstanceProperties$1 = {
    __defineGetter__: globalOnly(["es7.object.define-getter"]),
    __defineSetter__: globalOnly(["es7.object.define-setter"]),
    __lookupGetter__: globalOnly(["es7.object.lookup-getter"]),
    __lookupSetter__: globalOnly(["es7.object.lookup-setter"]),
    anchor: globalOnly(["es6.string.anchor"]),
    big: globalOnly(["es6.string.big"]),
    bind: globalOnly(["es6.function.bind"]),
    blink: globalOnly(["es6.string.blink"]),
    bold: globalOnly(["es6.string.bold"]),
    codePointAt: globalOnly(["es6.string.code-point-at"]),
    copyWithin: globalOnly(["es6.array.copy-within"]),
    endsWith: globalOnly(["es6.string.ends-with"]),
    entries: globalOnly(ArrayNatureIterators$1),
    every: globalOnly(["es6.array.every"]),
    fill: globalOnly(["es6.array.fill"]),
    filter: globalOnly(["es6.array.filter"]),
    "finally": globalOnly(["es7.promise.finally"].concat(PromiseDependencies$1)),
    find: globalOnly(["es6.array.find"]),
    findIndex: globalOnly(["es6.array.find-index"]),
    fixed: globalOnly(["es6.string.fixed"]),
    flags: globalOnly(["es6.regexp.flags"]),
    flatMap: globalOnly(["es7.array.flat-map"]),
    fontcolor: globalOnly(["es6.string.fontcolor"]),
    fontsize: globalOnly(["es6.string.fontsize"]),
    forEach: globalOnly(["es6.array.for-each"]),
    includes: globalOnly(["es6.string.includes", "es7.array.includes"]),
    indexOf: globalOnly(["es6.array.index-of"]),
    italics: globalOnly(["es6.string.italics"]),
    keys: globalOnly(ArrayNatureIterators$1),
    lastIndexOf: globalOnly(["es6.array.last-index-of"]),
    link: globalOnly(["es6.string.link"]),
    map: globalOnly(["es6.array.map"]),
    match: globalOnly(["es6.regexp.match"]),
    name: globalOnly(["es6.function.name"]),
    padStart: globalOnly(["es7.string.pad-start"]),
    padEnd: globalOnly(["es7.string.pad-end"]),
    reduce: globalOnly(["es6.array.reduce"]),
    reduceRight: globalOnly(["es6.array.reduce-right"]),
    repeat: globalOnly(["es6.string.repeat"]),
    replace: globalOnly(["es6.regexp.replace"]),
    search: globalOnly(["es6.regexp.search"]),
    small: globalOnly(["es6.string.small"]),
    some: globalOnly(["es6.array.some"]),
    sort: globalOnly(["es6.array.sort"]),
    split: globalOnly(["es6.regexp.split"]),
    startsWith: globalOnly(["es6.string.starts-with"]),
    strike: globalOnly(["es6.string.strike"]),
    sub: globalOnly(["es6.string.sub"]),
    sup: globalOnly(["es6.string.sup"]),
    toISOString: globalOnly(["es6.date.to-iso-string"]),
    toJSON: globalOnly(["es6.date.to-json"]),
    toString: globalOnly(["es6.object.to-string", "es6.date.to-string", "es6.regexp.to-string"]),
    trim: globalOnly(["es6.string.trim"]),
    trimEnd: globalOnly(["es7.string.trim-right"]),
    trimLeft: globalOnly(["es7.string.trim-left"]),
    trimRight: globalOnly(["es7.string.trim-right"]),
    trimStart: globalOnly(["es7.string.trim-left"]),
    values: globalOnly(ArrayNatureIterators$1)
  };

  if ("es6.array.slice" in corejs2BuiltIns) {
    InstanceProperties$1.slice = globalOnly(["es6.array.slice"]);
  }

  var StaticProperties$1 = {
    Array: {
      from: pureAndGlobal("array/from", ["es6.symbol", "es6.array.from"].concat(_toConsumableArray(CommonIterators$1))),
      isArray: pureAndGlobal("array/is-array", ["es6.array.is-array"]),
      of: pureAndGlobal("array/of", ["es6.array.of"])
    },
    Date: {
      now: pureAndGlobal("date/now", ["es6.date.now"])
    },
    JSON: {
      stringify: pureOnly("json/stringify", "es6.symbol")
    },
    Math: {
      acosh: pureAndGlobal("math/acosh", ["es6.math.acosh"], "7.0.1"),
      asinh: pureAndGlobal("math/asinh", ["es6.math.asinh"], "7.0.1"),
      atanh: pureAndGlobal("math/atanh", ["es6.math.atanh"], "7.0.1"),
      cbrt: pureAndGlobal("math/cbrt", ["es6.math.cbrt"], "7.0.1"),
      clz32: pureAndGlobal("math/clz32", ["es6.math.clz32"], "7.0.1"),
      cosh: pureAndGlobal("math/cosh", ["es6.math.cosh"], "7.0.1"),
      expm1: pureAndGlobal("math/expm1", ["es6.math.expm1"], "7.0.1"),
      fround: pureAndGlobal("math/fround", ["es6.math.fround"], "7.0.1"),
      hypot: pureAndGlobal("math/hypot", ["es6.math.hypot"], "7.0.1"),
      imul: pureAndGlobal("math/imul", ["es6.math.imul"], "7.0.1"),
      log1p: pureAndGlobal("math/log1p", ["es6.math.log1p"], "7.0.1"),
      log10: pureAndGlobal("math/log10", ["es6.math.log10"], "7.0.1"),
      log2: pureAndGlobal("math/log2", ["es6.math.log2"], "7.0.1"),
      sign: pureAndGlobal("math/sign", ["es6.math.sign"], "7.0.1"),
      sinh: pureAndGlobal("math/sinh", ["es6.math.sinh"], "7.0.1"),
      tanh: pureAndGlobal("math/tanh", ["es6.math.tanh"], "7.0.1"),
      trunc: pureAndGlobal("math/trunc", ["es6.math.trunc"], "7.0.1")
    },
    Number: {
      EPSILON: pureAndGlobal("number/epsilon", ["es6.number.epsilon"]),
      MIN_SAFE_INTEGER: pureAndGlobal("number/min-safe-integer", ["es6.number.min-safe-integer"]),
      MAX_SAFE_INTEGER: pureAndGlobal("number/max-safe-integer", ["es6.number.max-safe-integer"]),
      isFinite: pureAndGlobal("number/is-finite", ["es6.number.is-finite"]),
      isInteger: pureAndGlobal("number/is-integer", ["es6.number.is-integer"]),
      isSafeInteger: pureAndGlobal("number/is-safe-integer", ["es6.number.is-safe-integer"]),
      isNaN: pureAndGlobal("number/is-nan", ["es6.number.is-nan"]),
      parseFloat: pureAndGlobal("number/parse-float", ["es6.number.parse-float"]),
      parseInt: pureAndGlobal("number/parse-int", ["es6.number.parse-int"])
    },
    Object: {
      assign: pureAndGlobal("object/assign", ["es6.object.assign"]),
      create: pureAndGlobal("object/create", ["es6.object.create"]),
      defineProperties: pureAndGlobal("object/define-properties", ["es6.object.define-properties"]),
      defineProperty: pureAndGlobal("object/define-property", ["es6.object.define-property"]),
      entries: pureAndGlobal("object/entries", ["es7.object.entries"]),
      freeze: pureAndGlobal("object/freeze", ["es6.object.freeze"]),
      getOwnPropertyDescriptor: pureAndGlobal("object/get-own-property-descriptor", ["es6.object.get-own-property-descriptor"]),
      getOwnPropertyDescriptors: pureAndGlobal("object/get-own-property-descriptors", ["es7.object.get-own-property-descriptors"]),
      getOwnPropertyNames: pureAndGlobal("object/get-own-property-names", ["es6.object.get-own-property-names"]),
      getOwnPropertySymbols: pureAndGlobal("object/get-own-property-symbols", ["es6.symbol"]),
      getPrototypeOf: pureAndGlobal("object/get-prototype-of", ["es6.object.get-prototype-of"]),
      is: pureAndGlobal("object/is", ["es6.object.is"]),
      isExtensible: pureAndGlobal("object/is-extensible", ["es6.object.is-extensible"]),
      isFrozen: pureAndGlobal("object/is-frozen", ["es6.object.is-frozen"]),
      isSealed: pureAndGlobal("object/is-sealed", ["es6.object.is-sealed"]),
      keys: pureAndGlobal("object/keys", ["es6.object.keys"]),
      preventExtensions: pureAndGlobal("object/prevent-extensions", ["es6.object.prevent-extensions"]),
      seal: pureAndGlobal("object/seal", ["es6.object.seal"]),
      setPrototypeOf: pureAndGlobal("object/set-prototype-of", ["es6.object.set-prototype-of"]),
      values: pureAndGlobal("object/values", ["es7.object.values"])
    },
    Promise: {
      all: globalOnly(CommonIterators$1),
      race: globalOnly(CommonIterators$1)
    },
    Reflect: {
      apply: pureAndGlobal("reflect/apply", ["es6.reflect.apply"]),
      construct: pureAndGlobal("reflect/construct", ["es6.reflect.construct"]),
      defineProperty: pureAndGlobal("reflect/define-property", ["es6.reflect.define-property"]),
      deleteProperty: pureAndGlobal("reflect/delete-property", ["es6.reflect.delete-property"]),
      get: pureAndGlobal("reflect/get", ["es6.reflect.get"]),
      getOwnPropertyDescriptor: pureAndGlobal("reflect/get-own-property-descriptor", ["es6.reflect.get-own-property-descriptor"]),
      getPrototypeOf: pureAndGlobal("reflect/get-prototype-of", ["es6.reflect.get-prototype-of"]),
      has: pureAndGlobal("reflect/has", ["es6.reflect.has"]),
      isExtensible: pureAndGlobal("reflect/is-extensible", ["es6.reflect.is-extensible"]),
      ownKeys: pureAndGlobal("reflect/own-keys", ["es6.reflect.own-keys"]),
      preventExtensions: pureAndGlobal("reflect/prevent-extensions", ["es6.reflect.prevent-extensions"]),
      set: pureAndGlobal("reflect/set", ["es6.reflect.set"]),
      setPrototypeOf: pureAndGlobal("reflect/set-prototype-of", ["es6.reflect.set-prototype-of"])
    },
    String: {
      at: pureOnly("string/at", "es7.string.at"),
      fromCodePoint: pureAndGlobal("string/from-code-point", ["es6.string.from-code-point"]),
      raw: pureAndGlobal("string/raw", ["es6.string.raw"])
    },
    Symbol: {
      asyncIterator: globalOnly(["es6.symbol", "es7.symbol.async-iterator"]),
      "for": pureOnly("symbol/for", "es6.symbol"),
      hasInstance: pureOnly("symbol/has-instance", "es6.symbol"),
      isConcatSpreadable: pureOnly("symbol/is-concat-spreadable", "es6.symbol"),
      iterator: define$1("es6.symbol", "symbol/iterator", CommonIterators$1),
      keyFor: pureOnly("symbol/key-for", "es6.symbol"),
      match: pureAndGlobal("symbol/match", ["es6.regexp.match"]),
      replace: pureOnly("symbol/replace", "es6.symbol"),
      search: pureOnly("symbol/search", "es6.symbol"),
      species: pureOnly("symbol/species", "es6.symbol"),
      split: pureOnly("symbol/split", "es6.symbol"),
      toPrimitive: pureOnly("symbol/to-primitive", "es6.symbol"),
      toStringTag: pureOnly("symbol/to-string-tag", "es6.symbol"),
      unscopables: pureOnly("symbol/unscopables", "es6.symbol")
    }
  };
  var webPolyfills = {
    "web.timers": {},
    "web.immediate": {},
    "web.dom.iterable": {}
  };
  var purePolyfills = {
    "es6.parse-float": {},
    "es6.parse-int": {},
    "es7.string.at": {}
  };

  function addPlatformSpecificPolyfills(targets, method, polyfills) {
    var targetNames = Object.keys(targets);
    var isAnyTarget = !targetNames.length;
    var isWebTarget = targetNames.some(function (name) {
      return name !== "node";
    });
    return Object.assign(Object.assign(Object.assign({}, polyfills), method === "usage-pure" ? purePolyfills : null), isAnyTarget || isWebTarget ? webPolyfills : null);
  }

  function hasMinVersion(minVersion, runtimeVersion) {
    if (!runtimeVersion || !minVersion) return true;
    if (semver.valid(runtimeVersion)) runtimeVersion = "^" + runtimeVersion;
    return !semver.intersects("<" + minVersion, runtimeVersion) && !semver.intersects(">=8.0.0", runtimeVersion);
  }

  var _ref$1 = undefined || babel,
      t$2 = _ref$1.types;

  var presetEnvCompat = "#__secret_key__@babel/preset-env__compatibility";
  var runtimeCompat$2 = "#__secret_key__@babel/runtime__compatibility";
  var has = Function.call.bind(Object.hasOwnProperty);
  var index$2 = definePolyfillProvider(function (api, _ref2) {
    var _ref2$presetEnvCompat = _ref2[presetEnvCompat];
    _ref2$presetEnvCompat = _ref2$presetEnvCompat === void 0 ? {} : _ref2$presetEnvCompat;
    var entryInjectRegenerator = _ref2$presetEnvCompat.entryInjectRegenerator,
        _ref2$runtimeCompat = _ref2[runtimeCompat$2];
    _ref2$runtimeCompat = _ref2$runtimeCompat === void 0 ? {} : _ref2$runtimeCompat;
    var useBabelRuntime = _ref2$runtimeCompat.useBabelRuntime,
        runtimeVersion = _ref2$runtimeCompat.runtimeVersion,
        _ref2$runtimeCompat$e = _ref2$runtimeCompat.ext,
        ext = _ref2$runtimeCompat$e === void 0 ? ".js" : _ref2$runtimeCompat$e;
    var resolve = api.createMetaResolver({
      global: BuiltIns$1,
      "static": StaticProperties$1,
      instance: InstanceProperties$1
    });
    var debug = api.debug,
        shouldInjectPolyfill = api.shouldInjectPolyfill,
        method = api.method;
    var polyfills = addPlatformSpecificPolyfills(api.targets, method, corejs2BuiltIns);
    var coreJSBase = useBabelRuntime ? useBabelRuntime + "/core-js" : method === "usage-pure" ? "core-js/library/fn" : "core-js/modules";

    function inject(name, utils) {
      if (typeof name === "string") {
        if (has(polyfills, name) && shouldInjectPolyfill(name)) {
          debug(name);
          utils.injectGlobalImport(coreJSBase + "/" + name + ".js");
        }

        return;
      }

      name.forEach(function (name) {
        return inject(name, utils);
      });
    }

    function maybeInjectPure(desc, hint, utils) {
      var pure = desc.pure,
          meta = desc.meta,
          name = desc.name;
      if (!pure || !shouldInjectPolyfill(name)) return;

      if (runtimeVersion && meta && meta.minRuntimeVersion && !hasMinVersion(meta && meta.minRuntimeVersion, runtimeVersion)) {
        return;
      }

      return utils.injectDefaultImport(coreJSBase + "/" + pure + ext, hint);
    }

    return {
      name: "corejs2",
      polyfills: polyfills,
      entryGlobal: function entryGlobal(meta, utils, path) {
        if (meta.kind === "import" && meta.source === "core-js") {
          debug(null);
          inject(Object.keys(polyfills), utils);

          if (entryInjectRegenerator) {
            utils.injectGlobalImport("regenerator-runtime/runtime.js");
          }

          path.remove();
        }
      },
      usageGlobal: function usageGlobal(meta, utils) {
        var resolved = resolve(meta);
        if (!resolved) return;
        var deps = resolved.desc.global;

        if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
          var low = meta.object.toLowerCase();
          deps = deps.filter(function (m) {
            return m.includes(low);
          });
        }

        inject(deps, utils);
      },
      usagePure: function usagePure(meta, utils, path) {
        if (meta.kind === "in") {
          if (meta.key === "Symbol.iterator") {
            path.replaceWith(t$2.callExpression(utils.injectDefaultImport(coreJSBase + "/is-iterable" + ext, "isIterable"), [path.node.right]));
          }

          return;
        }

        if (path.parentPath.isUnaryExpression({
          operator: "delete"
        })) return;

        if (meta.kind === "property") {
          if (!path.isMemberExpression()) return;
          if (!path.isReferenced()) return;

          if (meta.key === "Symbol.iterator" && shouldInjectPolyfill("es6.symbol") && path.parentPath.isCallExpression({
            callee: path.node
          }) && path.parent.arguments.length === 0) {
            path.parentPath.replaceWith(t$2.callExpression(utils.injectDefaultImport(coreJSBase + "/get-iterator" + ext, "getIterator"), [path.node.object]));
            path.skip();
            return;
          }
        }

        var resolved = resolve(meta);
        if (!resolved) return;
        var id = maybeInjectPure(resolved.desc, resolved.name, utils);
        if (id) path.replaceWith(id);
      },
      visitor: method === "usage-global" && {
        YieldExpression: function YieldExpression(path) {
          if (path.node.delegate) {
            inject("web.dom.iterable", api.getUtils(path));
          }
        },
        "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
          CommonIterators$1.forEach(function (name) {
            return inject(name, api.getUtils(path));
          });
        }
      }
    };
  });

  var data = require$$0$3;

  var getModulesListForTargetVersion = getModulesListForTargetVersion$2;

  var entries = require$$0$2;

  var corejs3ShippedProposalsList = new Set(["esnext.global-this", "esnext.string.match-all"]);
  var polyfillsOrder = {};
  Object.keys(data).forEach(function (name, index) {
    polyfillsOrder[name] = index;
  });

  var define = function define(pure, global, name, exclude) {
    if (name === void 0) {
      name = global[0];
    }

    return {
      name: name,
      pure: pure,
      global: global.sort(function (a, b) {
        return polyfillsOrder[a] - polyfillsOrder[b];
      }),
      exclude: exclude
    };
  };

  var typed = function typed(name) {
    return define(null, [name].concat(TypedArrayDependencies));
  };

  var ArrayNatureIterators = ["es.array.iterator", "web.dom-collections.iterator"];
  var CommonIterators = ["es.string.iterator"].concat(ArrayNatureIterators);
  var ArrayNatureIteratorsWithTag = ["es.object.to-string"].concat(ArrayNatureIterators);
  var CommonIteratorsWithTag = ["es.object.to-string"].concat(_toConsumableArray(CommonIterators));
  var TypedArrayDependencies = ["es.typed-array.copy-within", "es.typed-array.every", "es.typed-array.fill", "es.typed-array.filter", "es.typed-array.find", "es.typed-array.find-index", "es.typed-array.for-each", "es.typed-array.includes", "es.typed-array.index-of", "es.typed-array.iterator", "es.typed-array.join", "es.typed-array.last-index-of", "es.typed-array.map", "es.typed-array.reduce", "es.typed-array.reduce-right", "es.typed-array.reverse", "es.typed-array.set", "es.typed-array.slice", "es.typed-array.some", "es.typed-array.sort", "es.typed-array.subarray", "es.typed-array.to-locale-string", "es.typed-array.to-string", "es.object.to-string", "es.array.iterator", "es.array-buffer.slice"];
  var TypedArrayStaticMethods = {
    from: define(null, ["es.typed-array.from"]),
    of: define(null, ["es.typed-array.of"])
  };
  var PromiseDependencies = ["es.promise", "es.object.to-string"];
  var PromiseDependenciesWithIterators = [].concat(PromiseDependencies, _toConsumableArray(CommonIterators));
  var SymbolDependencies = ["es.symbol", "es.symbol.description", "es.object.to-string"];
  var MapDependencies = ["es.map", "esnext.map.delete-all", "esnext.map.every", "esnext.map.filter", "esnext.map.find", "esnext.map.find-key", "esnext.map.includes", "esnext.map.key-of", "esnext.map.map-keys", "esnext.map.map-values", "esnext.map.merge", "esnext.map.reduce", "esnext.map.some", "esnext.map.update"].concat(_toConsumableArray(CommonIteratorsWithTag));
  var SetDependencies = ["es.set", "esnext.set.add-all", "esnext.set.delete-all", "esnext.set.difference", "esnext.set.every", "esnext.set.filter", "esnext.set.find", "esnext.set.intersection", "esnext.set.is-disjoint-from", "esnext.set.is-subset-of", "esnext.set.is-superset-of", "esnext.set.join", "esnext.set.map", "esnext.set.reduce", "esnext.set.some", "esnext.set.symmetric-difference", "esnext.set.union"].concat(_toConsumableArray(CommonIteratorsWithTag));
  var WeakMapDependencies = ["es.weak-map", "esnext.weak-map.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag));
  var WeakSetDependencies = ["es.weak-set", "esnext.weak-set.add-all", "esnext.weak-set.delete-all"].concat(_toConsumableArray(CommonIteratorsWithTag));
  var URLSearchParamsDependencies = ["web.url"].concat(_toConsumableArray(CommonIteratorsWithTag));
  var BuiltIns = {
    AggregateError: define("aggregate-error", ["esnext.aggregate-error"].concat(_toConsumableArray(CommonIterators))),
    ArrayBuffer: define(null, ["es.array-buffer.constructor", "es.array-buffer.slice", "es.object.to-string"]),
    DataView: define(null, ["es.data-view", "es.array-buffer.slice", "es.object.to-string"]),
    Date: define(null, ["es.date.to-string"]),
    Float32Array: typed("es.typed-array.float32-array"),
    Float64Array: typed("es.typed-array.float64-array"),
    Int8Array: typed("es.typed-array.int8-array"),
    Int16Array: typed("es.typed-array.int16-array"),
    Int32Array: typed("es.typed-array.int32-array"),
    Uint8Array: typed("es.typed-array.uint8-array"),
    Uint8ClampedArray: typed("es.typed-array.uint8-clamped-array"),
    Uint16Array: typed("es.typed-array.uint16-array"),
    Uint32Array: typed("es.typed-array.uint32-array"),
    Map: define("map/index", MapDependencies),
    Number: define(null, ["es.number.constructor"]),
    Observable: define("observable/index", ["esnext.observable", "esnext.symbol.observable", "es.object.to-string"].concat(_toConsumableArray(CommonIteratorsWithTag))),
    Promise: define("promise/index", PromiseDependencies),
    RegExp: define(null, ["es.regexp.constructor", "es.regexp.exec", "es.regexp.to-string"]),
    Set: define("set/index", SetDependencies),
    Symbol: define("symbol/index", SymbolDependencies),
    URL: define("url/index", ["web.url"].concat(_toConsumableArray(URLSearchParamsDependencies))),
    URLSearchParams: define("url-search-params/index", URLSearchParamsDependencies),
    WeakMap: define("weak-map/index", WeakMapDependencies),
    WeakSet: define("weak-set/index", WeakSetDependencies),
    clearImmediate: define("clear-immediate", ["web.immediate"]),
    compositeKey: define("composite-key", ["esnext.composite-key"]),
    compositeSymbol: define("composite-symbol", ["esnext.composite-symbol"]),
    fetch: define(null, PromiseDependencies),
    globalThis: define("global-this", ["es.global-this"]),
    parseFloat: define("parse-float", ["es.parse-float"]),
    parseInt: define("parse-int", ["es.parse-int"]),
    queueMicrotask: define("queue-microtask", ["web.queue-microtask"]),
    setImmediate: define("set-immediate", ["web.immediate"]),
    setInterval: define("set-interval", ["web.timers"]),
    setTimeout: define("set-timeout", ["web.timers"])
  };
  var StaticProperties = {
    Array: {
      from: define("array/from", ["es.array.from", "es.string.iterator"]),
      isArray: define("array/is-array", ["es.array.is-array"]),
      of: define("array/of", ["es.array.of"])
    },
    ArrayBuffer: {
      isView: define(null, ["es.array-buffer.is-view"])
    },
    Date: {
      now: define("date/now", ["es.date.now"])
    },
    JSON: {
      stringify: define("json/stringify", [], "es.symbol")
    },
    Math: {
      DEG_PER_RAD: define("math/deg-per-rad", ["esnext.math.deg-per-rad"]),
      RAD_PER_DEG: define("math/rad-per-deg", ["esnext.math.rad-per-deg"]),
      acosh: define("math/acosh", ["es.math.acosh"]),
      asinh: define("math/asinh", ["es.math.asinh"]),
      atanh: define("math/atanh", ["es.math.atanh"]),
      cbrt: define("math/cbrt", ["es.math.cbrt"]),
      clamp: define("math/clamp", ["esnext.math.clamp"]),
      clz32: define("math/clz32", ["es.math.clz32"]),
      cosh: define("math/cosh", ["es.math.cosh"]),
      degrees: define("math/degrees", ["esnext.math.degrees"]),
      expm1: define("math/expm1", ["es.math.expm1"]),
      fround: define("math/fround", ["es.math.fround"]),
      fscale: define("math/fscale", ["esnext.math.fscale"]),
      hypot: define("math/hypot", ["es.math.hypot"]),
      iaddh: define("math/iaddh", ["esnext.math.iaddh"]),
      imul: define("math/imul", ["es.math.imul"]),
      imulh: define("math/imulh", ["esnext.math.imulh"]),
      isubh: define("math/isubh", ["esnext.math.isubh"]),
      log10: define("math/log10", ["es.math.log10"]),
      log1p: define("math/log1p", ["es.math.log1p"]),
      log2: define("math/log2", ["es.math.log2"]),
      radians: define("math/radians", ["esnext.math.radians"]),
      scale: define("math/scale", ["esnext.math.scale"]),
      seededPRNG: define("math/seeded-prng", ["esnext.math.seeded-prng"]),
      sign: define("math/sign", ["es.math.sign"]),
      signbit: define("math/signbit", ["esnext.math.signbit"]),
      sinh: define("math/sinh", ["es.math.sinh"]),
      tanh: define("math/tanh", ["es.math.tanh"]),
      trunc: define("math/trunc", ["es.math.trunc"]),
      umulh: define("math/umulh", ["esnext.math.umulh"])
    },
    Map: {
      from: define(null, ["esnext.map.from"].concat(_toConsumableArray(MapDependencies))),
      groupBy: define(null, ["esnext.map.group-by"].concat(_toConsumableArray(MapDependencies))),
      keyBy: define(null, ["esnext.map.key-by"].concat(_toConsumableArray(MapDependencies))),
      of: define(null, ["esnext.map.of"].concat(_toConsumableArray(MapDependencies)))
    },
    Number: {
      EPSILON: define("number/epsilon", ["es.number.epsilon"]),
      MAX_SAFE_INTEGER: define("number/max-safe-integer", ["es.number.max-safe-integer"]),
      MIN_SAFE_INTEGER: define("number/min-safe-integer", ["es.number.min-safe-integer"]),
      fromString: define("number/from-string", ["esnext.number.from-string"]),
      isFinite: define("number/is-finite", ["es.number.is-finite"]),
      isInteger: define("number/is-integer", ["es.number.is-integer"]),
      isNaN: define("number/is-nan", ["es.number.is-nan"]),
      isSafeInteger: define("number/is-safe-integer", ["es.number.is-safe-integer"]),
      parseFloat: define("number/parse-float", ["es.number.parse-float"]),
      parseInt: define("number/parse-int", ["es.number.parse-int"])
    },
    Object: {
      assign: define("object/assign", ["es.object.assign"]),
      create: define("object/create", ["es.object.create"]),
      defineProperties: define("object/define-properties", ["es.object.define-properties"]),
      defineProperty: define("object/define-property", ["es.object.define-property"]),
      entries: define("object/entries", ["es.object.entries"]),
      freeze: define("object/freeze", ["es.object.freeze"]),
      fromEntries: define("object/from-entries", ["es.object.from-entries", "es.array.iterator"]),
      getOwnPropertyDescriptor: define("object/get-own-property-descriptor", ["es.object.get-own-property-descriptor"]),
      getOwnPropertyDescriptors: define("object/get-own-property-descriptors", ["es.object.get-own-property-descriptors"]),
      getOwnPropertyNames: define("object/get-own-property-names", ["es.object.get-own-property-names"]),
      getOwnPropertySymbols: define("object/get-own-property-symbols", ["es.symbol"]),
      getPrototypeOf: define("object/get-prototype-of", ["es.object.get-prototype-of"]),
      is: define("object/is", ["es.object.is"]),
      isExtensible: define("object/is-extensible", ["es.object.is-extensible"]),
      isFrozen: define("object/is-frozen", ["es.object.is-frozen"]),
      isSealed: define("object/is-sealed", ["es.object.is-sealed"]),
      keys: define("object/keys", ["es.object.keys"]),
      preventExtensions: define("object/prevent-extensions", ["es.object.prevent-extensions"]),
      seal: define("object/seal", ["es.object.seal"]),
      setPrototypeOf: define("object/set-prototype-of", ["es.object.set-prototype-of"]),
      values: define("object/values", ["es.object.values"])
    },
    Promise: {
      all: define(null, PromiseDependenciesWithIterators),
      allSettled: define(null, ["es.promise.all-settled"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
      any: define(null, ["esnext.promise.any"].concat(_toConsumableArray(PromiseDependenciesWithIterators))),
      race: define(null, PromiseDependenciesWithIterators),
      "try": define(null, ["esnext.promise.try"].concat(_toConsumableArray(PromiseDependenciesWithIterators)))
    },
    Reflect: {
      apply: define("reflect/apply", ["es.reflect.apply"]),
      construct: define("reflect/construct", ["es.reflect.construct"]),
      defineMetadata: define("reflect/define-metadata", ["esnext.reflect.define-metadata"]),
      defineProperty: define("reflect/define-property", ["es.reflect.define-property"]),
      deleteMetadata: define("reflect/delete-metadata", ["esnext.reflect.delete-metadata"]),
      deleteProperty: define("reflect/delete-property", ["es.reflect.delete-property"]),
      get: define("reflect/get", ["es.reflect.get"]),
      getMetadata: define("reflect/get-metadata", ["esnext.reflect.get-metadata"]),
      getMetadataKeys: define("reflect/get-metadata-keys", ["esnext.reflect.get-metadata-keys"]),
      getOwnMetadata: define("reflect/get-own-metadata", ["esnext.reflect.get-own-metadata"]),
      getOwnMetadataKeys: define("reflect/get-own-metadata-keys", ["esnext.reflect.get-own-metadata-keys"]),
      getOwnPropertyDescriptor: define("reflect/get-own-property-descriptor", ["es.reflect.get-own-property-descriptor"]),
      getPrototypeOf: define("reflect/get-prototype-of", ["es.reflect.get-prototype-of"]),
      has: define("reflect/has", ["es.reflect.has"]),
      hasMetadata: define("reflect/has-metadata", ["esnext.reflect.has-metadata"]),
      hasOwnMetadata: define("reflect/has-own-metadata", ["esnext.reflect.has-own-metadata"]),
      isExtensible: define("reflect/is-extensible", ["es.reflect.is-extensible"]),
      metadata: define("reflect/metadata", ["esnext.reflect.metadata"]),
      ownKeys: define("reflect/own-keys", ["es.reflect.own-keys"]),
      preventExtensions: define("reflect/prevent-extensions", ["es.reflect.prevent-extensions"]),
      set: define("reflect/set", ["es.reflect.set"]),
      setPrototypeOf: define("reflect/set-prototype-of", ["es.reflect.set-prototype-of"])
    },
    Set: {
      from: define(null, ["esnext.set.from"].concat(_toConsumableArray(SetDependencies))),
      of: define(null, ["esnext.set.of"].concat(_toConsumableArray(SetDependencies)))
    },
    String: {
      fromCodePoint: define("string/from-code-point", ["es.string.from-code-point"]),
      raw: define("string/raw", ["es.string.raw"])
    },
    Symbol: {
      asyncIterator: define("symbol/async-iterator", ["es.symbol.async-iterator"]),
      dispose: define("symbol/dispose", ["esnext.symbol.dispose"]),
      "for": define("symbol/for", [], "es.symbol"),
      hasInstance: define("symbol/has-instance", ["es.symbol.has-instance", "es.function.has-instance"]),
      isConcatSpreadable: define("symbol/is-concat-spreadable", ["es.symbol.is-concat-spreadable", "es.array.concat"]),
      iterator: define("symbol/iterator", ["es.symbol.iterator"].concat(_toConsumableArray(CommonIteratorsWithTag))),
      keyFor: define("symbol/key-for", [], "es.symbol"),
      match: define("symbol/match", ["es.symbol.match", "es.string.match"]),
      observable: define("symbol/observable", ["esnext.symbol.observable"]),
      patternMatch: define("symbol/pattern-match", ["esnext.symbol.pattern-match"]),
      replace: define("symbol/replace", ["es.symbol.replace", "es.string.replace"]),
      search: define("symbol/search", ["es.symbol.search", "es.string.search"]),
      species: define("symbol/species", ["es.symbol.species", "es.array.species"]),
      split: define("symbol/split", ["es.symbol.split", "es.string.split"]),
      toPrimitive: define("symbol/to-primitive", ["es.symbol.to-primitive", "es.date.to-primitive"]),
      toStringTag: define("symbol/to-string-tag", ["es.symbol.to-string-tag", "es.object.to-string", "es.math.to-string-tag", "es.json.to-string-tag"]),
      unscopables: define("symbol/unscopables", ["es.symbol.unscopables"])
    },
    WeakMap: {
      from: define(null, ["esnext.weak-map.from"].concat(_toConsumableArray(WeakMapDependencies))),
      of: define(null, ["esnext.weak-map.of"].concat(_toConsumableArray(WeakMapDependencies)))
    },
    WeakSet: {
      from: define(null, ["esnext.weak-set.from"].concat(_toConsumableArray(WeakSetDependencies))),
      of: define(null, ["esnext.weak-set.of"].concat(_toConsumableArray(WeakSetDependencies)))
    },
    Int8Array: TypedArrayStaticMethods,
    Uint8Array: TypedArrayStaticMethods,
    Uint8ClampedArray: TypedArrayStaticMethods,
    Int16Array: TypedArrayStaticMethods,
    Uint16Array: TypedArrayStaticMethods,
    Int32Array: TypedArrayStaticMethods,
    Uint32Array: TypedArrayStaticMethods,
    Float32Array: TypedArrayStaticMethods,
    Float64Array: TypedArrayStaticMethods
  };
  var InstanceProperties = {
    at: define("instance/at", ["esnext.string.at"]),
    anchor: define(null, ["es.string.anchor"]),
    big: define(null, ["es.string.big"]),
    bind: define("instance/bind", ["es.function.bind"]),
    blink: define(null, ["es.string.blink"]),
    bold: define(null, ["es.string.bold"]),
    codePointAt: define("instance/code-point-at", ["es.string.code-point-at"]),
    codePoints: define("instance/code-points", ["esnext.string.code-points"]),
    concat: define("instance/concat", ["es.array.concat"], undefined, ["String"]),
    copyWithin: define("instance/copy-within", ["es.array.copy-within"]),
    description: define(null, ["es.symbol", "es.symbol.description"]),
    endsWith: define("instance/ends-with", ["es.string.ends-with"]),
    entries: define("instance/entries", ArrayNatureIteratorsWithTag),
    every: define("instance/every", ["es.array.every"]),
    exec: define(null, ["es.regexp.exec"]),
    fill: define("instance/fill", ["es.array.fill"]),
    filter: define("instance/filter", ["es.array.filter"]),
    "finally": define(null, ["es.promise.finally"].concat(PromiseDependencies)),
    find: define("instance/find", ["es.array.find"]),
    findIndex: define("instance/find-index", ["es.array.find-index"]),
    fixed: define(null, ["es.string.fixed"]),
    flags: define("instance/flags", ["es.regexp.flags"]),
    flatMap: define("instance/flat-map", ["es.array.flat-map", "es.array.unscopables.flat-map"]),
    flat: define("instance/flat", ["es.array.flat"]),
    fontcolor: define(null, ["es.string.fontcolor"]),
    fontsize: define(null, ["es.string.fontsize"]),
    forEach: define("instance/for-each", ["es.array.for-each", "web.dom-collections.for-each"]),
    includes: define("instance/includes", ["es.array.includes", "es.string.includes"]),
    indexOf: define("instance/index-of", ["es.array.index-of"]),
    italic: define(null, ["es.string.italics"]),
    join: define(null, ["es.array.join"]),
    keys: define("instance/keys", ArrayNatureIteratorsWithTag),
    lastIndex: define(null, ["esnext.array.last-index"]),
    lastIndexOf: define("instance/last-index-of", ["es.array.last-index-of"]),
    lastItem: define(null, ["esnext.array.last-item"]),
    link: define(null, ["es.string.link"]),
    map: define("instance/map", ["es.array.map"]),
    match: define(null, ["es.string.match", "es.regexp.exec"]),
    matchAll: define("instance/match-all", ["es.string.match-all"]),
    name: define(null, ["es.function.name"]),
    padEnd: define("instance/pad-end", ["es.string.pad-end"]),
    padStart: define("instance/pad-start", ["es.string.pad-start"]),
    reduce: define("instance/reduce", ["es.array.reduce"]),
    reduceRight: define("instance/reduce-right", ["es.array.reduce-right"]),
    repeat: define("instance/repeat", ["es.string.repeat"]),
    replace: define(null, ["es.string.replace", "es.regexp.exec"]),
    replaceAll: define("instance/replace-all", ["esnext.string.replace-all"]),
    reverse: define("instance/reverse", ["es.array.reverse"]),
    search: define(null, ["es.string.search", "es.regexp.exec"]),
    slice: define("instance/slice", ["es.array.slice"]),
    small: define(null, ["es.string.small"]),
    some: define("instance/some", ["es.array.some"]),
    sort: define("instance/sort", ["es.array.sort"]),
    splice: define("instance/splice", ["es.array.splice"]),
    split: define(null, ["es.string.split", "es.regexp.exec"]),
    startsWith: define("instance/starts-with", ["es.string.starts-with"]),
    strike: define(null, ["es.string.strike"]),
    sub: define(null, ["es.string.sub"]),
    sup: define(null, ["es.string.sup"]),
    toFixed: define(null, ["es.number.to-fixed"]),
    toISOString: define(null, ["es.date.to-iso-string"]),
    toJSON: define(null, ["es.date.to-json", "web.url.to-json"]),
    toPrecision: define(null, ["es.number.to-precision"]),
    toString: define(null, ["es.object.to-string", "es.regexp.to-string", "es.date.to-string"]),
    trim: define("instance/trim", ["es.string.trim"]),
    trimEnd: define("instance/trim-end", ["es.string.trim-end"]),
    trimLeft: define("instance/trim-left", ["es.string.trim-start"]),
    trimRight: define("instance/trim-right", ["es.string.trim-end"]),
    trimStart: define("instance/trim-start", ["es.string.trim-start"]),
    values: define("instance/values", ArrayNatureIteratorsWithTag),
    __defineGetter__: define(null, ["es.object.define-getter"]),
    __defineSetter__: define(null, ["es.object.define-setter"]),
    __lookupGetter__: define(null, ["es.object.lookup-getter"]),
    __lookupSetter__: define(null, ["es.object.lookup-setter"])
  };
  var CommonInstanceDependencies = new Set(["es.object.to-string", "es.object.define-getter", "es.object.define-setter", "es.object.lookup-getter", "es.object.lookup-setter", "es.regexp.exec"]);

  var _ref = undefined || babel,
      t$1 = _ref.types;

  function callMethod(path, id) {
    var object = path.node.object;
    var context1, context2;

    if (t$1.isIdentifier(object)) {
      context1 = object;
      context2 = t$1.cloneNode(object);
    } else {
      context1 = path.scope.generateDeclaredUidIdentifier("context");
      context2 = t$1.assignmentExpression("=", t$1.cloneNode(context1), object);
    }

    path.replaceWith(t$1.memberExpression(t$1.callExpression(id, [context2]), t$1.identifier("call")));
    path.parentPath.unshiftContainer("arguments", context1);
  }

  function isCoreJSSource(source) {
    if (typeof source === "string") {
      source = source.replace(/\\/g, "/").replace(/(\/(index)?)?(\.js)?$/i, "").toLowerCase();
    }

    return hasOwnProperty.call(entries, source) && entries[source];
  }

  function coreJSModule(name) {
    return "core-js/modules/" + name + ".js";
  }

  function coreJSPureHelper(name, useBabelRuntime, ext) {
    return useBabelRuntime ? useBabelRuntime + "/core-js/" + name + ext : "core-js-pure/features/" + name + ".js";
  }

  var _ref2 = undefined || babel,
      t = _ref2.types;

  var runtimeCompat$1 = "#__secret_key__@babel/runtime__compatibility";

  var esnextFallback = function esnextFallback(name, cb) {
    if (cb(name)) return true;
    if (!name.startsWith("es.")) return false;
    var fallback = "esnext." + name.slice(3);
    if (!data[fallback]) return false;
    return cb(fallback);
  };

  var index$1 = definePolyfillProvider(function (_ref3, _ref4) {
    var getUtils = _ref3.getUtils,
        method = _ref3.method,
        shouldInjectPolyfill = _ref3.shouldInjectPolyfill,
        createMetaResolver = _ref3.createMetaResolver,
        debug = _ref3.debug,
        babel = _ref3.babel;
    var _ref4$version = _ref4.version,
        version = _ref4$version === void 0 ? 3 : _ref4$version,
        proposals = _ref4.proposals,
        shippedProposals = _ref4.shippedProposals,
        _ref4$runtimeCompat = _ref4[runtimeCompat$1];
    _ref4$runtimeCompat = _ref4$runtimeCompat === void 0 ? {} : _ref4$runtimeCompat;
    var useBabelRuntime = _ref4$runtimeCompat.useBabelRuntime,
        _ref4$runtimeCompat$e = _ref4$runtimeCompat.ext,
        ext = _ref4$runtimeCompat$e === void 0 ? ".js" : _ref4$runtimeCompat$e;
    var isWebpack = babel.caller(function (caller) {
      return (caller == null ? void 0 : caller.name) === "babel-loader";
    });
    var resolve = createMetaResolver({
      global: BuiltIns,
      "static": StaticProperties,
      instance: InstanceProperties
    });
    var available = new Set(getModulesListForTargetVersion(version));
    var coreJSPureBase = useBabelRuntime ? proposals ? useBabelRuntime + "/core-js" : useBabelRuntime + "/core-js-stable" : proposals ? "core-js-pure/features" : "core-js-pure/stable";

    function maybeInjectGlobalImpl(name, utils) {
      if (shouldInjectPolyfill(name)) {
        debug(name);
        utils.injectGlobalImport(coreJSModule(name));
        return true;
      }

      return false;
    }

    function maybeInjectGlobal(names, utils, fallback) {
      if (fallback === void 0) {
        fallback = true;
      }

      for (var _iterator = _createForOfIteratorHelperLoose(names), _step; !(_step = _iterator()).done;) {
        var name = _step.value;

        if (fallback) {
          esnextFallback(name, function (name) {
            return maybeInjectGlobalImpl(name, utils);
          });
        } else {
          maybeInjectGlobalImpl(name, utils);
        }
      }
    }

    function maybeInjectPure(desc, hint, utils, object) {
      if (desc.pure && !(object && desc.exclude && desc.exclude.includes(object)) && esnextFallback(desc.name, shouldInjectPolyfill)) {
        return utils.injectDefaultImport(coreJSPureBase + "/" + desc.pure + ext, hint);
      }
    }

    return {
      name: "corejs3",
      polyfills: data,
      filterPolyfills: function filterPolyfills(name) {
        if (!available.has(name)) return false;
        if (proposals || method === "entry-global") return true;

        if (shippedProposals && corejs3ShippedProposalsList.has(name)) {
          return true;
        }

        return !name.startsWith("esnext.");
      },
      entryGlobal: function entryGlobal(meta, utils, path) {
        if (meta.kind !== "import") return;
        var modules = isCoreJSSource(meta.source);
        if (!modules) return;

        if (modules.length === 1 && meta.source === coreJSModule(modules[0]) && shouldInjectPolyfill(modules[0])) {
          debug(null);
          return;
        }

        maybeInjectGlobal(modules, utils, false);
        path.remove();
      },
      usageGlobal: function usageGlobal(meta, utils) {
        var resolved = resolve(meta);
        if (!resolved) return;
        var deps = resolved.desc.global;

        if (resolved.kind !== "global" && meta.object && meta.placement === "prototype") {
          var low = meta.object.toLowerCase();
          deps = deps.filter(function (m) {
            return m.includes(low) || CommonInstanceDependencies.has(m);
          });
        }

        maybeInjectGlobal(deps, utils);
      },
      usagePure: function usagePure(meta, utils, path) {
        if (meta.kind === "in") {
          if (meta.key === "Symbol.iterator") {
            path.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("is-iterable", useBabelRuntime, ext), "isIterable"), [path.node.right]));
          }

          return;
        }

        if (path.parentPath.isUnaryExpression({
          operator: "delete"
        })) return;
        var isCall;

        if (meta.kind === "property") {
          if (!path.isMemberExpression()) return;
          if (!path.isReferenced()) return;
          isCall = path.parentPath.isCallExpression({
            callee: path.node
          });

          if (meta.key === "Symbol.iterator") {
            if (!shouldInjectPolyfill("es.symbol.iterator")) return;

            if (isCall) {
              if (path.parent.arguments.length === 0) {
                path.parentPath.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("get-iterator", useBabelRuntime, ext), "getIterator"), [path.node.object]));
                path.skip();
              } else {
                callMethod(path, utils.injectDefaultImport(coreJSPureHelper("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"));
              }
            } else {
              path.replaceWith(t.callExpression(utils.injectDefaultImport(coreJSPureHelper("get-iterator-method", useBabelRuntime, ext), "getIteratorMethod"), [path.node.object]));
            }

            return;
          }
        }

        var resolved = resolve(meta);
        if (!resolved) return;

        if (useBabelRuntime && resolved.desc.pure && resolved.desc.pure.slice(-6) === "/index") {
          resolved = Object.assign(Object.assign({}, resolved), {}, {
            desc: Object.assign(Object.assign({}, resolved.desc), {}, {
              pure: resolved.desc.pure.slice(0, -6)
            })
          });
        }

        if (resolved.kind === "global") {
          var id = maybeInjectPure(resolved.desc, resolved.name, utils);
          if (id) path.replaceWith(id);
        } else if (resolved.kind === "static") {
          var _id = maybeInjectPure(resolved.desc, resolved.name, utils, meta.object);

          if (_id) path.replaceWith(_id);
        } else if (resolved.kind === "instance") {
          var _id2 = maybeInjectPure(resolved.desc, resolved.name + "InstanceProperty", utils, meta.object);

          if (!_id2) return;

          if (isCall) {
            callMethod(path, _id2);
          } else {
            path.replaceWith(t.callExpression(_id2, [path.node.object]));
          }
        }
      },
      visitor: method === "usage-global" && {
        CallExpression: function CallExpression(path) {
          if (path.get("callee").isImport()) {
            var utils = getUtils(path);

            if (isWebpack) {
              maybeInjectGlobal(PromiseDependenciesWithIterators, utils);
            } else {
              maybeInjectGlobal(PromiseDependencies, utils);
            }
          }
        },
        Function: function Function(path) {
          if (path.node.async) {
            maybeInjectGlobal(PromiseDependencies, getUtils(path));
          }
        },
        "ForOfStatement|ArrayPattern": function ForOfStatementArrayPattern(path) {
          maybeInjectGlobal(CommonIterators, getUtils(path));
        },
        SpreadElement: function SpreadElement(path) {
          if (!path.parentPath.isObjectExpression()) {
            maybeInjectGlobal(CommonIterators, getUtils(path));
          }
        },
        YieldExpression: function YieldExpression(path) {
          if (path.node.delegate) {
            maybeInjectGlobal(CommonIterators, getUtils(path));
          }
        }
      }
    };
  });

  var runtimeCompat = "#__secret_key__@babel/runtime__compatibility";
  var index = definePolyfillProvider(function (_ref, options) {
    var debug = _ref.debug;
    var _options$runtimeCompa = options[runtimeCompat];
    _options$runtimeCompa = _options$runtimeCompa === void 0 ? {} : _options$runtimeCompa;
    var useBabelRuntime = _options$runtimeCompa.useBabelRuntime;
    var pureName = useBabelRuntime ? useBabelRuntime + "/regenerator" : "regenerator-runtime";
    return {
      name: "regenerator",
      polyfills: ["regenerator-runtime"],
      usageGlobal: function usageGlobal(meta, utils) {
        if (isRegenerator(meta)) {
          debug("regenerator-runtime");
          utils.injectGlobalImport("regenerator-runtime/runtime.js");
        }
      },
      usagePure: function usagePure(meta, utils, path) {
        if (isRegenerator(meta)) {
          path.replaceWith(utils.injectDefaultImport(pureName, "regenerator-runtime"));
        }
      }
    };
  });

  var isRegenerator = function isRegenerator(meta) {
    return meta.kind === "global" && meta.name === "regeneratorRuntime";
  };

  var pluginCoreJS2 = index$2["default"] || index$2;
  var pluginCoreJS3 = index$1["default"] || index$1;
  var pluginRegenerator = index["default"] || index;

  function filterStageFromList(list, stageList) {
    return Object.keys(list).reduce(function (result, item) {
      if (!stageList.has(item)) {
        result[item] = list[item];
      }

      return result;
    }, {});
  }

  var pluginLists = {
    withProposals: {
      withoutBugfixes: pluginsFiltered,
      withBugfixes: Object.assign({}, pluginsFiltered, bugfixPluginsFiltered)
    },
    withoutProposals: {
      withoutBugfixes: filterStageFromList(pluginsFiltered, shippedProposals.proposalPlugins),
      withBugfixes: filterStageFromList(Object.assign({}, pluginsFiltered, bugfixPluginsFiltered), shippedProposals.proposalPlugins)
    }
  };

  function getPluginList(proposals, bugfixes) {
    if (proposals) {
      if (bugfixes) return pluginLists.withProposals.withBugfixes;else return pluginLists.withProposals.withoutBugfixes;
    } else {
      if (bugfixes) return pluginLists.withoutProposals.withBugfixes;else return pluginLists.withoutProposals.withoutBugfixes;
    }
  }

  var getPlugin = function getPlugin(pluginName) {
    var plugin = availablePlugins$1[pluginName]();

    if (!plugin) {
      throw new Error("Could not find plugin \"" + pluginName + "\". Ensure there is an entry in ./available-plugins.js for it.");
    }

    return plugin;
  };

  var transformIncludesAndExcludes = function transformIncludesAndExcludes(opts) {
    return opts.reduce(function (result, opt) {
      var target = opt.match(/^(es|es6|es7|esnext|web)\./) ? "builtIns" : "plugins";
      result[target].add(opt);
      return result;
    }, {
      all: opts,
      plugins: new Set(),
      builtIns: new Set()
    });
  };
  var getModulesPluginNames = function getModulesPluginNames(_ref) {
    var modules = _ref.modules,
        transformations = _ref.transformations,
        shouldTransformESM = _ref.shouldTransformESM,
        shouldTransformDynamicImport = _ref.shouldTransformDynamicImport,
        shouldTransformExportNamespaceFrom = _ref.shouldTransformExportNamespaceFrom,
        shouldParseTopLevelAwait = _ref.shouldParseTopLevelAwait;
    var modulesPluginNames = [];

    if (modules !== false && transformations[modules]) {
      if (shouldTransformESM) {
        modulesPluginNames.push(transformations[modules]);
      }

      if (shouldTransformDynamicImport && shouldTransformESM && modules !== "umd") {
        modulesPluginNames.push("proposal-dynamic-import");
      } else {
        if (shouldTransformDynamicImport) {
          console.warn("Dynamic import can only be supported when transforming ES modules" + " to AMD, CommonJS or SystemJS. Only the parser plugin will be enabled.");
        }

        modulesPluginNames.push("syntax-dynamic-import");
      }
    } else {
      modulesPluginNames.push("syntax-dynamic-import");
    }

    if (shouldTransformExportNamespaceFrom) {
      modulesPluginNames.push("proposal-export-namespace-from");
    } else {
      modulesPluginNames.push("syntax-export-namespace-from");
    }

    if (shouldParseTopLevelAwait) {
      modulesPluginNames.push("syntax-top-level-await");
    }

    return modulesPluginNames;
  };
  var getPolyfillPlugins = function getPolyfillPlugins(_ref2) {
    var useBuiltIns = _ref2.useBuiltIns,
        corejs = _ref2.corejs,
        polyfillTargets = _ref2.polyfillTargets,
        include = _ref2.include,
        exclude = _ref2.exclude,
        proposals = _ref2.proposals,
        shippedProposals = _ref2.shippedProposals,
        regenerator = _ref2.regenerator,
        debug = _ref2.debug;
    var polyfillPlugins = [];

    if (useBuiltIns === "usage" || useBuiltIns === "entry") {
      var pluginOptions = {
        method: useBuiltIns + "-global",
        version: corejs ? corejs.toString() : undefined,
        targets: polyfillTargets,
        include: include,
        exclude: exclude,
        proposals: proposals,
        shippedProposals: shippedProposals,
        debug: debug
      };

      if (corejs) {
        if (useBuiltIns === "usage") {
          if (corejs.major === 2) {
            polyfillPlugins.push([pluginCoreJS2, pluginOptions], [legacyBabelPolyfillPlugin, {
              usage: true
            }]);
          } else {
            polyfillPlugins.push([pluginCoreJS3, pluginOptions], [legacyBabelPolyfillPlugin, {
              usage: true,
              deprecated: true
            }]);
          }

          if (regenerator) {
            polyfillPlugins.push([pluginRegenerator, {
              method: "usage-global",
              debug: debug
            }]);
          }
        } else {
          if (corejs.major === 2) {
            polyfillPlugins.push([legacyBabelPolyfillPlugin, {
              regenerator: regenerator
            }], [pluginCoreJS2, pluginOptions]);
          } else {
            polyfillPlugins.push([pluginCoreJS3, pluginOptions], [legacyBabelPolyfillPlugin, {
              deprecated: true
            }]);

            if (!regenerator) {
              polyfillPlugins.push([removeRegeneratorEntryPlugin, pluginOptions]);
            }
          }
        }
      }
    }

    return polyfillPlugins;
  };

  function getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv) {
    if (optionsTargets != null && optionsTargets.esmodules && optionsTargets.browsers) {
      console.warn("\n@babel/preset-env: esmodules and browsers targets have been specified together.\n`browsers` target, `" + optionsTargets.browsers.toString() + "` will be ignored.\n");
    }

    return getTargets$2(optionsTargets, {
      ignoreBrowserslistConfig: ignoreBrowserslistConfig,
      configPath: configPath,
      browserslistEnv: browserslistEnv
    });
  }

  function supportsStaticESM(caller) {
    return !!(caller != null && caller.supportsStaticESM);
  }

  function supportsDynamicImport(caller) {
    return !!(caller != null && caller.supportsDynamicImport);
  }

  function supportsExportNamespaceFrom(caller) {
    return !!(caller != null && caller.supportsExportNamespaceFrom);
  }

  function supportsTopLevelAwait(caller) {
    return !!(caller != null && caller.supportsTopLevelAwait);
  }

  var presetEnv = declare(function (api, opts) {
    api.assertVersion(7);
    var babelTargets = api.targets();

    var _normalizeOptions = normalizeOptions$3(opts),
        bugfixes = _normalizeOptions.bugfixes,
        configPath = _normalizeOptions.configPath,
        debug = _normalizeOptions.debug,
        optionsExclude = _normalizeOptions.exclude,
        forceAllTransforms = _normalizeOptions.forceAllTransforms,
        ignoreBrowserslistConfig = _normalizeOptions.ignoreBrowserslistConfig,
        optionsInclude = _normalizeOptions.include,
        loose = _normalizeOptions.loose,
        modules = _normalizeOptions.modules,
        shippedProposals$1 = _normalizeOptions.shippedProposals,
        spec = _normalizeOptions.spec,
        optionsTargets = _normalizeOptions.targets,
        useBuiltIns = _normalizeOptions.useBuiltIns,
        _normalizeOptions$cor = _normalizeOptions.corejs,
        corejs = _normalizeOptions$cor.version,
        proposals = _normalizeOptions$cor.proposals,
        browserslistEnv = _normalizeOptions.browserslistEnv;

    var targets = babelTargets;

    if (semver$4.lt(api.version, "7.13.0") || opts.targets || opts.configPath || opts.browserslistEnv || opts.ignoreBrowserslistConfig) {
      {
        var hasUglifyTarget = false;

        if (optionsTargets != null && optionsTargets.uglify) {
          hasUglifyTarget = true;
          delete optionsTargets.uglify;
          console.warn("\nThe uglify target has been deprecated. Set the top level\noption `forceAllTransforms: true` instead.\n");
        }
      }
      targets = getLocalTargets(optionsTargets, ignoreBrowserslistConfig, configPath, browserslistEnv);
    }

    var transformTargets = forceAllTransforms || hasUglifyTarget ? {} : targets;
    var include = transformIncludesAndExcludes(optionsInclude);
    var exclude = transformIncludesAndExcludes(optionsExclude);
    var compatData = getPluginList(shippedProposals$1, bugfixes);
    var shouldSkipExportNamespaceFrom = modules === "auto" && (api.caller == null ? void 0 : api.caller(supportsExportNamespaceFrom)) || modules === false && !isRequired("proposal-export-namespace-from", transformTargets, {
      compatData: compatData,
      includes: include.plugins,
      excludes: exclude.plugins
    });
    var modulesPluginNames = getModulesPluginNames({
      modules: modules,
      transformations: moduleTransformations,
      shouldTransformESM: modules !== "auto" || !(api.caller != null && api.caller(supportsStaticESM)),
      shouldTransformDynamicImport: modules !== "auto" || !(api.caller != null && api.caller(supportsDynamicImport)),
      shouldTransformExportNamespaceFrom: !shouldSkipExportNamespaceFrom,
      shouldParseTopLevelAwait: !api.caller || api.caller(supportsTopLevelAwait)
    });
    var pluginNames = filterItems(compatData, include.plugins, exclude.plugins, transformTargets, modulesPluginNames, getOptionSpecificExcludesFor({
      loose: loose
    }), shippedProposals.pluginSyntaxMap);
    removeUnnecessaryItems(pluginNames, overlappingPlugins);
    removeUnsupportedItems(pluginNames, api.version);
    var polyfillPlugins = getPolyfillPlugins({
      useBuiltIns: useBuiltIns,
      corejs: corejs,
      polyfillTargets: targets,
      include: include.builtIns,
      exclude: exclude.builtIns,
      proposals: proposals,
      shippedProposals: shippedProposals$1,
      regenerator: pluginNames.has("transform-regenerator"),
      debug: debug
    });
    var pluginUseBuiltIns = useBuiltIns !== false;
    var plugins = Array.from(pluginNames).map(function (pluginName) {
      if (pluginName === "proposal-class-properties" || pluginName === "proposal-private-methods" || pluginName === "proposal-private-property-in-object") {
        return [getPlugin(pluginName), {
          loose: loose ? "#__internal__@babel/preset-env__prefer-true-but-false-is-ok-if-it-prevents-an-error" : "#__internal__@babel/preset-env__prefer-false-but-true-is-ok-if-it-prevents-an-error"
        }];
      }

      return [getPlugin(pluginName), {
        spec: spec,
        loose: loose,
        useBuiltIns: pluginUseBuiltIns
      }];
    }).concat(polyfillPlugins);

    if (debug) {
      console.log("@babel/preset-env: `DEBUG` option");
      console.log("\nUsing targets:");
      console.log(JSON.stringify(prettifyTargets(targets), null, 2));
      console.log("\nUsing modules transform: " + modules.toString());
      console.log("\nUsing plugins:");
      pluginNames.forEach(function (pluginName) {
        logPlugin(pluginName, targets, compatData);
      });

      if (!useBuiltIns) {
        console.log("\nUsing polyfills: No polyfills were added, since the `useBuiltIns` option was not set.");
      }
    }

    return {
      plugins: plugins
    };
  });

  function normalizeOptions$2(options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        all = _options.all;
    var _options2 = options,
        allowDeclareFields = _options2.allowDeclareFields;
    {
      return {
        all: all,
        allowDeclareFields: allowDeclareFields
      };
    }
  }

  var presetFlow = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions$2(opts),
        all = _normalizeOptions.all,
        allowDeclareFields = _normalizeOptions.allowDeclareFields;

    return {
      plugins: [[transformFlowStripTypes, {
        all: all,
        allowDeclareFields: allowDeclareFields
      }]]
    };
  });

  var PURE_CALLS = new Map([["react", ["cloneElement", "createContext", "createElement", "createFactory", "createRef", "forwardRef", "isValidElement", "memo", "lazy"]], ["react-dom", ["createPortal"]]]);
  var transformReactPure = declare(function (api) {
    api.assertVersion(7);
    return {
      name: "transform-react-pure-annotations",
      visitor: {
        CallExpression: function CallExpression(path) {
          if (isReactCall(path)) {
            annotateAsPure(path);
          }
        }
      }
    };
  });

  function isReactCall(path) {
    if (!isMemberExpression(path.node.callee)) {
      var callee = path.get("callee");

      for (var _iterator = _createForOfIteratorHelperLoose(PURE_CALLS), _step; !(_step = _iterator()).done;) {
        var _step$value = _slicedToArray$2(_step.value, 2),
            module = _step$value[0],
            methods = _step$value[1];

        for (var _iterator2 = _createForOfIteratorHelperLoose(methods), _step2; !(_step2 = _iterator2()).done;) {
          var method = _step2.value;

          if (callee.referencesImport(module, method)) {
            return true;
          }
        }
      }

      return false;
    }

    for (var _iterator3 = _createForOfIteratorHelperLoose(PURE_CALLS), _step3; !(_step3 = _iterator3()).done;) {
      var _step3$value = _slicedToArray$2(_step3.value, 2),
          _module = _step3$value[0],
          _methods = _step3$value[1];

      var object = path.get("callee.object");

      if (object.referencesImport(_module, "default") || object.referencesImport(_module, "*")) {
        for (var _iterator4 = _createForOfIteratorHelperLoose(_methods), _step4; !(_step4 = _iterator4()).done;) {
          var _method = _step4.value;

          if (isIdentifier(path.node.callee.property, {
            name: _method
          })) {
            return true;
          }
        }

        return false;
      }
    }

    return false;
  }

  function normalizeOptions$1(options) {
    if (options === void 0) {
      options = {};
    }

    {
      var _options = options,
          pragma = _options.pragma,
          pragmaFrag = _options.pragmaFrag;
      var _options2 = options,
          pure = _options2.pure,
          _options2$throwIfName = _options2.throwIfNamespace,
          throwIfNamespace = _options2$throwIfName === void 0 ? true : _options2$throwIfName,
          _options2$runtime = _options2.runtime,
          runtime = _options2$runtime === void 0 ? "classic" : _options2$runtime,
          importSource = _options2.importSource,
          useBuiltIns = _options2.useBuiltIns,
          useSpread = _options2.useSpread;

      if (runtime === "classic") {
        pragma = pragma || "React.createElement";
        pragmaFrag = pragmaFrag || "React.Fragment";
      }

      var development = !!options.development;
      return {
        development: development,
        importSource: importSource,
        pragma: pragma,
        pragmaFrag: pragmaFrag,
        pure: pure,
        runtime: runtime,
        throwIfNamespace: throwIfNamespace,
        useBuiltIns: useBuiltIns,
        useSpread: useSpread
      };
    }
  }

  var presetReact = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions$1(opts),
        development = _normalizeOptions.development,
        importSource = _normalizeOptions.importSource,
        pragma = _normalizeOptions.pragma,
        pragmaFrag = _normalizeOptions.pragmaFrag,
        pure = _normalizeOptions.pure,
        runtime = _normalizeOptions.runtime,
        throwIfNamespace = _normalizeOptions.throwIfNamespace;

    return {
      plugins: [[development ? transformReactJSXDevelopment : transformReactJSX, {
        importSource: importSource,
        pragma: pragma,
        pragmaFrag: pragmaFrag,
        runtime: runtime,
        throwIfNamespace: throwIfNamespace,
        pure: pure,
        useBuiltIns: !!opts.useBuiltIns,
        useSpread: opts.useSpread
      }], transformReactDisplayName, pure !== false && transformReactPure].filter(Boolean)
    };
  });

  var v = new OptionValidator("@babel/preset-typescript");
  function normalizeOptions(options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$allowNamespa = _options.allowNamespaces,
        allowNamespaces = _options$allowNamespa === void 0 ? true : _options$allowNamespa,
        jsxPragma = _options.jsxPragma,
        onlyRemoveTypeImports = _options.onlyRemoveTypeImports;
    var jsxPragmaFrag = v.validateStringOption("jsxPragmaFrag", options.jsxPragmaFrag, "React.Fragment");
    var allExtensions = v.validateBooleanOption("allExtensions", options.allExtensions, false);
    var isTSX = v.validateBooleanOption("isTSX", options.isTSX, false);

    if (isTSX) {
      v.invariant(allExtensions, "isTSX:true requires allExtensions:true");
    }

    return {
      allExtensions: allExtensions,
      allowNamespaces: allowNamespaces,
      isTSX: isTSX,
      jsxPragma: jsxPragma,
      jsxPragmaFrag: jsxPragmaFrag,
      onlyRemoveTypeImports: onlyRemoveTypeImports
    };
  }

  var presetTypescript = declare(function (api, opts) {
    api.assertVersion(7);

    var _normalizeOptions = normalizeOptions(opts),
        allExtensions = _normalizeOptions.allExtensions,
        allowNamespaces = _normalizeOptions.allowNamespaces,
        isTSX = _normalizeOptions.isTSX,
        jsxPragma = _normalizeOptions.jsxPragma,
        jsxPragmaFrag = _normalizeOptions.jsxPragmaFrag,
        onlyRemoveTypeImports = _normalizeOptions.onlyRemoveTypeImports;

    var pluginOptions = function pluginOptions(isTSX) {
      return {
        allowDeclareFields: opts.allowDeclareFields,
        allowNamespaces: allowNamespaces,
        isTSX: isTSX,
        jsxPragma: jsxPragma,
        jsxPragmaFrag: jsxPragmaFrag,
        onlyRemoveTypeImports: onlyRemoveTypeImports
      };
    };

    return {
      overrides: allExtensions ? [{
        plugins: [[transformTypeScript, pluginOptions(isTSX)]]
      }] : [{
        test: /\.ts$/,
        plugins: [[transformTypeScript, pluginOptions(false)]]
      }, {
        test: /\.tsx$/,
        plugins: [[transformTypeScript, pluginOptions(true)]]
      }]
    };
  });

  var scriptTypes = ["text/jsx", "text/babel"];
  var headEl;
  var inlineScriptCount = 0;

  function transformCode(transformFn, script) {
    var source;

    if (script.url != null) {
      source = script.url;
    } else {
      source = "Inline Babel script";
      inlineScriptCount++;

      if (inlineScriptCount > 1) {
        source += " (" + inlineScriptCount + ")";
      }
    }

    return transformFn(script.content, buildBabelOptions(script, source)).code;
  }

  function buildBabelOptions(script, filename) {
    var presets = script.presets;

    if (!presets) {
      if (script.type === "module") {
        presets = ["react", ["env", {
          targets: {
            esmodules: true
          },
          modules: false
        }]];
      } else {
        presets = ["react", "env"];
      }
    }

    return {
      filename: filename,
      presets: presets,
      plugins: script.plugins || ["proposal-class-properties", "proposal-object-rest-spread", "transform-flow-strip-types"],
      sourceMaps: "inline",
      sourceFileName: filename
    };
  }

  function run(transformFn, script) {
    var scriptEl = document.createElement("script");

    if (script.type) {
      scriptEl.setAttribute("type", script.type);
    }

    scriptEl.text = transformCode(transformFn, script);
    headEl.appendChild(scriptEl);
  }

  function load(url, successCallback, errorCallback) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", url, true);

    if ("overrideMimeType" in xhr) {
      xhr.overrideMimeType("text/plain");
    }

    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        if (xhr.status === 0 || xhr.status === 200) {
          successCallback(xhr.responseText);
        } else {
          errorCallback();
          throw new Error("Could not load " + url);
        }
      }
    };

    return xhr.send(null);
  }

  function getPluginsOrPresetsFromScript(script, attributeName) {
    var rawValue = script.getAttribute(attributeName);

    if (rawValue === "") {
      return [];
    }

    if (!rawValue) {
      return null;
    }

    return rawValue.split(",").map(function (item) {
      return item.trim();
    });
  }

  function loadScripts(transformFn, scripts) {
    var result = [];
    var count = scripts.length;

    function check() {
      var script, i;

      for (i = 0; i < count; i++) {
        script = result[i];

        if (script.loaded && !script.executed) {
          script.executed = true;
          run(transformFn, script);
        } else if (!script.loaded && !script.error && !script.async) {
          break;
        }
      }
    }

    scripts.forEach(function (script, i) {
      var scriptData = {
        async: script.hasAttribute("async"),
        type: script.getAttribute("data-type"),
        error: false,
        executed: false,
        plugins: getPluginsOrPresetsFromScript(script, "data-plugins"),
        presets: getPluginsOrPresetsFromScript(script, "data-presets")
      };

      if (script.src) {
        result[i] = Object.assign({}, scriptData, {
          content: null,
          loaded: false,
          url: script.src
        });
        load(script.src, function (content) {
          result[i].loaded = true;
          result[i].content = content;
          check();
        }, function () {
          result[i].error = true;
          check();
        });
      } else {
        result[i] = Object.assign({}, scriptData, {
          content: script.innerHTML,
          loaded: true,
          url: script.getAttribute("data-module") || null
        });
      }
    });
    check();
  }

  function runScripts(transformFn, scripts) {
    headEl = document.getElementsByTagName("head")[0];

    if (!scripts) {
      scripts = document.getElementsByTagName("script");
    }

    var jsxScripts = [];

    for (var i = 0; i < scripts.length; i++) {
      var script = scripts.item(i);
      var type = script.type.split(";")[0];

      if (scriptTypes.indexOf(type) !== -1) {
        jsxScripts.push(script);
      }
    }

    if (jsxScripts.length === 0) {
      return;
    }

    console.warn("You are using the in-browser Babel transformer. Be sure to precompile " + "your scripts for production - https://babeljs.io/docs/setup/");
    loadScripts(transformFn, jsxScripts);
  }

  var _window;

  var isArray = Array.isArray || function (arg) {
    return Object.prototype.toString.call(arg) === "[object Array]";
  };

  function loadBuiltin(builtinTable, name) {
    if (isArray(name) && typeof name[0] === "string") {
      if (Object.prototype.hasOwnProperty.call(builtinTable, name[0])) {
        return [builtinTable[name[0]]].concat(name.slice(1));
      }

      return;
    } else if (typeof name === "string") {
      return builtinTable[name];
    }

    return name;
  }

  function processOptions(options) {
    var presets = (options.presets || []).map(function (presetName) {
      var preset = loadBuiltin(availablePresets, presetName);

      if (preset) {
        if (isArray(preset) && typeof preset[0] === "object" && Object.prototype.hasOwnProperty.call(preset[0], "buildPreset")) {
          preset[0] = Object.assign({}, preset[0], {
            buildPreset: preset[0].buildPreset
          });
        }
      } else {
        throw new Error("Invalid preset specified in Babel options: \"" + presetName + "\"");
      }

      return preset;
    });
    var plugins = (options.plugins || []).map(function (pluginName) {
      var plugin = loadBuiltin(availablePlugins, pluginName);

      if (!plugin) {
        throw new Error("Invalid plugin specified in Babel options: \"" + pluginName + "\"");
      }

      return plugin;
    });
    return Object.assign({
      babelrc: false
    }, options, {
      presets: presets,
      plugins: plugins
    });
  }

  function transform(code, options) {
    return transform$2(code, processOptions(options));
  }
  function transformFromAst(ast, code, options) {
    return transformFromAst$1(ast, code, processOptions(options));
  }
  var availablePlugins = {};
  var availablePresets = {};
  var buildExternalHelpers = babelBuildExternalHelpers;
  function registerPlugin(name, plugin) {
    if (Object.prototype.hasOwnProperty.call(availablePlugins, name)) {
      console.warn("A plugin named \"" + name + "\" is already registered, it will be overridden");
    }

    availablePlugins[name] = plugin;
  }
  function registerPlugins(newPlugins) {
    Object.keys(newPlugins).forEach(function (name) {
      return registerPlugin(name, newPlugins[name]);
    });
  }
  function registerPreset(name, preset) {
    if (Object.prototype.hasOwnProperty.call(availablePresets, name)) {
      if (name === "env") {
        console.warn("@babel/preset-env is now included in @babel/standalone, please remove @babel/preset-env-standalone");
      } else {
        console.warn("A preset named \"" + name + "\" is already registered, it will be overridden");
      }
    }

    availablePresets[name] = preset;
  }
  function registerPresets(newPresets) {
    Object.keys(newPresets).forEach(function (name) {
      return registerPreset(name, newPresets[name]);
    });
  }
  registerPlugins(all);
  registerPresets({
    env: presetEnv,
    es2015: preset2015,
    es2016: function es2016() {
      return {
        plugins: [availablePlugins["transform-exponentiation-operator"]]
      };
    },
    es2017: function es2017() {
      return {
        plugins: [availablePlugins["transform-async-to-generator"]]
      };
    },
    react: presetReact,
    "stage-0": presetStage0,
    "stage-1": presetStage1,
    "stage-2": presetStage2,
    "stage-3": presetStage3,
    "es2015-loose": {
      presets: [[preset2015, {
        loose: true
      }]]
    },
    "es2015-no-commonjs": {
      presets: [[preset2015, {
        modules: false
      }]]
    },
    typescript: presetTypescript,
    flow: presetFlow
  });
  var version = "7.14.7";

  function onDOMContentLoaded() {
    transformScriptTags();
  }

  if (typeof window !== "undefined" && (_window = window) != null && _window.addEventListener) {
    window.addEventListener("DOMContentLoaded", onDOMContentLoaded, false);
  }

  function transformScriptTags(scriptTags) {
    runScripts(transform, scriptTags);
  }
  function disableScriptTags() {
    window.removeEventListener("DOMContentLoaded", onDOMContentLoaded);
  }

  exports.availablePlugins = availablePlugins;
  exports.availablePresets = availablePresets;
  exports.buildExternalHelpers = buildExternalHelpers;
  exports.disableScriptTags = disableScriptTags;
  exports.registerPlugin = registerPlugin;
  exports.registerPlugins = registerPlugins;
  exports.registerPreset = registerPreset;
  exports.registerPresets = registerPresets;
  exports.transform = transform;
  exports.transformFromAst = transformFromAst;
  exports.transformScriptTags = transformScriptTags;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
