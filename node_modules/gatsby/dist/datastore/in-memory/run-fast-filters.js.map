{"version":3,"sources":["../../../src/datastore/in-memory/run-fast-filters.ts"],"names":["createFilterCacheKey","typeNames","filter","filterStep","comparator","paths","push","path","type","q","nestedQuery","query","join","applyFastFilters","filters","nodeTypeNames","filtersCache","nodesPerValueArrs","getBucketsForFilters","length","sort","a","b","pop","result","every","filterCacheKey","getBucketsForQueryFilter","collectBucketForElemMatch","undefined","filterPath","value","filterValue","has","nodesPerValue","targetValue","f","nodesByValue","runFastFiltersAndSort","args","queryArgs","limit","skip","resolvedFields","stats","convertAndApplyFastFilters","sortedResult","sortNodes","totalCount","entries","slice","GatsbyIterable","filterFields","forEach","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","totalNonSingleFilters","filterCache","cache","meta","orderedByCounter","totalIndexHits","totalSiftHits","concat","nodes","fields","dottedFields","dottedFieldKeys","Object","keys","sortFields","map","field","some","key","startsWith","sortFns","v","sortOrder","order","toLowerCase","sortField","uniqueSorts","_","orderBy"],"mappings":"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","sourcesContent":["import { IGatsbyNode } from \"../../redux/types\"\nimport { getValueAt } from \"../../utils/get-value-at\"\nimport _ from \"lodash\"\nimport {\n  DbQuery,\n  IDbQueryQuery,\n  IDbQueryElemMatch,\n  IInputQuery,\n  FilterValueNullable,\n  objectToDottedField,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n  prepareQueryArgs,\n} from \"../common/query\"\nimport {\n  FilterOp,\n  FilterCacheKey,\n  FiltersCache,\n  ensureEmptyFilterCache,\n  ensureIndexByQuery,\n  ensureIndexByElemMatch,\n  getNodesFromCacheByValue,\n  intersectNodesByCounter,\n  IFilterCache,\n} from \"./indexing\"\nimport { IGraphQLRunnerStats } from \"../../query/types\"\nimport { IRunQueryArgs, IQueryResult } from \"../types\"\nimport { GatsbyIterable } from \"../common/iterable\"\n\nexport interface IRunFilterArg extends IRunQueryArgs {\n  filtersCache: FiltersCache\n}\n\n/**\n * Creates a key for one filterCache inside FiltersCache\n */\nfunction createFilterCacheKey(\n  typeNames: Array<string>,\n  filter: DbQuery | null\n): FilterCacheKey {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let filterStep = filter\n  let comparator = ``\n  const paths: Array<string> = []\n  while (filterStep) {\n    paths.push(...filterStep.path)\n    if (filterStep.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = filterStep\n      filterStep = q.nestedQuery\n      // Make distinction between filtering `a.elemMatch.b.eq` and `a.b.eq`\n      // In practice this is unlikely to be an issue, but it might\n      paths.push(`elemMatch`)\n    } else {\n      const q: IDbQueryQuery = filterStep\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + paths.join(`,`) + `/` + comparator\n}\n\n/**\n * Given the path of a set of filters, return the sets of nodes that pass the\n * filter.\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n *\n * Note: Not a public API. Exported for tests.\n */\nexport function applyFastFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): Array<IGatsbyNode> | null {\n  if (!filtersCache) {\n    // If no filter cache is passed on, explicitly don't use one\n    return null\n  }\n\n  const nodesPerValueArrs = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    filtersCache\n  )\n\n  if (!nodesPerValueArrs) {\n    return null\n  }\n\n  if (nodesPerValueArrs.length === 0) {\n    return []\n  } else {\n    // Put smallest last (we'll pop it)\n    nodesPerValueArrs.sort((a, b) => b.length - a.length)\n\n    // All elements of nodesPerValueArrs should be sorted by counter and deduped\n    // So if there's only one bucket in this list the next loop is skipped\n\n    while (nodesPerValueArrs.length > 1) {\n      // TS limitation: cannot guard against .pop(), so we must double cast\n      const a = (nodesPerValueArrs.pop() as unknown) as Array<IGatsbyNode>\n      const b = (nodesPerValueArrs.pop() as unknown) as Array<IGatsbyNode>\n      nodesPerValueArrs.push(intersectNodesByCounter(a, b))\n    }\n\n    const result = nodesPerValueArrs[0]\n\n    if (result.length === 0) {\n      // Intersection came up empty. Not one node appeared in every bucket.\n      return null\n    }\n\n    return result\n  }\n}\n\n/**\n * If this returns undefined it means at least one cache was not found\n */\nfunction getBucketsForFilters(\n  filters: Array<DbQuery>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): Array<Array<IGatsbyNode>> | undefined {\n  const nodesPerValueArrs: Array<Array<IGatsbyNode>> = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  const every = filters.every(filter => {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, filter)\n    if (filter.type === `query`) {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryQuery = filter\n      return getBucketsForQueryFilter(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs\n      )\n    } else {\n      // (Let TS warn us if a new query type gets added)\n      const q: IDbQueryElemMatch = filter\n      return collectBucketForElemMatch(\n        filterCacheKey,\n        q,\n        nodeTypeNames,\n        filtersCache,\n        nodesPerValueArrs\n      )\n    }\n  })\n\n  if (every) {\n    return nodesPerValueArrs\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Fetch all buckets for given query filter. That means it's not elemMatch.\n * Returns `false` if it found none.\n */\nfunction getBucketsForQueryFilter(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryQuery,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNode>>\n): boolean {\n  const {\n    path: filterPath,\n    query: { comparator, value: filterValue },\n  } = filter\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByQuery(\n      comparator as FilterOp,\n      filterCacheKey,\n      filterPath,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesPerValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    filterValue as FilterValueNullable,\n    filtersCache,\n    false\n  )\n\n  if (!nodesPerValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesPerValue)\n\n  return true\n}\n\n/**\n * Matching node arrs are put in given array by reference\n */\nfunction collectBucketForElemMatch(\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  nodesPerValueArrs: Array<Array<IGatsbyNode>>\n): boolean {\n  // Get comparator and target value for this elemMatch\n  let comparator: FilterOp = `$eq` // (Must be overridden but TS requires init)\n  let targetValue: FilterValueNullable = null\n  let f: DbQuery = filter\n  while (f) {\n    if (f.type === `elemMatch`) {\n      const q: IDbQueryElemMatch = f\n      f = q.nestedQuery\n    } else {\n      const q: IDbQueryQuery = f\n      comparator = q.query.comparator as FilterOp\n      targetValue = q.query.value as FilterValueNullable\n      break\n    }\n  }\n\n  if (!filtersCache.has(filterCacheKey)) {\n    ensureIndexByElemMatch(\n      comparator,\n      filterCacheKey,\n      filter,\n      nodeTypeNames,\n      filtersCache\n    )\n  }\n\n  const nodesByValue = getNodesFromCacheByValue(\n    filterCacheKey,\n    targetValue,\n    filtersCache,\n    true\n  )\n\n  if (!nodesByValue) {\n    return false\n  }\n\n  // In all other cases this must be a non-empty arr because the indexing\n  // mechanism does not create an array unless there's a IGatsbyNode for it\n  nodesPerValueArrs.push(nodesByValue)\n\n  return true\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {{filter?: Object, sort?: Object, skip?: number, limit?: number} | undefined} args.queryArgs\n * @property {FiltersCache} args.filtersCache A cache of indexes where you can\n *   look up Nodes grouped by a FilterCacheKey, which yields a Map which holds\n *   an arr of Nodes for the value that the filter is trying to query against.\n *   This object lives in query/query-runner.js and is passed down runQuery.\n * @returns Collection of results. Collection will be sliced by `skip` and `limit`\n */\nexport function runFastFiltersAndSort(args: IRunFilterArg): IQueryResult {\n  const {\n    queryArgs: { filter, sort, limit, skip = 0 } = {},\n    resolvedFields = {},\n    nodeTypeNames,\n    filtersCache,\n    stats,\n  } = args\n\n  const result = convertAndApplyFastFilters(\n    filter,\n    nodeTypeNames,\n    filtersCache,\n    resolvedFields,\n    stats\n  )\n\n  const sortedResult = sortNodes(result, sort, resolvedFields, stats)\n  const totalCount = async (): Promise<number> => sortedResult.length\n\n  const entries =\n    skip || limit\n      ? sortedResult.slice(skip, limit ? skip + (limit ?? 0) : undefined)\n      : sortedResult\n\n  return { entries: new GatsbyIterable(entries), totalCount }\n}\n\n/**\n * Return a collection of results.\n */\nfunction convertAndApplyFastFilters(\n  filterFields: IInputQuery | undefined,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache,\n  resolvedFields: Record<string, any>,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNode> {\n  const filters = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach(filter => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  if (filters.length === 0) {\n    const filterCacheKey = createFilterCacheKey(nodeTypeNames, null)\n    if (!filtersCache.has(filterCacheKey)) {\n      ensureEmptyFilterCache(filterCacheKey, nodeTypeNames, filtersCache)\n    }\n\n    // If there's a filter, there (now) must be an entry for this cache key\n    const filterCache = filtersCache.get(filterCacheKey) as IFilterCache\n    // If there is no filter then the ensureCache step will populate this:\n    const cache = filterCache.meta.orderedByCounter as Array<IGatsbyNode>\n\n    return cache.slice(0)\n  }\n\n  const result = applyFastFilters(filters, nodeTypeNames, filtersCache)\n\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    return result\n  }\n\n  if (stats) {\n    // to mean, \"empty results\"\n    stats.totalSiftHits++\n  }\n\n  return []\n}\n\nfunction filterToStats(\n  filter: DbQuery,\n  filterPath: Array<string> = [],\n  comparatorPath: Array<string> = []\n): {\n  filterPath: Array<string>\n  comparatorPath: Array<string>\n} {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Returns same reference as input, sorted inline\n */\nfunction sortNodes(\n  nodes: Array<IGatsbyNode>,\n  sort:\n    | {\n        fields: Array<string>\n        order: Array<boolean | \"asc\" | \"desc\" | \"ASC\" | \"DESC\">\n      }\n    | undefined,\n  resolvedFields: any,\n  stats: IGraphQLRunnerStats\n): Array<IGatsbyNode> {\n  if (!sort || sort.fields?.length === 0 || !nodes || nodes.length === 0) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const sortFields = sort.fields.map(field => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some(key => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`\n    } else {\n      return field\n    }\n  })\n  const sortFns = sortFields.map(field => (v): ((any) => any) =>\n    getValueAt(v, field)\n  )\n  const sortOrder = sort.order.map(order =>\n    typeof order === `boolean` ? order : order.toLowerCase()\n  ) as Array<boolean | \"asc\" | \"desc\">\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"file":"run-fast-filters.js"}