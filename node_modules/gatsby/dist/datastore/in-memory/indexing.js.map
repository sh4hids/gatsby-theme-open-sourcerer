{"version":3,"sources":["../../../src/datastore/in-memory/indexing.ts"],"names":["postIndexingMetaSetup","filterCache","op","bucket","byValue","sort","a","b","internal","counter","postIndexingMetaSetupNeNin","includes","postIndexingMetaSetupLtLteGtGte","arr","meta","nodesUnordered","forEach","v","node","push","entriesNullable","entries","filter","orderedNodes","orderedValues","offsets","Map","set","length","valuesAsc","nodesByValueAsc","valueRangesAsc","valuesDesc","nodesByValueDesc","valueRangesDesc","ensureIndexByQuery","filterCacheKey","filterPath","nodeTypeNames","filtersCache","state","store","getState","resolvedNodesCache","iterateNodesByType","addNodeToFilterCache","iterateNodes","type","ensureEmptyFilterCache","orderedByCounter","__gatsby_resolved","typeName","resolvedNodes","get","resolved","id","undefined","chain","valueOffset","i","nextProp","Array","isArray","markNodeForValue","value","ensureIndexByElemMatch","addNodeToBucketWithElemMatch","valueAtCurrentStep","path","nestedQuery","elem","binarySearchAsc","values","needle","min","max","pivot","Math","floor","binarySearchDesc","getNodesFromCacheByValue","filterValue","wasElemMatch","arrNull","arrUndef","unionNodesByCounter","Error","filterValueArr","Set","add","A","B","nodes","expensiveDedupeInline","removeBucketFromSet","RegExp","regex","test","String","ranges","range","slice","point","pivotMin","pivotMax","pivotValue","exclPivot","inclPivot","until","reverse","cache","delete","intersectNodesByCounter","pointerA","pointerB","result","maxA","maxB","lastAdded","nodeA","nodeB","counterA","counterB","prev","j"],"mappings":"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","sourcesContent":["import { store } from \"../../redux\"\nimport { IGatsbyNode } from \"../../redux/types\"\nimport {\n  IDbQueryElemMatch,\n  FilterValue,\n  FilterValueNullable,\n} from \"../common/query\"\nimport { getDataStore } from \"../\"\n\n// Only list supported ops here. \"CacheableFilterOp\"\nexport type FilterOp =  // TODO: merge with DbComparator ?\n  | \"$eq\"\n  | \"$ne\"\n  | \"$lt\"\n  | \"$lte\"\n  | \"$gt\"\n  | \"$gte\"\n  | \"$in\"\n  | \"$nin\"\n  | \"$regex\" // Note: this includes $glob\n// Note: `undefined` is an encoding for a property that does not exist\n\nexport type FilterCacheKey = string\nexport interface IFilterCache {\n  op: FilterOp\n  // In this map `undefined` values represent nodes that did not have the path\n  // The individual arrays are ordered asc by internal.counter which will\n  // preserve insertion order and guarantee uniqueness and it's a number so our\n  // .sort() calls can subtract one from the other which is nice :)\n  // This arrays may contain duplicates (!) because those only get filtered in the\n  // last step.\n  // TODO: We might decide to make sure these buckets _are_ deduped for eq perf\n  byValue: Map<FilterValueNullable, Array<IGatsbyNode>>\n  meta: {\n    // Used by ne/nin, which will create a Set from this array and then remove another set(s) and sort\n    nodesUnordered?: Array<IGatsbyNode>\n    // Flat list of all nodes by requested types, ordered by counter (cached for empty filters)\n    orderedByCounter?: Array<IGatsbyNode>\n    // Ordered list of all values (by `<`) found by this filter. No null / undefs\n    valuesAsc?: Array<FilterValue>\n    // Flat list of nodes, ordered by valueAsc\n    nodesByValueAsc?: Array<IGatsbyNode>\n    // Ranges of nodes per value, maps to the nodesByValueAsc array\n    valueRangesAsc?: Map<FilterValue, [number, number]>\n    // Ordered list of all values (by `>`) found by this filter. No null / undefs\n    valuesDesc?: Array<FilterValue>\n    // Flat list of nodes, ordered by valueDesc\n    nodesByValueDesc?: Array<IGatsbyNode>\n    // Ranges of nodes per value, maps to the nodesByValueDesc array\n    valueRangesDesc?: Map<FilterValue, [number, number]>\n  }\n}\nexport type FiltersCache = Map<FilterCacheKey, IFilterCache>\n\nexport function postIndexingMetaSetup(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  // Loop through byValue and make sure the buckets are sorted by counter\n  // Since we don't do insertion sort, we have to do it afterwards\n  for (const bucket of filterCache.byValue) {\n    bucket[1].sort((a, b) => a.internal.counter - b.internal.counter)\n  }\n\n  if (op === `$ne` || op === `$nin`) {\n    postIndexingMetaSetupNeNin(filterCache)\n  } else if ([`$lt`, `$lte`, `$gt`, `$gte`].includes(op)) {\n    postIndexingMetaSetupLtLteGtGte(filterCache, op)\n  }\n}\n\nfunction postIndexingMetaSetupNeNin(filterCache: IFilterCache): void {\n  // Note: edge cases regarding `null` and `undefined`. Here `undefined` signals\n  // that the property did not exist as the filters do not support actual\n  // `undefined` values.\n  // For $ne, `null` only returns nodes that actually have the property\n  // and in that case the property cannot be `null` either. For any other value,\n  // $ne will return all nodes where the value is not actually the needle,\n  // including nodes where the value is null.\n  // A $nin does the same as an $ne except it filters multiple values instead\n  // of just one.\n\n  // For `$ne` we will take the list of all targeted nodes and eliminate the\n  // bucket of nodes with a particular value, if it exists at all..\n\n  const arr: Array<IGatsbyNode> = []\n  filterCache.meta.nodesUnordered = arr\n  filterCache.byValue.forEach(v => {\n    v.forEach(node => {\n      arr.push(node)\n    })\n  })\n}\n\nfunction postIndexingMetaSetupLtLteGtGte(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  // Create an ordered array of individual nodes, ordered (grouped) by the\n  // value to which the filter resolves. Nodes per value are ordered by\n  // internal.counter, asc.\n  // This way non-eq ops can simply slice the array to get a range.\n\n  const entriesNullable: Array<[FilterValueNullable, Array<IGatsbyNode>]> = [\n    ...filterCache.byValue.entries(),\n  ]\n\n  // These range checks never return `null` or `undefined` so filter those out\n  // By filtering them out early, the sort should be faster. Could be ...\n  const entries: Array<[\n    FilterValue,\n    Array<IGatsbyNode>\n  ]> = entriesNullable.filter(([v]) => v != null) as Array<\n    [FilterValue, Array<IGatsbyNode>]\n  >\n\n  // Sort all arrays by its value, asc. Ignore/allow potential type casting.\n  // Note: while `<` is the inverse of `>=`, the ordering might coerce values.\n  // This coercion makes the op no longer idempotent (normally the result of\n  // `a < b` is the opposite of `b >= a` for any a or b of the same type). The\n  // exception is a number that is `NaN`, which we're ignoring here as it's most\n  // likely a bug in the user code. However, when coercing the ops may end up\n  // comparing against `NaN`, too. For example: `(\"abc\" <= 12) !== (12 > \"abc\")`\n  // which ends up doing `NaN <= 12` and `NaN > \"abc\"`, which will both yield\n  // false.\n  // So instead we potentially track two ordered lists; ascending and descending\n  // and the only difference when comparing the inverse of one to the other\n  // should be how these `NaN` cases end up getting ordered.\n  // It's fine for `lt` and `lte` to use the same ordered list. Same for gt/gte.\n  if (op === `$lt` || op === `$lte`) {\n    // Order ascending; first value is lowest\n    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  } else if (op === `$gt` || op === `$gte`) {\n    // Order descending; first value is highest\n    entries.sort(([a], [b]) => (a > b ? -1 : a < b ? 1 : 0))\n  }\n\n  const orderedNodes: Array<IGatsbyNode> = []\n  const orderedValues: Array<FilterValue> = []\n  const offsets: Map<FilterValue, [number, number]> = new Map()\n  entries.forEach(([v, bucket]: [FilterValue, Array<IGatsbyNode>]) => {\n    // Record the range containing all nodes with as filter value v\n    // The last value of the range should be the offset of the next value\n    // (So you should be able to do `nodes.slice(start, stop)` to get them)\n    offsets.set(v, [orderedNodes.length, orderedNodes.length + bucket.length])\n    // We could do `arr.push(...bucket)` here but that's not safe with very\n    // large sets, so we use a regular loop\n    bucket.forEach(node => orderedNodes.push(node))\n    orderedValues.push(v)\n  })\n\n  if (op === `$lt` || op === `$lte`) {\n    filterCache.meta.valuesAsc = orderedValues\n    filterCache.meta.nodesByValueAsc = orderedNodes\n    // The nodesByValueAsc is ordered by value, but multiple nodes per value are\n    // not ordered. To make lt as fast as lte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesAsc = offsets\n  } else if (op === `$gt` || op === `$gte`) {\n    filterCache.meta.valuesDesc = orderedValues\n    filterCache.meta.nodesByValueDesc = orderedNodes\n    // The nodesByValueDesc is ordered by value, but multiple nodes per value are\n    // not ordered. To make gt as fast as gte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesDesc = offsets\n  }\n}\n\n/**\n * Given a single non-elemMatch filter path, a list of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a list.\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scales up.\n */\nexport const ensureIndexByQuery = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filterPath: Array<string>,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): void => {\n  const state = store.getState()\n  const resolvedNodesCache = state.resolvedNodesCache\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNode>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  // We cache the subsets of nodes by type, but only one type. So if searching\n  // through one node type we can prevent a search through all nodes, otherwise\n  // it's probably faster to loop through all nodes. Perhaps. Maybe.\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        addNodeToFilterCache(node, filterPath, filterCache, resolvedNodesCache)\n      })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return\n        }\n\n        addNodeToFilterCache(node, filterPath, filterCache, resolvedNodesCache)\n      })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nexport function ensureEmptyFilterCache(\n  filterCacheKey,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): void {\n  // This is called for queries without any filters\n  // We want to cache the result since it's basically a list of nodes by type(s)\n  // There are sites that have multiple queries which are empty\n\n  const state = store.getState()\n  const resolvedNodesCache = state.resolvedNodesCache\n  const orderedByCounter: Array<IGatsbyNode> = []\n\n  filtersCache.set(filterCacheKey, {\n    op: `$eq`, // Ignore.\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNode>>(),\n    meta: {\n      orderedByCounter, // This is what we want\n    },\n  })\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        if (!node.__gatsby_resolved) {\n          const typeName = node.internal.type\n          const resolvedNodes = resolvedNodesCache.get(typeName)\n          const resolved = resolvedNodes?.get(node.id)\n          if (resolved !== undefined) {\n            node.__gatsby_resolved = resolved\n          }\n        }\n        orderedByCounter.push(node)\n      })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (nodeTypeNames.includes(node.internal.type)) {\n          if (!node.__gatsby_resolved) {\n            const typeName = node.internal.type\n            const resolvedNodes = resolvedNodesCache.get(typeName)\n            const resolved = resolvedNodes?.get(node.id)\n            if (resolved !== undefined) {\n              node.__gatsby_resolved = resolved\n            }\n          }\n          orderedByCounter.push(node)\n        }\n      })\n  }\n\n  // Since each node can only have one type, we shouldn't have to be concerned\n  // about duplicates in this array. Just make sure they're sorted.\n  orderedByCounter.sort((a, b) => a.internal.counter - b.internal.counter)\n}\n\nfunction addNodeToFilterCache(\n  node: IGatsbyNode,\n  chain: Array<string>,\n  filterCache: IFilterCache,\n  resolvedNodesCache,\n  valueOffset: any = node\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  // - for plain query, valueOffset === node\n  // - for elemMatch, valueOffset is sub-tree of the node to continue matching\n  let v = valueOffset as any\n  let i = 0\n  while (i < chain.length && v) {\n    const nextProp = chain[i++]\n    v = v[nextProp]\n  }\n\n  if (\n    (typeof v !== `string` &&\n      typeof v !== `number` &&\n      typeof v !== `boolean` &&\n      v !== null) ||\n    i !== chain.length\n  ) {\n    if (i === chain.length && Array.isArray(v)) {\n      // The op resolved to an array\n      // Add an entry for each element of the array. This would work for ops\n      // like eq and ne, but not sure about range ops like lt,lte,gt,gte.\n\n      v.forEach(v => markNodeForValue(filterCache, node, v))\n\n      return\n    }\n\n    // This means that either\n    // - The filter resolved to `undefined`, or\n    // - The filter resolved to something other than a primitive\n    // Set the value to `undefined` to mark \"path does not (fully) exist\"\n    v = undefined\n  }\n\n  markNodeForValue(filterCache, node, v)\n}\n\nfunction markNodeForValue(\n  filterCache: IFilterCache,\n  node: IGatsbyNode,\n  value: FilterValueNullable\n): void {\n  let arr = filterCache.byValue.get(value)\n  if (!arr) {\n    arr = []\n    filterCache.byValue.set(value, arr)\n  }\n  arr.push(node)\n}\n\nexport const ensureIndexByElemMatch = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): void => {\n  // Given an elemMatch filter, generate the cache that contains all nodes that\n  // matches a given value for that sub-query\n\n  const state = store.getState()\n  const { resolvedNodesCache } = state\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Array<IGatsbyNode>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  if (nodeTypeNames.length === 1) {\n    getDataStore()\n      .iterateNodesByType(nodeTypeNames[0])\n      .forEach(node => {\n        addNodeToBucketWithElemMatch(\n          node,\n          node,\n          filter,\n          filterCache,\n          resolvedNodesCache\n        )\n      })\n  } else {\n    // Expensive at scale\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        if (!nodeTypeNames.includes(node.internal.type)) {\n          return\n        }\n\n        addNodeToBucketWithElemMatch(\n          node,\n          node,\n          filter,\n          filterCache,\n          resolvedNodesCache\n        )\n      })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nfunction addNodeToBucketWithElemMatch(\n  node: IGatsbyNode,\n  valueAtCurrentStep: any, // Arbitrary step on the path inside the node\n  filter: IDbQueryElemMatch,\n  filterCache: IFilterCache,\n  resolvedNodesCache\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  const { path, nestedQuery } = filter\n\n  // Find the value to apply elemMatch to\n  let i = 0\n  while (i < path.length && valueAtCurrentStep) {\n    const nextProp = path[i++]\n    valueAtCurrentStep = valueAtCurrentStep[nextProp]\n  }\n\n  if (path.length !== i) {\n    // Found undefined before the end of the path\n    return\n  }\n\n  // `v` should now be an elemMatch target, probably an array (but maybe not)\n  if (!Array.isArray(valueAtCurrentStep)) {\n    // It's possible to `elemMatch` on a non-array so let's support that too\n    valueAtCurrentStep = [valueAtCurrentStep]\n  }\n\n  // Note: We need to check all elements because the node may need to be added\n  // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that\n  // node ends up in buckets for value 3 and 4. This may lead to duplicate\n  // work when elements resolve to the same value, but that can't be helped.\n  valueAtCurrentStep.forEach(elem => {\n    if (nestedQuery.type === `elemMatch`) {\n      addNodeToBucketWithElemMatch(\n        node,\n        elem,\n        nestedQuery,\n        filterCache,\n        resolvedNodesCache\n      )\n    } else {\n      // Now take same route as non-elemMatch filters would take\n      addNodeToFilterCache(\n        node,\n        nestedQuery.path,\n        filterCache,\n        resolvedNodesCache,\n        elem\n      )\n    }\n  })\n}\n\nconst binarySearchAsc = (\n  values: Array<FilterValue>, // Assume ordered asc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot < max\n      max = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot > min\n      min = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable\n  return undefined\n}\nconst binarySearchDesc = (\n  values: Array<FilterValue>, // Assume ordered desc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot < min\n      min = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot > max\n      max = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable\n  return undefined\n}\n\n/**\n * Given the cache key for a filter and a target value return the list of nodes\n * that resolve to this value. The returned array should be ordered by id.\n * This returns `undefined` if there is no such node\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n *\n * Arrays returned by this function must be ordered by internal.counter and\n * not contain duplicate nodes (!)\n */\nexport const getNodesFromCacheByValue = (\n  filterCacheKey: FilterCacheKey,\n  filterValue: FilterValueNullable,\n  filtersCache: FiltersCache,\n  wasElemMatch\n): Array<IGatsbyNode> | undefined => {\n  const filterCache = filtersCache.get(filterCacheKey)\n  if (!filterCache) {\n    return undefined\n  }\n\n  const op = filterCache.op\n\n  if (op === `$eq`) {\n    // Arrays in byValue are assumed to be ordered by counter\n\n    if (filterValue == null) {\n      // Edge case for null; fetch all nodes for `null` and `undefined` because\n      // `$eq` also returns nodes without the path when searching for `null`.\n      // Not all ops do so, so we map non-existing paths to `undefined`.\n\n      const arrNull = filterCache.byValue.get(null) ?? []\n      const arrUndef = filterCache.byValue.get(undefined) ?? []\n\n      // Merge the two (ordered) arrays and return an ordered deduped array\n      // TODO: is there a reason left why we cant just cache this merged list?\n      return unionNodesByCounter(arrNull, arrUndef)\n    }\n\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (op === `$in`) {\n    if (!Array.isArray(filterValue)) {\n      throw new Error(\"The argument to the `in` comparator should be an array\")\n    }\n    const filterValueArr: Array<FilterValueNullable> = filterValue\n\n    const set: Set<IGatsbyNode> = new Set()\n\n    // TODO: we can also mergeSort for every step. this may perform worse because of how memory in js works.\n    // For every value in the needle array, find the bucket of nodes for\n    // that value, add this bucket of nodes to one list, return the list.\n    filterValueArr.forEach((v: FilterValueNullable) =>\n      filterCache.byValue.get(v)?.forEach(v => set.add(v))\n    )\n\n    const arr = [...set] // this is bad for perf but will guarantee us a unique set :(\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n\n    // Note: it's very unlikely that the list of filter values is big so .includes should be fine here\n    if (filterValueArr.includes(null)) {\n      // Like all other ops, `in: [null]` behaves weirdly, allowing all nodes\n      // that do not actually have a (complete) path (v=undefined)\n      const nodes = filterCache.byValue.get(undefined)\n      if (nodes) {\n        // This will also dedupe so don't do that immediately\n        return unionNodesByCounter(nodes, arr)\n      }\n    }\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe first\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n\n    return arr\n  }\n\n  if (op === `$nin`) {\n    // This is essentially the same as the $ne operator, just with multiple\n    // values to exclude.\n\n    if (!Array.isArray(filterValue)) {\n      throw new Error(`The $nin operator expects an array as value`)\n    }\n\n    const values: Set<FilterValueNullable> = new Set(filterValue)\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    // Do the action for \"$ne\" for each element in the set of values\n    values.forEach(filterValue => {\n      removeBucketFromSet(filterValue, filterCache, set)\n    })\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to re-sort\n    return [...set].sort((A, B) => A.internal.counter - B.internal.counter)\n  }\n\n  if (op === `$ne`) {\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    removeBucketFromSet(filterValue, filterCache, set)\n\n    // TODO: there's probably a more efficient algorithm to do set\n    //       subtraction in such a way that we don't have to resort here\n    return [...set].sort((A, B) => A.internal.counter - B.internal.counter)\n  }\n\n  if (op === `$regex`) {\n    // Note: $glob is converted to $regex so $glob filters go through here, too\n    // Aside from the input pattern format, further behavior is exactly the same.\n\n    // The input to the filter must be a string (including leading/trailing slash and regex flags)\n    // By the time the filter reaches this point, the filterValue has to be a regex.\n\n    if (!(filterValue instanceof RegExp)) {\n      throw new Error(\n        `The value for the $regex comparator must be an instance of RegExp`\n      )\n    }\n    const regex = filterValue\n\n    const arr: Array<IGatsbyNode> = []\n    filterCache.byValue.forEach((nodes, value) => {\n      // TODO: does the value have to be a string for $regex? Can we auto-ignore any non-strings? Or does it coerce.\n      // Note: for legacy reasons partial paths should also be included for regex\n      if (value !== undefined && regex.test(String(value))) {\n        nodes.forEach(node => arr.push(node))\n      }\n    })\n\n    // TODO: we _can_ cache this list as well. Might make sense if it turns out that $regex is mostly used with literals\n    // TODO: it may make sense to first collect all buckets and then to .concat them, or merge sort them\n\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n\n    return arr\n  }\n\n  if (filterValue == null) {\n    if (op === `$lt` || op === `$gt`) {\n      // Nothing is lt/gt null\n      return undefined\n    }\n\n    // This is an edge case and this value should be directly indexed\n    // For `lte`/`gte` this should only return nodes for `null`, not a \"range\"\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (Array.isArray(filterValue)) {\n    throw new Error(\n      \"Array is an invalid filter value for the `\" + op + \"` comparator\"\n    )\n  }\n\n  if (filterValue instanceof RegExp) {\n    // This is most likely an internal error, although it is possible for\n    // users to talk to this API more directly.\n    throw new Error(\n      `A RegExp instance is only valid for $regex and $glob comparators`\n    )\n  }\n\n  if (op === `$lt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[0])\n      arr.sort((A, B) => A.internal.counter - B.internal.counter)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue < filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until)\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$lte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[1])\n      arr.sort((A, B) => A.internal.counter - B.internal.counter)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be list at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue <= filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until)\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$gt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[0]).reverse()\n      arr.sort((A, B) => A.internal.counter - B.internal.counter)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue > filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until).reverse()\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  if (op === `$gte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole list, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      const arr = nodes!.slice(0, range[1]).reverse()\n      arr.sort((A, B) => A.internal.counter - B.internal.counter)\n      // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n      if (wasElemMatch) {\n        expensiveDedupeInline(arr)\n      }\n      return arr\n    }\n\n    // Query may ask for a value that doesn't appear in the list, like if the\n    // list is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be list at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue >= filterValue ? inclPivot : exclPivot\n    const arr = nodes!.slice(0, until).reverse()\n    arr.sort((A, B) => A.internal.counter - B.internal.counter)\n    // elemMatch can cause a node to appear in multiple buckets so we must dedupe\n    if (wasElemMatch) {\n      expensiveDedupeInline(arr)\n    }\n    return arr\n  }\n\n  // Unreachable because we checked all values of FilterOp (which op is)\n  return undefined\n}\n\nfunction removeBucketFromSet(\n  filterValue: FilterValueNullable,\n  filterCache: IFilterCache,\n  set: Set<IGatsbyNode>\n): void {\n  if (filterValue === null) {\n    // Edge case: $ne with `null` returns only the nodes that contain the full\n    // path and that don't resolve to null, so drop `undefined` as well.\n    let cache = filterCache.byValue.get(undefined)\n    if (cache) cache.forEach(node => set.delete(node))\n    cache = filterCache.byValue.get(null)\n    if (cache) cache.forEach(node => set.delete(node))\n  } else {\n    // Not excluding null so it should include undefined leafs or leafs where\n    // only the partial path exists for whatever reason.\n    const cache = filterCache.byValue.get(filterValue)\n    if (cache) cache.forEach(node => set.delete(node))\n  }\n}\n\n/**\n * Finds the intersection of two arrays in O(n) with n = min(a.length, b.length)\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function intersectNodesByCounter(\n  a: Array<IGatsbyNode>,\n  b: Array<IGatsbyNode>\n): Array<IGatsbyNode> {\n  let pointerA = 0\n  let pointerB = 0\n  // TODO: perf check: is it helpful to init the array to min(maxA,maxB) items?\n  const result: Array<IGatsbyNode> = []\n  const maxA = a.length\n  const maxB = b.length\n  let lastAdded: IGatsbyNode | undefined = undefined // Used to dedupe the list\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const nodeA = a[pointerA]\n    const nodeB = b[pointerB]\n    const counterA = nodeA.internal.counter\n    const counterB = nodeB.internal.counter\n\n    if (counterA < counterB) {\n      pointerA++\n    } else if (counterA > counterB) {\n      pointerB++\n    } else {\n      if (nodeA !== nodeB) {\n        throw new Error(\n          `Invariant violation: inconsistent node counters detected`\n        )\n      }\n      // nodeA===nodeB. Make sure we didn't just add this node already.\n      // Since input arrays are sorted, the same node should be grouped\n      // back to back, so even if both input arrays contained the same node\n      // twice, this check would prevent the result from getting duplicate nodes\n      if (lastAdded !== nodeA) {\n        result.push(nodeA)\n        lastAdded = nodeA\n      }\n      pointerA++\n      pointerB++\n    }\n  }\n\n  return result\n}\n\n/**\n * Merge two lists of nodes.\n * The returned set should not contain duplicate nodes.\n *\n * The input should be ordered by node.internal.counter and it will return a\n * list that is also ordered by node.internal.counter\n */\nexport function unionNodesByCounter(\n  a: Array<IGatsbyNode>,\n  b: Array<IGatsbyNode>\n): Array<IGatsbyNode> {\n  // TODO: perf check: is it helpful to init the array to max(maxA,maxB) items?\n  const arr: Array<IGatsbyNode> = []\n  let lastAdded: IGatsbyNode | undefined = undefined // Used to dedupe the list\n\n  let pointerA = 0\n  let pointerB = 0\n  const maxA = a.length\n  const maxB = b.length\n\n  while (pointerA < maxA && pointerB < maxB) {\n    const nodeA = a[pointerA]\n    const nodeB = b[pointerB]\n    const counterA = nodeA.internal.counter\n    const counterB = nodeB.internal.counter\n\n    if (counterA < counterB) {\n      if (lastAdded !== nodeA) {\n        arr.push(nodeA)\n        lastAdded = nodeA\n      }\n      pointerA++\n    } else if (counterA > counterB) {\n      if (lastAdded !== nodeB) {\n        arr.push(nodeB)\n        lastAdded = nodeB\n      }\n      pointerB++\n    } else {\n      if (lastAdded !== nodeA) {\n        arr.push(nodeA)\n        lastAdded = nodeA\n      }\n      pointerA++\n      pointerB++\n    }\n  }\n\n  while (pointerA < maxA) {\n    const nodeA = a[pointerA]\n    if (lastAdded !== nodeA) {\n      arr.push(nodeA)\n      lastAdded = nodeA\n    }\n    pointerA++\n  }\n\n  while (pointerB < maxB) {\n    const nodeB = b[pointerB]\n    if (lastAdded !== nodeB) {\n      arr.push(nodeB)\n      lastAdded = nodeB\n    }\n    pointerB++\n  }\n\n  return arr\n}\n\nfunction expensiveDedupeInline(arr: Array<IGatsbyNode>): void {\n  // An elemMatch filter may cause duplicates to appear in a bucket.\n  // Since the bucket is sorted those should now be back to back\n  // Worst case this is a fast O(n) loop that does nothing.\n  let prev: IGatsbyNode | undefined = undefined\n\n  // We copy-on-find because a splice is expensive and we can't use Sets\n\n  let j = 0\n  for (let i = 0; i < arr.length; ++i) {\n    const node = arr[i]\n    if (node !== prev) {\n      // Only start copying the remainder of the list once a dupe is found\n      if (i !== j) {\n        arr[j] = node\n      }\n      ++j\n      prev = node\n    }\n  }\n  arr.length = j\n}\n"],"file":"indexing.js"}