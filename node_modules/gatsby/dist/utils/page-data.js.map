{"version":3,"sources":["../../src/utils/page-data.ts"],"names":["fixedPagePath","pagePath","reverseFixedPagePath","pageDataRequestPath","getFilePath","publicDir","path","join","readPageData","filePath","rawPageData","fs","readFile","JSON","parse","removePageData","existsSync","remove","Promise","resolve","pageDataExists","writePageData","componentChunkName","matchPath","staticQueryHashes","inputFilePath","replace","outputFilePath","result","readJSON","body","bodyStr","stringify","pageDataSize","Buffer","byteLength","store","dispatch","type","payload","size","pageDataHash","outputFile","isFlushPending","isFlushing","isFlushEnqueued","flush","pendingPageDataWrites","pages","program","staticQueriesByTemplate","queries","getState","pagePaths","writePageDataActivity","reporter","createProgress","start","flushQueue","cb","page","get","_","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","query","trackedQueries","Error","dirty","FLAG_DIRTY_NEW_PAGE","componentPath","directory","tick","websocketManager","emitPageData","id","push","idle","drain","end","enqueueFlush","handleStalePageData","pathExists","activity","activityTimer","pageDataFilesFromPreviousBuilds","reject","results","Set","stream","on","data","name","add","e","expectedPageDataFiles","forEach","deletionPromises","pageDataFilePath","has","all"],"mappings":"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","sourcesContent":["import { walkStream as fsWalkStream, Entry } from \"@nodelib/fs.walk\"\nimport fs from \"fs-extra\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport fastq from \"fastq\"\nimport path from \"path\"\nimport { createContentDigest } from \"gatsby-core-utils\"\nimport { IGatsbyPage } from \"../redux/types\"\nimport { websocketManager } from \"./websocket-manager\"\nimport { isWebpackStatusPending } from \"./webpack-status\"\nimport { store } from \"../redux\"\nimport { hasFlag, FLAG_DIRTY_NEW_PAGE } from \"../redux/reducers/queries\"\n\nimport { IExecutionResult } from \"../query/types\"\n\ninterface IPageData {\n  componentChunkName: IGatsbyPage[\"componentChunkName\"]\n  matchPath?: IGatsbyPage[\"matchPath\"]\n  path: IGatsbyPage[\"path\"]\n  staticQueryHashes: Array<string>\n}\n\nexport interface IPageDataWithQueryResult extends IPageData {\n  result: IExecutionResult\n}\n\nexport function fixedPagePath(pagePath: string): string {\n  return pagePath === `/` ? `index` : pagePath\n}\n\nexport function reverseFixedPagePath(pageDataRequestPath: string): string {\n  return pageDataRequestPath === `index` ? `/` : pageDataRequestPath\n}\n\nfunction getFilePath(publicDir: string, pagePath: string): string {\n  return path.join(\n    publicDir,\n    `page-data`,\n    fixedPagePath(pagePath),\n    `page-data.json`\n  )\n}\n\nexport async function readPageData(\n  publicDir: string,\n  pagePath: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = getFilePath(publicDir, pagePath)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawPageData)\n}\n\nexport async function removePageData(\n  publicDir: string,\n  pagePath: string\n): Promise<void> {\n  const filePath = getFilePath(publicDir, pagePath)\n\n  if (fs.existsSync(filePath)) {\n    return await fs.remove(filePath)\n  }\n\n  return Promise.resolve()\n}\n\nexport function pageDataExists(publicDir: string, pagePath: string): boolean {\n  return fs.existsSync(getFilePath(publicDir, pagePath))\n}\n\nexport async function writePageData(\n  publicDir: string,\n  {\n    componentChunkName,\n    matchPath,\n    path: pagePath,\n    staticQueryHashes,\n  }: IPageData\n): Promise<IPageDataWithQueryResult> {\n  const inputFilePath = path.join(\n    publicDir,\n    `..`,\n    `.cache`,\n    `json`,\n    `${pagePath.replace(/\\//g, `_`)}.json`\n  )\n\n  const outputFilePath = getFilePath(publicDir, pagePath)\n  const result = await fs.readJSON(inputFilePath)\n  const body = {\n    componentChunkName,\n    path: pagePath,\n    matchPath,\n    result,\n    staticQueryHashes,\n  }\n\n  const bodyStr = JSON.stringify(body)\n  // transform asset size to kB (from bytes) to fit 64 bit to numbers\n  const pageDataSize = Buffer.byteLength(bodyStr) / 1000\n\n  store.dispatch({\n    type: `ADD_PAGE_DATA_STATS`,\n    payload: {\n      pagePath,\n      filePath: outputFilePath,\n      size: pageDataSize,\n      pageDataHash: createContentDigest(bodyStr),\n    },\n  })\n\n  await fs.outputFile(outputFilePath, bodyStr)\n  return body\n}\n\nlet isFlushPending = false\nlet isFlushing = false\n\nexport function isFlushEnqueued(): boolean {\n  return isFlushPending\n}\n\nexport async function flush(): Promise<void> {\n  if (isFlushing) {\n    // We're already in the middle of a flush\n    return\n  }\n  isFlushPending = false\n  isFlushing = true\n  const {\n    pendingPageDataWrites,\n    pages,\n    program,\n    staticQueriesByTemplate,\n    queries,\n  } = store.getState()\n\n  const { pagePaths } = pendingPageDataWrites\n\n  const writePageDataActivity = reporter.createProgress(\n    `Writing page-data.json files to public directory`,\n    pagePaths.size,\n    0\n  )\n  writePageDataActivity.start()\n\n  const flushQueue = fastq(async (pagePath, cb) => {\n    const page = pages.get(pagePath)\n\n    // It's a gloomy day in Bombay, let me tell you a short story...\n    // Once upon a time, writing page-data.json files were atomic\n    // After this change (#24808), they are not and this means that\n    // between adding a pending write for a page and actually flushing\n    // them, a page might not exist anymore щ（ﾟДﾟщ）\n    // This is why we need this check\n    if (page) {\n      if (\n        program?._?.[0] === `develop` &&\n        process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND\n      ) {\n        // check if already did run query for this page\n        // with query-on-demand we might have pending page-data write due to\n        // changes in static queries assigned to page template, but we might not\n        // have query result for it\n        const query = queries.trackedQueries.get(page.path)\n        if (!query) {\n          // this should not happen ever\n          throw new Error(\n            `We have a page, but we don't have registered query for it (???)`\n          )\n        }\n\n        if (hasFlag(query.dirty, FLAG_DIRTY_NEW_PAGE)) {\n          // query results are not written yet\n          return cb(null, true)\n        }\n      }\n\n      const staticQueryHashes =\n        staticQueriesByTemplate.get(page.componentPath) || []\n\n      const result = await writePageData(\n        path.join(program.directory, `public`),\n        {\n          ...page,\n          staticQueryHashes,\n        }\n      )\n\n      writePageDataActivity.tick()\n\n      if (program?._?.[0] === `develop`) {\n        websocketManager.emitPageData({\n          id: pagePath,\n          result,\n        })\n      }\n    }\n\n    store.dispatch({\n      type: `CLEAR_PENDING_PAGE_DATA_WRITE`,\n      payload: {\n        page: pagePath,\n      },\n    })\n\n    return cb(null, true)\n  }, 25)\n\n  for (const pagePath of pagePaths) {\n    flushQueue.push(pagePath, () => {})\n  }\n\n  if (!flushQueue.idle()) {\n    await new Promise(resolve => {\n      flushQueue.drain = resolve as () => unknown\n    })\n  }\n\n  writePageDataActivity.end()\n  isFlushing = false\n\n  return\n}\n\nexport function enqueueFlush(): void {\n  if (isWebpackStatusPending()) {\n    isFlushPending = true\n  } else {\n    flush()\n  }\n}\n\nexport async function handleStalePageData(): Promise<void> {\n  if (!(await fs.pathExists(`public/page-data`))) {\n    return\n  }\n\n  // public directory might have stale page-data files from previous builds\n  // we get the list of those and compare against expected page-data files\n  // and remove ones that shouldn't be there anymore\n\n  const activity = reporter.activityTimer(`Cleaning up stale page-data`)\n  activity.start()\n\n  const pageDataFilesFromPreviousBuilds = await new Promise<Set<string>>(\n    (resolve, reject) => {\n      const results = new Set<string>()\n\n      const stream = fsWalkStream(`public/page-data`)\n\n      stream.on(`data`, (data: Entry) => {\n        if (data.name === `page-data.json`) {\n          results.add(data.path)\n        }\n      })\n\n      stream.on(`error`, e => {\n        reject(e)\n      })\n\n      stream.on(`end`, () => resolve(results))\n    }\n  )\n\n  const expectedPageDataFiles = new Set<string>()\n  store.getState().pages.forEach(page => {\n    expectedPageDataFiles.add(getFilePath(`public`, page.path))\n  })\n\n  const deletionPromises: Array<Promise<void>> = []\n  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {\n    if (!expectedPageDataFiles.has(pageDataFilePath)) {\n      deletionPromises.push(fs.remove(pageDataFilePath))\n    }\n  })\n\n  await Promise.all(deletionPromises)\n\n  activity.end()\n}\n"],"file":"page-data.js"}